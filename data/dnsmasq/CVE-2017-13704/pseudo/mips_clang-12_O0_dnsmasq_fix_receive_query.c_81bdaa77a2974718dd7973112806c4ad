void __fastcall receive_query(listener *listen, time_t now)
{
  int v2; // $v0
  const char *v3; // $a0
  unsigned __int16 v4; // $at
  int v5; // [sp+28h] [+28h]
  int v6; // [sp+30h] [+30h]
  struct cmsghdr *msg_control; // [sp+38h] [+38h]
  bool v8; // [sp+43h] [+43h]
  int v9; // [sp+44h] [+44h]
  int v10; // [sp+54h] [+54h]
  int m; // [sp+58h] [+58h]
  int j; // [sp+5Ch] [+5Ch]
  int k; // [sp+5Ch] [+5Ch]
  char v14[32]; // [sp+70h] [+70h] BYREF
  uint32_t v15; // [sp+90h] [+90h]
  int i; // [sp+98h] [+98h]
  _BOOL4 v17; // [sp+9Ch] [+9Ch]
  char v18; // [sp+A0h] [+A0h] BYREF
  struct cmsghdr *cmsg; // [sp+C4h] [+C4h]
  struct msghdr v20; // [sp+C8h] [+C8h] BYREF
  int v21[3]; // [sp+E8h] [+E8h] BYREF
  int v22; // [sp+F4h] [+F4h]
  int v23; // [sp+F8h] [+F8h]
  int v24; // [sp+FCh] [+FCh]
  int dns_auth; // [sp+100h] [+100h] BYREF
  unsigned int dst_iface; // [sp+104h] [+104h]
  signed int v27; // [sp+108h] [+108h]
  size_t len; // [sp+10Ch] [+10Ch]
  in_addr_t s_addr; // [sp+110h] [+110h]
  in_addr_t v30; // [sp+118h] [+118h]
  all_addr v31; // [sp+120h] [+120h] BYREF
  unsigned __int16 v32; // [sp+134h] [+134h]
  unsigned __int16 v33; // [sp+138h] [+138h] BYREF
  unsigned __int16 *v34; // [sp+13Ch] [+13Ch] BYREF
  mysockaddr v35; // [sp+140h] [+140h] BYREF
  char *packet; // [sp+15Ch] [+15Ch]
  time_t v37; // [sp+160h] [+160h]
  listener *v38; // [sp+164h] [+164h]

  v38 = listen;
  v37 = now;
  packet = *(char **)(dnsmasq_daemon + 476);
  v32 = 512;
  dst_iface = 0;
  dns_auth = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v8 = 1;
  if ( (*(_BYTE *)(dnsmasq_daemon + 2) & 0x20) != 0 )
    v8 = v38->family == 0xA;
  v17 = v8;
  *(_DWORD *)(dnsmasq_daemon + 528) = 0;
  v31.addr.addr4.s_addr = 0;
  s_addr = 0;
  v30 = 0;
  if ( (*(_BYTE *)(dnsmasq_daemon + 2) & 0x20) != 0 )
  {
    if ( v38->iface )
    {
      dns_auth = v38->iface->dns_auth;
      if ( v38->family == 2 )
      {
        v31.addr.addr4.s_addr = v38->iface->addr.in.sin_addr.s_addr;
        s_addr = v31.addr.addr4.s_addr;
        v30 = v38->iface->netmask.s_addr;
      }
    }
  }
  v21[0] = *(_DWORD *)(dnsmasq_daemon + 476);
  v21[1] = *(unsigned __int16 *)(dnsmasq_daemon + 432);
  v20.msg_control = &v18;
  v20.msg_controllen = 32;
  v20.msg_flags = 0;
  v20.msg_name = &v35;
  v20.msg_namelen = 28;
  v20.msg_iov = (iovec *)v21;
  v20.msg_iovlen = 1;
  v27 = recvmsg(v38->fd, &v20, 0);
  if ( v27 != -1 && v27 >= 12 && (v20.msg_flags & 0x20) == 0 && (packet[2] & 0x80) == 0 )
  {
    memset((void *)(*(_DWORD *)(dnsmasq_daemon + 476) + v27), 0, *(unsigned __int16 *)(dnsmasq_daemon + 432) - v27);
    v35.sa.sa_family = v38->family;
    if ( v38->family == 2 )
    {
      if ( !v35.in.sin_port )
        return;
    }
    else
    {
      if ( !v35.in.sin_port )
        return;
      v35.in.sin_addr.s_addr = 0;
    }
    if ( (*(_BYTE *)(dnsmasq_daemon + 5) & 2) != 0 )
    {
      if ( v38->family == 10 )
      {
        for ( i = *(_DWORD *)(dnsmasq_daemon + 1136);
              i && ((*(_BYTE *)(i + 19) & 2) == 0 || !is_same_net6(i, &v35.in6.sin6_addr, *(_DWORD *)(i + 20)));
              i = *(_DWORD *)(i + 24) )
        {
          ;
        }
      }
      else
      {
        for ( i = *(_DWORD *)(dnsmasq_daemon + 1136); i; i = *(_DWORD *)(i + 24) )
        {
          v15 = htonl(-1 << (32 - *(_BYTE *)(i + 20)));
          if ( (*(_BYTE *)(i + 19) & 2) == 0 )
          {
            if ( is_same_net(*(_DWORD *)i, v35.in.sin_addr.s_addr, v15) )
              break;
          }
        }
      }
      if ( !i )
      {
        if ( !receive_query_warned )
        {
          my_syslog(4, "Ignoring query from non-local network");
          receive_query_warned = 1;
        }
        return;
      }
    }
    if ( v17 )
    {
      if ( v20.msg_controllen < 0xC )
        return;
      if ( v38->family == 2 )
      {
        for ( cmsg = (struct cmsghdr *)v20.msg_control; cmsg; cmsg = _cmsg_nxthdr(&v20, cmsg) )
        {
          if ( !cmsg->cmsg_level && cmsg->cmsg_type == 8 )
          {
            v31.addr.addr4.s_addr = *(_DWORD *)&cmsg->__cmsg_data[4];
            s_addr = v31.addr.addr4.s_addr;
            dst_iface = *(_DWORD *)cmsg->__cmsg_data;
          }
        }
      }
      if ( v38->family == 10 )
      {
        if ( v20.msg_controllen < 0xC )
          msg_control = 0;
        else
          msg_control = (struct cmsghdr *)v20.msg_control;
        for ( cmsg = msg_control; cmsg; cmsg = _cmsg_nxthdr(&v20, cmsg) )
        {
          if ( cmsg->cmsg_level == 41 && cmsg->cmsg_type == *(_DWORD *)(dnsmasq_daemon + 1132) )
          {
            *((_QWORD *)&v31.addr.dnssec + 1) = *(_QWORD *)&cmsg->__cmsg_data[8];
            *(_QWORD *)&v31.addr.addr4.s_addr = *(_QWORD *)cmsg->__cmsg_data;
            dst_iface = *(_DWORD *)&cmsg->__cmsg_data[16];
          }
        }
      }
      if ( !indextoname(v38->fd, dst_iface, v14) )
        return;
      if ( !iface_check(v38->family, &v31, v14, &dns_auth) )
      {
        if ( (*(_BYTE *)(dnsmasq_daemon + 7) & 0x80) == 0 )
          enumerate_interfaces(0);
        if ( !loopback_exception(v38->fd, v38->family, &v31, v14) && !label_exception(dst_iface, v38->family, &v31) )
          return;
      }
      if ( v38->family == 2 && (*(_BYTE *)(dnsmasq_daemon + 1) & 4) != 0 )
      {
        for ( j = *(_DWORD *)(dnsmasq_daemon + 508);
              j && (*(_WORD *)j != 2 || *(_DWORD *)(j + 4) != s_addr);
              j = *(_DWORD *)(j + 80) )
        {
          ;
        }
        if ( !j && (*(_BYTE *)(dnsmasq_daemon + 7) & 0x80) == 0 )
          enumerate_interfaces(0);
        for ( k = *(_DWORD *)(dnsmasq_daemon + 508);
              k && (*(_WORD *)k != 2 || *(_DWORD *)(k + 4) != s_addr);
              k = *(_DWORD *)(k + 80) )
        {
          ;
        }
        if ( k )
          v30 = *(_DWORD *)(k + 28);
        else
          s_addr = 0;
      }
    }
    v2 = *(_DWORD *)(dnsmasq_daemon + 1140) + 1;
    *(_DWORD *)(dnsmasq_daemon + 1140) = v2;
    *(_DWORD *)(dnsmasq_daemon + 1144) = v2;
    *(_DWORD *)(dnsmasq_daemon + 1148) = &v35;
    if ( !extract_request(packet, v27, *(_DWORD *)(dnsmasq_daemon + 484), &v33) )
      goto LABEL_113;
    v3 = "query";
    if ( dns_auth )
      v3 = "auth";
    v10 = querystr(v3, v33);
    if ( v38->family == 2 )
      log_query(524424, *(_DWORD *)(dnsmasq_daemon + 484), &v35.in6.sin6_flowinfo, v10);
    else
      log_query(524552, *(_DWORD *)(dnsmasq_daemon + 484), &v35.in6.sin6_addr, v10);
    if ( !dns_auth && (*(_BYTE *)(dnsmasq_daemon + 1) & 4) == 0 )
    {
      for ( m = *(_DWORD *)(dnsmasq_daemon + 80); m; m = *(_DWORD *)(m + 16) )
      {
        if ( in_zone(m, *(_DWORD *)(dnsmasq_daemon + 484), 0) )
        {
          dns_auth = 1;
          v22 = 1;
          break;
        }
      }
    }
    if ( !detect_loop(*(_DWORD *)(dnsmasq_daemon + 484), v33) )
    {
LABEL_113:
      if ( find_pseudoheader(packet, v27, 0, &v34) )
      {
        v23 = 1;
        v32 = _byteswap_ushort(*v34++);
        v4 = _byteswap_ushort(*++v34);
        ++v34;
        if ( (v4 & 0x8000) != 0 )
          v24 = 1;
        if ( *(unsigned __int16 *)(dnsmasq_daemon + 432) < (int)v32 )
          v32 = *(_WORD *)(dnsmasq_daemon + 432);
      }
      if ( dns_auth )
      {
        len = answer_auth(packet, &packet[v32], v27, v37);
        if ( len )
        {
          LOBYTE(v6) = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 2) & 0x20) == 0 )
            v6 = *(unsigned __int8 *)(dnsmasq_daemon + 7) >> 7;
          send_from(v38->fd, v6 & 1, packet, len, &v35, &v31, dst_iface);
          ++*(_DWORD *)(dnsmasq_daemon + 496);
        }
      }
      else
      {
        v9 = v24;
        if ( (packet[3] & 0x20) != 0 )
          v9 = 1;
        len = answer_request(packet, &packet[v32], v27, s_addr);
        if ( len )
        {
          LOBYTE(v5) = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 2) & 0x20) == 0 )
            v5 = *(unsigned __int8 *)(dnsmasq_daemon + 7) >> 7;
          send_from(v38->fd, v5 & 1, packet, len, &v35, &v31, dst_iface);
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
        else if ( forward_query(v38->fd, &v35, &v31, dst_iface, (dns_header *)packet, v27, v37, 0u, v9, v24) )
        {
          ++*(_DWORD *)(dnsmasq_daemon + 492);
        }
        else
        {
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
      }
    }
  }
}
