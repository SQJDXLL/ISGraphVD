// local variable allocation has failed, the output may be wrong!
void __cdecl receive_query(listener *listen, time_t now)
{
  int v2; // w10
  const char *v3; // x0
  bool v4; // [xsp+18h] [xbp-1C8h]
  bool v5; // [xsp+20h] [xbp-1C0h]
  struct cmsghdr *msg_control; // [xsp+28h] [xbp-1B8h]
  bool v7; // [xsp+38h] [xbp-1A8h]
  unsigned int ad_reqd; // [xsp+5Ch] [xbp-184h]
  unsigned __int16 v9; // [xsp+76h] [xbp-16Ah]
  __int64 v10; // [xsp+78h] [xbp-168h]
  __int64 n; // [xsp+80h] [xbp-160h]
  __int64 k; // [xsp+88h] [xbp-158h]
  __int64 m; // [xsp+88h] [xbp-158h]
  char v14[44]; // [xsp+A0h] [xbp-140h] BYREF
  uint32_t v15; // [xsp+CCh] [xbp-114h]
  unsigned int *i; // [xsp+D0h] [xbp-110h]
  _BOOL4 v17; // [xsp+DCh] [xbp-104h]
  char v18; // [xsp+E0h] [xbp-100h] BYREF
  struct cmsghdr *j; // [xsp+108h] [xbp-D8h]
  struct msghdr message; // [xsp+110h] [xbp-D0h] BYREF
  _QWORD v21[2]; // [xsp+148h] [xbp-98h] BYREF
  unsigned int v22; // [xsp+158h] [xbp-88h]
  unsigned int v23; // [xsp+15Ch] [xbp-84h]
  unsigned int v24; // [xsp+160h] [xbp-80h]
  int v25; // [xsp+164h] [xbp-7Ch] BYREF
  iovec iov[1]; // [xsp+168h] [xbp-78h]
  int local_auth; // [xsp+178h] [xbp-68h]
  int have_pseudoheader; // [xsp+17Ch] [xbp-64h]
  all_addr do_bit; // [xsp+180h] [xbp-60h] OVERLAPPED BYREF
  in_addr netmask; // [xsp+19Ch] [xbp-44h] BYREF
  all_addr dst_addr; // [xsp+1A0h] [xbp-40h] BYREF
  unsigned int v32; // [xsp+1B0h] [xbp-30h] BYREF
  int v33; // [xsp+1B4h] [xbp-2Ch] BYREF
  _BYTE v34[24]; // [xsp+1C8h] [xbp-18h] OVERLAPPED

  *(_QWORD *)&v34[16] = listen;
  *(_QWORD *)&v34[8] = now;
  *(_QWORD *)v34 = *(_QWORD *)(dnsmasq_daemon + 848LL);
  LOWORD(netmask.s_addr) = 512;
  LODWORD(iov[0].iov_base) = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v7 = 1;
  if ( (*dnsmasq_daemon & 0x2000) != 0 )
    v7 = *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 10;
  v17 = v7;
  *(_QWORD *)(dnsmasq_daemon + 944LL) = 0LL;
  do_bit.addr.addr4.s_addr = 0;
  local_auth = 0;
  have_pseudoheader = 0;
  if ( (*dnsmasq_daemon & 0x2000) != 0 )
  {
    if ( *(_QWORD *)(*(_QWORD *)&v34[16] + 16LL) )
    {
      v25 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v34[16] + 16LL) + 56LL);
      if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 2 )
      {
        do_bit.addr.addr4.s_addr = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v34[16] + 16LL) + 4LL);
        local_auth = do_bit.addr.addr4.s_addr;
        have_pseudoheader = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v34[16] + 16LL) + 28LL);
      }
    }
  }
  v21[0] = *(_QWORD *)(dnsmasq_daemon + 848LL);
  v21[1] = *(unsigned __int16 *)(dnsmasq_daemon + 768LL);
  message.msg_control = &v18;
  message.msg_controllen = 40LL;
  message.msg_flags = 0;
  message.msg_name = &dst_addr.addr.dnssec + 3;
  message.msg_namelen = 28;
  message.msg_iov = (iovec *)v21;
  message.msg_iovlen = 1LL;
  HIDWORD(iov[0].iov_base) = recvmsg(**(_DWORD **)&v34[16], &message, 0);
  if ( HIDWORD(iov[0].iov_base) != -1
    && SHIDWORD(iov[0].iov_base) >= 12
    && (message.msg_flags & 0x20) == 0
    && (*(_BYTE *)(*(_QWORD *)v34 + 2LL) & 0x80) == 0 )
  {
    dst_addr.addr.addr6.__in6_u.__u6_addr16[6] = *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL);
    if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 2 )
    {
      if ( !dst_addr.addr.addr6.__in6_u.__u6_addr16[7] )
        return;
    }
    else
    {
      if ( !dst_addr.addr.addr6.__in6_u.__u6_addr16[7] )
        return;
      v32 = 0;
    }
    if ( (*(_DWORD *)(dnsmasq_daemon + 4LL) & 0x20000) != 0 )
    {
      if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 10 )
      {
        for ( i = *(unsigned int **)(dnsmasq_daemon + 1568LL);
              i && ((i[4] & 2) == 0 || !(unsigned int)is_same_net6(i, &v33, i[5]));
              i = (unsigned int *)*((_QWORD *)i + 3) )
        {
          ;
        }
      }
      else
      {
        for ( i = *(unsigned int **)(dnsmasq_daemon + 1568LL); i; i = (unsigned int *)*((_QWORD *)i + 3) )
        {
          v15 = htonl(-1 << (32 - i[5]));
          if ( (i[4] & 2) == 0 )
          {
            if ( (unsigned int)is_same_net(*i, v32, v15) )
              break;
          }
        }
      }
      if ( !i )
      {
        if ( !receive_query_warned )
        {
          my_syslog(4LL, "Ignoring query from non-local network");
          receive_query_warned = 1;
        }
        return;
      }
    }
    if ( v17 )
    {
      if ( message.msg_controllen < 0x10 )
        return;
      if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 2 )
      {
        for ( j = (struct cmsghdr *)message.msg_control; j; j = _cmsg_nxthdr(&message, j) )
        {
          if ( !j->cmsg_level && j->cmsg_type == 8 )
          {
            do_bit.addr.addr4.s_addr = *(_DWORD *)&j->__cmsg_data[4];
            local_auth = do_bit.addr.addr4.s_addr;
            LODWORD(iov[0].iov_base) = *(_DWORD *)j->__cmsg_data;
          }
        }
      }
      if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 10 )
      {
        if ( message.msg_controllen < 0x10 )
          msg_control = 0LL;
        else
          msg_control = (struct cmsghdr *)message.msg_control;
        for ( j = msg_control; j; j = _cmsg_nxthdr(&message, j) )
        {
          if ( j->cmsg_level == 41 && j->cmsg_type == *(_DWORD *)(dnsmasq_daemon + 1560LL) )
          {
            do_bit = *(all_addr *)j->__cmsg_data;
            LODWORD(iov[0].iov_base) = *(_DWORD *)&j->__cmsg_data[16];
          }
        }
      }
      if ( !(unsigned int)indextoname((unsigned int)**(_DWORD **)&v34[16], LODWORD(iov[0].iov_base), v14) )
        return;
      if ( !(unsigned int)iface_check(*(unsigned int *)(*(_QWORD *)&v34[16] + 12LL), &do_bit, v14, &v25) )
      {
        if ( (*(_DWORD *)(dnsmasq_daemon + 4LL) & 0x80) == 0 )
          enumerate_interfaces(0LL);
        if ( !(unsigned int)loopback_exception(
                              (unsigned int)**(_DWORD **)&v34[16],
                              *(unsigned int *)(*(_QWORD *)&v34[16] + 12LL),
                              &do_bit,
                              v14)
          && !(unsigned int)label_exception(
                              LODWORD(iov[0].iov_base),
                              *(unsigned int *)(*(_QWORD *)&v34[16] + 12LL),
                              &do_bit) )
        {
          return;
        }
      }
      if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 2 && (*dnsmasq_daemon & 0x40000) != 0 )
      {
        for ( k = *(_QWORD *)(dnsmasq_daemon + 904LL);
              k && (*(_WORD *)k != 2 || *(_DWORD *)(k + 4) != local_auth);
              k = *(_QWORD *)(k + 88) )
        {
          ;
        }
        if ( !k && (*(_DWORD *)(dnsmasq_daemon + 4LL) & 0x80) == 0 )
          enumerate_interfaces(0LL);
        for ( m = *(_QWORD *)(dnsmasq_daemon + 904LL);
              m && (*(_WORD *)m != 2 || *(_DWORD *)(m + 4) != local_auth);
              m = *(_QWORD *)(m + 88) )
        {
          ;
        }
        if ( m )
          have_pseudoheader = *(_DWORD *)(m + 28);
        else
          local_auth = 0;
      }
    }
    v2 = *(_DWORD *)(dnsmasq_daemon + 1576LL) + 1;
    *(_DWORD *)(dnsmasq_daemon + 1576LL) = v2;
    *(_DWORD *)(dnsmasq_daemon + 1580LL) = v2;
    *(_QWORD *)(dnsmasq_daemon + 1584LL) = &dst_addr.addr.dnssec + 3;
    if ( !(unsigned int)extract_request(
                          *(_QWORD *)v34,
                          SHIDWORD(iov[0].iov_base),
                          *(_QWORD *)(dnsmasq_daemon + 864LL),
                          (char *)&netmask.s_addr + 2) )
      goto LABEL_114;
    if ( v25 )
      v3 = "auth";
    else
      v3 = "query";
    v10 = querystr(v3, HIWORD(netmask.s_addr));
    if ( *(_DWORD *)(*(_QWORD *)&v34[16] + 12LL) == 2 )
      log_query(524424LL, *(_QWORD *)(dnsmasq_daemon + 864LL), &v32, v10);
    else
      log_query(524552LL, *(_QWORD *)(dnsmasq_daemon + 864LL), &v33, v10);
    if ( !v25 && (*dnsmasq_daemon & 0x40000) == 0 )
    {
      for ( n = *(_QWORD *)(dnsmasq_daemon + 144LL); n; n = *(_QWORD *)(n + 32) )
      {
        if ( (unsigned int)in_zone(n, *(_QWORD *)(dnsmasq_daemon + 864LL), 0LL) )
        {
          v25 = 1;
          v22 = 1;
          break;
        }
      }
    }
    if ( !(unsigned int)detect_loop(*(_QWORD *)(dnsmasq_daemon + 864LL), HIWORD(netmask.s_addr)) )
    {
LABEL_114:
      if ( find_pseudoheader(*(_QWORD *)v34, SHIDWORD(iov[0].iov_base), 0LL, &dst_addr, 0LL, 0LL) )
      {
        v23 = 1;
        LOWORD(netmask.s_addr) = _byteswap_ushort(**(_WORD **)&dst_addr.addr.addr4.s_addr);
        *(_QWORD *)&dst_addr.addr.addr4.s_addr += 2LL;
        *(_QWORD *)&dst_addr.addr.addr4.s_addr += 2LL;
        v9 = _byteswap_ushort(**(_WORD **)&dst_addr.addr.addr4.s_addr);
        *(_QWORD *)&dst_addr.addr.addr4.s_addr += 2LL;
        if ( (v9 & 0x8000) != 0 )
          v24 = 1;
        if ( LOWORD(netmask.s_addr) > (int)*(unsigned __int16 *)(dnsmasq_daemon + 768LL) )
          LOWORD(netmask.s_addr) = *(_WORD *)(dnsmasq_daemon + 768LL);
      }
      if ( v25 )
      {
        iov[0].iov_len = answer_auth(
                           *(_QWORD *)v34,
                           *(_QWORD *)v34 + LOWORD(netmask.s_addr),
                           SHIDWORD(iov[0].iov_base),
                           *(_QWORD *)&v34[8],
                           &dst_addr.addr.dnssec + 3,
                           v22,
                           v24,
                           v23);
        if ( iov[0].iov_len )
        {
          v5 = 1;
          if ( (*dnsmasq_daemon & 0x2000) == 0 )
            v5 = (*(_DWORD *)(dnsmasq_daemon + 4LL) & 0x80) != 0;
          send_from(
            **(_DWORD **)&v34[16],
            v5,
            *(char **)v34,
            iov[0].iov_len,
            (mysockaddr *)(&dst_addr.addr.dnssec + 3),
            &do_bit,
            (unsigned int)iov[0].iov_base);
          ++*(_DWORD *)(dnsmasq_daemon + 880LL);
        }
      }
      else
      {
        ad_reqd = v24;
        if ( (*(_BYTE *)(*(_QWORD *)v34 + 3LL) & 0x20) != 0 )
          ad_reqd = 1;
        iov[0].iov_len = answer_request(
                           *(_QWORD *)v34,
                           *(_QWORD *)v34 + LOWORD(netmask.s_addr),
                           SHIDWORD(iov[0].iov_base),
                           (unsigned int)local_auth,
                           (unsigned int)have_pseudoheader,
                           *(_QWORD *)&v34[8],
                           ad_reqd,
                           v24,
                           v23);
        if ( iov[0].iov_len )
        {
          v4 = 1;
          if ( (*dnsmasq_daemon & 0x2000) == 0 )
            v4 = (*(_DWORD *)(dnsmasq_daemon + 4LL) & 0x80) != 0;
          send_from(
            **(_DWORD **)&v34[16],
            v4,
            *(char **)v34,
            iov[0].iov_len,
            (mysockaddr *)(&dst_addr.addr.dnssec + 3),
            &do_bit,
            (unsigned int)iov[0].iov_base);
          ++*(_DWORD *)(dnsmasq_daemon + 872LL);
        }
        else if ( forward_query(
                    **(_DWORD **)&v34[16],
                    (mysockaddr *)(&dst_addr.addr.dnssec + 3),
                    &do_bit,
                    (unsigned int)iov[0].iov_base,
                    *(dns_header **)v34,
                    SHIDWORD(iov[0].iov_base),
                    *(time_t *)&v34[8],
                    0uLL,
                    ad_reqd,
                    v24) )
        {
          ++*(_DWORD *)(dnsmasq_daemon + 876LL);
        }
        else
        {
          ++*(_DWORD *)(dnsmasq_daemon + 872LL);
        }
      }
    }
  }
}
