void __cdecl receive_query(listener *listen, dns_header *now)
{
  int v2; // eax
  char *v3; // ebp
  bool v4; // bl
  in_addr_t s_addr; // esi
  irec *v6; // ecx
  int v7; // ecx
  irec *iface; // ecx
  ssize_t v9; // eax
  unsigned int v10; // esi
  int family; // eax
  int v12; // ebp
  __uint32_t v13; // eax
  bool v14; // zf
  char v15; // bl
  mysockaddr *v16; // ebx
  mysockaddr *v17; // ebx
  struct cmsghdr *msg_control; // eax
  char *i; // eax
  listener *v20; // edi
  int v21; // ecx
  in_addr_t v22; // edi
  int v23; // eax
  _DWORD *v24; // eax
  int v25; // ecx
  const char *v26; // ecx
  int v27; // eax
  int v28; // ecx
  int v29; // edi
  int v30; // eax
  int v31; // edx
  unsigned int v32; // ecx
  time_t v33; // ecx
  int v34; // eax
  int v35; // edx
  size_t v36; // eax
  int v37; // edx
  all_addr *v38; // edi
  time_t v39; // ebp
  size_t v40; // eax
  int v41; // esi
  frec *v42; // [esp-4h] [ebp-D0h]
  int v43; // [esp+0h] [ebp-CCh]
  int v44; // [esp+4h] [ebp-C8h]
  mysockaddr *udpaddr; // [esp+8h] [ebp-C4h]
  int dns_auth; // [esp+Ch] [ebp-C0h] BYREF
  char *v47; // [esp+10h] [ebp-BCh]
  in_addr_t v48; // [esp+14h] [ebp-B8h]
  unsigned __int16 v49; // [esp+1Ah] [ebp-B2h] BYREF
  int v50; // [esp+1Ch] [ebp-B0h]
  all_addr source; // [esp+20h] [ebp-ACh] BYREF
  struct msghdr message; // [esp+30h] [ebp-9Ch] BYREF
  mysockaddr to; // [esp+50h] [ebp-7Ch] BYREF
  int v54[2]; // [esp+70h] [ebp-5Ch] BYREF
  int v55[8]; // [esp+78h] [ebp-54h] BYREF
  char v56; // [esp+98h] [ebp-34h] BYREF

  v2 = dnsmasq_daemon;
  v3 = *(char **)(dnsmasq_daemon + 476);
  dns_auth = 0;
  v4 = 1;
  if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) != 0 )
    v4 = listen->family == 10;
  *(_DWORD *)(dnsmasq_daemon + 528) = 0;
  source.addr.addr4.s_addr = 0;
  s_addr = 0;
  if ( (*(_BYTE *)(v2 + 1) & 0x20) != 0 && (v6 = listen->iface) != 0 )
  {
    dns_auth = v6->dns_auth;
    v7 = 0;
    if ( listen->family == 2 )
    {
      iface = listen->iface;
      s_addr = iface->addr.in.sin_addr.s_addr;
      source.addr.addr4.s_addr = s_addr;
      v7 = iface->netmask.s_addr;
    }
  }
  else
  {
    v7 = 0;
  }
  v50 = v7;
  v48 = s_addr;
  v54[0] = *(_DWORD *)(v2 + 476);
  v54[1] = *(unsigned __int16 *)(v2 + 432);
  message.msg_control = &v56;
  message.msg_controllen = 32;
  message.msg_flags = 0;
  message.msg_name = &to;
  message.msg_namelen = 28;
  message.msg_iov = (iovec *)v54;
  message.msg_iovlen = 1;
  v9 = recvmsg(listen->fd, &message, 0);
  if ( v9 < 12 || (message.msg_flags & 0x20) != 0 || v3[2] < 0 )
    return;
  v10 = v9;
  family = listen->family;
  to.sa.sa_family = family;
  if ( family == 2 )
  {
    if ( !to.in.sin_port )
      return;
  }
  else
  {
    if ( !to.in.sin_port )
      return;
    to.in.sin_addr.s_addr = 0;
  }
  if ( (*(_BYTE *)(dnsmasq_daemon + 6) & 2) != 0 )
  {
    v47 = v3;
    v12 = *(_DWORD *)(dnsmasq_daemon + 1136);
    if ( family == 10 )
    {
      while ( v12 )
      {
        if ( (*(_BYTE *)(v12 + 16) & 2) != 0 && is_same_net6(v12, &to.in6.sin6_addr, *(_DWORD *)(v12 + 20)) )
          goto LABEL_30;
        v12 = *(_DWORD *)(v12 + 24);
      }
      v12 = 0;
    }
    else
    {
      while ( v12 )
      {
        if ( (*(_BYTE *)(v12 + 16) & 2) == 0 )
        {
          v13 = _bswap_32(-1 << -*(_BYTE *)(v12 + 20));
          if ( is_same_net(*(_DWORD *)v12, to.in.sin_addr.s_addr, v13) )
            break;
        }
        v12 = *(_DWORD *)(v12 + 24);
      }
    }
LABEL_30:
    v14 = v12 == 0;
    v3 = v47;
    if ( v14 )
    {
      if ( !receive_query_warned )
      {
        my_syslog(4, "Ignoring query from non-local network");
        receive_query_warned = 1;
      }
      return;
    }
  }
  v47 = 0;
  if ( !v4 )
  {
    v16 = 0;
LABEL_74:
    v24 = (_DWORD *)dnsmasq_daemon;
    v25 = *(_DWORD *)(dnsmasq_daemon + 1140) + 1;
    *(_DWORD *)(dnsmasq_daemon + 1140) = v25;
    v24[286] = v25;
    v24[287] = &to;
    if ( !extract_request(v3, v10, v24[121], &v49) )
      goto LABEL_109;
    v26 = "auth";
    if ( !dns_auth )
      v26 = "query";
    v27 = querystr(v26, v49);
    v28 = *(_DWORD *)(dnsmasq_daemon + 484);
    if ( listen->family == 2 )
      log_query(524424, v28, &to.in6.sin6_flowinfo, v27);
    else
      log_query(524552, v28, &to.in6.sin6_addr, v27);
    v47 = 0;
    if ( !dns_auth && (*(_BYTE *)(dnsmasq_daemon + 2) & 4) == 0 )
    {
      v29 = *(_DWORD *)(dnsmasq_daemon + 80);
      if ( v29 )
      {
        while ( !in_zone(v29, *(_DWORD *)(dnsmasq_daemon + 484), 0) )
        {
          v29 = *(_DWORD *)(v29 + 16);
          if ( !v29 )
            goto LABEL_87;
        }
        dns_auth = 1;
        v47 = (char *)1;
      }
    }
LABEL_87:
    if ( !detect_loop(*(_DWORD *)(dnsmasq_daemon + 484), v49) )
    {
LABEL_109:
      if ( find_pseudoheader(v3, v10, 0, v55, 0, 0) )
      {
        v30 = v55[0];
        LOWORD(v31) = __ROL2__(*(_WORD *)v55[0], 8);
        v55[0] += 4;
        v32 = *(unsigned __int8 *)v55[0];
        v55[0] = v30 + 6;
        v33 = v32 >> 7;
        if ( (unsigned __int16)v31 > (unsigned __int16)*(_DWORD *)(dnsmasq_daemon + 432) )
          v31 = *(_DWORD *)(dnsmasq_daemon + 432);
        v34 = (unsigned __int16)v31;
        v35 = 1;
      }
      else
      {
        v34 = 512;
        v35 = 0;
        v33 = 0;
      }
      if ( dns_auth )
      {
        v36 = answer_auth(v3, &v3[v34], v10, now, &to, v47, v33, v35);
        if ( v36 )
        {
          v37 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) == 0 )
            v37 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
          send_from(listen->fd, v37, v3, v36, &to, &source, (unsigned int)v16);
          ++*(_DWORD *)(dnsmasq_daemon + 496);
        }
      }
      else
      {
        v14 = (v3[3] & 0x20) == 0;
        v38 = (all_addr *)v3;
        v39 = 1;
        if ( v14 )
          v39 = v33;
        v40 = answer_request(v38, (char *)v38 + v34, v10, v48, v50, now, v39, v33, v35);
        if ( v40 )
        {
          v41 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) == 0 )
            v41 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
          send_from(listen->fd, v41, (char *)v38, v40, &to, &source, (unsigned int)v16);
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
        else if ( forward_query((int)&source, v16, v38, v10, now, 0, v39, v42, v43, v44) )
        {
          ++*(_DWORD *)(dnsmasq_daemon + 492);
        }
        else
        {
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
      }
    }
    return;
  }
  v15 = 0;
  if ( message.msg_controllen >= 0xC )
  {
    v17 = 0;
    if ( listen->family == 2 )
    {
      msg_control = (struct cmsghdr *)message.msg_control;
      if ( message.msg_control )
      {
        v17 = 0;
        do
        {
          if ( !msg_control->cmsg_level && msg_control->cmsg_type == 8 )
          {
            v48 = *(_DWORD *)&msg_control->__cmsg_data[4];
            source.addr.addr4.s_addr = v48;
            v17 = *(mysockaddr **)msg_control->__cmsg_data;
          }
          msg_control = _cmsg_nxthdr(&message, msg_control);
        }
        while ( msg_control );
      }
    }
    if ( listen->family == 10 && message.msg_controllen >= 0xC )
    {
      for ( i = (char *)message.msg_control; i; i = (char *)_cmsg_nxthdr(&message, (struct cmsghdr *)i) )
      {
        if ( *((_DWORD *)i + 1) == 41 && *((_DWORD *)i + 2) == *(_DWORD *)(dnsmasq_daemon + 1132) )
        {
          source = *(all_addr *)(i + 12);
          v17 = (mysockaddr *)*((_DWORD *)i + 7);
        }
      }
    }
    udpaddr = v17;
    v20 = listen;
    if ( !indextoname(listen->fd, v17, v55) )
      goto LABEL_72;
    if ( iface_check(listen->family, &source, v55, &dns_auth) )
      goto LABEL_56;
    if ( *(char *)(dnsmasq_daemon + 4) >= 0 )
      enumerate_interfaces(0);
    v20 = listen;
    if ( loopback_exception(listen->fd, listen->family, &source, v55) || label_exception(v17, listen->family, &source) )
    {
LABEL_56:
      v15 = 1;
      if ( v20->family == 2 && (*(_BYTE *)(dnsmasq_daemon + 2) & 4) != 0 )
      {
        v21 = *(_DWORD *)(dnsmasq_daemon + 508);
        v22 = v48;
        if ( v21 )
        {
          while ( *(_WORD *)v21 != 2 || *(_DWORD *)(v21 + 4) != v48 )
          {
            v21 = *(_DWORD *)(v21 + 80);
            if ( !v21 )
              goto LABEL_59;
          }
        }
        else
        {
LABEL_59:
          if ( *(char *)(dnsmasq_daemon + 4) >= 0 )
            enumerate_interfaces(0);
        }
        v23 = *(_DWORD *)(dnsmasq_daemon + 508);
        if ( v23 )
        {
          while ( *(_WORD *)v23 != 2 || *(_DWORD *)(v23 + 4) != v22 )
          {
            v23 = *(_DWORD *)(v23 + 80);
            if ( !v23 )
              goto LABEL_65;
          }
          v50 = *(_DWORD *)(v23 + 28);
        }
        else
        {
LABEL_65:
          v48 = 0;
        }
      }
    }
    else
    {
LABEL_72:
      v15 = 0;
    }
  }
  else
  {
    udpaddr = 0;
  }
  v14 = v15 == 0;
  v16 = udpaddr;
  if ( !v14 )
    goto LABEL_74;
}
