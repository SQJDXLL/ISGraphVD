void __fastcall receive_query(listener *listen, time_t now)
{
  __int64 v4; // x0
  int v5; // w1
  dns_header *v6; // x23
  unsigned int v7; // w22
  in_addr_t s_addr; // w21
  size_t v9; // x0
  signed __int64 v10; // x25
  unsigned __int64 v11; // x24
  int family; // w0
  irec *iface; // x1
  addrlist *v14; // x3
  in6_addr *p_sin6_addr; // x1
  __int64 v16; // x2
  int v17; // w0
  struct cmsghdr *msg_control; // x1
  addrlist *v19; // x2
  struct cmsghdr *v20; // x1
  __int64 i; // x0
  __int64 j; // x0
  __int64 v23; // x0
  __int64 v24; // x2
  int v25; // w1
  const char *v26; // x0
  __int64 v27; // x3
  addrlist *v28; // x3
  unsigned int v29; // w28
  __int64 v30; // x7
  unsigned __int8 *v31; // x0
  unsigned int v32; // w2
  unsigned __int16 v33; // w2
  unsigned int v34; // w24
  unsigned int v35; // w1
  char *v36; // x1
  size_t v37; // x3
  int v38; // w0
  __int64 v39; // x5
  in6_addr *p_sin6_flowinfo; // x2
  __int64 v41; // x1
  unsigned __int16 v42; // w0
  __int64 k; // x28
  int v44; // w0
  unsigned int v45; // w28
  size_t v46; // x3
  __int64 v47; // x1
  int v48; // w0
  int v49; // [xsp+8h] [xbp-8h]
  in_addr_t v50; // [xsp+7Ch] [xbp+6Ch]
  addrlist *addr; // [xsp+80h] [xbp+70h]
  addrlist *addra; // [xsp+80h] [xbp+70h]
  addrlist *addrb; // [xsp+80h] [xbp+70h]
  addrlist *addrc; // [xsp+80h] [xbp+70h]
  in6_addr *v55; // [xsp+88h] [xbp+78h]
  unsigned __int16 type; // [xsp+92h] [xbp+82h] BYREF
  int auth_dns; // [xsp+94h] [xbp+84h] BYREF
  unsigned __int8 *t_cp; // [xsp+98h] [xbp+88h] BYREF
  msghdr msg; // [xsp+A0h] [xbp+90h] BYREF
  all_addr dst_addr; // [xsp+D8h] [xbp+C8h] BYREF
  iovec iov[1]; // [xsp+E8h] [xbp+D8h] BYREF
  mysockaddr source_addr; // [xsp+F8h] [xbp+E8h] BYREF
  union {cmsghdr align;char control6[40];char control[32];} control_u; // [xsp+118h] [xbp+108h] BYREF
  ifreq ifr; // [xsp+140h] [xbp+130h] BYREF

  v4 = dnsmasq_daemon_0;
  v5 = *dnsmasq_daemon_0;
  auth_dns = 0;
  v6 = *(dns_header **)(dnsmasq_daemon_0 + 848LL);
  v7 = (v5 & 0x2000) == 0 || listen->family == 10;
  v50 = 0;
  dst_addr.addr.addr4.s_addr = 0;
  *(_QWORD *)(dnsmasq_daemon_0 + 944LL) = 0LL;
  if ( (v5 & 0x2000) != 0 && (iface = listen->iface) != 0LL && (auth_dns = iface->dns_auth, listen->family == 2) )
  {
    s_addr = iface->addr.in.sin_addr.s_addr;
    v50 = iface->netmask.s_addr;
    dst_addr.addr.addr4.s_addr = s_addr;
  }
  else
  {
    s_addr = 0;
  }
  v9 = *(unsigned __int16 *)(v4 + 768);
  iov[0].iov_base = v6;
  iov[0].iov_len = v9;
  msg.msg_control = &control_u;
  msg.msg_controllen = 40LL;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1LL;
  LODWORD(v9) = listen->fd;
  msg.msg_name = &source_addr;
  msg.msg_flags = 0;
  v10 = recvmsg(v9, &msg, 0);
  if ( v10 <= 11 )
    return;
  LODWORD(v11) = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || ((char)v6->hb3 & 0x80000000) != 0 )
    return;
  family = listen->family;
  source_addr.sa.sa_family = family;
  if ( family == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
  }
  else
  {
    if ( !source_addr.in.sin_port )
      return;
    source_addr.in.sin_addr.s_addr = 0;
  }
  if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x20000) != 0 )
  {
    v14 = *(addrlist **)(dnsmasq_daemon_0 + 1568LL);
    if ( family == 10 )
    {
      p_sin6_addr = &source_addr.in6.sin6_addr;
      while ( v14 )
      {
        if ( (v14->flags & 2) != 0 )
        {
          addr = v14;
          v55 = p_sin6_addr;
          v17 = is_same_net6(v14);
          v14 = addr;
          p_sin6_addr = v55;
          if ( v17 )
            goto LABEL_29;
        }
        v14 = v14->next;
      }
    }
    else
    {
      while ( v14 )
      {
        v16 = bswap32(-1 << (32 - v14->prefixlen));
        if ( (v14->flags & 2) == 0 )
        {
          addra = v14;
          v38 = is_same_net(v14->addr.addr.addr4.s_addr, source_addr.in.sin_addr.s_addr, v16, v14, 32LL, 0xFFFFFFFFLL);
          v14 = addra;
          if ( v38 )
            goto LABEL_29;
        }
        v14 = v14->next;
      }
    }
    if ( !warned_2 )
    {
      my_syslog(4LL, "Ignoring query from non-local network");
      warned_2 = 1;
    }
  }
  else
  {
LABEL_29:
    if ( v7 )
    {
      if ( msg.msg_controllen <= 0xF )
        return;
      if ( listen->family == 2 )
      {
        msg_control = (struct cmsghdr *)msg.msg_control;
        v7 = 0;
        while ( msg_control )
        {
          if ( *(_QWORD *)&msg_control->cmsg_level == 0x800000000LL )
          {
            v7 = *(_DWORD *)msg_control->__cmsg_data;
            s_addr = *(_DWORD *)&msg_control->__cmsg_data[4];
            dst_addr.addr.addr4.s_addr = s_addr;
          }
          msg_control = _cmsg_nxthdr(&msg, msg_control);
        }
      }
      else
      {
        v7 = 0;
      }
      if ( listen->family == 10 && msg.msg_controllen > 0xF )
      {
        v19 = (addrlist *)&dnsmasq_daemon_0;
        v20 = (struct cmsghdr *)msg.msg_control;
        while ( v20 )
        {
          if ( v20->cmsg_level == 41 && v20->cmsg_type == *(_DWORD *)(*(_QWORD *)&v19->addr.addr.addr4.s_addr + 1560LL) )
          {
            v7 = *(_DWORD *)&v20->__cmsg_data[16];
            v39 = *(_QWORD *)&v20->__cmsg_data[8];
            *(_QWORD *)&dst_addr.addr.addr4.s_addr = *(_QWORD *)v20->__cmsg_data;
            *((_QWORD *)&dst_addr.addr.dnssec + 1) = v39;
          }
          addrb = v19;
          v20 = _cmsg_nxthdr(&msg, v20);
          v19 = addrb;
        }
      }
      if ( !(unsigned int)indextoname((unsigned int)listen->fd, v7) )
        return;
      if ( !(unsigned int)iface_check((unsigned int)listen->family, &dst_addr, &ifr, &auth_dns) )
      {
        if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x80) == 0 )
          ((void (*)(void))enumerate_interfaces)();
        if ( !(unsigned int)loopback_exception((unsigned int)listen->fd, (unsigned int)listen->family, &dst_addr, &ifr)
          && !(unsigned int)label_exception(v7, (unsigned int)listen->family, &dst_addr) )
        {
          return;
        }
      }
      if ( listen->family == 2 && (*dnsmasq_daemon_0 & 0x40000) != 0 )
      {
        for ( i = *(_QWORD *)(dnsmasq_daemon_0 + 904LL); i; i = *(_QWORD *)(i + 88) )
        {
          if ( *(_WORD *)i == 2 && *(_DWORD *)(i + 4) == s_addr )
            goto LABEL_46;
        }
        if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x80) == 0 )
          enumerate_interfaces(0LL);
LABEL_46:
        for ( j = *(_QWORD *)(dnsmasq_daemon_0 + 904LL); ; j = *(_QWORD *)(j + 88) )
        {
          if ( !j )
          {
            s_addr = 0;
            goto LABEL_49;
          }
          if ( *(_WORD *)j == 2 && *(_DWORD *)(j + 4) == s_addr )
            break;
        }
        v50 = *(_DWORD *)(j + 28);
      }
    }
LABEL_49:
    v23 = dnsmasq_daemon_0;
    v24 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
    v25 = *(_DWORD *)(dnsmasq_daemon_0 + 1576LL) + 1;
    *(_DWORD *)(dnsmasq_daemon_0 + 1576LL) = v25;
    *(_DWORD *)(v23 + 1580) = v25;
    *(_QWORD *)(v23 + 1584) = &source_addr;
    if ( (unsigned int)extract_request(v6, v10, v24, &type) )
    {
      v26 = "auth";
      if ( !auth_dns )
        v26 = "query";
      v27 = querystr(v26, type);
      if ( listen->family == 2 )
      {
        p_sin6_flowinfo = (in6_addr *)&source_addr.in6.sin6_flowinfo;
        v41 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
        v42 = 136;
      }
      else
      {
        p_sin6_flowinfo = &source_addr.in6.sin6_addr;
        v41 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
        v42 = 264;
      }
      log_query(v42 | 0x80000u, v41, p_sin6_flowinfo, v27);
      v28 = (addrlist *)&dnsmasq_daemon_0;
      if ( !auth_dns && (*dnsmasq_daemon_0 & 0x40000) == 0 )
      {
        for ( k = *(_QWORD *)(dnsmasq_daemon_0 + 144LL); k; k = *(_QWORD *)(k + 32) )
        {
          addrc = v28;
          v44 = in_zone(k, *(_QWORD *)(*(_QWORD *)&v28->addr.addr.addr4.s_addr + 864LL), 0LL);
          v28 = addrc;
          if ( v44 )
          {
            v29 = 1;
            auth_dns = 1;
            goto LABEL_57;
          }
        }
      }
      v29 = 0;
LABEL_57:
      if ( (unsigned int)detect_loop(*(_QWORD *)(dnsmasq_daemon_0 + 864LL), type) )
        return;
    }
    else
    {
      v29 = 0;
    }
    if ( find_pseudoheader(v6, v10, 0LL, &t_cp, 0LL, 0LL) )
    {
      v30 = 1LL;
      v31 = t_cp + 6;
      v32 = *(unsigned __int16 *)t_cp;
      t_cp += 4;
      v33 = __rev16(v32);
      v34 = *((unsigned __int16 *)v31 - 1);
      t_cp = v31;
      v11 = ((unsigned __int64)__rev16(v34) >> 15) & 1;
      v35 = *(unsigned __int16 *)(dnsmasq_daemon_0 + 768LL);
      if ( v35 > v33 )
        LOWORD(v35) = v33;
    }
    else
    {
      v30 = 0LL;
      LOWORD(v35) = 512;
    }
    v36 = (char *)v6 + (unsigned __int16)v35;
    if ( !auth_dns )
    {
      if ( (v6->hb4 & 0x20) != 0 )
        v45 = 1;
      else
        v45 = v11;
      v46 = answer_request(v6, v36, v10, s_addr, v50, now, v45, (unsigned int)v11, v30);
      if ( v46 )
      {
        send_from(listen->fd, (*dnsmasq_daemon_0 & 0x8000002000LL) != 0, (char *)v6, v46, &source_addr, &dst_addr, v7);
        v47 = dnsmasq_daemon_0;
      }
      else
      {
        v48 = forward_query(listen->fd, &source_addr, &dst_addr, v7, v6, v10, now, 0uLL, v45, v49);
        v47 = dnsmasq_daemon_0;
        if ( v48 )
        {
          ++*(_DWORD *)(dnsmasq_daemon_0 + 876LL);
          return;
        }
      }
      ++*(_DWORD *)(v47 + 872);
      return;
    }
    v37 = answer_auth(v6, v36, v10, now, &source_addr, v29, (unsigned int)v11, v30);
    if ( v37 )
    {
      send_from(listen->fd, (*dnsmasq_daemon_0 & 0x8000002000LL) != 0, (char *)v6, v37, &source_addr, &dst_addr, v7);
      ++*(_DWORD *)(dnsmasq_daemon_0 + 880LL);
    }
  }
}
