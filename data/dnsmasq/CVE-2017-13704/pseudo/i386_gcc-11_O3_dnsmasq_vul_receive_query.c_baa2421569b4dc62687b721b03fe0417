void __cdecl receive_query(listener *listen, time_t now)
{
  _DWORD *v2; // eax
  int family; // ecx
  irec *iface; // edx
  size_t v5; // eax
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // ebp
  int v9; // eax
  char *v10; // ecx
  char *v11; // ebp
  unsigned int v12; // edx
  unsigned int v13; // eax
  _DWORD *v14; // eax
  int v15; // edx
  const char *v16; // eax
  int v17; // eax
  int v18; // esi
  _DWORD *v19; // eax
  int v20; // ebp
  _DWORD *v21; // edx
  __int16 v22; // dx
  __int16 v23; // ax
  int v24; // eax
  int v25; // edx
  char *v26; // eax
  int v27; // ecx
  size_t v28; // esi
  size_t v29; // eax
  int v30; // edx
  in_addr_t s_addr; // ecx
  in_addr_t v32; // edx
  int v33; // esi
  int v34; // edx
  unsigned __int32 v35; // eax
  int v36; // eax
  unsigned int *msg_control; // ecx
  char *v38; // ebp
  unsigned int v39; // edx
  unsigned int v40; // eax
  int v41; // edx
  int v42; // ecx
  in_addr_t v43; // ecx
  size_t v44; // eax
  int v45; // edx
  time_t v46; // [esp-4h] [ebp-F4h]
  char *types; // [esp+0h] [ebp-F0h]
  int v48; // [esp+4h] [ebp-ECh]
  int v49; // [esp+8h] [ebp-E8h]
  mysockaddr *header; // [esp+10h] [ebp-E0h]
  in_addr dst_addr_4; // [esp+14h] [ebp-DCh]
  int check_dst; // [esp+1Ch] [ebp-D4h]
  int n; // [esp+20h] [ebp-D0h]
  in_addr_t v54; // [esp+24h] [ebp-CCh]
  int ad_reqd; // [esp+2Ch] [ebp-C4h]
  int v56; // [esp+30h] [ebp-C0h]
  unsigned __int16 type; // [esp+36h] [ebp-BAh] BYREF
  unsigned __int8 *t_cp; // [esp+38h] [ebp-B8h] BYREF
  int auth_dns; // [esp+3Ch] [ebp-B4h] BYREF
  msghdr msg; // [esp+40h] [ebp-B0h] BYREF
  iovec iov[1]; // [esp+5Ch] [ebp-94h] BYREF
  all_addr dst_addr; // [esp+64h] [ebp-8Ch] BYREF
  mysockaddr source_addr; // [esp+74h] [ebp-7Ch] BYREF
  union {cmsghdr align;char control6[32];char control[24];} control_u; // [esp+90h] [ebp-60h] BYREF
  ifreq ifr; // [esp+B0h] [ebp-40h] BYREF
  unsigned int v66; // [esp+D0h] [ebp-20h]

  v66 = __readgsdword(0x14u);
  auth_dns = 0;
  v2 = dnsmasq_daemon_0;
  header = (mysockaddr *)dnsmasq_daemon_0[119];
  dst_addr_4.s_addr = *dnsmasq_daemon_0 & 0x2000;
  if ( dst_addr_4.s_addr )
  {
    family = listen->family;
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v54 = 0;
    dst_addr_4.s_addr = 0;
    check_dst = family == 10;
    iface = listen->iface;
    if ( iface )
    {
      auth_dns = iface->dns_auth;
      if ( family == 2 )
      {
        s_addr = iface->addr.in.sin_addr.s_addr;
        v32 = iface->netmask.s_addr;
        dst_addr.addr.addr4.s_addr = s_addr;
        dst_addr_4.s_addr = s_addr;
        v54 = v32;
      }
    }
  }
  else
  {
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v54 = 0;
    check_dst = 1;
  }
  v5 = *((unsigned __int16 *)v2 + 216);
  msg.msg_controllen = 32;
  msg.msg_flags = 0;
  iov[0].iov_len = v5;
  msg.msg_control = &control_u;
  msg.msg_name = &source_addr;
  iov[0].iov_base = header;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;
  n = recvmsg(listen->fd, &msg, 0);
  if ( n <= 11 )
    return;
  ad_reqd = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || header->sa.sa_data[0] < 0 )
    return;
  v6 = listen->family;
  source_addr.sa.sa_family = v6;
  if ( v6 == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
    v7 = dnsmasq_daemon_0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_17;
    goto LABEL_58;
  }
  if ( !source_addr.in.sin_port )
    return;
  source_addr.in.sin_addr.s_addr = 0;
  v7 = dnsmasq_daemon_0;
  if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
    goto LABEL_17;
  v8 = dnsmasq_daemon_0[284];
  if ( v6 != 10 )
  {
LABEL_58:
    v33 = v7[284];
    if ( !v33 )
      goto LABEL_99;
    v34 = 32;
    while ( 1 )
    {
      v35 = _byteswap_ulong(-1 << (v34 - *(_BYTE *)(v33 + 20)));
      if ( (*(_BYTE *)(v33 + 16) & 2) == 0 )
      {
        v56 = v34;
        v36 = is_same_net(*(_DWORD *)v33, source_addr.in.sin_addr.s_addr, v35);
        v34 = v56;
        if ( v36 )
          goto LABEL_17;
      }
      v33 = *(_DWORD *)(v33 + 24);
      if ( !v33 )
        goto LABEL_99;
    }
  }
  if ( !v8 )
  {
LABEL_99:
    if ( !warned_2 )
    {
      my_syslog(4, "Ignoring query from non-local network");
      warned_2 = 1;
    }
    return;
  }
  while ( (*(_BYTE *)(v8 + 16) & 2) == 0 || !is_same_net6(v8, &source_addr.in6.sin6_addr, *(_DWORD *)(v8 + 20)) )
  {
    v8 = *(_DWORD *)(v8 + 24);
    if ( !v8 )
      goto LABEL_99;
  }
LABEL_17:
  if ( !check_dst )
  {
    v14 = dnsmasq_daemon_0;
    goto LABEL_30;
  }
  if ( msg.msg_controllen > 0xB )
  {
    v9 = listen->family;
    if ( v9 == 2 )
    {
      msg_control = (unsigned int *)msg.msg_control;
      check_dst = 0;
      if ( msg.msg_control )
      {
        v38 = (char *)msg.msg_control + msg.msg_controllen;
        if ( *((_DWORD *)msg.msg_control + 1) )
          goto LABEL_68;
LABEL_66:
        if ( msg_control[2] == 8 )
        {
          dst_addr.addr.addr4.s_addr = msg_control[4];
          dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr;
          check_dst = msg_control[3];
        }
LABEL_68:
        while ( 1 )
        {
          v39 = *msg_control;
          v40 = (-*msg_control & 3) + 12;
          if ( *msg_control <= 0xB || v40 > v38 - (char *)msg_control || v39 > v38 - (char *)msg_control - v40 )
            break;
          msg_control = (unsigned int *)((char *)msg_control + ((v39 + 3) & 0xFFFFFFFC));
          if ( !msg_control[1] )
            goto LABEL_66;
        }
      }
    }
    else if ( v9 == 10 )
    {
      v10 = (char *)msg.msg_control;
      check_dst = 0;
      if ( msg.msg_control )
      {
        v11 = (char *)msg.msg_control + msg.msg_controllen;
        if ( *((_DWORD *)msg.msg_control + 1) == 41 )
          goto LABEL_27;
        while ( 1 )
        {
          v12 = *(_DWORD *)v10;
          v13 = (-*(_DWORD *)v10 & 3) + 12;
          if ( *(_DWORD *)v10 <= 0xBu || v13 > v11 - v10 || v12 > v11 - v10 - v13 )
            break;
          v10 += (v12 + 3) & 0xFFFFFFFC;
          if ( *((_DWORD *)v10 + 1) == 41 )
          {
LABEL_27:
            if ( *((_DWORD *)v10 + 2) == dnsmasq_daemon_0[283] )
            {
              dst_addr = *(all_addr *)(v10 + 12);
              check_dst = *((_DWORD *)v10 + 7);
            }
          }
        }
      }
    }
    else
    {
      check_dst = 0;
    }
    if ( indextoname(listen->fd, check_dst, &ifr) )
    {
      if ( iface_check(listen->family, &dst_addr, &ifr, &auth_dns) )
        goto LABEL_80;
      if ( *((char *)dnsmasq_daemon_0 + 4) >= 0 )
        enumerate_interfaces(0);
      if ( loopback_exception(listen->fd, listen->family, &dst_addr, &ifr)
        || label_exception(check_dst, listen->family, &dst_addr) )
      {
LABEL_80:
        v14 = dnsmasq_daemon_0;
        if ( listen->family != 2 || (*dnsmasq_daemon_0 & 0x40000) == 0 )
        {
LABEL_30:
          v15 = v14[285] + 1;
          v14[287] = &source_addr;
          v14[285] = v15;
          v14[286] = v15;
          if ( extract_request(header, n, v14[121], &type) )
          {
            v16 = "auth";
            if ( !auth_dns )
              v16 = "query";
            v17 = querystr(v16, type);
            if ( listen->family == 2 )
              log_query(524424, dnsmasq_daemon_0[121], &source_addr.in6.sin6_flowinfo, v17);
            else
              log_query(524552, dnsmasq_daemon_0[121], &source_addr.in6.sin6_addr, v17);
            v18 = auth_dns;
            v19 = dnsmasq_daemon_0;
            if ( auth_dns )
            {
              v18 = 0;
            }
            else if ( (*dnsmasq_daemon_0 & 0x40000) == 0 )
            {
              v20 = dnsmasq_daemon_0[20];
              if ( v20 )
              {
                v21 = dnsmasq_daemon_0;
                do
                {
                  if ( in_zone(v20, v21[121], 0) )
                  {
                    auth_dns = 1;
                    v18 = 1;
                    v19 = dnsmasq_daemon_0;
                    goto LABEL_42;
                  }
                  v20 = *(_DWORD *)(v20 + 16);
                  v21 = dnsmasq_daemon_0;
                }
                while ( v20 );
                v18 = 0;
                v19 = dnsmasq_daemon_0;
              }
            }
LABEL_42:
            if ( detect_loop(v19[121], type) )
              return;
          }
          else
          {
            v18 = 0;
          }
          if ( find_pseudoheader(header, n, 0, &t_cp, 0, 0) )
          {
            v22 = *((_WORD *)t_cp + 2);
            v23 = *(_WORD *)t_cp;
            t_cp += 6;
            LOWORD(v24) = __ROL2__(v23, 8);
            ad_reqd = (unsigned int)(__int16)__ROL2__(v22, 8) >> 31;
            if ( (unsigned __int16)v24 > *((_WORD *)dnsmasq_daemon_0 + 216) )
              LOWORD(v24) = *((_WORD *)dnsmasq_daemon_0 + 216);
            v25 = 1;
            v24 = (unsigned __int16)v24;
          }
          else
          {
            v25 = 0;
            v24 = 512;
          }
          v26 = (char *)header + v24;
          if ( auth_dns )
          {
            v44 = answer_auth(header, v26, n, now, &source_addr, v18, ad_reqd, v25);
            if ( v44 )
            {
              v45 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v45 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(listen->fd, v45, (char *)header, v44, &source_addr, &dst_addr, check_dst);
              ++dnsmasq_daemon_0[124];
            }
          }
          else
          {
            v27 = 1;
            if ( (header->sa.sa_data[1] & 0x20) == 0 )
              v27 = ad_reqd;
            v28 = v27;
            v29 = answer_request(header, v26, n, dst_addr_4.s_addr, v54, now, v27, ad_reqd, v25);
            if ( v29 )
            {
              v30 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v30 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(listen->fd, v30, (char *)header, v29, &source_addr, &dst_addr, check_dst);
              ++dnsmasq_daemon_0[122];
            }
            else if ( forward_query(check_dst, header, (all_addr *)n, now, 0, v28, v46, (frec *)types, v48, v49) )
            {
              ++dnsmasq_daemon_0[123];
            }
            else
            {
              ++dnsmasq_daemon_0[122];
            }
          }
          return;
        }
        v41 = dnsmasq_daemon_0[127];
        if ( v41 )
        {
          v42 = dnsmasq_daemon_0[127];
          do
          {
            if ( *(_WORD *)v42 == 2 && *(_DWORD *)(v42 + 4) == dst_addr_4.s_addr )
            {
              v43 = dst_addr_4.s_addr;
LABEL_89:
              while ( *(_WORD *)v41 != 2 || *(_DWORD *)(v41 + 4) != v43 )
              {
                v41 = *(_DWORD *)(v41 + 80);
                if ( !v41 )
                  goto LABEL_109;
              }
              dst_addr_4.s_addr = v43;
              v54 = *(_DWORD *)(v41 + 28);
              goto LABEL_30;
            }
            v42 = *(_DWORD *)(v42 + 80);
          }
          while ( v42 );
          if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
            goto LABEL_111;
        }
        else if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
        {
LABEL_109:
          dst_addr_4.s_addr = 0;
          goto LABEL_30;
        }
        enumerate_interfaces(0);
        v14 = dnsmasq_daemon_0;
        v41 = dnsmasq_daemon_0[127];
        if ( v41 )
        {
LABEL_111:
          v43 = dst_addr_4.s_addr;
          goto LABEL_89;
        }
        goto LABEL_109;
      }
    }
  }
}
