void __fastcall receive_query(listener *listen, time_t now)
{
  __int64 v3; // x0
  int v4; // w1
  dns_header *v5; // x23
  unsigned int v6; // w22
  in_addr_t v7; // w27
  in_addr_t s_addr; // w21
  size_t v9; // x0
  signed __int64 v10; // x24
  unsigned __int64 v11; // x25
  __int64 v12; // x3
  int family; // w0
  irec *iface; // x1
  unsigned int *v15; // x28
  in6_addr *p_sin6_addr; // x1
  __int64 v17; // x2
  int v18; // w0
  struct cmsghdr *msg_control; // x1
  void *i; // x1
  __int64 j; // x0
  __int64 k; // x0
  __int64 v23; // x0
  __int64 v24; // x2
  int v25; // w1
  const char *v26; // x0
  __int64 v27; // x3
  unsigned int v28; // w28
  __int64 v29; // x7
  unsigned __int8 *v30; // x0
  unsigned int v31; // w2
  unsigned __int16 v32; // w2
  unsigned int v33; // w25
  unsigned int v34; // w1
  char *v35; // x1
  size_t v36; // x3
  __int64 v37; // x3
  __int64 v38; // x1
  in6_addr *p_sin6_flowinfo; // x2
  unsigned __int16 v40; // w0
  __int64 m; // x28
  unsigned int v42; // w28
  size_t v43; // x0
  __int64 v44; // x1
  int v45; // w0
  int v46; // [xsp+8h] [xbp-8h]
  in6_addr *v48; // [xsp+88h] [xbp+78h]
  unsigned __int16 type; // [xsp+92h] [xbp+82h] BYREF
  int auth_dns; // [xsp+94h] [xbp+84h] BYREF
  unsigned __int8 *t_cp; // [xsp+98h] [xbp+88h] BYREF
  msghdr msg; // [xsp+A0h] [xbp+90h] BYREF
  all_addr dst_addr; // [xsp+D8h] [xbp+C8h] BYREF
  iovec iov[1]; // [xsp+E8h] [xbp+D8h] BYREF
  mysockaddr source_addr; // [xsp+F8h] [xbp+E8h] BYREF
  union {cmsghdr align;char control6[40];char control[32];} control_u; // [xsp+118h] [xbp+108h] BYREF
  ifreq ifr; // [xsp+140h] [xbp+130h] BYREF

  v3 = dnsmasq_daemon_0;
  v4 = *dnsmasq_daemon_0;
  auth_dns = 0;
  v5 = *(dns_header **)(dnsmasq_daemon_0 + 848LL);
  v6 = (v4 & 0x2000) == 0 || listen->family == 10;
  dst_addr.addr.addr4.s_addr = 0;
  v7 = 0;
  *(_QWORD *)(dnsmasq_daemon_0 + 944LL) = 0LL;
  if ( (v4 & 0x2000) != 0 && (iface = listen->iface) != 0LL && (auth_dns = iface->dns_auth, listen->family == 2) )
  {
    s_addr = iface->addr.in.sin_addr.s_addr;
    v7 = iface->netmask.s_addr;
    dst_addr.addr.addr4.s_addr = s_addr;
  }
  else
  {
    s_addr = 0;
  }
  v9 = *(unsigned __int16 *)(v3 + 768);
  iov[0].iov_base = v5;
  iov[0].iov_len = v9;
  msg.msg_control = &control_u;
  msg.msg_controllen = 40LL;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1LL;
  LODWORD(v9) = listen->fd;
  msg.msg_name = &source_addr;
  msg.msg_flags = 0;
  v10 = recvmsg(v9, &msg, 0);
  if ( v10 <= 11 )
    return;
  LODWORD(v11) = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || ((char)v5->hb3 & 0x80000000) != 0 )
    return;
  memset(
    (void *)(*(_QWORD *)(dnsmasq_daemon_0 + 848LL) + v10),
    0,
    *(unsigned __int16 *)(dnsmasq_daemon_0 + 768LL) - v10);
  family = listen->family;
  source_addr.sa.sa_family = family;
  if ( family == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
  }
  else
  {
    if ( !source_addr.in.sin_port )
      return;
    source_addr.in.sin_addr.s_addr = 0;
  }
  if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x20000) != 0 )
  {
    v15 = *(unsigned int **)(dnsmasq_daemon_0 + 1568LL);
    if ( family == 10 )
    {
      p_sin6_addr = &source_addr.in6.sin6_addr;
      while ( v15 )
      {
        if ( (v15[4] & 2) != 0 )
        {
          v48 = p_sin6_addr;
          v18 = is_same_net6(v15);
          p_sin6_addr = v48;
          if ( v18 )
            goto LABEL_29;
        }
        v15 = (unsigned int *)*((_QWORD *)v15 + 3);
      }
    }
    else
    {
      while ( v15 )
      {
        v17 = bswap32(-1 << (32 - v15[5]));
        if ( (v15[4] & 2) == 0
          && (unsigned int)is_same_net(*v15, source_addr.in.sin_addr.s_addr, v17, v12, 32LL, 0xFFFFFFFFLL) )
        {
          goto LABEL_29;
        }
        v15 = (unsigned int *)*((_QWORD *)v15 + 3);
      }
    }
    if ( !warned_2 )
    {
      my_syslog(4LL, "Ignoring query from non-local network");
      warned_2 = 1;
    }
  }
  else
  {
LABEL_29:
    if ( v6 )
    {
      if ( msg.msg_controllen <= 0xF )
        return;
      if ( listen->family == 2 )
      {
        msg_control = (struct cmsghdr *)msg.msg_control;
        v6 = 0;
        while ( msg_control )
        {
          if ( *(_QWORD *)&msg_control->cmsg_level == 0x800000000LL )
          {
            v6 = *(_DWORD *)msg_control->__cmsg_data;
            s_addr = *(_DWORD *)&msg_control->__cmsg_data[4];
            dst_addr.addr.addr4.s_addr = s_addr;
          }
          msg_control = _cmsg_nxthdr(&msg, msg_control);
        }
      }
      else
      {
        v6 = 0;
      }
      if ( listen->family == 10 && msg.msg_controllen > 0xF )
      {
        for ( i = msg.msg_control; i; i = _cmsg_nxthdr(&msg, (struct cmsghdr *)i) )
        {
          if ( *((_DWORD *)i + 2) == 41 && *((_DWORD *)i + 3) == *(_DWORD *)(dnsmasq_daemon_0 + 1560LL) )
          {
            v6 = *((_DWORD *)i + 8);
            v37 = *((_QWORD *)i + 3);
            *(_QWORD *)&dst_addr.addr.addr4.s_addr = *((_QWORD *)i + 2);
            *((_QWORD *)&dst_addr.addr.dnssec + 1) = v37;
          }
        }
      }
      if ( !(unsigned int)indextoname((unsigned int)listen->fd, v6, &ifr) )
        return;
      if ( !(unsigned int)iface_check((unsigned int)listen->family, &dst_addr, &ifr, &auth_dns) )
      {
        if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x80) == 0 )
          ((void (*)(void))enumerate_interfaces)();
        if ( !(unsigned int)loopback_exception((unsigned int)listen->fd, (unsigned int)listen->family, &dst_addr, &ifr)
          && !(unsigned int)label_exception(v6, (unsigned int)listen->family, &dst_addr) )
        {
          return;
        }
      }
      if ( listen->family == 2 && (*dnsmasq_daemon_0 & 0x40000) != 0 )
      {
        for ( j = *(_QWORD *)(dnsmasq_daemon_0 + 904LL); j; j = *(_QWORD *)(j + 88) )
        {
          if ( *(_WORD *)j == 2 && *(_DWORD *)(j + 4) == s_addr )
            goto LABEL_46;
        }
        if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x80) == 0 )
          enumerate_interfaces(0LL);
LABEL_46:
        for ( k = *(_QWORD *)(dnsmasq_daemon_0 + 904LL); ; k = *(_QWORD *)(k + 88) )
        {
          if ( !k )
          {
            s_addr = 0;
            goto LABEL_49;
          }
          if ( *(_WORD *)k == 2 && *(_DWORD *)(k + 4) == s_addr )
            break;
        }
        v7 = *(_DWORD *)(k + 28);
      }
    }
LABEL_49:
    v23 = dnsmasq_daemon_0;
    v24 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
    *(_QWORD *)(dnsmasq_daemon_0 + 1584LL) = &source_addr;
    v25 = *(_DWORD *)(v23 + 1576) + 1;
    *(_DWORD *)(v23 + 1576) = v25;
    *(_DWORD *)(v23 + 1580) = v25;
    if ( (unsigned int)extract_request(v5, v10, v24, &type) )
    {
      v26 = "query";
      if ( auth_dns )
        v26 = "auth";
      v27 = querystr(v26, type);
      if ( listen->family == 2 )
      {
        p_sin6_flowinfo = (in6_addr *)&source_addr.in6.sin6_flowinfo;
        v38 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
        v40 = 136;
      }
      else
      {
        v38 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
        p_sin6_flowinfo = &source_addr.in6.sin6_addr;
        v40 = 264;
      }
      log_query(v40 | 0x80000u, v38, p_sin6_flowinfo, v27);
      if ( !auth_dns && (*dnsmasq_daemon_0 & 0x40000) == 0 )
      {
        for ( m = *(_QWORD *)(dnsmasq_daemon_0 + 144LL); m; m = *(_QWORD *)(m + 32) )
        {
          if ( (unsigned int)in_zone(m, *(_QWORD *)(dnsmasq_daemon_0 + 864LL), 0LL) )
          {
            v28 = 1;
            auth_dns = 1;
            goto LABEL_57;
          }
        }
      }
      v28 = 0;
LABEL_57:
      if ( (unsigned int)detect_loop(*(_QWORD *)(dnsmasq_daemon_0 + 864LL), type) )
        return;
    }
    else
    {
      v28 = 0;
    }
    if ( find_pseudoheader(v5, v10, 0LL, &t_cp, 0LL, 0LL) )
    {
      v29 = 1LL;
      v30 = t_cp + 6;
      v31 = *(unsigned __int16 *)t_cp;
      t_cp += 4;
      v32 = __rev16(v31);
      v33 = *((unsigned __int16 *)v30 - 1);
      t_cp = v30;
      v11 = ((unsigned __int64)__rev16(v33) >> 15) & 1;
      v34 = *(unsigned __int16 *)(dnsmasq_daemon_0 + 768LL);
      if ( v34 > v32 )
        LOWORD(v34) = v32;
    }
    else
    {
      v29 = 0LL;
      LOWORD(v34) = 512;
    }
    v35 = (char *)v5 + (unsigned __int16)v34;
    if ( !auth_dns )
    {
      if ( (v5->hb4 & 0x20) != 0 )
        v42 = 1;
      else
        v42 = v11;
      v43 = answer_request(v5, v35, v10, s_addr, v7, now, v42, (unsigned int)v11, v29);
      if ( v43 )
      {
        send_from(listen->fd, (*dnsmasq_daemon_0 & 0x8000002000LL) != 0, (char *)v5, v43, &source_addr, &dst_addr, v6);
        v44 = dnsmasq_daemon_0;
      }
      else
      {
        v45 = forward_query(listen->fd, &source_addr, &dst_addr, v6, v5, v10, now, 0uLL, v42, v46);
        v44 = dnsmasq_daemon_0;
        if ( v45 )
        {
          ++*(_DWORD *)(dnsmasq_daemon_0 + 876LL);
          return;
        }
      }
      ++*(_DWORD *)(v44 + 872);
      return;
    }
    v36 = answer_auth(v5, v35, v10, now, &source_addr, v28, (unsigned int)v11, v29);
    if ( v36 )
    {
      send_from(listen->fd, (*dnsmasq_daemon_0 & 0x8000002000LL) != 0, (char *)v5, v36, &source_addr, &dst_addr, v6);
      ++*(_DWORD *)(dnsmasq_daemon_0 + 880LL);
    }
  }
}
