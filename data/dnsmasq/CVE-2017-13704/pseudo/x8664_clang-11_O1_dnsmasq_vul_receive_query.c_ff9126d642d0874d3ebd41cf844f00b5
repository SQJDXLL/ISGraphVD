void __fastcall receive_query(listener *listen, time_t now)
{
  __int64 v3; // rax
  dns_header *v4; // r14
  bool v5; // bp
  in_addr_t s_addr; // r13d
  irec *v7; // rcx
  unsigned int v8; // ecx
  irec *iface; // rcx
  ssize_t v10; // rax
  size_t v11; // r12
  int family; // eax
  unsigned int *v13; // r14
  __uint32_t v14; // eax
  bool v15; // zf
  char v16; // bp
  __int64 v17; // rbp
  struct cmsghdr *msg_control; // rax
  unsigned int *v19; // rax
  int v20; // eax
  int v21; // eax
  __int64 i; // rcx
  __int64 v23; // rax
  __int64 v24; // rax
  int v25; // ecx
  const char *v26; // rdi
  __int64 v27; // rax
  in6_addr *p_sin6_flowinfo; // rdx
  __int64 v29; // rdi
  __int64 v30; // rbp
  __int64 v31; // rbp
  __int64 v32; // rcx
  unsigned __int16 v33; // dx
  unsigned int v34; // eax
  __int64 v35; // rax
  __int64 v36; // rsi
  size_t v37; // rax
  int v38; // esi
  __int64 v39; // r15
  __int64 v40; // rcx
  time_t v41; // r13
  size_t v42; // rax
  int fd; // edi
  int v44; // esi
  int v45; // [rsp-8h] [rbp-140h]
  unsigned int v46; // [rsp+4h] [rbp-134h]
  int dns_auth; // [rsp+8h] [rbp-130h] BYREF
  unsigned __int16 v48; // [rsp+Eh] [rbp-12Ah] BYREF
  unsigned int dst_iface[2]; // [rsp+10h] [rbp-128h]
  unsigned int v50; // [rsp+1Ch] [rbp-11Ch]
  all_addr source; // [rsp+20h] [rbp-118h] BYREF
  dns_header *v52; // [rsp+38h] [rbp-100h]
  mysockaddr to; // [rsp+40h] [rbp-F8h] BYREF
  time_t v54; // [rsp+60h] [rbp-D8h]
  struct msghdr message; // [rsp+68h] [rbp-D0h] BYREF
  __int64 v56[3]; // [rsp+A0h] [rbp-98h] BYREF
  __int64 v57[5]; // [rsp+B8h] [rbp-80h] BYREF
  char v58; // [rsp+E0h] [rbp-58h] BYREF

  v54 = now;
  v3 = dnsmasq_daemon;
  v4 = *(dns_header **)(dnsmasq_daemon + 848LL);
  dns_auth = 0;
  v5 = 1;
  if ( (*(_BYTE *)(dnsmasq_daemon + 1LL) & 0x20) != 0 )
    v5 = listen->family == 10;
  *(_QWORD *)(dnsmasq_daemon + 944LL) = 0LL;
  source.addr.addr4.s_addr = 0;
  s_addr = 0;
  if ( (*(_BYTE *)(v3 + 1) & 0x20) != 0 && (v7 = listen->iface) != 0LL )
  {
    dns_auth = v7->dns_auth;
    v8 = 0;
    if ( listen->family == 2 )
    {
      iface = listen->iface;
      s_addr = iface->addr.in.sin_addr.s_addr;
      source.addr.addr4.s_addr = s_addr;
      v8 = iface->netmask.s_addr;
    }
  }
  else
  {
    v8 = 0;
  }
  v50 = v8;
  v56[0] = *(_QWORD *)(v3 + 848);
  v56[1] = *(unsigned __int16 *)(v3 + 768);
  message.msg_control = &v58;
  message.msg_controllen = 40LL;
  message.msg_flags = 0;
  message.msg_name = &to;
  message.msg_namelen = 28;
  message.msg_iov = (iovec *)v56;
  message.msg_iovlen = 1LL;
  v10 = recvmsg(listen->fd, &message, 0);
  if ( v10 < 12 || (message.msg_flags & 0x20) != 0 || (v4->hb3 & 0x80u) != 0 )
    return;
  v11 = v10;
  family = listen->family;
  to.sa.sa_family = family;
  if ( family == 2 )
  {
    if ( !to.in.sin_port )
      return;
  }
  else
  {
    if ( !to.in.sin_port )
      return;
    to.in.sin_addr.s_addr = 0;
  }
  if ( (*(_BYTE *)(dnsmasq_daemon + 6LL) & 2) != 0 )
  {
    v52 = v4;
    v13 = *(unsigned int **)(dnsmasq_daemon + 1568LL);
    if ( family == 10 )
    {
      while ( v13 )
      {
        if ( (v13[4] & 2) != 0 && (unsigned int)is_same_net6(v13, &to.in6.sin6_addr, v13[5]) )
          goto LABEL_30;
        v13 = (unsigned int *)*((_QWORD *)v13 + 3);
      }
      v13 = 0LL;
    }
    else
    {
      while ( v13 )
      {
        if ( (v13[4] & 2) == 0 )
        {
          v14 = _bswap_32(-1 << -*((_BYTE *)v13 + 20));
          if ( (unsigned int)is_same_net(*v13, to.in.sin_addr.s_addr, v14) )
            break;
        }
        v13 = (unsigned int *)*((_QWORD *)v13 + 3);
      }
    }
LABEL_30:
    v15 = v13 == 0LL;
    v4 = v52;
    if ( v15 )
    {
      if ( !receive_query_warned )
      {
        my_syslog(4LL, "Ignoring query from non-local network");
        receive_query_warned = 1;
      }
      return;
    }
  }
  if ( !v5 )
  {
    v46 = 0;
    *(_QWORD *)dst_iface = 0LL;
LABEL_77:
    v24 = dnsmasq_daemon;
    v25 = *(_DWORD *)(dnsmasq_daemon + 1576LL) + 1;
    *(_DWORD *)(dnsmasq_daemon + 1576LL) = v25;
    *(_DWORD *)(v24 + 1580) = v25;
    *(_QWORD *)(v24 + 1584) = &to;
    if ( !(unsigned int)extract_request(v4, v11, *(_QWORD *)(v24 + 864), &v48) )
      goto LABEL_91;
    v26 = "auth";
    if ( !dns_auth )
      v26 = "query";
    v27 = querystr(v26, v48);
    if ( listen->family == 2 )
    {
      p_sin6_flowinfo = (in6_addr *)&to.in6.sin6_flowinfo;
      v29 = 524424LL;
    }
    else
    {
      p_sin6_flowinfo = &to.in6.sin6_addr;
      v29 = 524552LL;
    }
    log_query(v29, *(_QWORD *)(dnsmasq_daemon + 864LL), p_sin6_flowinfo, v27);
    v46 = 0;
    if ( !dns_auth && (*(_BYTE *)(dnsmasq_daemon + 2LL) & 4) == 0 )
    {
      v30 = *(_QWORD *)(dnsmasq_daemon + 144LL);
      if ( v30 )
      {
        while ( !(unsigned int)in_zone(v30, *(_QWORD *)(dnsmasq_daemon + 864LL), 0LL) )
        {
          v30 = *(_QWORD *)(v30 + 32);
          if ( !v30 )
          {
            v46 = 0;
            goto LABEL_90;
          }
        }
        dns_auth = 1;
        v46 = 1;
      }
    }
LABEL_90:
    if ( !(unsigned int)detect_loop(*(_QWORD *)(dnsmasq_daemon + 864LL), v48) )
    {
LABEL_91:
      v31 = 0LL;
      if ( find_pseudoheader(v4, v11, 0LL, v57, 0LL, 0LL) )
      {
        v32 = v57[0];
        v33 = __ROL2__(*(_WORD *)v57[0], 8);
        v57[0] += 4LL;
        v34 = *(unsigned __int8 *)v57[0];
        v57[0] = v32 + 6;
        v35 = v34 >> 7;
        if ( v33 > (unsigned __int16)*(_DWORD *)(dnsmasq_daemon + 768LL) )
          v33 = *(_DWORD *)(dnsmasq_daemon + 768LL);
        v36 = v33;
        v31 = 1LL;
      }
      else
      {
        v36 = 512LL;
        v35 = 0LL;
      }
      if ( dns_auth )
      {
        v37 = answer_auth(v4, (char *)v4 + v36, v11, v54, &to, v46, v35, v31);
        if ( v37 )
        {
          v38 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1LL) & 0x20) == 0 )
            v38 = (*(_DWORD *)(dnsmasq_daemon + 4LL) >> 7) & 1;
          send_from(listen->fd, v38, (char *)v4, v37, &to, &source, dst_iface[0]);
          ++*(_DWORD *)(dnsmasq_daemon + 880LL);
        }
      }
      else
      {
        v39 = 1LL;
        if ( (v4->hb4 & 0x20) == 0 )
          v39 = (unsigned int)v35;
        v40 = s_addr;
        v41 = v54;
        v42 = answer_request(v4, (char *)v4 + v36, v11, v40, v50, v54, v39, v35, v31);
        fd = listen->fd;
        if ( v42 )
        {
          v44 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1LL) & 0x20) == 0 )
            v44 = (*(_DWORD *)(dnsmasq_daemon + 4LL) >> 7) & 1;
          send_from(fd, v44, (char *)v4, v42, &to, &source, dst_iface[0]);
          ++*(_DWORD *)(dnsmasq_daemon + 872LL);
        }
        else if ( forward_query(fd, &to, &source, dst_iface[0], v4, v11, v41, 0LL, v39, v45) )
        {
          ++*(_DWORD *)(dnsmasq_daemon + 876LL);
        }
        else
        {
          ++*(_DWORD *)(dnsmasq_daemon + 872LL);
        }
      }
    }
    return;
  }
  v16 = 0;
  if ( message.msg_controllen >= 0x10 )
  {
    v46 = 0;
    v17 = 0LL;
    v15 = listen->family == 2;
    v52 = v4;
    if ( v15 )
    {
      msg_control = (struct cmsghdr *)message.msg_control;
      if ( message.msg_control )
      {
        v17 = 0LL;
        do
        {
          if ( !msg_control->cmsg_level && msg_control->cmsg_type == 8 )
          {
            s_addr = *(_DWORD *)&msg_control->__cmsg_data[4];
            source.addr.addr4.s_addr = s_addr;
            v17 = *(unsigned int *)msg_control->__cmsg_data;
          }
          msg_control = _cmsg_nxthdr(&message, msg_control);
        }
        while ( msg_control );
      }
    }
    if ( listen->family == 10 && message.msg_controllen >= 0x10 )
    {
      v19 = (unsigned int *)message.msg_control;
      if ( message.msg_control )
      {
        do
        {
          if ( v19[2] == 41 && v19[3] == *(_DWORD *)(dnsmasq_daemon + 1560LL) )
          {
            source = (all_addr)*((_OWORD *)v19 + 1);
            v17 = v19[8];
          }
          v19 = (unsigned int *)_cmsg_nxthdr(&message, (struct cmsghdr *)v19);
        }
        while ( v19 );
      }
    }
    v20 = indextoname((unsigned int)listen->fd, (unsigned int)v17, v57);
    *(_QWORD *)dst_iface = v17;
    if ( v20 )
    {
      v21 = iface_check((unsigned int)listen->family, &source, v57, &dns_auth);
      v4 = v52;
      if ( v21 )
        goto LABEL_56;
      if ( *(char *)(dnsmasq_daemon + 4LL) >= 0 )
        enumerate_interfaces(0LL);
      if ( (unsigned int)loopback_exception((unsigned int)listen->fd, (unsigned int)listen->family, &source, v57)
        || (unsigned int)label_exception((unsigned int)v17, (unsigned int)listen->family, &source) )
      {
LABEL_56:
        v16 = 1;
        if ( listen->family == 2 && (*(_BYTE *)(dnsmasq_daemon + 2LL) & 4) != 0 )
        {
          for ( i = *(_QWORD *)(dnsmasq_daemon + 904LL); i; i = *(_QWORD *)(i + 88) )
          {
            if ( *(_WORD *)i == 2 && *(_DWORD *)(i + 4) == s_addr )
              goto LABEL_69;
          }
          if ( *(char *)(dnsmasq_daemon + 4LL) >= 0 )
            enumerate_interfaces(0LL);
LABEL_69:
          v23 = *(_QWORD *)(dnsmasq_daemon + 904LL);
          if ( v23 )
          {
            while ( *(_WORD *)v23 != 2 || *(_DWORD *)(v23 + 4) != s_addr )
            {
              v23 = *(_QWORD *)(v23 + 88);
              if ( !v23 )
                goto LABEL_70;
            }
            v50 = *(_DWORD *)(v23 + 28);
          }
          else
          {
LABEL_70:
            s_addr = 0;
          }
        }
      }
      else
      {
        v16 = 0;
      }
    }
    else
    {
      v16 = 0;
      v4 = v52;
    }
  }
  else
  {
    v46 = 0;
    *(_QWORD *)dst_iface = 0LL;
  }
  if ( v16 )
    goto LABEL_77;
}
