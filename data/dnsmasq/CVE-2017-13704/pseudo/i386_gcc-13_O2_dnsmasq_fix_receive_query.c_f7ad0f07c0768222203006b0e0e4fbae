void __cdecl receive_query(listener *listen, time_t now)
{
  listener *v2; // esi
  _DWORD *v3; // eax
  int family; // ecx
  irec *iface; // edx
  in_addr_t s_addr; // edi
  size_t v7; // eax
  int v8; // eax
  _DWORD *v9; // edx
  int v10; // esi
  int v11; // edx
  char *v12; // ecx
  unsigned int v13; // eax
  unsigned int v14; // edx
  int v15; // edx
  int v16; // esi
  unsigned __int32 v17; // eax
  unsigned int *msg_control; // ecx
  unsigned int v19; // eax
  unsigned int v20; // edx
  _DWORD *v21; // eax
  int v22; // edx
  const char *v23; // eax
  int v24; // eax
  _DWORD *v25; // eax
  int v26; // edi
  _DWORD *v27; // edx
  __int16 v28; // dx
  __int16 v29; // ax
  int v30; // eax
  int v31; // edx
  char *v32; // ecx
  size_t v33; // edi
  size_t v34; // eax
  int v35; // edx
  size_t v36; // eax
  int v37; // edx
  int v38; // edx
  int v39; // ecx
  in_addr_t v40; // ecx
  time_t v41; // [esp-4h] [ebp-F4h]
  char *types; // [esp+0h] [ebp-F0h]
  int v43; // [esp+4h] [ebp-ECh]
  int v44; // [esp+8h] [ebp-E8h]
  mysockaddr *header; // [esp+10h] [ebp-E0h]
  in_addr dst_addr_4; // [esp+14h] [ebp-DCh]
  int if_index; // [esp+18h] [ebp-D8h]
  int n; // [esp+1Ch] [ebp-D4h]
  in_addr_t v49; // [esp+20h] [ebp-D0h]
  int ad_reqd; // [esp+28h] [ebp-C8h]
  char *local_auth; // [esp+2Ch] [ebp-C4h]
  char *local_autha; // [esp+2Ch] [ebp-C4h]
  int local_authb; // [esp+2Ch] [ebp-C4h]
  unsigned __int16 type; // [esp+36h] [ebp-BAh] BYREF
  unsigned __int8 *t_cp; // [esp+38h] [ebp-B8h] BYREF
  int auth_dns; // [esp+3Ch] [ebp-B4h] BYREF
  msghdr msg; // [esp+40h] [ebp-B0h] BYREF
  iovec iov[1]; // [esp+5Ch] [ebp-94h] BYREF
  all_addr dst_addr; // [esp+64h] [ebp-8Ch] BYREF
  mysockaddr source_addr; // [esp+74h] [ebp-7Ch] BYREF
  union {cmsghdr align;char control6[32];char control[24];} control_u; // [esp+90h] [ebp-60h] BYREF
  ifreq ifr; // [esp+B0h] [ebp-40h] BYREF
  unsigned int v63; // [esp+D0h] [ebp-20h]

  v63 = __readgsdword(0x14u);
  v2 = listen;
  auth_dns = 0;
  v3 = dnsmasq_daemon_0;
  header = (mysockaddr *)dnsmasq_daemon_0[119];
  dst_addr_4.s_addr = *dnsmasq_daemon_0 & 0x2000;
  if ( dst_addr_4.s_addr )
  {
    family = listen->family;
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v49 = 0;
    if_index = family == 10;
    iface = listen->iface;
    if ( iface )
    {
      dst_addr_4.s_addr = 0;
      auth_dns = iface->dns_auth;
      if ( family == 2 )
      {
        s_addr = iface->netmask.s_addr;
        dst_addr.addr.addr4.s_addr = iface->addr.in.sin_addr.s_addr;
        dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr;
        v49 = s_addr;
      }
    }
    else
    {
      dst_addr_4.s_addr = 0;
    }
  }
  else
  {
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v49 = 0;
    if_index = 1;
  }
  v7 = *((unsigned __int16 *)v3 + 216);
  msg.msg_controllen = 32;
  msg.msg_flags = 0;
  iov[0].iov_len = v7;
  msg.msg_control = &control_u;
  msg.msg_name = &source_addr;
  iov[0].iov_base = header;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;
  n = recvmsg(listen->fd, &msg, 0);
  if ( n <= 11 )
    return;
  ad_reqd = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || header->sa.sa_data[0] < 0 )
    return;
  memset((void *)(dnsmasq_daemon_0[119] + n), 0, *((unsigned __int16 *)dnsmasq_daemon_0 + 216) - n);
  v8 = listen->family;
  source_addr.sa.sa_family = v8;
  if ( v8 == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
    v9 = dnsmasq_daemon_0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_19;
  }
  else
  {
    if ( !source_addr.in.sin_port )
      return;
    v9 = dnsmasq_daemon_0;
    source_addr.in.sin_addr.s_addr = 0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_19;
    if ( v8 == 10 )
    {
      if ( dnsmasq_daemon_0[284] )
      {
        v10 = dnsmasq_daemon_0[284];
        while ( (*(_BYTE *)(v10 + 16) & 2) == 0 || !is_same_net6(v10, &source_addr.in6.sin6_addr, *(_DWORD *)(v10 + 20)) )
        {
          v10 = *(_DWORD *)(v10 + 24);
          if ( !v10 )
            goto LABEL_41;
        }
        v2 = listen;
        goto LABEL_19;
      }
LABEL_41:
      if ( !warned_2 )
      {
        my_syslog(4, "Ignoring query from non-local network");
        warned_2 = 1;
      }
      return;
    }
  }
  v15 = v9[284];
  if ( !v15 )
    goto LABEL_41;
  v16 = v15;
  while ( 1 )
  {
    v17 = _byteswap_ulong(-1 << (32 - *(_BYTE *)(v16 + 20)));
    if ( (*(_BYTE *)(v16 + 16) & 2) == 0 )
    {
      if ( is_same_net(*(_DWORD *)v16, source_addr.in.sin_addr.s_addr, v17) )
        break;
    }
    v16 = *(_DWORD *)(v16 + 24);
    if ( !v16 )
      goto LABEL_41;
  }
  v2 = listen;
LABEL_19:
  if ( !if_index )
  {
    v21 = dnsmasq_daemon_0;
    goto LABEL_59;
  }
  if ( msg.msg_controllen > 0xB )
  {
    v11 = v2->family;
    if ( v11 == 2 )
    {
      msg_control = (unsigned int *)msg.msg_control;
      if_index = 0;
      if ( msg.msg_control )
      {
        local_autha = (char *)msg.msg_control + msg.msg_controllen;
        if ( *((_DWORD *)msg.msg_control + 1) )
          goto LABEL_47;
LABEL_45:
        if ( msg_control[2] == 8 )
        {
          dst_addr.addr.addr4.s_addr = msg_control[4];
          dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr;
          if_index = msg_control[3];
        }
LABEL_47:
        while ( 1 )
        {
          v19 = *msg_control;
          v20 = (-*msg_control & 3) + 12;
          if ( *msg_control <= 0xB
            || local_autha - (char *)msg_control < v20
            || local_autha - (char *)msg_control - v20 < v19 )
          {
            break;
          }
          msg_control = (unsigned int *)((char *)msg_control + ((v19 + 3) & 0xFFFFFFFC));
          if ( !msg_control[1] )
            goto LABEL_45;
        }
      }
    }
    else if ( v11 == 10 && (v12 = (char *)msg.msg_control) != 0 )
    {
      if_index = 0;
      local_auth = (char *)msg.msg_control + msg.msg_controllen;
      if ( *((_DWORD *)msg.msg_control + 1) == 41 )
        goto LABEL_29;
      while ( 1 )
      {
        v13 = *(_DWORD *)v12;
        v14 = (-*(_DWORD *)v12 & 3) + 12;
        if ( *(_DWORD *)v12 <= 0xBu || local_auth - v12 < v14 || local_auth - v12 - v14 < v13 )
          break;
        v12 += (v13 + 3) & 0xFFFFFFFC;
        if ( *((_DWORD *)v12 + 1) == 41 )
        {
LABEL_29:
          if ( *((_DWORD *)v12 + 2) == dnsmasq_daemon_0[283] )
          {
            dst_addr = *(all_addr *)(v12 + 12);
            if_index = *((_DWORD *)v12 + 7);
          }
        }
      }
    }
    else
    {
      if_index = 0;
    }
    if ( indextoname(v2->fd, if_index, &ifr) )
    {
      if ( iface_check(v2->family, &dst_addr, &ifr, &auth_dns) )
        goto LABEL_58;
      if ( *((char *)dnsmasq_daemon_0 + 4) >= 0 )
        enumerate_interfaces(0);
      if ( loopback_exception(v2->fd, v2->family, &dst_addr, &ifr) || label_exception(if_index, v2->family, &dst_addr) )
      {
LABEL_58:
        v21 = dnsmasq_daemon_0;
        if ( v2->family != 2 || (*dnsmasq_daemon_0 & 0x40000) == 0 )
          goto LABEL_59;
        v38 = dnsmasq_daemon_0[127];
        if ( v38 )
        {
          v39 = dnsmasq_daemon_0[127];
          do
          {
            if ( *(_WORD *)v39 == 2 && *(_DWORD *)(v39 + 4) == dst_addr_4.s_addr )
            {
              v40 = dst_addr_4.s_addr;
LABEL_102:
              while ( *(_WORD *)v38 != 2 || *(_DWORD *)(v38 + 4) != v40 )
              {
                v38 = *(_DWORD *)(v38 + 80);
                if ( !v38 )
                  goto LABEL_112;
              }
              dst_addr_4.s_addr = v40;
              v49 = *(_DWORD *)(v38 + 28);
              goto LABEL_59;
            }
            v39 = *(_DWORD *)(v39 + 80);
          }
          while ( v39 );
          if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
            goto LABEL_114;
        }
        else if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
        {
LABEL_111:
          v21 = dnsmasq_daemon_0;
LABEL_112:
          dst_addr_4.s_addr = 0;
LABEL_59:
          v22 = v21[285] + 1;
          v21[285] = v22;
          v21[286] = v22;
          v21[287] = &source_addr;
          if ( extract_request(header, n, v21[121], &type) )
          {
            v23 = "query";
            if ( auth_dns )
              v23 = "auth";
            v24 = querystr(v23, type);
            if ( v2->family == 2 )
              log_query(524424, dnsmasq_daemon_0[121], &source_addr.in6.sin6_flowinfo, v24);
            else
              log_query(524552, dnsmasq_daemon_0[121], &source_addr.in6.sin6_addr, v24);
            v25 = dnsmasq_daemon_0;
            local_authb = auth_dns;
            if ( auth_dns )
            {
              local_authb = 0;
            }
            else if ( (*dnsmasq_daemon_0 & 0x40000) == 0 )
            {
              v26 = dnsmasq_daemon_0[20];
              if ( v26 )
              {
                v27 = dnsmasq_daemon_0;
                do
                {
                  if ( in_zone(v26, v27[121], 0) )
                  {
                    auth_dns = 1;
                    v25 = dnsmasq_daemon_0;
                    local_authb = 1;
                    goto LABEL_71;
                  }
                  v26 = *(_DWORD *)(v26 + 16);
                  v27 = dnsmasq_daemon_0;
                }
                while ( v26 );
                local_authb = 0;
                v25 = dnsmasq_daemon_0;
              }
            }
LABEL_71:
            if ( detect_loop(v25[121], type) )
              return;
          }
          else
          {
            local_authb = 0;
          }
          if ( find_pseudoheader(header, n, 0, &t_cp, 0, 0) )
          {
            v28 = *((_WORD *)t_cp + 2);
            v29 = *(_WORD *)t_cp;
            t_cp += 6;
            LOWORD(v30) = __ROL2__(v29, 8);
            ad_reqd = (unsigned int)(__int16)__ROL2__(v28, 8) >> 31;
            if ( (unsigned __int16)v30 > *((_WORD *)dnsmasq_daemon_0 + 216) )
              LOWORD(v30) = *((_WORD *)dnsmasq_daemon_0 + 216);
            v31 = 1;
            v30 = (unsigned __int16)v30;
          }
          else
          {
            v31 = 0;
            v30 = 512;
          }
          v32 = (char *)header + v30;
          if ( auth_dns )
          {
            v36 = answer_auth(header, v32, n, now, &source_addr, local_authb, ad_reqd, v31);
            if ( v36 )
            {
              v37 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v37 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(v2->fd, v37, (char *)header, v36, &source_addr, &dst_addr, if_index);
              ++dnsmasq_daemon_0[124];
            }
          }
          else
          {
            v33 = 1;
            if ( (header->sa.sa_data[1] & 0x20) == 0 )
              v33 = ad_reqd;
            v34 = answer_request(header, v32, n, dst_addr_4.s_addr, v49, now, v33, ad_reqd, v31);
            if ( v34 )
            {
              v35 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v35 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(v2->fd, v35, (char *)header, v34, &source_addr, &dst_addr, if_index);
              ++dnsmasq_daemon_0[122];
            }
            else if ( forward_query(if_index, header, (all_addr *)n, now, 0, v33, v41, (frec *)types, v43, v44) )
            {
              ++dnsmasq_daemon_0[123];
            }
            else
            {
              ++dnsmasq_daemon_0[122];
            }
          }
          return;
        }
        enumerate_interfaces(0);
        v21 = dnsmasq_daemon_0;
        v38 = dnsmasq_daemon_0[127];
        if ( v38 )
        {
LABEL_114:
          v40 = dst_addr_4.s_addr;
          goto LABEL_102;
        }
        goto LABEL_111;
      }
    }
  }
}
