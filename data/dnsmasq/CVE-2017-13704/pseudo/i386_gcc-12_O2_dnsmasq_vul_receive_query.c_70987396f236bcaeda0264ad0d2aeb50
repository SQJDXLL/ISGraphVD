void __cdecl receive_query(listener *listen, time_t now)
{
  listener *v2; // edi
  _DWORD *v3; // eax
  int family; // esi
  irec *iface; // ecx
  in_addr_t s_addr; // esi
  in_addr_t v7; // ecx
  size_t v8; // eax
  int v9; // eax
  _DWORD *v10; // ecx
  int v11; // edi
  int v12; // eax
  char *v13; // esi
  unsigned int v14; // edx
  unsigned int v15; // eax
  _DWORD *v16; // eax
  int v17; // ecx
  const char *v18; // eax
  int v19; // eax
  int v20; // esi
  _DWORD *v21; // eax
  int v22; // esi
  _DWORD *v23; // edx
  __int16 v24; // dx
  __int16 v25; // ax
  int v26; // eax
  int v27; // ecx
  char *v28; // eax
  size_t v29; // esi
  size_t v30; // eax
  int v31; // ecx
  int v32; // esi
  int v33; // edx
  unsigned __int32 v34; // eax
  int v35; // eax
  unsigned int *msg_control; // esi
  unsigned int v37; // edx
  unsigned int v38; // eax
  int v39; // ecx
  in_addr_t v40; // edx
  int v41; // esi
  size_t v42; // eax
  int v43; // ecx
  time_t v44; // [esp-4h] [ebp-F4h]
  char *types; // [esp+0h] [ebp-F0h]
  int v46; // [esp+4h] [ebp-ECh]
  int v47; // [esp+8h] [ebp-E8h]
  mysockaddr *header; // [esp+10h] [ebp-E0h]
  in_addr dst_addr_4; // [esp+14h] [ebp-DCh]
  int if_index; // [esp+18h] [ebp-D8h]
  int n; // [esp+1Ch] [ebp-D4h]
  in_addr_t v52; // [esp+20h] [ebp-D0h]
  int ad_reqd; // [esp+28h] [ebp-C8h]
  char *v54; // [esp+2Ch] [ebp-C4h]
  int v55; // [esp+2Ch] [ebp-C4h]
  char *v56; // [esp+2Ch] [ebp-C4h]
  unsigned __int16 type; // [esp+36h] [ebp-BAh] BYREF
  unsigned __int8 *t_cp; // [esp+38h] [ebp-B8h] BYREF
  int auth_dns; // [esp+3Ch] [ebp-B4h] BYREF
  msghdr msg; // [esp+40h] [ebp-B0h] BYREF
  iovec iov[1]; // [esp+5Ch] [ebp-94h] BYREF
  all_addr dst_addr; // [esp+64h] [ebp-8Ch] BYREF
  mysockaddr source_addr; // [esp+74h] [ebp-7Ch] BYREF
  union {cmsghdr align;char control6[32];char control[24];} control_u; // [esp+90h] [ebp-60h] BYREF
  ifreq ifr; // [esp+B0h] [ebp-40h] BYREF
  unsigned int v66; // [esp+D0h] [ebp-20h]

  v66 = __readgsdword(0x14u);
  v2 = listen;
  auth_dns = 0;
  v3 = dnsmasq_daemon_0;
  header = (mysockaddr *)dnsmasq_daemon_0[119];
  dst_addr_4.s_addr = *dnsmasq_daemon_0 & 0x2000;
  if ( dst_addr_4.s_addr )
  {
    family = listen->family;
    iface = listen->iface;
    dst_addr.addr.addr4.s_addr = 0;
    dnsmasq_daemon_0[132] = 0;
    v52 = 0;
    if_index = family == 10;
    if ( iface )
    {
      dst_addr_4.s_addr = 0;
      auth_dns = iface->dns_auth;
      if ( family == 2 )
      {
        s_addr = iface->addr.in.sin_addr.s_addr;
        v7 = iface->netmask.s_addr;
        dst_addr.addr.addr4.s_addr = s_addr;
        dst_addr_4.s_addr = s_addr;
        v52 = v7;
      }
    }
    else
    {
      dst_addr_4.s_addr = 0;
    }
  }
  else
  {
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v52 = 0;
    if_index = 1;
  }
  v8 = *((unsigned __int16 *)v3 + 216);
  msg.msg_controllen = 32;
  msg.msg_flags = 0;
  iov[0].iov_len = v8;
  msg.msg_control = &control_u;
  msg.msg_name = &source_addr;
  iov[0].iov_base = header;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;
  n = recvmsg(listen->fd, &msg, 0);
  if ( n <= 11 )
    return;
  ad_reqd = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || header->sa.sa_data[0] < 0 )
    return;
  v9 = listen->family;
  source_addr.sa.sa_family = v9;
  if ( v9 == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
    v10 = dnsmasq_daemon_0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_19;
  }
  else
  {
    if ( !source_addr.in.sin_port )
      return;
    v10 = dnsmasq_daemon_0;
    source_addr.in.sin_addr.s_addr = 0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_19;
    if ( v9 == 10 )
    {
      if ( dnsmasq_daemon_0[284] )
      {
        v11 = dnsmasq_daemon_0[284];
        while ( (*(_BYTE *)(v11 + 16) & 2) == 0 || !is_same_net6(v11, &source_addr.in6.sin6_addr, *(_DWORD *)(v11 + 20)) )
        {
          v11 = *(_DWORD *)(v11 + 24);
          if ( !v11 )
            goto LABEL_66;
        }
        v2 = listen;
        goto LABEL_19;
      }
LABEL_66:
      if ( !warned_2 )
      {
        my_syslog(4, "Ignoring query from non-local network");
        warned_2 = 1;
      }
      return;
    }
  }
  v32 = v10[284];
  if ( !v32 )
    goto LABEL_66;
  v33 = -1;
  while ( 1 )
  {
    v34 = _byteswap_ulong(v33 << (32 - *(_BYTE *)(v32 + 20)));
    if ( (*(_BYTE *)(v32 + 16) & 2) == 0 )
    {
      v55 = v33;
      v35 = is_same_net(*(_DWORD *)v32, source_addr.in.sin_addr.s_addr, v34);
      v33 = v55;
      if ( v35 )
        break;
    }
    v32 = *(_DWORD *)(v32 + 24);
    if ( !v32 )
      goto LABEL_66;
  }
LABEL_19:
  if ( !if_index )
  {
    v16 = dnsmasq_daemon_0;
    goto LABEL_32;
  }
  if ( msg.msg_controllen > 0xB )
  {
    v12 = v2->family;
    if ( v12 == 2 )
    {
      msg_control = (unsigned int *)msg.msg_control;
      if_index = 0;
      if ( msg.msg_control )
      {
        v56 = (char *)msg.msg_control + msg.msg_controllen;
        if ( *((_DWORD *)msg.msg_control + 1) )
          goto LABEL_72;
LABEL_70:
        if ( msg_control[2] == 8 )
        {
          dst_addr.addr.addr4.s_addr = msg_control[4];
          dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr;
          if_index = msg_control[3];
        }
LABEL_72:
        while ( 1 )
        {
          v37 = *msg_control;
          v38 = (-*msg_control & 3) + 12;
          if ( *msg_control <= 0xB || v56 - (char *)msg_control < v38 || v56 - (char *)msg_control - v38 < v37 )
            break;
          msg_control = (unsigned int *)((char *)msg_control + ((v37 + 3) & 0xFFFFFFFC));
          if ( !msg_control[1] )
            goto LABEL_70;
        }
      }
    }
    else if ( v12 == 10 && (v13 = (char *)msg.msg_control) != 0 )
    {
      if_index = 0;
      v54 = (char *)msg.msg_control + msg.msg_controllen;
      if ( *((_DWORD *)msg.msg_control + 1) == 41 )
        goto LABEL_29;
      while ( 1 )
      {
        v14 = *(_DWORD *)v13;
        v15 = (-*(_DWORD *)v13 & 3) + 12;
        if ( *(_DWORD *)v13 <= 0xBu || v54 - v13 < v15 || v54 - v13 - v15 < v14 )
          break;
        v13 += (v14 + 3) & 0xFFFFFFFC;
        if ( *((_DWORD *)v13 + 1) == 41 )
        {
LABEL_29:
          if ( *((_DWORD *)v13 + 2) == dnsmasq_daemon_0[283] )
          {
            dst_addr = *(all_addr *)(v13 + 12);
            if_index = *((_DWORD *)v13 + 7);
          }
        }
      }
    }
    else
    {
      if_index = 0;
    }
    if ( indextoname(v2->fd, if_index, &ifr) )
    {
      if ( iface_check(v2->family, &dst_addr, &ifr, &auth_dns) )
        goto LABEL_84;
      if ( *((char *)dnsmasq_daemon_0 + 4) >= 0 )
        enumerate_interfaces(0);
      if ( loopback_exception(v2->fd, v2->family, &dst_addr, &ifr) || label_exception(if_index, v2->family, &dst_addr) )
      {
LABEL_84:
        v16 = dnsmasq_daemon_0;
        if ( v2->family != 2 || (*dnsmasq_daemon_0 & 0x40000) == 0 )
          goto LABEL_32;
        v39 = dnsmasq_daemon_0[127];
        if ( v39 )
        {
          v40 = dst_addr_4.s_addr;
          v41 = dnsmasq_daemon_0[127];
          do
          {
            if ( *(_WORD *)v41 == 2 && *(_DWORD *)(v41 + 4) == dst_addr_4.s_addr )
            {
LABEL_93:
              while ( *(_WORD *)v39 != 2 || *(_DWORD *)(v39 + 4) != v40 )
              {
                v39 = *(_DWORD *)(v39 + 80);
                if ( !v39 )
                  goto LABEL_112;
              }
              dst_addr_4.s_addr = v40;
              v52 = *(_DWORD *)(v39 + 28);
              goto LABEL_32;
            }
            v41 = *(_DWORD *)(v41 + 80);
          }
          while ( v41 );
          if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
            goto LABEL_114;
        }
        else if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
        {
LABEL_111:
          v16 = dnsmasq_daemon_0;
LABEL_112:
          dst_addr_4.s_addr = 0;
LABEL_32:
          v17 = v16[285] + 1;
          v16[285] = v17;
          v16[286] = v17;
          v16[287] = &source_addr;
          if ( extract_request(header, n, v16[121], &type) )
          {
            v18 = "query";
            if ( auth_dns )
              v18 = "auth";
            v19 = querystr(v18, type);
            if ( v2->family == 2 )
              log_query(524424, dnsmasq_daemon_0[121], &source_addr.in6.sin6_flowinfo, v19);
            else
              log_query(524552, dnsmasq_daemon_0[121], &source_addr.in6.sin6_addr, v19);
            v20 = auth_dns;
            v21 = dnsmasq_daemon_0;
            if ( auth_dns )
            {
              v20 = 0;
            }
            else if ( (*dnsmasq_daemon_0 & 0x40000) == 0 && dnsmasq_daemon_0[20] )
            {
              v22 = dnsmasq_daemon_0[20];
              v23 = dnsmasq_daemon_0;
              do
              {
                if ( in_zone(v22, v23[121], 0) )
                {
                  auth_dns = 1;
                  v21 = dnsmasq_daemon_0;
                  v20 = 1;
                  goto LABEL_44;
                }
                v22 = *(_DWORD *)(v22 + 16);
                v23 = dnsmasq_daemon_0;
              }
              while ( v22 );
              v20 = 0;
              v21 = dnsmasq_daemon_0;
            }
LABEL_44:
            if ( detect_loop(v21[121], type) )
              return;
          }
          else
          {
            v20 = 0;
          }
          if ( find_pseudoheader(header, n, 0, &t_cp, 0, 0) )
          {
            v24 = *((_WORD *)t_cp + 2);
            v25 = *(_WORD *)t_cp;
            t_cp += 6;
            LOWORD(v26) = __ROL2__(v25, 8);
            ad_reqd = (unsigned int)(__int16)__ROL2__(v24, 8) >> 31;
            if ( (unsigned __int16)v26 > *((_WORD *)dnsmasq_daemon_0 + 216) )
              LOWORD(v26) = *((_WORD *)dnsmasq_daemon_0 + 216);
            v27 = 1;
            v26 = (unsigned __int16)v26;
          }
          else
          {
            v27 = 0;
            v26 = 512;
          }
          v28 = (char *)header + v26;
          if ( auth_dns )
          {
            v42 = answer_auth(header, v28, n, now, &source_addr, v20, ad_reqd, v27);
            if ( v42 )
            {
              v43 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v43 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(v2->fd, v43, (char *)header, v42, &source_addr, &dst_addr, if_index);
              ++dnsmasq_daemon_0[124];
            }
          }
          else
          {
            v29 = 1;
            if ( (header->sa.sa_data[1] & 0x20) == 0 )
              v29 = ad_reqd;
            v30 = answer_request(header, v28, n, dst_addr_4.s_addr, v52, now, v29, ad_reqd, v27);
            if ( v30 )
            {
              v31 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v31 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(v2->fd, v31, (char *)header, v30, &source_addr, &dst_addr, if_index);
              ++dnsmasq_daemon_0[122];
            }
            else if ( forward_query(if_index, header, (all_addr *)n, now, 0, v29, v44, (frec *)types, v46, v47) )
            {
              ++dnsmasq_daemon_0[123];
            }
            else
            {
              ++dnsmasq_daemon_0[122];
            }
          }
          return;
        }
        enumerate_interfaces(0);
        v16 = dnsmasq_daemon_0;
        v39 = dnsmasq_daemon_0[127];
        if ( v39 )
        {
LABEL_114:
          v40 = dst_addr_4.s_addr;
          goto LABEL_93;
        }
        goto LABEL_111;
      }
    }
  }
}
