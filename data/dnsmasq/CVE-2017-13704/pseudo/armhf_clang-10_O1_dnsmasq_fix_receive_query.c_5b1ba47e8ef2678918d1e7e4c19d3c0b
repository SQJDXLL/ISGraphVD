void __fastcall receive_query(listener *listen, time_t now)
{
  int v4; // r0
  dns_header *v5; // r10
  in_addr_t s_addr; // r7
  _BOOL4 v7; // r8
  irec *v8; // r1
  in_addr_t v9; // r1
  irec *iface; // r1
  ssize_t v11; // r0
  size_t v12; // r9
  int family; // r0
  int v14; // r4
  __uint32_t v15; // r0
  int v16; // r4
  unsigned int v17; // r8
  unsigned int v18; // r8
  struct cmsghdr *msg_control; // r1
  unsigned int v20; // r4
  struct cmsghdr *v21; // r1
  in_addr_t v22; // r0
  __int64 v23; // r2
  int v24; // r0
  unsigned __int16 *v25; // r1
  int v26; // r2
  bool v27; // zf
  _DWORD *v28; // r0
  int v29; // r1
  bool v30; // zf
  _DWORD *v31; // r0
  int v32; // r1
  const char *v33; // r0
  int v34; // r3
  in6_addr *p_sin6_flowinfo; // r2
  int v36; // r0
  int v37; // r4
  int v38; // r5
  int v39; // r1
  int v40; // r2
  unsigned int v41; // r3
  unsigned int v42; // r0
  int v43; // r1
  size_t v44; // r0
  int v45; // r1
  int v46; // r8
  size_t v47; // r3
  int fd; // r0
  int v49; // r7
  int v50; // [sp+14h] [bp-C4h]
  time_t v51; // [sp+18h] [bp-C0h]
  all_addr *v52; // [sp+1Ch] [bp-BCh]
  all_addr *v53; // [sp+1Ch] [bp-BCh]
  in_addr_t v54; // [sp+20h] [bp-B8h]
  int v55[8]; // [sp+24h] [bp-B4h] BYREF
  char v56; // [sp+44h] [bp-94h] BYREF
  struct msghdr message; // [sp+64h] [bp-74h] BYREF
  iovec iov[1]; // [sp+80h] [bp-58h] BYREF
  int auth_dns; // [sp+88h] [bp-50h] BYREF
  all_addr dst_addr; // [sp+8Ch] [bp-4Ch] BYREF
  unsigned __int16 type; // [sp+9Eh] [bp-3Ah] BYREF
  mysockaddr source_addr; // [sp+A0h] [bp-38h] BYREF

  v4 = dnsmasq_daemon;
  v5 = *(dns_header **)(dnsmasq_daemon + 476);
  s_addr = 0;
  auth_dns = 0;
  v7 = 1;
  if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) != 0 )
    v7 = listen->family == 0xA;
  *(_DWORD *)(dnsmasq_daemon + 528) = 0;
  dst_addr.addr.addr4.s_addr = 0;
  if ( (*(_BYTE *)(v4 + 1) & 0x20) != 0 && (v8 = listen->iface) != 0 )
  {
    auth_dns = v8->dns_auth;
    v9 = 0;
    if ( listen->family == 2 )
    {
      iface = listen->iface;
      s_addr = iface->addr.in.sin_addr.s_addr;
      v9 = iface->netmask.s_addr;
      dst_addr.addr.addr4.s_addr = s_addr;
    }
  }
  else
  {
    v9 = 0;
  }
  v54 = v9;
  message.msg_controllen = 32;
  message.msg_control = &v56;
  message.msg_iovlen = 1;
  message.msg_iov = iov;
  message.msg_namelen = 28;
  message.msg_name = &source_addr;
  iov[0].iov_base = *(void **)(v4 + 476);
  iov[0].iov_len = *(unsigned __int16 *)(v4 + 432);
  message.msg_flags = 0;
  v11 = recvmsg(listen->fd, &message, 0);
  if ( v11 < 12 )
    return;
  v12 = v11;
  if ( (message.msg_flags & 0x20) != 0 || (v5->hb3 & 0x80u) != 0 )
    return;
  memset((void *)(*(_DWORD *)(dnsmasq_daemon + 476) + v11), 0, *(unsigned __int16 *)(dnsmasq_daemon + 432) - v11);
  family = listen->family;
  source_addr.sa.sa_family = family;
  if ( family == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
  }
  else
  {
    if ( !source_addr.in.sin_port )
      return;
    source_addr.in.sin_addr.s_addr = 0;
  }
  v51 = now;
  if ( (*(_BYTE *)(dnsmasq_daemon + 6) & 2) != 0 )
  {
    v14 = *(_DWORD *)(dnsmasq_daemon + 1136);
    if ( family == 10 )
    {
      if ( v14 )
      {
        while ( (*(_BYTE *)(v14 + 16) & 2) == 0 || !is_same_net6(v14, &source_addr.in6.sin6_addr, *(_DWORD *)(v14 + 20)) )
        {
          v14 = *(_DWORD *)(v14 + 24);
          if ( !v14 )
            goto LABEL_31;
        }
      }
      else
      {
LABEL_31:
        v14 = 0;
      }
    }
    else
    {
      for ( ; v14; v14 = *(_DWORD *)(v14 + 24) )
      {
        if ( (*(_BYTE *)(v14 + 16) & 2) == 0 )
        {
          v15 = _bswap_32(-1 << (0x20 - *(_DWORD *)(v14 + 20)));
          if ( is_same_net(*(_DWORD *)v14, source_addr.in.sin_addr.s_addr, v15) )
            break;
        }
      }
    }
    if ( !v14 )
    {
      if ( !receive_query_warned )
      {
        my_syslog(4, "Ignoring query from non-local network");
        receive_query_warned = 1;
      }
      return;
    }
  }
  v52 = 0;
  if ( !v7 )
  {
    v17 = 0;
LABEL_78:
    v31 = (_DWORD *)dnsmasq_daemon;
    *(_DWORD *)(dnsmasq_daemon + 1148) = &source_addr;
    v32 = v31[285] + 1;
    v31[286] = v32;
    v31[285] = v32;
    if ( !extract_request(v5, v12, v31[121], &type) )
      goto LABEL_93;
    v33 = "auth";
    if ( !auth_dns )
      v33 = "query";
    v34 = querystr(v33, type);
    if ( listen->family == 2 )
    {
      p_sin6_flowinfo = (in6_addr *)&source_addr.in6.sin6_flowinfo;
      v36 = 524424;
    }
    else
    {
      v36 = 524552;
      p_sin6_flowinfo = &source_addr.in6.sin6_addr;
    }
    log_query(v36, *(_DWORD *)(dnsmasq_daemon + 484), p_sin6_flowinfo, v34);
    if ( auth_dns )
    {
LABEL_85:
      v52 = 0;
    }
    else
    {
      v52 = 0;
      if ( (*(_BYTE *)(dnsmasq_daemon + 2) & 4) == 0 )
      {
        v37 = *(_DWORD *)(dnsmasq_daemon + 80);
        if ( v37 )
        {
          while ( !in_zone(v37, *(_DWORD *)(dnsmasq_daemon + 484), 0) )
          {
            v37 = *(_DWORD *)(v37 + 16);
            if ( !v37 )
              goto LABEL_85;
          }
          v52 = (all_addr *)(send_from + 1);
          auth_dns = 1;
        }
      }
    }
    if ( !detect_loop(*(_DWORD *)(dnsmasq_daemon + 484), type) )
    {
LABEL_93:
      v38 = 0;
      if ( find_pseudoheader(v5, v12, 0, v55, 0, 0) )
      {
        v39 = *(unsigned __int8 *)v55[0];
        v40 = *(unsigned __int8 *)(v55[0] + 1);
        v41 = *(unsigned __int8 *)(v55[0] + 4);
        v55[0] += 6;
        v42 = v40 | (v39 << 8);
        if ( v42 > *(unsigned __int16 *)(dnsmasq_daemon + 432) )
          v42 = *(unsigned __int16 *)(dnsmasq_daemon + 432);
        v43 = v41 >> 7;
        v38 = 1;
      }
      else
      {
        v42 = 512;
        v43 = 0;
      }
      if ( auth_dns )
      {
        v44 = answer_auth(v5, (char *)v5 + v42, v12, v51, &source_addr, v52, v43, v38);
        if ( v44 )
        {
          v45 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) == 0 )
            v45 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
          send_from(listen->fd, v45, (char *)v5, v44, &source_addr, &dst_addr, v17);
          ++*(_DWORD *)(dnsmasq_daemon + 496);
        }
      }
      else
      {
        v53 = (all_addr *)v17;
        v46 = 1;
        if ( (v5->hb4 & 0x20) == 0 )
          v46 = v43;
        v47 = answer_request(v5, (char *)v5 + v42, v12, s_addr, v54, v51, v46, v43, v38);
        fd = listen->fd;
        if ( v47 )
        {
          v49 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) == 0 )
            v49 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
          send_from(fd, v49, (char *)v5, v47, &source_addr, &dst_addr, (unsigned int)v53);
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
        else if ( forward_query(fd, &source_addr, &dst_addr, (unsigned int)v53, v5, v12, v51, 0u, v46, v50) )
        {
          ++*(_DWORD *)(dnsmasq_daemon + 492);
        }
        else
        {
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
      }
    }
    return;
  }
  v16 = 0;
  if ( message.msg_controllen >= 0xC )
  {
    v18 = 0;
    if ( listen->family == 2 )
    {
      msg_control = (struct cmsghdr *)message.msg_control;
      if ( message.msg_control )
      {
        v18 = 0;
        do
        {
          if ( !msg_control->cmsg_level && msg_control->cmsg_type == 8 )
          {
            v18 = *(_DWORD *)msg_control->__cmsg_data;
            s_addr = *(_DWORD *)&msg_control->__cmsg_data[4];
            dst_addr.addr.addr4.s_addr = s_addr;
          }
          msg_control = _cmsg_nxthdr(&message, msg_control);
        }
        while ( msg_control );
      }
    }
    v20 = v18;
    if ( listen->family == 10 )
    {
      v21 = (struct cmsghdr *)message.msg_control;
      if ( message.msg_control )
      {
        if ( message.msg_controllen >= 0xC )
        {
          do
          {
            if ( v21->cmsg_level == 41 && v21->cmsg_type == *(_DWORD *)(dnsmasq_daemon + 1132) )
            {
              v22 = *(_DWORD *)v21->__cmsg_data;
              v23 = *(_QWORD *)&v21->__cmsg_data[4];
              dst_addr.addr.addr6.__in6_u.__u6_addr32[3] = *(_DWORD *)&v21->__cmsg_data[12];
              dst_addr.addr.addr4.s_addr = v22;
              *(_QWORD *)(&dst_addr.addr.dnssec + 1) = v23;
              v20 = *(_DWORD *)&v21->__cmsg_data[16];
            }
            v21 = _cmsg_nxthdr(&message, v21);
          }
          while ( v21 );
        }
      }
    }
    v17 = v20;
    v24 = indextoname(listen->fd, v20, v55);
    v16 = 0;
    if ( v24 )
    {
      if ( iface_check(listen->family, &dst_addr, v55, &auth_dns) )
        goto LABEL_114;
      if ( (*(_BYTE *)(dnsmasq_daemon + 4) & 0x80) == 0 )
        enumerate_interfaces(0);
      if ( loopback_exception(listen->fd, listen->family, &dst_addr, v55)
        || label_exception(v17, listen->family, &dst_addr) )
      {
LABEL_114:
        v16 = 1;
        if ( listen->family == 2 && (*(_BYTE *)(dnsmasq_daemon + 2) & 4) != 0 )
        {
          v25 = *(unsigned __int16 **)(dnsmasq_daemon + 508);
          if ( v25 )
          {
            while ( 1 )
            {
              v26 = *v25;
              v27 = v26 == 2;
              if ( v26 == 2 )
                v27 = *((_DWORD *)v25 + 1) == s_addr;
              if ( v27 )
                break;
              v25 = (unsigned __int16 *)*((_DWORD *)v25 + 20);
              if ( !v25 )
                goto LABEL_66;
            }
          }
          else
          {
LABEL_66:
            if ( (*(_BYTE *)(dnsmasq_daemon + 4) & 0x80) == 0 )
              enumerate_interfaces(0);
          }
          v28 = *(_DWORD **)(dnsmasq_daemon + 508);
          if ( v28 )
          {
            while ( 1 )
            {
              v29 = *(unsigned __int16 *)v28;
              v30 = v29 == 2;
              if ( v29 == 2 )
                v30 = v28[1] == s_addr;
              if ( v30 )
                break;
              v28 = (_DWORD *)v28[20];
              if ( !v28 )
                goto LABEL_73;
            }
            v54 = v28[7];
          }
          else
          {
LABEL_73:
            s_addr = 0;
          }
        }
      }
    }
  }
  else
  {
    v17 = 0;
  }
  if ( v16 )
    goto LABEL_78;
}
