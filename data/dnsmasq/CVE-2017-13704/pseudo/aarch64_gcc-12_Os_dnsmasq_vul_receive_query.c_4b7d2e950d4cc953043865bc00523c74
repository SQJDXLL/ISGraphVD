void __fastcall receive_query(listener *listen, time_t now)
{
  __int64 v3; // x0
  int v4; // w1
  dns_header *v5; // x23
  irec *iface; // x1
  int family; // w2
  in_addr_t v8; // w27
  unsigned int v9; // w22
  unsigned int s_addr; // w21
  size_t v11; // x0
  signed __int64 v12; // x25
  unsigned __int64 v13; // x24
  int v14; // w1
  __int64 v15; // x0
  struct cmsghdr *msg_control; // x1
  void *j; // x1
  __int64 k; // x0
  __int64 m; // x0
  __int64 v20; // x0
  __int64 v21; // x2
  int v22; // w1
  const char *v23; // x0
  __int64 v24; // x3
  unsigned int v25; // w28
  __int64 v26; // x7
  unsigned __int8 *v27; // x0
  unsigned int v28; // w2
  unsigned __int16 v29; // w2
  unsigned int v30; // w24
  unsigned int v31; // w1
  char *v32; // x1
  size_t v33; // x3
  int v34; // w2
  addrlist *v35; // x3
  in6_addr *p_sin6_addr; // x1
  int v37; // w0
  addrlist *i; // x3
  __int64 v39; // x2
  int v40; // w0
  __int64 v41; // x3
  __int64 v42; // x1
  in6_addr *p_sin6_flowinfo; // x2
  unsigned __int16 v44; // w0
  __int64 n; // x28
  unsigned int v46; // w28
  size_t v47; // x0
  __int64 v48; // x1
  int v49; // w0
  int v50; // [xsp+8h] [xbp-8h]
  addrlist *addr; // [xsp+80h] [xbp+70h]
  addrlist *addra; // [xsp+80h] [xbp+70h]
  in6_addr *v54; // [xsp+88h] [xbp+78h]
  unsigned __int16 type; // [xsp+92h] [xbp+82h] BYREF
  int auth_dns; // [xsp+94h] [xbp+84h] BYREF
  unsigned __int8 *t_cp; // [xsp+98h] [xbp+88h] BYREF
  msghdr msg; // [xsp+A0h] [xbp+90h] BYREF
  all_addr dst_addr; // [xsp+D8h] [xbp+C8h] BYREF
  iovec iov[1]; // [xsp+E8h] [xbp+D8h] BYREF
  mysockaddr source_addr; // [xsp+F8h] [xbp+E8h] BYREF
  union {cmsghdr align;char control6[40];char control[32];} control_u; // [xsp+118h] [xbp+108h] BYREF
  ifreq ifr; // [xsp+140h] [xbp+130h] BYREF

  v3 = dnsmasq_daemon_0;
  v4 = *dnsmasq_daemon_0;
  auth_dns = 0;
  v5 = *(dns_header **)(dnsmasq_daemon_0 + 848LL);
  if ( (v4 & 0x2000) != 0 )
  {
    iface = listen->iface;
    dst_addr.addr.addr4.s_addr = 0;
    family = listen->family;
    v8 = 0;
    *(_QWORD *)(dnsmasq_daemon_0 + 944LL) = 0LL;
    v9 = family == 10;
    if ( iface && (auth_dns = iface->dns_auth, family == 2) )
    {
      s_addr = iface->addr.in.sin_addr.s_addr;
      v8 = iface->netmask.s_addr;
      dst_addr.addr.addr4.s_addr = s_addr;
    }
    else
    {
      s_addr = 0;
    }
  }
  else
  {
    s_addr = v4 & 0x2000;
    v8 = 0;
    v9 = 1;
    dst_addr.addr.addr4.s_addr = 0;
    *(_QWORD *)(dnsmasq_daemon_0 + 944LL) = 0LL;
  }
  v11 = *(unsigned __int16 *)(v3 + 768);
  iov[0].iov_base = v5;
  iov[0].iov_len = v11;
  msg.msg_control = &control_u;
  msg.msg_controllen = 40LL;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1LL;
  LODWORD(v11) = listen->fd;
  msg.msg_name = &source_addr;
  msg.msg_flags = 0;
  v12 = recvmsg(v11, &msg, 0);
  if ( v12 <= 11 )
    return;
  LODWORD(v13) = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || ((char)v5->hb3 & 0x80000000) != 0 )
    return;
  v14 = listen->family;
  source_addr.sa.sa_family = v14;
  if ( v14 == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
    v15 = dnsmasq_daemon_0;
    if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x20000) == 0 )
      goto LABEL_11;
    goto LABEL_60;
  }
  if ( !source_addr.in.sin_port )
    return;
  v15 = dnsmasq_daemon_0;
  v34 = *(_DWORD *)(dnsmasq_daemon_0 + 4LL);
  source_addr.in.sin_addr.s_addr = 0;
  if ( (v34 & 0x20000) != 0 )
  {
    v35 = *(addrlist **)(dnsmasq_daemon_0 + 1568LL);
    if ( v14 == 10 )
    {
      p_sin6_addr = &source_addr.in6.sin6_addr;
      while ( v35 )
      {
        if ( (v35->flags & 2) != 0 )
        {
          addr = v35;
          v54 = p_sin6_addr;
          v37 = is_same_net6(v35);
          v35 = addr;
          p_sin6_addr = v54;
          if ( v37 )
            goto LABEL_11;
        }
        v35 = v35->next;
      }
      goto LABEL_53;
    }
LABEL_60:
    for ( i = *(addrlist **)(v15 + 1568); i; i = i->next )
    {
      v39 = bswap32(-1 << (32 - i->prefixlen));
      if ( (i->flags & 2) == 0 )
      {
        addra = i;
        v40 = is_same_net(i->addr.addr.addr4.s_addr, source_addr.in.sin_addr.s_addr, v39, i, 32LL, 0xFFFFFFFFLL);
        i = addra;
        if ( v40 )
          goto LABEL_11;
      }
    }
LABEL_53:
    if ( !warned_2 )
    {
      my_syslog(4LL, "Ignoring query from non-local network");
      warned_2 = 1;
    }
    return;
  }
LABEL_11:
  if ( v9 )
  {
    if ( msg.msg_controllen <= 0xF )
      return;
    if ( listen->family == 2 )
    {
      msg_control = (struct cmsghdr *)msg.msg_control;
      v9 = 0;
      while ( msg_control )
      {
        if ( *(_QWORD *)&msg_control->cmsg_level == 0x800000000LL )
        {
          v9 = *(_DWORD *)msg_control->__cmsg_data;
          s_addr = *(_DWORD *)&msg_control->__cmsg_data[4];
          dst_addr.addr.addr4.s_addr = s_addr;
        }
        msg_control = _cmsg_nxthdr(&msg, msg_control);
      }
    }
    else
    {
      v9 = 0;
    }
    if ( listen->family == 10 && msg.msg_controllen > 0xF )
    {
      for ( j = msg.msg_control; j; j = _cmsg_nxthdr(&msg, (struct cmsghdr *)j) )
      {
        if ( *((_DWORD *)j + 2) == 41 && *((_DWORD *)j + 3) == *(_DWORD *)(dnsmasq_daemon_0 + 1560LL) )
        {
          v9 = *((_DWORD *)j + 8);
          v41 = *((_QWORD *)j + 3);
          *(_QWORD *)&dst_addr.addr.addr4.s_addr = *((_QWORD *)j + 2);
          *((_QWORD *)&dst_addr.addr.dnssec + 1) = v41;
        }
      }
    }
    if ( !(unsigned int)indextoname((unsigned int)listen->fd, v9, &ifr) )
      return;
    if ( !(unsigned int)iface_check((unsigned int)listen->family, &dst_addr, &ifr, &auth_dns) )
    {
      if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x80) == 0 )
        ((void (*)(void))enumerate_interfaces)();
      if ( !(unsigned int)loopback_exception((unsigned int)listen->fd, (unsigned int)listen->family, &dst_addr, &ifr)
        && !(unsigned int)label_exception(v9, (unsigned int)listen->family, &dst_addr) )
      {
        return;
      }
    }
    if ( listen->family == 2 && (*dnsmasq_daemon_0 & 0x40000) != 0 )
    {
      for ( k = *(_QWORD *)(dnsmasq_daemon_0 + 904LL); k; k = *(_QWORD *)(k + 88) )
      {
        if ( *(_WORD *)k == 2 && *(_DWORD *)(k + 4) == s_addr )
          goto LABEL_28;
      }
      if ( (*(_DWORD *)(dnsmasq_daemon_0 + 4LL) & 0x80) == 0 )
        enumerate_interfaces(0LL);
LABEL_28:
      for ( m = *(_QWORD *)(dnsmasq_daemon_0 + 904LL); ; m = *(_QWORD *)(m + 88) )
      {
        if ( !m )
        {
          s_addr = 0;
          goto LABEL_31;
        }
        if ( *(_WORD *)m == 2 && *(_DWORD *)(m + 4) == s_addr )
          break;
      }
      v8 = *(_DWORD *)(m + 28);
    }
  }
LABEL_31:
  v20 = dnsmasq_daemon_0;
  v21 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
  *(_QWORD *)(dnsmasq_daemon_0 + 1584LL) = &source_addr;
  v22 = *(_DWORD *)(v20 + 1576) + 1;
  *(_DWORD *)(v20 + 1576) = v22;
  *(_DWORD *)(v20 + 1580) = v22;
  if ( (unsigned int)extract_request(v5, v12, v21, &type) )
  {
    v23 = "query";
    if ( auth_dns )
      v23 = "auth";
    v24 = querystr(v23, type);
    if ( listen->family == 2 )
    {
      p_sin6_flowinfo = (in6_addr *)&source_addr.in6.sin6_flowinfo;
      v42 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
      v44 = 136;
    }
    else
    {
      v42 = *(_QWORD *)(dnsmasq_daemon_0 + 864LL);
      p_sin6_flowinfo = &source_addr.in6.sin6_addr;
      v44 = 264;
    }
    log_query(v44 | 0x80000u, v42, p_sin6_flowinfo, v24);
    if ( !auth_dns && (*dnsmasq_daemon_0 & 0x40000) == 0 )
    {
      for ( n = *(_QWORD *)(dnsmasq_daemon_0 + 144LL); n; n = *(_QWORD *)(n + 32) )
      {
        if ( (unsigned int)in_zone(n, *(_QWORD *)(dnsmasq_daemon_0 + 864LL), 0LL) )
        {
          v25 = 1;
          auth_dns = 1;
          goto LABEL_39;
        }
      }
    }
    v25 = 0;
LABEL_39:
    if ( (unsigned int)detect_loop(*(_QWORD *)(dnsmasq_daemon_0 + 864LL), type) )
      return;
  }
  else
  {
    v25 = 0;
  }
  if ( find_pseudoheader(v5, v12, 0LL, &t_cp, 0LL, 0LL) )
  {
    v26 = 1LL;
    v27 = t_cp + 6;
    v28 = *(unsigned __int16 *)t_cp;
    t_cp += 4;
    v29 = __rev16(v28);
    v30 = *((unsigned __int16 *)v27 - 1);
    t_cp = v27;
    v13 = ((unsigned __int64)__rev16(v30) >> 15) & 1;
    v31 = *(unsigned __int16 *)(dnsmasq_daemon_0 + 768LL);
    if ( v31 > v29 )
      LOWORD(v31) = v29;
  }
  else
  {
    v26 = 0LL;
    LOWORD(v31) = 512;
  }
  v32 = (char *)v5 + (unsigned __int16)v31;
  if ( !auth_dns )
  {
    if ( (v5->hb4 & 0x20) != 0 )
      v46 = 1;
    else
      v46 = v13;
    v47 = answer_request(v5, v32, v12, s_addr, v8, now, v46, (unsigned int)v13, v26);
    if ( v47 )
    {
      send_from(listen->fd, (*dnsmasq_daemon_0 & 0x8000002000LL) != 0, (char *)v5, v47, &source_addr, &dst_addr, v9);
      v48 = dnsmasq_daemon_0;
    }
    else
    {
      v49 = forward_query(listen->fd, &source_addr, &dst_addr, v9, v5, v12, now, 0uLL, v46, v50);
      v48 = dnsmasq_daemon_0;
      if ( v49 )
      {
        ++*(_DWORD *)(dnsmasq_daemon_0 + 876LL);
        return;
      }
    }
    ++*(_DWORD *)(v48 + 872);
    return;
  }
  v33 = answer_auth(v5, v32, v12, now, &source_addr, v25, (unsigned int)v13, v26);
  if ( v33 )
  {
    send_from(listen->fd, (*dnsmasq_daemon_0 & 0x8000002000LL) != 0, (char *)v5, v33, &source_addr, &dst_addr, v9);
    ++*(_DWORD *)(dnsmasq_daemon_0 + 880LL);
  }
}
