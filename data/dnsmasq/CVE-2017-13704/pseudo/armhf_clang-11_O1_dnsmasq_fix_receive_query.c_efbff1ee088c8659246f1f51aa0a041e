void __fastcall receive_query(listener *listen, time_t now)
{
  int v4; // r0
  dns_header *v5; // r10
  in_addr_t s_addr; // r7
  _BOOL4 v7; // r9
  irec *v8; // r1
  in_addr_t v9; // r8
  irec *iface; // r1
  ssize_t v11; // r0
  size_t v12; // r11
  int family; // r0
  int v14; // r4
  __uint32_t v15; // r0
  int v16; // r4
  unsigned int v17; // r9
  unsigned int v18; // r9
  struct cmsghdr *msg_control; // r1
  unsigned int v20; // r4
  struct cmsghdr *v21; // r1
  in_addr_t v22; // r0
  __int64 v23; // r2
  int v24; // r0
  unsigned __int16 *v25; // r1
  int v26; // r2
  bool v27; // zf
  _DWORD *v28; // r0
  int v29; // r1
  bool v30; // zf
  _DWORD *v31; // r0
  int v32; // r1
  const char *v33; // r0
  int v34; // r3
  in6_addr *p_sin6_flowinfo; // r2
  int v36; // r0
  int v37; // r4
  int v38; // r5
  int v39; // r1
  int v40; // r2
  unsigned int v41; // r3
  unsigned int v42; // r0
  int v43; // r1
  size_t v44; // r0
  int v45; // r1
  int v46; // r9
  size_t v47; // r3
  int fd; // r0
  int v49; // r7
  int v50; // [sp+14h] [bp-C4h]
  all_addr *v51; // [sp+18h] [bp-C0h]
  all_addr *v52; // [sp+18h] [bp-C0h]
  int v53[8]; // [sp+1Ch] [bp-BCh] BYREF
  char v54; // [sp+3Ch] [bp-9Ch] BYREF
  struct msghdr message; // [sp+5Ch] [bp-7Ch] BYREF
  int v56[2]; // [sp+78h] [bp-60h] BYREF
  int dns_auth; // [sp+80h] [bp-58h] BYREF
  all_addr source; // [sp+84h] [bp-54h] BYREF
  unsigned __int16 v59; // [sp+96h] [bp-42h] BYREF
  mysockaddr udpaddr; // [sp+98h] [bp-40h] BYREF

  v4 = dnsmasq_daemon;
  v5 = *(dns_header **)(dnsmasq_daemon + 476);
  s_addr = 0;
  dns_auth = 0;
  v7 = 1;
  if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) != 0 )
    v7 = listen->family == 0xA;
  *(_DWORD *)(dnsmasq_daemon + 528) = 0;
  source.addr.addr4.s_addr = 0;
  if ( (*(_BYTE *)(v4 + 1) & 0x20) != 0 && (v8 = listen->iface) != 0 )
  {
    dns_auth = v8->dns_auth;
    v9 = 0;
    if ( listen->family == 2 )
    {
      iface = listen->iface;
      s_addr = iface->addr.in.sin_addr.s_addr;
      v9 = iface->netmask.s_addr;
      source.addr.addr4.s_addr = s_addr;
    }
  }
  else
  {
    v9 = 0;
  }
  message.msg_controllen = 32;
  message.msg_control = &v54;
  message.msg_iovlen = 1;
  message.msg_iov = (iovec *)v56;
  message.msg_namelen = 28;
  message.msg_name = &udpaddr;
  v56[0] = *(_DWORD *)(v4 + 476);
  v56[1] = *(unsigned __int16 *)(v4 + 432);
  message.msg_flags = 0;
  v11 = recvmsg(listen->fd, &message, 0);
  if ( v11 < 12 )
    return;
  v12 = v11;
  if ( (message.msg_flags & 0x20) != 0 || (v5->hb3 & 0x80u) != 0 )
    return;
  memset((void *)(*(_DWORD *)(dnsmasq_daemon + 476) + v11), 0, *(unsigned __int16 *)(dnsmasq_daemon + 432) - v11);
  family = listen->family;
  udpaddr.sa.sa_family = family;
  if ( family == 2 )
  {
    if ( !udpaddr.in.sin_port )
      return;
  }
  else
  {
    if ( !udpaddr.in.sin_port )
      return;
    udpaddr.in.sin_addr.s_addr = 0;
  }
  v50 = now;
  if ( (*(_BYTE *)(dnsmasq_daemon + 6) & 2) != 0 )
  {
    v14 = *(_DWORD *)(dnsmasq_daemon + 1136);
    if ( family == 10 )
    {
      if ( v14 )
      {
        while ( (*(_BYTE *)(v14 + 16) & 2) == 0 || !is_same_net6(v14, &udpaddr.in6.sin6_addr, *(_DWORD *)(v14 + 20)) )
        {
          v14 = *(_DWORD *)(v14 + 24);
          if ( !v14 )
            goto LABEL_31;
        }
      }
      else
      {
LABEL_31:
        v14 = 0;
      }
    }
    else
    {
      for ( ; v14; v14 = *(_DWORD *)(v14 + 24) )
      {
        if ( (*(_BYTE *)(v14 + 16) & 2) == 0 )
        {
          v15 = _bswap_32(-1 << (0x20 - *(_DWORD *)(v14 + 20)));
          if ( is_same_net(*(_DWORD *)v14, udpaddr.in.sin_addr.s_addr, v15) )
            break;
        }
      }
    }
    if ( !v14 )
    {
      if ( !receive_query_warned )
      {
        my_syslog(4, "Ignoring query from non-local network");
        receive_query_warned = 1;
      }
      return;
    }
  }
  if ( !v7 )
  {
    v51 = 0;
    v17 = 0;
LABEL_78:
    v31 = (_DWORD *)dnsmasq_daemon;
    *(_DWORD *)(dnsmasq_daemon + 1148) = &udpaddr;
    v32 = v31[285] + 1;
    v31[286] = v32;
    v31[285] = v32;
    if ( !extract_request(v5, v12, v31[121], &v59) )
      goto LABEL_92;
    v33 = "auth";
    if ( !dns_auth )
      v33 = "query";
    v34 = querystr(v33, v59);
    if ( listen->family == 2 )
    {
      p_sin6_flowinfo = (in6_addr *)&udpaddr.in6.sin6_flowinfo;
      v36 = 524424;
    }
    else
    {
      v36 = 524552;
      p_sin6_flowinfo = &udpaddr.in6.sin6_addr;
    }
    log_query(v36, *(_DWORD *)(dnsmasq_daemon + 484), p_sin6_flowinfo, v34);
    v51 = 0;
    if ( !dns_auth && (*(_BYTE *)(dnsmasq_daemon + 2) & 4) == 0 )
    {
      v37 = *(_DWORD *)(dnsmasq_daemon + 80);
      if ( v37 )
      {
        while ( !in_zone(v37, *(_DWORD *)(dnsmasq_daemon + 484), 0) )
        {
          v37 = *(_DWORD *)(v37 + 16);
          if ( !v37 )
          {
            v51 = 0;
            goto LABEL_91;
          }
        }
        v51 = (all_addr *)(send_from + 1);
        dns_auth = 1;
      }
    }
LABEL_91:
    if ( !detect_loop(*(_DWORD *)(dnsmasq_daemon + 484), v59) )
    {
LABEL_92:
      v38 = 0;
      if ( find_pseudoheader(v5, v12, 0, v53, 0, 0) )
      {
        v39 = *(unsigned __int8 *)v53[0];
        v40 = *(unsigned __int8 *)(v53[0] + 1);
        v41 = *(unsigned __int8 *)(v53[0] + 4);
        v53[0] += 6;
        v42 = v40 | (v39 << 8);
        if ( v42 > *(unsigned __int16 *)(dnsmasq_daemon + 432) )
          v42 = *(unsigned __int16 *)(dnsmasq_daemon + 432);
        v43 = v41 >> 7;
        v38 = 1;
      }
      else
      {
        v42 = 512;
        v43 = 0;
      }
      if ( dns_auth )
      {
        v44 = answer_auth(v5, (char *)v5 + v42, v12, v50, &udpaddr, v51, v43, v38);
        if ( v44 )
        {
          v45 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) == 0 )
            v45 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
          send_from(listen->fd, v45, (char *)v5, v44, &udpaddr, &source, v17);
          ++*(_DWORD *)(dnsmasq_daemon + 496);
        }
      }
      else
      {
        v52 = (all_addr *)v17;
        v46 = 1;
        if ( (v5->hb4 & 0x20) == 0 )
          v46 = v43;
        v47 = answer_request(v5, (char *)v5 + v42, v12, s_addr, v9, v50, v46, v43, v38);
        fd = listen->fd;
        if ( v47 )
        {
          v49 = 1;
          if ( (*(_BYTE *)(dnsmasq_daemon + 1) & 0x20) == 0 )
            v49 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
          send_from(fd, v49, (char *)v5, v47, &udpaddr, &source, (unsigned int)v52);
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
        else if ( forward_query(fd, &udpaddr, &source, (unsigned int)v52, v5, v12, v50, 0u, v46, v50) )
        {
          ++*(_DWORD *)(dnsmasq_daemon + 492);
        }
        else
        {
          ++*(_DWORD *)(dnsmasq_daemon + 488);
        }
      }
    }
    return;
  }
  v16 = 0;
  if ( message.msg_controllen >= 0xC )
  {
    v51 = 0;
    v18 = 0;
    if ( listen->family == 2 )
    {
      msg_control = (struct cmsghdr *)message.msg_control;
      if ( message.msg_control )
      {
        v18 = 0;
        do
        {
          if ( !msg_control->cmsg_level && msg_control->cmsg_type == 8 )
          {
            v18 = *(_DWORD *)msg_control->__cmsg_data;
            s_addr = *(_DWORD *)&msg_control->__cmsg_data[4];
            source.addr.addr4.s_addr = s_addr;
          }
          msg_control = _cmsg_nxthdr(&message, msg_control);
        }
        while ( msg_control );
      }
    }
    v20 = v18;
    if ( listen->family == 10 && message.msg_controllen >= 0xC )
    {
      v21 = (struct cmsghdr *)message.msg_control;
      if ( message.msg_control )
      {
        do
        {
          if ( v21->cmsg_level == 41 && v21->cmsg_type == *(_DWORD *)(dnsmasq_daemon + 1132) )
          {
            v22 = *(_DWORD *)v21->__cmsg_data;
            v23 = *(_QWORD *)&v21->__cmsg_data[4];
            source.addr.addr6.__in6_u.__u6_addr32[3] = *(_DWORD *)&v21->__cmsg_data[12];
            source.addr.addr4.s_addr = v22;
            *(_QWORD *)(&source.addr.dnssec + 1) = v23;
            v20 = *(_DWORD *)&v21->__cmsg_data[16];
          }
          v21 = _cmsg_nxthdr(&message, v21);
        }
        while ( v21 );
      }
    }
    v17 = v20;
    v24 = indextoname(listen->fd, v20, v53);
    v16 = 0;
    if ( v24 )
    {
      if ( iface_check(listen->family, &source, v53, &dns_auth) )
        goto LABEL_113;
      if ( (*(_BYTE *)(dnsmasq_daemon + 4) & 0x80) == 0 )
        enumerate_interfaces(0);
      if ( loopback_exception(listen->fd, listen->family, &source, v53) || label_exception(v17, listen->family, &source) )
      {
LABEL_113:
        v16 = 1;
        if ( listen->family == 2 && (*(_BYTE *)(dnsmasq_daemon + 2) & 4) != 0 )
        {
          v25 = *(unsigned __int16 **)(dnsmasq_daemon + 508);
          if ( v25 )
          {
            while ( 1 )
            {
              v26 = *v25;
              v27 = v26 == 2;
              if ( v26 == 2 )
                v27 = *((_DWORD *)v25 + 1) == s_addr;
              if ( v27 )
                break;
              v25 = (unsigned __int16 *)*((_DWORD *)v25 + 20);
              if ( !v25 )
                goto LABEL_66;
            }
          }
          else
          {
LABEL_66:
            if ( (*(_BYTE *)(dnsmasq_daemon + 4) & 0x80) == 0 )
              enumerate_interfaces(0);
          }
          v28 = *(_DWORD **)(dnsmasq_daemon + 508);
          if ( v28 )
          {
            while ( 1 )
            {
              v29 = *(unsigned __int16 *)v28;
              v30 = v29 == 2;
              if ( v29 == 2 )
                v30 = v28[1] == s_addr;
              if ( v30 )
                break;
              v28 = (_DWORD *)v28[20];
              if ( !v28 )
                goto LABEL_73;
            }
            v9 = v28[7];
          }
          else
          {
LABEL_73:
            s_addr = 0;
          }
        }
      }
    }
  }
  else
  {
    v51 = 0;
    v17 = 0;
  }
  if ( v16 )
    goto LABEL_78;
}
