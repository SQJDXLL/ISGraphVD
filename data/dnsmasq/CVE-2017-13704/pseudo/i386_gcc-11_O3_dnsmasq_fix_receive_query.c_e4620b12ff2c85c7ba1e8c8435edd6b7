void __cdecl receive_query(listener *listen, time_t now)
{
  listener *v2; // esi
  _DWORD *v3; // eax
  int family; // ecx
  irec *iface; // edx
  size_t v6; // eax
  int v7; // eax
  _DWORD *v8; // edx
  int v9; // esi
  int v10; // edx
  char *v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // edx
  in_addr_t s_addr; // ecx
  in_addr_t v15; // edx
  int v16; // edi
  int v17; // edx
  unsigned __int32 v18; // eax
  int v19; // eax
  unsigned int *msg_control; // ecx
  unsigned int v21; // eax
  unsigned int v22; // edx
  _DWORD *v23; // eax
  int v24; // edx
  const char *v25; // eax
  int v26; // eax
  _DWORD *v27; // eax
  int v28; // edi
  _DWORD *v29; // edx
  __int16 v30; // dx
  __int16 v31; // ax
  int v32; // eax
  int v33; // edx
  char *v34; // ecx
  size_t v35; // edi
  size_t v36; // eax
  int v37; // edx
  size_t v38; // eax
  int v39; // edx
  int v40; // edx
  int v41; // ecx
  int v42; // ecx
  time_t v43; // [esp-4h] [ebp-E4h]
  char *types; // [esp+0h] [ebp-E0h]
  mysockaddr *header; // [esp+4h] [ebp-DCh]
  int dst_addr_4; // [esp+8h] [ebp-D8h]
  int check_dst; // [esp+Ch] [ebp-D4h]
  int n; // [esp+10h] [ebp-D0h]
  in_addr_t v49; // [esp+14h] [ebp-CCh]
  int ad_reqd; // [esp+1Ch] [ebp-C4h]
  char *local_auth; // [esp+20h] [ebp-C0h]
  int local_authc; // [esp+20h] [ebp-C0h]
  char *local_autha; // [esp+20h] [ebp-C0h]
  int local_authb; // [esp+20h] [ebp-C0h]
  unsigned __int16 type; // [esp+26h] [ebp-BAh] BYREF
  unsigned __int8 *t_cp; // [esp+28h] [ebp-B8h] BYREF
  int auth_dns; // [esp+2Ch] [ebp-B4h] BYREF
  msghdr msg; // [esp+30h] [ebp-B0h] BYREF
  iovec iov[1]; // [esp+4Ch] [ebp-94h] BYREF
  all_addr dst_addr; // [esp+54h] [ebp-8Ch] BYREF
  mysockaddr source_addr; // [esp+64h] [ebp-7Ch] BYREF
  union {cmsghdr align;char control6[32];char control[24];} control_u; // [esp+80h] [ebp-60h] BYREF
  ifreq ifr; // [esp+A0h] [ebp-40h] BYREF
  unsigned int v64; // [esp+C0h] [ebp-20h]

  v64 = __readgsdword(0x14u);
  v2 = listen;
  auth_dns = 0;
  v3 = dnsmasq_daemon_0;
  header = (mysockaddr *)dnsmasq_daemon_0[119];
  dst_addr_4 = *dnsmasq_daemon_0 & 0x2000;
  if ( dst_addr_4 )
  {
    family = listen->family;
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v49 = 0;
    dst_addr_4 = 0;
    check_dst = family == 10;
    iface = listen->iface;
    if ( iface )
    {
      auth_dns = iface->dns_auth;
      if ( family == 2 )
      {
        s_addr = iface->addr.in.sin_addr.s_addr;
        v15 = iface->netmask.s_addr;
        dst_addr.addr.addr4.s_addr = s_addr;
        dst_addr_4 = s_addr;
        v49 = v15;
      }
    }
  }
  else
  {
    dnsmasq_daemon_0[132] = 0;
    dst_addr.addr.addr4.s_addr = 0;
    v49 = 0;
    check_dst = 1;
  }
  v6 = *((unsigned __int16 *)v3 + 216);
  msg.msg_controllen = 32;
  msg.msg_flags = 0;
  iov[0].iov_len = v6;
  msg.msg_control = &control_u;
  msg.msg_name = &source_addr;
  iov[0].iov_base = header;
  msg.msg_namelen = 28;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;
  n = recvmsg(listen->fd, &msg, 0);
  if ( n <= 11 )
    return;
  ad_reqd = msg.msg_flags & 0x20;
  if ( (msg.msg_flags & 0x20) != 0 || header->sa.sa_data[0] < 0 )
    return;
  memset((void *)(dnsmasq_daemon_0[119] + n), 0, *((unsigned __int16 *)dnsmasq_daemon_0 + 216) - n);
  v7 = listen->family;
  source_addr.sa.sa_family = v7;
  if ( v7 == 2 )
  {
    if ( !source_addr.in.sin_port )
      return;
    v8 = dnsmasq_daemon_0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_18;
  }
  else
  {
    if ( !source_addr.in.sin_port )
      return;
    v8 = dnsmasq_daemon_0;
    source_addr.in.sin_addr.s_addr = 0;
    if ( (*((_BYTE *)dnsmasq_daemon_0 + 6) & 2) == 0 )
      goto LABEL_18;
    if ( v7 == 10 )
    {
      if ( dnsmasq_daemon_0[284] )
      {
        v9 = dnsmasq_daemon_0[284];
        while ( (*(_BYTE *)(v9 + 16) & 2) == 0 || !is_same_net6(v9, &source_addr.in6.sin6_addr, *(_DWORD *)(v9 + 20)) )
        {
          v9 = *(_DWORD *)(v9 + 24);
          if ( !v9 )
            goto LABEL_89;
        }
        v2 = listen;
        goto LABEL_18;
      }
LABEL_89:
      if ( !warned_2 )
      {
        my_syslog(4, "Ignoring query from non-local network");
        warned_2 = 1;
      }
      return;
    }
  }
  v16 = v8[284];
  if ( !v16 )
    goto LABEL_89;
  v17 = 32;
  while ( 1 )
  {
    v18 = _byteswap_ulong(-1 << (v17 - *(_BYTE *)(v16 + 20)));
    if ( (*(_BYTE *)(v16 + 16) & 2) == 0 )
    {
      local_authc = v17;
      v19 = is_same_net(*(_DWORD *)v16, source_addr.in.sin_addr.s_addr, v18);
      v17 = local_authc;
      if ( v19 )
        break;
    }
    v16 = *(_DWORD *)(v16 + 24);
    if ( !v16 )
      goto LABEL_89;
  }
LABEL_18:
  if ( !check_dst )
  {
    v23 = dnsmasq_daemon_0;
    goto LABEL_56;
  }
  if ( msg.msg_controllen > 0xB )
  {
    v10 = v2->family;
    if ( v10 == 2 )
    {
      msg_control = (unsigned int *)msg.msg_control;
      check_dst = 0;
      if ( msg.msg_control )
      {
        local_autha = (char *)msg.msg_control + msg.msg_controllen;
        if ( *((_DWORD *)msg.msg_control + 1) )
          goto LABEL_44;
LABEL_42:
        if ( msg_control[2] == 8 )
        {
          dst_addr.addr.addr4.s_addr = msg_control[4];
          dst_addr_4 = dst_addr.addr.addr4.s_addr;
          check_dst = msg_control[3];
        }
LABEL_44:
        while ( 1 )
        {
          v21 = *msg_control;
          v22 = (-*msg_control & 3) + 12;
          if ( *msg_control <= 0xB
            || v22 > local_autha - (char *)msg_control
            || v21 > local_autha - (char *)msg_control - v22 )
          {
            break;
          }
          msg_control = (unsigned int *)((char *)msg_control + ((v21 + 3) & 0xFFFFFFFC));
          if ( !msg_control[1] )
            goto LABEL_42;
        }
      }
    }
    else if ( v10 == 10 )
    {
      v11 = (char *)msg.msg_control;
      check_dst = 0;
      if ( msg.msg_control )
      {
        local_auth = (char *)msg.msg_control + msg.msg_controllen;
        if ( *((_DWORD *)msg.msg_control + 1) == 41 )
          goto LABEL_28;
        while ( 1 )
        {
          v12 = *(_DWORD *)v11;
          v13 = (-*(_DWORD *)v11 & 3) + 12;
          if ( *(_DWORD *)v11 <= 0xBu || v13 > local_auth - v11 || v12 > local_auth - v11 - v13 )
            break;
          v11 += (v12 + 3) & 0xFFFFFFFC;
          if ( *((_DWORD *)v11 + 1) == 41 )
          {
LABEL_28:
            if ( *((_DWORD *)v11 + 2) == dnsmasq_daemon_0[283] )
            {
              dst_addr = *(all_addr *)(v11 + 12);
              check_dst = *((_DWORD *)v11 + 7);
            }
          }
        }
      }
    }
    else
    {
      check_dst = 0;
    }
    if ( indextoname(v2->fd, check_dst, &ifr) )
    {
      if ( iface_check(v2->family, &dst_addr, &ifr, &auth_dns) )
        goto LABEL_55;
      if ( *((char *)dnsmasq_daemon_0 + 4) >= 0 )
        enumerate_interfaces(0);
      if ( loopback_exception(v2->fd, v2->family, &dst_addr, &ifr) || label_exception(check_dst, v2->family, &dst_addr) )
      {
LABEL_55:
        v23 = dnsmasq_daemon_0;
        if ( v2->family != 2 || (*dnsmasq_daemon_0 & 0x40000) == 0 )
        {
LABEL_56:
          v24 = v23[285] + 1;
          v23[285] = v24;
          v23[286] = v24;
          v23[287] = &source_addr;
          if ( extract_request(header, n, v23[121], &type) )
          {
            v25 = "auth";
            if ( !auth_dns )
              v25 = "query";
            v26 = querystr(v25, type);
            if ( v2->family == 2 )
              log_query(524424, dnsmasq_daemon_0[121], &source_addr.in6.sin6_flowinfo, v26);
            else
              log_query(524552, dnsmasq_daemon_0[121], &source_addr.in6.sin6_addr, v26);
            v27 = dnsmasq_daemon_0;
            local_authb = auth_dns;
            if ( auth_dns )
            {
              local_authb = 0;
            }
            else if ( (*dnsmasq_daemon_0 & 0x40000) == 0 )
            {
              v28 = dnsmasq_daemon_0[20];
              if ( v28 )
              {
                v29 = dnsmasq_daemon_0;
                do
                {
                  if ( in_zone(v28, v29[121], 0) )
                  {
                    auth_dns = 1;
                    v27 = dnsmasq_daemon_0;
                    local_authb = 1;
                    goto LABEL_68;
                  }
                  v28 = *(_DWORD *)(v28 + 16);
                  v29 = dnsmasq_daemon_0;
                }
                while ( v28 );
                local_authb = 0;
                v27 = dnsmasq_daemon_0;
              }
            }
LABEL_68:
            if ( detect_loop(v27[121], type) )
              return;
          }
          else
          {
            local_authb = 0;
          }
          if ( find_pseudoheader(header, n, 0, &t_cp, 0, 0) )
          {
            v30 = *((_WORD *)t_cp + 2);
            v31 = *(_WORD *)t_cp;
            t_cp += 6;
            LOWORD(v32) = __ROL2__(v31, 8);
            ad_reqd = (unsigned int)(__int16)__ROL2__(v30, 8) >> 31;
            if ( (unsigned __int16)v32 > *((_WORD *)dnsmasq_daemon_0 + 216) )
              LOWORD(v32) = *((_WORD *)dnsmasq_daemon_0 + 216);
            v33 = 1;
            v32 = (unsigned __int16)v32;
          }
          else
          {
            v33 = 0;
            v32 = 512;
          }
          v34 = (char *)header + v32;
          if ( auth_dns )
          {
            v38 = answer_auth(header, v34, n, now, &source_addr, local_authb, ad_reqd, v33);
            if ( v38 )
            {
              v39 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v39 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(v2->fd, v39, (char *)header, v38, &source_addr, &dst_addr, check_dst);
              ++dnsmasq_daemon_0[124];
            }
          }
          else
          {
            v35 = 1;
            if ( (header->sa.sa_data[1] & 0x20) == 0 )
              v35 = ad_reqd;
            v36 = answer_request(header, v34, n, dst_addr_4, v49, now, v35, ad_reqd, v33);
            if ( v36 )
            {
              v37 = 1;
              if ( (*dnsmasq_daemon_0 & 0x2000) == 0 )
                v37 = (dnsmasq_daemon_0[1] >> 7) & 1;
              send_from(v2->fd, v37, (char *)header, v36, &source_addr, &dst_addr, check_dst);
              ++dnsmasq_daemon_0[122];
            }
            else if ( forward_query(
                        check_dst,
                        header,
                        (all_addr *)n,
                        now,
                        0,
                        v35,
                        v43,
                        (frec *)types,
                        (int)header,
                        dst_addr_4) )
            {
              ++dnsmasq_daemon_0[123];
            }
            else
            {
              ++dnsmasq_daemon_0[122];
            }
          }
          return;
        }
        v40 = dnsmasq_daemon_0[127];
        if ( v40 )
        {
          v41 = dnsmasq_daemon_0[127];
          do
          {
            if ( *(_WORD *)v41 == 2 && *(_DWORD *)(v41 + 4) == dst_addr_4 )
            {
              v42 = dst_addr_4;
LABEL_101:
              while ( *(_WORD *)v40 != 2 || *(_DWORD *)(v40 + 4) != v42 )
              {
                v40 = *(_DWORD *)(v40 + 80);
                if ( !v40 )
                  goto LABEL_110;
              }
              dst_addr_4 = v42;
              v49 = *(_DWORD *)(v40 + 28);
              goto LABEL_56;
            }
            v41 = *(_DWORD *)(v41 + 80);
          }
          while ( v41 );
          if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
            goto LABEL_112;
        }
        else if ( *((char *)dnsmasq_daemon_0 + 4) < 0 )
        {
LABEL_110:
          dst_addr_4 = 0;
          goto LABEL_56;
        }
        enumerate_interfaces(0);
        v23 = dnsmasq_daemon_0;
        v40 = dnsmasq_daemon_0[127];
        if ( v40 )
        {
LABEL_112:
          v42 = dst_addr_4;
          goto LABEL_101;
        }
        goto LABEL_110;
      }
    }
  }
}
