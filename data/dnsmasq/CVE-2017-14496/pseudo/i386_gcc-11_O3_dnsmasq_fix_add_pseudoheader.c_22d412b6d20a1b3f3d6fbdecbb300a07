size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // ebp
  unsigned __int8 *v11; // ebp
  u16 v12; // ax
  int v13; // edi
  signed int v14; // esi
  unsigned __int8 *v15; // ebx
  unsigned __int16 v16; // dx
  int v17; // eax
  int v18; // ecx
  int v19; // ebp
  unsigned __int8 *v20; // edi
  int v21; // ebp
  __int16 v22; // ax
  __int16 v23; // dx
  size_t v24; // edx
  __int16 v26; // di
  int v27; // eax
  int v28; // eax
  int v29; // ecx
  char *v30; // ebx
  unsigned __int8 *v31; // eax
  _WORD *v32; // esi
  unsigned __int8 *v33; // eax
  size_t rdlen; // [esp+28h] [ebp-44h]
  unsigned __int8 *v35; // [esp+30h] [ebp-3Ch]
  int v36; // [esp+30h] [ebp-3Ch]
  unsigned __int8 *datap; // [esp+34h] [ebp-38h]
  __int16 v38; // [esp+38h] [ebp-34h]
  u16 t_s; // [esp+3Ch] [ebp-30h]
  __int16 v40; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  pseudoheader = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( pseudoheader )
  {
    v11 = t_cp;
    v40 = *(_WORD *)t_cp;
    v38 = *((_WORD *)t_cp + 1);
    v12 = __ROL2__(*((_WORD *)t_cp + 2), 8);
    t_s = v12;
    if ( set_do )
    {
      t_s = v12 | 0x8000;
      *((_WORD *)t_cp + 2) = __ROL2__(v12 | 0x8000, 8);
    }
    v13 = (int)(v11 + 8);
    datap = v11 + 8;
    v14 = (unsigned __int16)__ROL2__(*((_WORD *)v11 + 3), 8);
    if ( (unsigned int)(unsigned __int16)v14 + v11 + 8 - (unsigned __int8 *)header > plen || !optno )
      return plen;
    if ( (unsigned __int16)v14 > 4u )
    {
      v15 = v11 + 12;
      v16 = __ROL2__(*((_WORD *)v11 + 4), 8);
      v17 = (unsigned __int16)__ROL2__(*((_WORD *)v11 + 5), 8);
      v18 = (unsigned __int16)v17 + 4;
      if ( (unsigned __int16)v14 < v18 )
      {
LABEL_42:
        is_last[0] = 0;
        pseudoheader = 0;
LABEL_43:
        udp_sz = __ROL2__(v40, 8);
        v26 = __ROL2__(v38, 8);
        plen = rrfilter(header, plen, 0);
        goto LABEL_24;
      }
      if ( !replace )
      {
        v35 = v11;
        v20 = v11 + 12;
        v21 = 0;
        while ( v16 != optno )
        {
          v21 += v17 + 4;
          v13 = (int)&v20[v17];
          if ( v21 + 4 >= (unsigned __int16)v14 )
            goto LABEL_32;
          v22 = *(_WORD *)(v13 + 2);
          v23 = *(_WORD *)v13;
          v20 = (unsigned __int8 *)(v13 + 4);
          v16 = __ROL2__(v23, 8);
          v17 = (unsigned __int16)__ROL2__(v22, 8);
          if ( (unsigned __int16)v17 + v21 + 4 > (unsigned __int16)v14 )
            goto LABEL_42;
        }
        return plen;
      }
      v35 = v11;
      v19 = 0;
      while ( 1 )
      {
        if ( v16 == optno )
        {
          v14 -= v18;
          memcpy((void *)v13, (const void *)(v13 + v17 + 4), v14 - v19);
          *((_WORD *)v35 + 3) = __ROL2__(v14, 8);
        }
        else
        {
          v13 = (int)&v15[v17];
          v19 += v18;
        }
        if ( v19 + 4 >= v14 )
          break;
        v15 = (unsigned __int8 *)(v13 + 4);
        v16 = __ROL2__(*(_WORD *)v13, 8);
        v17 = (unsigned __int16)__ROL2__(*(_WORD *)(v13 + 2), 8);
        if ( (unsigned __int16)v17 + v19 + 4 > v14 )
          goto LABEL_42;
        v18 = (unsigned __int16)v17 + 4;
      }
LABEL_32:
      v11 = v35;
    }
    if ( is_last[0] )
    {
      v31 = (unsigned __int8 *)(v13 + 4);
      if ( (int)&limit[-v13 - 4] >= (int)optlen )
      {
        v32 = v11 + 6;
        goto LABEL_36;
      }
      return plen;
    }
    if ( v14 )
    {
      v33 = (unsigned __int8 *)whine_malloc(v14);
      pseudoheader = v33;
      rdlen = v14;
      if ( v33 )
        memcpy(v33, datap, v14);
    }
    else
    {
      rdlen = 0;
      pseudoheader = 0;
    }
    goto LABEL_43;
  }
  v26 = 0;
  t_s = (set_do != 0) << 15;
LABEL_24:
  v27 = skip_questions(header, plen);
  v24 = plen;
  if ( !v27 )
    return v24;
  v28 = skip_section(
          v27,
          (unsigned __int16)__ROL2__(header->arcount, 8)
        + (unsigned __int16)__ROL2__(header->ancount, 8)
        + (unsigned __int16)__ROL2__(header->nscount, 8),
          header,
          plen);
  v24 = plen;
  v29 = v28;
  if ( !v28 )
    return v24;
  v30 = (char *)(v28 + 11);
  if ( (unsigned int)limit < v28 + 11 )
    return v24;
  *(_BYTE *)(v28 + 2) = 41;
  *(_WORD *)(v28 + 3) = __ROL2__(udp_sz, 8);
  *(_WORD *)(v28 + 5) = __ROL2__(v26, 8);
  *(_WORD *)v28 = 0;
  *(_WORD *)(v28 + 7) = __ROL2__(t_s, 8);
  LOWORD(datap) = v28 + 11;
  *(_WORD *)(v28 + 9) = __ROL2__(rdlen, 8);
  if ( pseudoheader )
  {
    v13 = (int)&v30[rdlen];
    if ( &v30[rdlen] > (char *)limit )
    {
      free(pseudoheader);
      return plen;
    }
    v36 = v28;
    memcpy(v30, pseudoheader, rdlen);
    free(pseudoheader);
    v29 = v36;
  }
  else
  {
    v13 = v28 + 11;
  }
  v31 = (unsigned __int8 *)(v13 + 4);
  v24 = plen;
  if ( (int)&limit[-v13 - 4] < (int)optlen )
    return v24;
  v32 = (_WORD *)(v29 + 9);
  header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_36:
  if ( !optno || replace == 2 )
    return v13 - (_DWORD)header;
  v24 = plen;
  if ( limit >= v31 )
  {
    *(_WORD *)v13 = __ROL2__(optno, 8);
    *(_WORD *)(v13 + 2) = __ROL2__(optlen, 8);
    v13 = (int)&v31[optlen];
    if ( &v31[optlen] <= limit )
    {
      memcpy(v31, opt, optlen);
      *v32 = __ROL2__(v13 - (_WORD)datap, 8);
      return v13 - (_DWORD)header;
    }
  }
  return v24;
}
