size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v13; // r14
  unsigned __int8 *pseudoheader; // rax
  __int64 v16; // rdx
  _BYTE *v18; // rsi
  unsigned __int8 *v19; // r12
  __int16 v20; // ax
  unsigned __int64 v21; // rdx
  char *v22; // rbx
  int v23; // ebp
  unsigned __int64 v24; // rax
  _BYTE *v25; // rsi
  unsigned __int64 v26; // r13
  void *v27; // r12
  __int16 v28; // bp
  int v29; // eax
  unsigned __int64 v30; // rcx
  int v31; // edx
  bool v32; // cc
  void *v33; // rsi
  unsigned __int8 *v34; // rdx
  int v35; // ebp
  char *v36; // r13
  size_t v37; // rbx
  void *v38; // rax
  __int64 v39; // rax
  __m128i v40; // xmm0
  __m128i v41; // xmm0
  __int64 v42; // rax
  __int64 v43; // r13
  __int64 v44; // rdx
  int v45; // eax
  void *v46; // rdi
  __int64 v47; // rbx
  unsigned __int8 *v48; // rcx
  unsigned __int8 *v49; // rbx
  char *v50; // r13
  __int16 v51; // [rsp+4h] [rbp-74h]
  __int16 v52; // [rsp+8h] [rbp-70h]
  int v53; // [rsp+Ch] [rbp-6Ch]
  __int16 v54; // [rsp+10h] [rbp-68h]
  int is_last; // [rsp+14h] [rbp-64h] BYREF
  unsigned __int64 v56; // [rsp+18h] [rbp-60h]
  void *src; // [rsp+20h] [rbp-58h]
  void *v58; // [rsp+28h] [rbp-50h]
  int is_sign; // [rsp+34h] [rbp-44h] BYREF
  unsigned __int8 *v60; // [rsp+38h] [rbp-40h]
  unsigned __int8 *v61; // [rsp+40h] [rbp-38h] BYREF

  v13 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v61, &is_sign, &is_last);
  if ( is_sign )
    return v13;
  v60 = limit;
  v58 = opt;
  v56 = 0LL;
  v18 = 0LL;
  LOBYTE(v16) = set_do != 0;
  v53 = optno;
  if ( !pseudoheader )
  {
    LOBYTE(v18) = set_do != 0;
    v54 = (_WORD)v18 << 15;
    v27 = 0LL;
    v28 = 0;
    goto LABEL_31;
  }
  v19 = v61;
  v20 = __ROL2__(*((_WORD *)v61 + 2), 8);
  if ( set_do )
  {
    v20 |= 0x8000u;
    v61[4] = HIBYTE(v20);
  }
  if ( !optno )
    return v13;
  v54 = v20;
  v21 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v19 + 3) << 48);
  v22 = (char *)(v19 + 8);
  if ( v21 + v19 + 8 - (unsigned __int8 *)header > v13 )
    return v13;
  v52 = *(_WORD *)v19;
  v51 = *((_WORD *)v19 + 1);
  src = v19 + 8;
  if ( (unsigned int)v21 >= 5 )
  {
    if ( replace )
    {
      v23 = 0;
      while ( 1 )
      {
        v24 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v22 + 1) << 48);
        if ( (int)v24 + v23 > (int)v21 )
          break;
        v25 = v22 + 4;
        if ( _byteswap_ulong(*(unsigned __int16 *)v22 << 16) == v53 )
        {
          v18 = &v25[v24];
          v26 = (unsigned int)(v21 - v24 - 4);
          memcpy(v22, v18, (int)v26 - v23);
          v21 = v26;
          *((_WORD *)v19 + 3) = __ROL2__(v26, 8);
          if ( v23 + 4 >= (int)v26 )
            goto LABEL_21;
        }
        else
        {
          v18 = &v25[(unsigned int)v24];
          v23 += v24 + 4;
          v22 = v18;
          if ( v23 + 4 >= (int)v21 )
            goto LABEL_21;
        }
      }
    }
    else
    {
      v29 = 0;
      while ( 1 )
      {
        v30 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v22 + 1) << 48);
        v18 = (_BYTE *)v21;
        if ( (int)v30 + v29 > (int)v21 )
          break;
        if ( _byteswap_ulong(*(unsigned __int16 *)v22 << 16) == optno )
          return v13;
        v22 += v30 + 4;
        v31 = v29 + v30 + 8;
        v29 += v30 + 4;
        v32 = v31 < (int)v18;
        v21 = (unsigned __int64)v18;
        if ( !v32 )
          goto LABEL_21;
      }
    }
    is_last = 0;
LABEL_28:
    v56 = 0LL;
    goto LABEL_29;
  }
LABEL_21:
  if ( is_last )
  {
    v33 = v58;
    v34 = v19 + 6;
    v35 = replace;
    v36 = v22 + 4;
    if ( v60 - (unsigned __int8 *)(v22 + 4) < (__int64)optlen )
      return v13;
    goto LABEL_38;
  }
  if ( !(_DWORD)v21 )
    goto LABEL_28;
  v56 = v21;
  v37 = (int)v21;
  v38 = (void *)whine_malloc((int)v21, v18);
  if ( !v38 )
  {
LABEL_29:
    v27 = 0LL;
    goto LABEL_30;
  }
  v27 = v38;
  memcpy(v38, src, v37);
LABEL_30:
  udp_sz = __ROL2__(v52, 8);
  v28 = __ROL2__(v51, 8);
  v13 = rrfilter(header, v13, 0LL);
LABEL_31:
  v39 = skip_questions(header, v13, v16);
  if ( v39 )
  {
    v40 = _mm_cvtsi32_si128(*(_DWORD *)&header->ancount);
    v41 = _mm_or_si128(_mm_slli_epi16(v40, 8u), _mm_srli_epi16(v40, 8u));
    v42 = skip_section(
            v39,
            _mm_cvtsi128_si32(_mm_add_epi32(_mm_srli_epi32(v41, 0x10u), _mm_unpacklo_epi16(v41, (__m128i)0LL)))
          + (unsigned int)(unsigned __int16)__ROL2__(header->arcount, 8),
            header,
            v13);
    if ( v42 )
    {
      v43 = v42;
      v44 = v42;
      *(_WORD *)v42 = 0;
      *(_BYTE *)(v42 + 2) = 41;
      *(_BYTE *)(v42 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v42 + 4) = udp_sz;
      *(_BYTE *)(v42 + 5) = HIBYTE(v28);
      *(_BYTE *)(v42 + 6) = v28;
      *(_BYTE *)(v42 + 7) = HIBYTE(v54);
      *(_BYTE *)(v42 + 8) = v54;
      v45 = v56;
      *(_BYTE *)(v44 + 9) = BYTE1(v56);
      *(_BYTE *)(v43 + 10) = v45;
      v46 = (void *)(v43 + 11);
      v22 = (char *)(v43 + 11);
      if ( v27 )
      {
        v47 = v45;
        memcpy(v46, v27, v45);
        free(v27);
        v46 = (void *)(v43 + 11);
        v22 = (char *)(v43 + 11 + v47);
      }
      v34 = (unsigned __int8 *)(v43 + 9);
      v48 = v60;
      src = v46;
      v33 = v58;
      if ( v60 - (unsigned __int8 *)v22 - 4 >= (__int64)optlen )
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
      v35 = replace;
      v36 = v22 + 4;
      if ( v48 - (unsigned __int8 *)(v22 + 4) >= (__int64)optlen )
      {
LABEL_38:
        if ( v53 && v35 != 2 )
        {
          *v22 = BYTE1(v53);
          v22[1] = v53;
          v22[2] = BYTE1(optlen);
          v22[3] = optlen;
          v49 = v34;
          memcpy(v36, v33, optlen);
          v50 = &v36[optlen];
          *(_WORD *)v49 = __ROL2__((_WORD)v50 - (_WORD)src, 8);
          v22 = v50;
        }
        return v22 - (char *)header;
      }
    }
  }
  return v13;
}
