size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $fp
  unsigned __int8 *v19; // $t0
  unsigned __int8 *v20; // $s7
  unsigned __int16 v21; // $s6
  int v22; // $a3
  unsigned __int8 *v23; // $a0
  int v24; // $v1
  int v25; // $v0
  unsigned __int8 *v26; // $a2
  int v27; // $t2
  int v28; // $v0
  int v29; // $v1
  unsigned __int8 *v30; // $v0
  int v31; // $a0
  size_t result; // $v0
  void *v33; // $a3
  _WORD *v34; // $s0
  char *v35; // $a3
  unsigned __int8 *v36; // $t0
  int v37; // $v0
  int v38; // $s7
  unsigned __int8 *v39; // $v0
  int v40; // $a3
  unsigned __int8 *v41; // $v0
  int t_sb; // [sp+24h] [-24h]
  unsigned __int8 *t_s; // [sp+24h] [-24h]
  unsigned __int8 *t_sc; // [sp+24h] [-24h]
  size_t t_sa; // [sp+24h] [-24h]
  int i; // [sp+28h] [-20h]
  unsigned __int8 *t_cp; // [sp+30h] [-18h]
  unsigned __int16 v48; // [sp+36h] [-12h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v48 = 0;
    v21 = (set_do != 0) << 15;
LABEL_17:
    t_s = v19;
    v31 = skip_questions(header, v17);
    if ( v31 )
    {
      v37 = skip_section(v31, header->ancount + header->nscount + header->arcount, header, v17);
      v38 = v37;
      if ( v37 )
      {
        *(_BYTE *)(v37 + 9) = BYTE2(v18);
        *(_BYTE *)(v37 + 4) = udp_sz;
        *(_BYTE *)v37 = 0;
        *(_WORD *)(v37 + 1) = 41;
        *(_BYTE *)(v37 + 3) = HIBYTE(udp_sz);
        *(_WORD *)(v37 + 5) = v48;
        *(_WORD *)(v37 + 7) = v21;
        *(_BYTE *)(v37 + 10) = v18;
        LOWORD(t_cp) = v37 + 0xB;
        if ( t_s )
        {
          memcpy((void *)(v37 + 0xB), t_s, v18);
          free(t_s);
          v23 = (unsigned __int8 *)(v38 + 0xB + v18);
        }
        else
        {
          v23 = (unsigned __int8 *)(v37 + 0xB);
        }
        v33 = v23 + 4;
        result = v17;
        if ( limit - (v23 + 4) >= (int)optlen )
        {
          ++header->arcount;
          if ( !optno )
            return v23 - (unsigned __int8 *)header;
          v34 = (_WORD *)(v38 + 9);
LABEL_24:
          if ( replace != 2 )
          {
            v23[2] = BYTE2(optlen);
            *(_WORD *)v23 = optno;
            v23[3] = optlen;
            v35 = (char *)memcpy(v33, opt, optlen);
            v23 = (unsigned __int8 *)&v35[optlen];
            *v34 = (_WORD)v35 + optlen - (_WORD)t_cp;
          }
          return v23 - (unsigned __int8 *)header;
        }
        return result;
      }
    }
    return v17;
  }
  v20 = udp_len;
  v21 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
  v48 = _byteswap_ushort(*((_WORD *)udp_len + 1));
  if ( set_do )
  {
    v21 |= 0x8000u;
    udp_len[4] = HIBYTE(v21);
    v20[5] = v21;
  }
  v22 = v20[7] | (v20[6] << 8);
  t_cp = v20 + 8;
  if ( v17 < v20 + 8 - (unsigned __int8 *)header + v22 || !optno )
    return v17;
  v23 = v20 + 8;
  if ( v22 >= 5 )
  {
    v24 = v20[11] | (v20[10] << 8);
    v25 = v20[9] | (v20[8] << 8);
    v26 = v20 + 0xC;
    if ( v22 >= v24 )
    {
      v23 = v20 + 8;
      v27 = 0;
      do
      {
        if ( v25 == optno )
        {
          v29 = v24 + 4;
          if ( !replace )
            return v17;
          i = v27;
          t_sb = v22 - v29;
          v30 = (unsigned __int8 *)memcpy(v23, &v23[v29], v22 - v29 - v27);
          v22 = t_sb;
          v23 = v30;
          v27 = i;
          *((_WORD *)v20 + 3) = t_sb;
        }
        else
        {
          v23 = &v26[v24];
          v27 += v24 + 4;
        }
        v28 = is_last;
        if ( v27 + 4 >= v22 )
          goto LABEL_21;
        v24 = v23[3] | (v23[2] << 8);
        v25 = v23[1] | (*v23 << 8);
        v26 = v23 + 4;
      }
      while ( v22 >= v24 + v27 );
    }
    is_last = 0;
    goto LABEL_28;
  }
  v28 = is_last;
LABEL_21:
  if ( !v28 )
  {
    if ( v22 )
    {
      t_sa = v22;
      v39 = (unsigned __int8 *)whine_malloc(v22);
      v36 = v39;
      v40 = t_sa;
      if ( v39 )
      {
        v41 = (unsigned __int8 *)memcpy(v39, t_cp, t_sa);
        v40 = t_sa;
        v36 = v41;
      }
      v18 = v40;
      goto LABEL_29;
    }
LABEL_28:
    v36 = 0;
LABEL_29:
    t_sc = v36;
    v17 = rrfilter(header, v17, 0);
    v19 = t_sc;
    goto LABEL_17;
  }
  v33 = v23 + 4;
  result = v17;
  if ( limit - (v23 + 4) >= (int)optlen )
  {
    v34 = v20 + 6;
    goto LABEL_24;
  }
  return result;
}
