size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // r13
  dns_header *v12; // rbp
  unsigned __int8 *pseudoheader; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  unsigned __int8 *v17; // rsi
  __int16 v18; // r10
  unsigned __int8 *v19; // rdi
  int v20; // r14d
  unsigned __int8 *v21; // r11
  unsigned __int16 v22; // dx
  __int64 v23; // rcx
  int v24; // eax
  int v25; // ebp
  int v26; // r12d
  int v27; // ebx
  unsigned int v28; // r14d
  __int16 v30; // r15
  __int16 v31; // r10
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rcx
  int v35; // r8d
  unsigned __int8 *v36; // r9
  __int64 v37; // r15
  __int64 v38; // r14
  void *v39; // r8
  _WORD *v40; // r12
  char *v41; // rax
  dns_header *v42; // r9
  __int64 v43; // rax
  dns_header *v44; // rax
  dns_header *v45; // rax
  const void *rdlen; // [rsp+10h] [rbp-88h]
  int rdlena; // [rsp+10h] [rbp-88h]
  __int16 ptr; // [rsp+18h] [rbp-80h]
  __int16 ptra; // [rsp+18h] [rbp-80h]
  unsigned __int8 *ptrb; // [rsp+18h] [rbp-80h]
  __int16 buff; // [rsp+20h] [rbp-78h]
  unsigned __int8 *buffa; // [rsp+20h] [rbp-78h]
  unsigned __int8 *buffb; // [rsp+20h] [rbp-78h]
  __int16 flags; // [rsp+28h] [rbp-70h]
  __int16 flagsa; // [rsp+28h] [rbp-70h]
  dns_header *headera; // [rsp+30h] [rbp-68h]
  dns_header *headerc; // [rsp+30h] [rbp-68h]
  __int16 headerb; // [rsp+30h] [rbp-68h]
  unsigned __int8 *limita; // [rsp+38h] [rbp-60h]
  int is_sign; // [rsp+48h] [rbp-50h] BYREF
  int is_last; // [rsp+4Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+50h] [rbp-48h] BYREF

  v10 = plen;
  v12 = header;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v15 = (unsigned int)is_sign;
  if ( is_sign )
    return v10;
  v16 = (unsigned __int64)pseudoheader;
  if ( !pseudoheader )
  {
    v30 = 0;
    v31 = (set_do != 0) << 15;
    goto LABEL_22;
  }
  v17 = udp_len[0];
  ptr = *(_WORD *)udp_len[0];
  v18 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
  buff = *((_WORD *)udp_len[0] + 1);
  if ( set_do )
  {
    v18 |= 0x8000u;
    *((_WORD *)udp_len[0] + 2) = __ROL2__(v18, 8);
  }
  v19 = v17 + 8;
  rdlen = v17 + 8;
  LOWORD(v20) = __ROL2__(*((_WORD *)v17 + 3), 8);
  if ( v10 < (unsigned __int64)(unsigned __int16)v20 + v17 + 8 - (unsigned __int8 *)v12 || !optno )
    return v10;
  v20 = (unsigned __int16)v20;
  if ( (unsigned __int16)v20 > 4u )
  {
    v23 = *((unsigned __int16 *)v17 + 4);
    v21 = v17 + 12;
    v22 = __ROL2__(*((_WORD *)v17 + 5), 8);
    LOWORD(v23) = __ROL2__(v23, 8);
    v24 = v22;
    if ( (unsigned __int16)v20 >= (int)v22 )
    {
      v16 = (unsigned int)replace;
      if ( !replace )
      {
        LODWORD(v16) = 0;
        while ( 1 )
        {
          v23 = (unsigned __int16)v23;
          if ( (unsigned __int16)v23 == optno )
            return v10;
          v16 = (unsigned int)(v24 + v16 + 4);
          v19 = &v21[v22];
          if ( (int)v16 + 4 >= (unsigned __int16)v20 )
          {
            if ( !is_last )
              goto LABEL_41;
            goto LABEL_30;
          }
          v23 = *(unsigned __int16 *)v19;
          v21 = v19 + 4;
          v22 = __ROL2__(*((_WORD *)v19 + 1), 8);
          LOWORD(v23) = __ROL2__(v23, 8);
          v24 = v22;
          if ( v22 + (int)v16 > (unsigned __int16)v20 )
            goto LABEL_37;
        }
      }
      headera = v12;
      limita = limit;
      v25 = 0;
      v26 = optno;
      v27 = (unsigned __int16)v20;
      flags = v18;
      v28 = v15;
      do
      {
        if ( (unsigned __int16)v23 == v26 )
        {
          v27 -= v24 + 4;
          v19 = (unsigned __int8 *)memcpy(v19, &v19[v22 + 4], v27 - v25);
          *((_WORD *)v17 + 3) = __ROL2__(v27, 8);
        }
        else
        {
          v25 += v24 + 4;
          v19 = &v21[v22];
        }
        if ( v27 <= v25 + 4 )
        {
          v15 = v28;
          v18 = flags;
          v20 = v27;
          optno = v26;
          v12 = headera;
          limit = limita;
          goto LABEL_29;
        }
        v23 = *(unsigned __int16 *)v19;
        v21 = v19 + 4;
        v22 = __ROL2__(*((_WORD *)v19 + 1), 8);
        LOWORD(v23) = __ROL2__(v23, 8);
        v24 = v22;
      }
      while ( v22 + v25 <= v27 );
      optno = v26;
      v12 = headera;
      limit = limita;
      LODWORD(v15) = v28;
      v18 = flags;
    }
LABEL_37:
    is_last = 0;
    goto LABEL_38;
  }
LABEL_29:
  v23 = (unsigned int)is_last;
  if ( is_last )
  {
LABEL_30:
    v39 = v19 + 4;
    if ( limit - (v19 + 4) >= (__int64)optlen )
    {
      v40 = v17 + 6;
      goto LABEL_32;
    }
    return v10;
  }
  if ( v20 )
  {
LABEL_41:
    headerb = v18;
    v44 = (dns_header *)whine_malloc(v20, v17, v20, v23, v15, v16);
    v18 = headerb;
    v42 = v44;
    if ( v44 )
    {
      v45 = (dns_header *)memcpy(v44, rdlen, v20);
      v18 = headerb;
      v42 = v45;
    }
    LODWORD(v15) = v20;
    goto LABEL_39;
  }
LABEL_38:
  v42 = 0LL;
LABEL_39:
  headerc = v42;
  flagsa = v18;
  udp_sz = __ROL2__(ptr, 8);
  rdlena = v15;
  v30 = __ROL2__(buff, 8);
  v43 = rrfilter(v12, v10, 0LL, v23);
  LODWORD(v15) = rdlena;
  v31 = flagsa;
  v16 = (unsigned __int64)headerc;
  v10 = v43;
LABEL_22:
  buffa = (unsigned __int8 *)v16;
  ptra = v31;
  LODWORD(rdlen) = v15;
  v32 = skip_questions(v12, v10);
  if ( !v32 )
    return v10;
  v33 = skip_section(
          v32,
          (unsigned __int16)__ROL2__(v12->arcount, 8)
        + (unsigned __int16)__ROL2__(v12->nscount, 8)
        + (unsigned int)(unsigned __int16)__ROL2__(v12->ancount, 8),
          v12,
          v10);
  v34 = v33;
  if ( !v33 )
    return v10;
  v35 = (int)rdlen;
  *(_WORD *)v33 = 0;
  *(_BYTE *)(v33 + 2) = 41;
  v36 = buffa;
  *(_QWORD *)(v33 + 3) = HIBYTE(udp_sz) | (((unsigned __int8)udp_sz | ((HIBYTE(v30) | (((unsigned __int8)v30 | ((HIBYTE(ptra) | (((unsigned __int8)ptra | ((BYTE1(rdlen) | ((unsigned __int64)(unsigned __int8)rdlen << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  LOWORD(rdlen) = v33 + 11;
  v37 = v33 + 11;
  v19 = (unsigned __int8 *)(v33 + 11);
  if ( buffa )
  {
    v38 = v35;
    buffb = (unsigned __int8 *)v33;
    ptrb = v36;
    memcpy(v19, v36, v35);
    free(ptrb);
    v34 = (__int64)buffb;
    v19 = (unsigned __int8 *)(v37 + v38);
  }
  v39 = v19 + 4;
  if ( limit - (v19 + 4) < (__int64)optlen )
    return v10;
  v40 = (_WORD *)(v34 + 9);
  v12->arcount = __ROL2__(__ROL2__(v12->arcount, 8) + 1, 8);
LABEL_32:
  if ( optno )
  {
    if ( replace != 2 )
    {
      *(_DWORD *)v19 = BYTE1(optno) | (((unsigned __int8)optno | ((BYTE1(optlen) | ((unsigned __int8)optlen << 8)) << 8)) << 8);
      v41 = (char *)memcpy(v39, opt, optlen);
      v19 = (unsigned __int8 *)&v41[optlen];
      *v40 = __ROL2__((_WORD)v41 + optlen - (_WORD)rdlen, 8);
    }
  }
  return v19 - (unsigned __int8 *)v12;
}
