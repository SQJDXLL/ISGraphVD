int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s2
  unsigned __int8 *v19; // $fp
  unsigned __int8 *v20; // $fp
  unsigned int v21; // $v0
  __int16 v22; // $s4
  unsigned int v23; // $v0
  unsigned __int8 *v24; // $s6
  signed int v25; // $s7
  int v26; // $v0
  unsigned int v27; // $a0
  unsigned int v28; // $v0
  int v29; // $v1
  unsigned int v30; // $a1
  int v31; // $v0
  int v32; // $a0
  unsigned __int8 *v33; // $a1
  int v34; // $t3
  int j; // $a2
  unsigned int v36; // $a1
  unsigned int v37; // $a0
  int v38; // $a2
  unsigned int v39; // $a0
  unsigned int v40; // $v0
  int result; // $v0
  __int16 v42; // $s7
  int v43; // $a0
  _BYTE *v44; // $v0
  _BYTE *v45; // $t0
  char *v46; // $a3
  unsigned __int8 *v47; // $a0
  _BYTE *v48; // $fp
  signed int v49; // $v1
  unsigned __int8 *v50; // $s6
  unsigned __int8 *v51; // $v0
  int i; // [sp+24h] [-24h]
  int ia; // [sp+24h] [-24h]
  unsigned __int8 *p; // [sp+2Ch] [-1Ch]
  unsigned int v55; // [sp+30h] [-18h]
  unsigned int v56; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v42 = 0;
    v22 = (set_do != 0) << 15;
LABEL_24:
    v43 = skip_questions(header, v17);
    if ( v43 )
    {
      v44 = (_BYTE *)skip_section(
                       v43,
                       (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                     + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                     + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                       header,
                       v17);
      v45 = v44;
      if ( v44 )
      {
        v46 = v44 + 0xB;
        LOWORD(p) = (_WORD)v44 + 0xB;
        if ( limit >= v44 + 0xB )
        {
          *v44 = 0;
          v44[1] = 0;
          v44[2] = 41;
          v44[3] = HIBYTE(udp_sz);
          v44[4] = udp_sz;
          v44[5] = HIBYTE(v42);
          v44[6] = v42;
          v44[7] = HIBYTE(v22);
          v44[8] = v22;
          v44[9] = BYTE1(v18);
          v44[10] = v18;
          if ( !v19 )
          {
            v24 = v44 + 0xB;
            goto LABEL_30;
          }
          v24 = (unsigned __int8 *)&v46[v18];
          if ( limit >= (unsigned __int8 *)&v46[v18] )
          {
            ia = (int)v44;
            memcpy(v46, v19, v18);
            free(v19);
            v45 = (_BYTE *)ia;
LABEL_30:
            v47 = v24 + 4;
            result = v17;
            if ( limit - (v24 + 4) < (int)optlen )
              return result;
            v48 = v45 + 9;
            header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
            if ( !optno )
              return v24 - (unsigned __int8 *)header;
            goto LABEL_37;
          }
          free(v19);
        }
      }
    }
    return v17;
  }
  v20 = udp_len;
  v21 = (udp_len[5] << 8) | udp_len[4];
  v55 = (udp_len[1] << 8) | *udp_len;
  v56 = (udp_len[3] << 8) | udp_len[2];
  v22 = ((_WORD)v21 << 8) | (v21 >> 8);
  if ( set_do )
  {
    v22 |= 0x8000u;
    udp_len[4] = HIBYTE(v22);
    v20[5] = v22;
  }
  v23 = (v20[7] << 8) | v20[6];
  v24 = v20 + 8;
  v25 = (unsigned __int16)(((_WORD)v23 << 8) | (v23 >> 8));
  p = v20 + 8;
  if ( v17 < v20 + 8 - (unsigned __int8 *)header + v25 || !optno )
    return v17;
  v26 = is_last;
  if ( v25 >= 5 )
  {
    v27 = (v20[11] << 8) | v20[10];
    v28 = (v20[9] << 8) | v20[8];
    v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
    v30 = v28 >> 8;
    LOWORD(v27) = (_WORD)v28 << 8;
    v31 = v29 + 4;
    v32 = (unsigned __int16)(v27 | v30);
    v33 = v20 + 0xC;
    if ( v25 < v29 + 4 )
    {
LABEL_41:
      is_last = 0;
      v19 = 0;
LABEL_42:
      udp_sz = ((_WORD)v55 << 8) | (v55 >> 8);
      v42 = ((_WORD)v56 << 8) | (v56 >> 8);
      v17 = rrfilter(header, v17, 0);
      goto LABEL_24;
    }
    v34 = 0;
    if ( !replace )
    {
      v38 = 0;
      while ( v32 != optno )
      {
        v38 += v29 + 4;
        v24 = &v33[v29];
        if ( v38 + 4 >= v25 )
        {
          if ( !is_last )
            goto LABEL_44;
          v49 = optlen;
          goto LABEL_35;
        }
        v39 = (v24[3] << 8) | v24[2];
        v40 = (v24[1] << 8) | *v24;
        v29 = (unsigned __int16)(((_WORD)v39 << 8) | (v39 >> 8));
        v32 = (unsigned __int16)(((_WORD)v40 << 8) | (v40 >> 8));
        v33 = v24 + 4;
        if ( v25 < v29 + v38 + 4 )
          goto LABEL_41;
      }
      return v17;
    }
    for ( j = optno; ; j = optno )
    {
      if ( v32 == j )
      {
        v25 -= v31;
        i = v34;
        memcpy(v24, &v24[(unsigned __int16)(v29 + 4)], v25 - v34);
        v34 = i;
        v20[6] = BYTE1(v25);
        v20[7] = v25;
      }
      else
      {
        v24 = &v33[v29];
        v34 += v31;
      }
      if ( v34 + 4 >= v25 )
        break;
      v36 = (v24[3] << 8) | v24[2];
      v37 = (v24[1] << 8) | *v24;
      v29 = (unsigned __int16)(((_WORD)v36 << 8) | (v36 >> 8));
      v32 = (unsigned __int16)(((_WORD)v37 << 8) | (v37 >> 8));
      v33 = v24 + 4;
      if ( v25 < v29 + v34 + 4 )
        goto LABEL_41;
      v31 = v29 + 4;
    }
    v26 = is_last;
  }
  v49 = optlen;
  if ( !v26 )
  {
    v19 = 0;
    if ( v25 )
    {
LABEL_44:
      v51 = (unsigned __int8 *)whine_malloc(v25);
      v19 = v51;
      if ( v51 )
        memcpy(v51, p, v25);
      v18 = v25;
    }
    goto LABEL_42;
  }
LABEL_35:
  v47 = v24 + 4;
  result = v17;
  if ( limit - (v24 + 4) < v49 )
    return result;
  v48 = v20 + 6;
LABEL_37:
  result = v24 - (unsigned __int8 *)header;
  if ( replace != 2 )
  {
    if ( limit >= v47 )
    {
      *v24 = BYTE1(optno);
      v24[2] = BYTE1(optlen);
      v24[1] = optno;
      v24[3] = optlen;
      v50 = &v47[optlen];
      if ( limit >= &v47[optlen] )
      {
        memcpy(v47, opt, optlen);
        *v48 = (unsigned __int16)((_WORD)v50 - (_WORD)p) >> 8;
        v48[1] = (_BYTE)v50 - (_BYTE)p;
        return v50 - (unsigned __int8 *)header;
      }
    }
    return v17;
  }
  return result;
}
