size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s3
  unsigned __int8 *v19; // $fp
  unsigned __int8 *v20; // $fp
  unsigned int v21; // $v0
  __int16 v22; // $s4
  unsigned int v23; // $v0
  unsigned __int8 *v24; // $s6
  signed int v25; // $s7
  int v26; // $v0
  unsigned int v27; // $v0
  unsigned int v28; // $a0
  signed int v29; // $v1
  int v30; // $v0
  unsigned __int8 *v31; // $a1
  int v32; // $t3
  int j; // $a0
  unsigned int v34; // $a1
  unsigned int v35; // $a0
  int v36; // $v1
  int v37; // $a2
  unsigned int v38; // $v0
  unsigned int v39; // $a0
  size_t result; // $v0
  __int16 v41; // $s7
  int v42; // $a0
  _BYTE *v43; // $v0
  _BYTE *v44; // $t0
  _BYTE *v45; // $s4
  void *v46; // $a0
  _BYTE *v47; // $fp
  bool v48; // dc
  signed int v49; // $v0
  _BOOL4 v50; // $s1
  size_t v51; // $s6
  unsigned __int8 *v52; // $v0
  int i; // [sp+24h] [-24h]
  int ia; // [sp+24h] [-24h]
  unsigned __int8 *datap; // [sp+2Ch] [-1Ch]
  unsigned int v56; // [sp+30h] [-18h]
  unsigned int v57; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( pseudoheader )
  {
    v20 = udp_len;
    v21 = (udp_len[5] << 8) | udp_len[4];
    v57 = (udp_len[1] << 8) | *udp_len;
    v56 = (udp_len[3] << 8) | udp_len[2];
    v22 = ((_WORD)v21 << 8) | (v21 >> 8);
    if ( set_do )
    {
      v22 |= 0x8000u;
      udp_len[4] = HIBYTE(v22);
      v20[5] = v22;
    }
    v23 = (v20[7] << 8) | v20[6];
    v24 = v20 + 8;
    v25 = (unsigned __int16)(((_WORD)v23 << 8) | (v23 >> 8));
    datap = v20 + 8;
    if ( v17 < v20 + 8 - (unsigned __int8 *)header + v25 || !optno )
      return v17;
    v26 = is_last;
    if ( v25 >= 5 )
    {
      v27 = (v20[11] << 8) | v20[10];
      v28 = (v20[9] << 8) | v20[8];
      v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
      v30 = (unsigned __int16)(((_WORD)v28 << 8) | (v28 >> 8));
      v31 = v20 + 0xC;
      if ( v25 < v29 )
      {
LABEL_36:
        is_last = 0;
        v19 = 0;
LABEL_37:
        udp_sz = ((_WORD)v57 << 8) | (v57 >> 8);
        v41 = ((_WORD)v56 << 8) | (v56 >> 8);
        v17 = rrfilter(header, v17, 0);
        goto LABEL_24;
      }
      v32 = 0;
      if ( !replace )
      {
        v37 = 0;
        while ( v30 != optno )
        {
          v37 += v29 + 4;
          v24 = &v31[v29];
          if ( v37 + 4 >= v25 )
          {
            if ( !is_last )
              goto LABEL_39;
            v49 = optlen;
            goto LABEL_32;
          }
          v38 = (v24[3] << 8) | v24[2];
          v39 = (v24[1] << 8) | *v24;
          v29 = (unsigned __int16)(((_WORD)v38 << 8) | (v38 >> 8));
          v30 = (unsigned __int16)(((_WORD)v39 << 8) | (v39 >> 8));
          v31 = v24 + 4;
          if ( v25 < v29 + v37 )
            goto LABEL_36;
        }
        return v17;
      }
      for ( j = optno; ; j = optno )
      {
        if ( v30 == j )
        {
          v36 = v29 + 4;
          v25 -= v36;
          i = v32;
          memcpy(v24, &v24[v36], v25 - v32);
          v32 = i;
          v20[6] = BYTE1(v25);
          v20[7] = v25;
        }
        else
        {
          v24 = &v31[v29];
          v32 += v29 + 4;
        }
        v26 = is_last;
        if ( v32 + 4 >= v25 )
          break;
        v34 = (v24[3] << 8) | v24[2];
        v35 = (v24[1] << 8) | *v24;
        v29 = (unsigned __int16)(((_WORD)v34 << 8) | (v34 >> 8));
        v30 = (unsigned __int16)(((_WORD)v35 << 8) | (v35 >> 8));
        v31 = v24 + 4;
        if ( v25 < v29 + v32 )
          goto LABEL_36;
      }
    }
    v48 = v26 == 0;
    v49 = optlen;
    if ( !v48 )
    {
LABEL_32:
      v46 = v24 + 4;
      v50 = limit - (v24 + 4) < v49;
      result = v17;
      if ( !v50 )
      {
        v47 = v20 + 6;
LABEL_34:
        if ( replace != 2 )
        {
          *v24 = BYTE1(optno);
          v24[2] = BYTE1(optlen);
          v24[1] = optno;
          v24[3] = optlen;
          v51 = (size_t)v46 + optlen;
          memcpy(v46, opt, optlen);
          *v47 = (unsigned __int16)(v51 - (_WORD)datap) >> 8;
          v47[1] = v51 - (_BYTE)datap;
          return v51 - (_DWORD)header;
        }
        return v24 - (unsigned __int8 *)header;
      }
      return result;
    }
    v19 = 0;
    if ( v25 )
    {
LABEL_39:
      v52 = (unsigned __int8 *)whine_malloc(v25);
      v19 = v52;
      if ( v52 )
        memcpy(v52, datap, v25);
      v18 = v25;
    }
    goto LABEL_37;
  }
  v41 = 0;
  v22 = (set_do != 0) << 15;
LABEL_24:
  v42 = skip_questions(header, v17);
  if ( !v42 )
    return v17;
  v43 = (_BYTE *)skip_section(
                   v42,
                   (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                 + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                 + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                   header,
                   v17);
  v44 = v43;
  if ( !v43 )
    return v17;
  v43[9] = BYTE1(v18);
  v43[8] = v22;
  *v43 = 0;
  v43[1] = 0;
  v43[2] = 41;
  v43[3] = HIBYTE(udp_sz);
  v43[4] = udp_sz;
  v43[5] = HIBYTE(v41);
  v43[6] = v41;
  v43[7] = HIBYTE(v22);
  v43[10] = v18;
  v45 = v43 + 0xB;
  LOWORD(datap) = (_WORD)v43 + 0xB;
  if ( v19 )
  {
    ia = (int)v43;
    memcpy(v43 + 0xB, v19, v18);
    v24 = &v45[v18];
    free(v19);
    v44 = (_BYTE *)ia;
  }
  else
  {
    v24 = v43 + 0xB;
  }
  v46 = v24 + 4;
  result = v17;
  if ( limit - (v24 + 4) >= (int)optlen )
  {
    v47 = v44 + 9;
    header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
    if ( !optno )
      return v24 - (unsigned __int8 *)header;
    goto LABEL_34;
  }
  return result;
}
