size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  __int64 v9; // r13
  unsigned __int8 *pseudoheader; // r12
  unsigned __int8 *v13; // r12
  unsigned __int16 v14; // ax
  int v15; // ebp
  __int64 v16; // rbx
  unsigned __int16 v17; // dx
  unsigned __int16 v18; // ax
  unsigned __int8 *v19; // rdi
  int v20; // ecx
  int v21; // r15d
  __int16 v22; // r15
  void *v23; // r15
  _BYTE *v24; // r12
  unsigned __int8 *v26; // rax
  __int16 v27; // ax
  __int64 v28; // rdi
  _BYTE *v29; // rax
  _BYTE *v30; // rbp
  int rdlen; // [rsp+14h] [rbp-74h]
  unsigned __int8 *p; // [rsp+20h] [rbp-68h]
  unsigned __int16 flags; // [rsp+28h] [rbp-60h]
  __int16 v37; // [rsp+2Ah] [rbp-5Eh]
  __int16 v38; // [rsp+2Ch] [rbp-5Ch]
  unsigned __int8 v39; // [rsp+2Eh] [rbp-5Ah]
  unsigned __int8 v40; // [rsp+2Fh] [rbp-59h]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  v9 = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  rdlen = is_sign;
  if ( is_sign )
    return v9;
  if ( pseudoheader )
  {
    v13 = udp_len[0];
    LOBYTE(v37) = *udp_len[0];
    v39 = udp_len[0][1];
    LOBYTE(v38) = udp_len[0][2];
    v40 = udp_len[0][3];
    v14 = _byteswap_ushort(*((_WORD *)udp_len[0] + 2));
    if ( set_do )
    {
      flags = v14 | 0x8000;
      udp_len[0][4] = (unsigned __int16)(v14 | 0x8000) >> 8;
      v13[5] = v14;
    }
    else
    {
      flags = v14;
    }
    v15 = v13[7] | (v13[6] << 8);
    v16 = (__int64)(v13 + 8);
    p = v13 + 8;
    if ( plen < v15 + v13 + 8 - (unsigned __int8 *)header || !optno )
      return v9;
    if ( v15 <= 4 )
    {
      if ( is_last )
      {
        v16 = (__int64)(v13 + 8);
LABEL_20:
        v23 = (void *)(v16 + 4);
        if ( (__int64)&limit[-v16 - 4] < (__int64)optlen )
          return v9;
        v24 = v13 + 6;
        goto LABEL_22;
      }
    }
    else
    {
      v17 = _byteswap_ushort(*((_WORD *)v13 + 4));
      v18 = _byteswap_ushort(*((_WORD *)v13 + 5));
      v19 = v13 + 12;
      v20 = v18;
      if ( v15 < v18 )
      {
LABEL_11:
        is_last = 0;
        pseudoheader = 0LL;
LABEL_12:
        udp_sz = v39 | (unsigned __int16)(v37 << 8);
        v22 = v40 | (unsigned __int16)(v38 << 8);
        v9 = rrfilter(header, plen, 0LL);
        goto LABEL_32;
      }
      v21 = 0;
      while ( 1 )
      {
        if ( v17 == optno )
        {
          if ( !replace )
            return v9;
          v15 -= v20 + 4;
          memcpy((void *)v16, (const void *)(v16 + v18 + 4), v15 - v21);
          v13[6] = BYTE1(v15);
          v13[7] = v15;
        }
        else
        {
          v16 = (__int64)&v19[v18];
          v21 += v20 + 4;
        }
        if ( v21 + 4 >= v15 )
          break;
        v17 = _byteswap_ushort(*(_WORD *)v16);
        v18 = _byteswap_ushort(*(_WORD *)(v16 + 2));
        v19 = (unsigned __int8 *)(v16 + 4);
        v20 = v18;
        if ( v18 + v21 > v15 )
          goto LABEL_11;
      }
      if ( is_last )
        goto LABEL_20;
    }
    if ( v15 )
    {
      v26 = (unsigned __int8 *)whine_malloc(v15);
      pseudoheader = v26;
      rdlen = v15;
      if ( v26 )
      {
        memcpy(v26, p, v15);
        rdlen = v15;
      }
    }
    else
    {
      rdlen = 0;
      pseudoheader = 0LL;
    }
    goto LABEL_12;
  }
  flags = (set_do != 0) << 15;
  v22 = 0;
LABEL_32:
  v28 = skip_questions(header, v9);
  if ( v28 )
  {
    v29 = (_BYTE *)skip_section(
                     v28,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8)
                   + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8),
                     header,
                     v9);
    v30 = v29;
    if ( v29 )
    {
      *v29 = 0;
      v29[1] = 0;
      v29[2] = 41;
      v29[3] = HIBYTE(udp_sz);
      v29[4] = udp_sz;
      v29[5] = HIBYTE(v22);
      v29[6] = v22;
      v29[7] = HIBYTE(flags);
      v29[8] = flags;
      v29[9] = BYTE1(rdlen);
      v29[10] = rdlen;
      LOWORD(p) = (_WORD)v29 + 11;
      v16 = (__int64)(v29 + 11);
      if ( pseudoheader )
      {
        memcpy(v29 + 11, pseudoheader, rdlen);
        free(pseudoheader);
        v16 = (__int64)&v30[rdlen + 11];
      }
      v23 = (void *)(v16 + 4);
      if ( (__int64)&limit[-v16 - 4] >= (__int64)optlen )
      {
        v24 = v30 + 9;
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_22:
        if ( optno && replace != 2 )
        {
          *(_BYTE *)v16 = BYTE1(optno);
          *(_BYTE *)(v16 + 1) = optno;
          *(_BYTE *)(v16 + 2) = BYTE1(optlen);
          *(_BYTE *)(v16 + 3) = optlen;
          memcpy(v23, opt, optlen);
          v16 = (__int64)v23 + optlen;
          v27 = optlen + (_WORD)v23 - (_WORD)p;
          *v24 = HIBYTE(v27);
          v24[1] = v27;
        }
        return v16 - (_QWORD)header;
      }
    }
  }
  return v9;
}
