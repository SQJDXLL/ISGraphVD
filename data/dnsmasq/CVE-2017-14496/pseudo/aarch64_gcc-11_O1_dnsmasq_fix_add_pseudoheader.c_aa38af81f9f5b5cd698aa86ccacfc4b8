size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // x24
  unsigned __int8 *pseudoheader; // x0
  unsigned __int8 *v15; // x4
  int v16; // w27
  unsigned __int8 *v17; // x21
  unsigned __int8 *v18; // x21
  __int16 v19; // w28
  __int64 v20; // x3
  __int16 v21; // w2
  __int16 v22; // w1
  unsigned __int16 v23; // w26
  int v24; // w20
  unsigned __int8 *v25; // x19
  unsigned __int64 v26; // x0
  bool v27; // cc
  int v29; // w2
  unsigned int v30; // w1
  int v31; // w22
  unsigned __int64 v32; // x0
  _BYTE *v33; // x21
  bool v34; // zf
  void *v35; // x0
  unsigned __int8 *v36; // x0
  __int64 v37; // x0
  _BYTE *v38; // x0
  _BYTE *v39; // x20
  unsigned __int8 *p; // [xsp+80h] [xbp+80h]
  __int16 rcode; // [xsp+8Ch] [xbp+8Ch]
  int is_sign; // [xsp+98h] [xbp+98h] BYREF
  int is_last; // [xsp+9Ch] [xbp+9Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+A0h] [xbp+A0h] BYREF

  v10 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v10;
  v17 = pseudoheader;
  if ( !pseudoheader )
  {
    v23 = (set_do != 0) << 15;
    rcode = 0;
    goto LABEL_50;
  }
  v18 = udp_len;
  v19 = *udp_len;
  v20 = udp_len[1];
  v21 = udp_len[2];
  v22 = udp_len[3];
  v23 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  if ( set_do )
  {
    v23 |= 0x8000u;
    udp_len[4] = HIBYTE(v23);
    v18[5] = v23;
  }
  v24 = v18[7] | (v18[6] << 8);
  v25 = v18 + 8;
  p = v18 + 8;
  v26 = v18 + 8 - (unsigned __int8 *)header + _byteswap_ushort(*((_WORD *)v18 + 3));
  if ( optno )
    v27 = v26 > v10;
  else
    v27 = 1;
  if ( v27 )
    return v10;
  udp_sz = v20 | (v19 << 8);
  rcode = v22 | (v21 << 8);
  if ( v24 <= 4 )
  {
    if ( is_last )
    {
      v25 = v18 + 8;
      goto LABEL_24;
    }
LABEL_33:
    if ( v24 )
    {
      v36 = (unsigned __int8 *)whine_malloc(v24);
      v17 = v36;
      v16 = v24;
      if ( v36 )
        memcpy(v36, p, v24);
    }
    else
    {
      v16 = 0;
      v17 = 0LL;
    }
    goto LABEL_15;
  }
  v29 = v18[9] | (v18[8] << 8);
  v30 = v18[11] | (v18[10] << 8);
  v15 = v18 + 0xC;
  v20 = v30;
  if ( v24 >= (int)(v30 + 4) )
  {
    v31 = 0;
    while ( 1 )
    {
      if ( v29 == optno )
      {
        if ( !replace )
          return v10;
        v24 -= v20 + 4;
        memcpy(v25, &v25[(unsigned __int16)v30 + 4], v24 - v31);
        v18[6] = BYTE1(v24);
        v18[7] = v24;
      }
      else
      {
        v25 = &v15[(unsigned __int16)v30];
        v20 = (unsigned int)(v20 + 4);
        v31 += v20;
      }
      if ( v31 + 4 >= v24 )
        break;
      v29 = v25[1] | (*v25 << 8);
      v30 = v25[3] | (v25[2] << 8);
      v15 = v25 + 4;
      v20 = v30;
      if ( (int)(v30 + v31 + 4) > v24 )
        goto LABEL_14;
    }
    if ( is_last )
    {
      if ( v25 )
      {
LABEL_24:
        v32 = (unsigned __int64)(v25 + 4);
        if ( limit - (v25 + 4) < (__int64)optlen )
          return v10;
        v33 = v18 + 6;
        goto LABEL_26;
      }
      v16 = v24;
      v17 = 0LL;
      goto LABEL_50;
    }
    goto LABEL_33;
  }
LABEL_14:
  is_last = 0;
  v17 = 0LL;
LABEL_15:
  v10 = rrfilter(header, v10, 0LL, v20, v15);
LABEL_50:
  v37 = skip_questions(header, v10);
  if ( v37 )
  {
    v38 = (_BYTE *)skip_section(
                     v37,
                     (unsigned __int16)__rev16(header->nscount)
                   + (unsigned __int16)__rev16(header->ancount)
                   + (unsigned int)(unsigned __int16)__rev16(header->arcount),
                     header,
                     v10);
    v39 = v38;
    if ( v38 )
    {
      if ( limit >= v38 + 0xB )
      {
        *v38 = 0;
        v38[1] = 0;
        v38[2] = 41;
        v38[3] = HIBYTE(udp_sz);
        v38[4] = udp_sz;
        v38[5] = HIBYTE(rcode);
        v38[6] = rcode;
        v38[7] = HIBYTE(v23);
        v38[8] = v23;
        v38[9] = BYTE1(v16);
        v38[10] = v16;
        p = v38 + 0xB;
        if ( v17 )
        {
          v25 = &v38[v16 + 0xB];
          if ( v25 > limit )
          {
            free(v17);
            return v10;
          }
          memcpy(p, v17, v16);
          free(v17);
        }
        else
        {
          v25 = v38 + 0xB;
        }
        v32 = (unsigned __int64)(v25 + 4);
        if ( limit - (v25 + 4) < (__int64)optlen )
          return v10;
        v33 = v39 + 9;
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_26:
        if ( optno )
          v34 = replace == 2;
        else
          v34 = 1;
        if ( !v34 )
        {
          if ( (unsigned __int64)limit < v32 )
            return v10;
          *v25 = BYTE1(optno);
          v25[1] = optno;
          v25[2] = BYTE1(optlen);
          v25[3] = optlen;
          v35 = v25 + 4;
          v25 += optlen + 4;
          if ( v25 > limit )
            return v10;
          memcpy(v35, opt, optlen);
          *v33 = (unsigned __int16)((_WORD)v25 - (_WORD)p) >> 8;
          v33[1] = (_BYTE)v25 - (_BYTE)p;
        }
        return v25 - (unsigned __int8 *)header;
      }
    }
  }
  return v10;
}
