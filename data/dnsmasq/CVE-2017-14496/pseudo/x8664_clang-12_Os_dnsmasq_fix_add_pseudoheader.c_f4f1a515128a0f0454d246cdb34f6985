size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // rax
  __int64 v14; // rdx
  size_t v15; // r15
  int v17; // ebx
  __int16 v18; // si
  unsigned __int8 *v19; // rbp
  __int16 v20; // bx
  int v21; // r8d
  dns_header *v22; // r14
  unsigned __int64 v23; // rdx
  char *v24; // rbx
  int v25; // r13d
  int v26; // ecx
  unsigned __int64 v27; // rax
  _BYTE *v28; // rsi
  int v29; // r12d
  _WORD *v30; // rbp
  signed __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  char *v33; // r12
  void *v34; // r12
  size_t v35; // rbp
  void *v36; // rax
  __int64 v37; // rax
  __m128i v38; // xmm0
  __m128i v39; // xmm0
  __int64 v40; // rax
  __int64 v41; // rbp
  int v42; // eax
  char *v43; // rdi
  __int16 v44; // [rsp+Ch] [rbp-7Ch]
  __int16 v45; // [rsp+Ch] [rbp-7Ch]
  int v46; // [rsp+10h] [rbp-78h]
  __int16 v47; // [rsp+14h] [rbp-74h]
  void *ptr; // [rsp+18h] [rbp-70h]
  __int16 v49; // [rsp+20h] [rbp-68h]
  int is_last; // [rsp+24h] [rbp-64h] BYREF
  unsigned __int8 *v51; // [rsp+28h] [rbp-60h]
  unsigned __int64 v52; // [rsp+30h] [rbp-58h]
  void *src; // [rsp+38h] [rbp-50h]
  void *v54; // [rsp+40h] [rbp-48h]
  unsigned __int8 *v55; // [rsp+48h] [rbp-40h] BYREF
  int is_sign[13]; // [rsp+54h] [rbp-34h] BYREF

  v52 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v55, is_sign, &is_last);
  if ( is_sign[0] )
    return v52;
  v54 = opt;
  v51 = limit;
  v17 = 0;
  v46 = optno;
  HIBYTE(v18) = 0;
  LOBYTE(v14) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v18) = set_do != 0;
    v49 = v18 << 15;
    ptr = 0LL;
    v45 = 0;
    v22 = header;
    v15 = v52;
    goto LABEL_27;
  }
  v19 = v55;
  v20 = __ROL2__(*((_WORD *)v55 + 2), 8);
  if ( set_do )
  {
    v20 |= 0x8000u;
    v55[4] = HIBYTE(v20);
  }
  v21 = optno;
  v22 = header;
  v15 = v52;
  if ( !optno )
    return v15;
  v23 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v19 + 3) << 48);
  if ( v23 + v19 + 8 - (unsigned __int8 *)header > v52 )
    return v15;
  v44 = *((_WORD *)v19 + 1);
  v49 = v20;
  v47 = *(_WORD *)v19;
  src = v19 + 8;
  v24 = (char *)(v19 + 8);
  if ( (unsigned int)v23 >= 5 )
  {
    v25 = 0;
    v26 = 4;
    while ( 1 )
    {
      v27 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v24 + 1) << 48);
      if ( (int)v27 + v26 > (int)v23 )
        break;
      v28 = v24 + 4;
      if ( _byteswap_ulong(*(unsigned __int16 *)v24 << 16) == v21 )
      {
        if ( !replace )
          return v15;
        v29 = v23 - v27 - 4;
        memcpy(v24, &v28[v27], v29 - v25);
        LODWORD(v23) = v29;
        v21 = v46;
        *((_WORD *)v19 + 3) = __ROL2__(v29, 8);
      }
      else
      {
        v25 += v27 + 4;
        v24 = &v28[(unsigned int)v27];
      }
      v26 = v25 + 4;
      if ( v25 + 4 >= (int)v23 )
        goto LABEL_17;
    }
    is_last = 0;
    goto LABEL_24;
  }
LABEL_17:
  if ( !is_last )
  {
    v34 = src;
    if ( (_DWORD)v23 )
    {
      v17 = v23;
      v35 = (int)v23;
      v36 = (void *)whine_malloc((int)v23);
      if ( v36 )
      {
        ptr = v36;
        memcpy(v36, v34, v35);
LABEL_26:
        udp_sz = __ROL2__(v47, 8);
        v45 = __ROL2__(v44, 8);
        v15 = rrfilter(header, v15, 0LL);
LABEL_27:
        v37 = skip_questions(v22, v15, v14);
        if ( !v37 )
          return v15;
        v38 = _mm_cvtsi32_si128(*(_DWORD *)&v22->ancount);
        v39 = _mm_or_si128(_mm_slli_epi16(v38, 8u), _mm_srli_epi16(v38, 8u));
        v40 = skip_section(
                v37,
                _mm_cvtsi128_si32(_mm_add_epi32(_mm_srli_epi32(v39, 0x10u), _mm_unpacklo_epi16(v39, (__m128i)0LL)))
              + (unsigned int)(unsigned __int16)__ROL2__(v22->arcount, 8),
                v22,
                v15);
        if ( !v40 )
          return v15;
        v41 = v40;
        v33 = (char *)(v40 + 11);
        v32 = (unsigned __int64)v51;
        if ( v40 + 11 > (unsigned __int64)v51 )
          return v15;
        *(_WORD *)v40 = 0;
        *(_BYTE *)(v40 + 2) = 41;
        *(_BYTE *)(v40 + 3) = HIBYTE(udp_sz);
        *(_BYTE *)(v40 + 4) = udp_sz;
        *(_BYTE *)(v40 + 5) = HIBYTE(v45);
        *(_BYTE *)(v40 + 6) = v45;
        *(_BYTE *)(v40 + 7) = HIBYTE(v49);
        *(_BYTE *)(v40 + 8) = v49;
        v42 = v17;
        *(_BYTE *)(v41 + 9) = BYTE1(v17);
        *(_BYTE *)(v41 + 10) = v17;
        v24 = v33;
        if ( ptr )
        {
          v24 = &v33[v42];
          if ( (unsigned __int64)v24 > v32 )
          {
            free(ptr);
            return v15;
          }
          memcpy(v33, ptr, v42);
          free(ptr);
          v32 = (unsigned __int64)v51;
        }
        v30 = (_WORD *)(v41 + 9);
        v31 = optlen;
        if ( (__int64)(v32 - (_QWORD)v24 - 4) >= (__int64)optlen )
          v22->arcount = __ROL2__(__ROL2__(v22->arcount, 8) + 1, 8);
        v21 = v46;
        goto LABEL_37;
      }
LABEL_25:
      ptr = 0LL;
      goto LABEL_26;
    }
LABEL_24:
    v17 = 0;
    goto LABEL_25;
  }
  v30 = v19 + 6;
  v31 = optlen;
  v32 = (unsigned __int64)v51;
  LOWORD(v33) = (_WORD)src;
LABEL_37:
  v43 = v24 + 4;
  if ( (__int64)(v32 - (_QWORD)(v24 + 4)) < v31 )
    return v15;
  if ( !v21 || replace == 2 )
    return v24 - (char *)v22;
  if ( (unsigned __int64)v43 <= v32 )
  {
    *v24 = BYTE1(v21);
    v24[1] = v21;
    v24[2] = BYTE1(v31);
    v24[3] = v31;
    v24 = &v43[v31];
    if ( (unsigned __int64)&v43[v31] <= v32 )
    {
      memcpy(v43, v54, v31);
      *v30 = __ROL2__((_WORD)v24 - (_WORD)v33, 8);
      return v24 - (char *)v22;
    }
  }
  return v15;
}
