size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *ptr; // ebp
  unsigned __int8 *v10; // ebp
  __int16 v11; // si
  unsigned __int8 v12; // bl
  __int16 v13; // cx
  unsigned __int16 v14; // ax
  int v15; // edi
  unsigned __int16 v16; // dx
  unsigned __int16 v17; // ax
  int v18; // ebx
  unsigned __int8 *v19; // esi
  int v20; // ebp
  unsigned __int8 *v21; // eax
  _BYTE *v22; // ebp
  unsigned __int8 *v24; // eax
  int v25; // ebx
  _BYTE *v26; // eax
  _BYTE *v27; // edi
  _BYTE *v28; // edx
  unsigned __int8 v29; // [esp+18h] [ebp-54h]
  unsigned __int8 *v30; // [esp+18h] [ebp-54h]
  size_t rdlen; // [esp+28h] [ebp-44h]
  unsigned __int8 *v33; // [esp+34h] [ebp-38h]
  unsigned __int8 *p; // [esp+38h] [ebp-34h]
  unsigned __int16 flags; // [esp+3Ch] [ebp-30h]
  unsigned __int16 rcode; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  ptr = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !ptr )
  {
    flags = (set_do != 0) << 15;
    rcode = 0;
LABEL_38:
    v25 = skip_questions(header, plen);
    if ( !v25 )
      return plen;
    v26 = (_BYTE *)skip_section(
                     v25,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->ancount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8),
                     header,
                     plen);
    v27 = v26;
    if ( !v26 )
      return plen;
    v28 = v26 + 11;
    p = v26 + 11;
    if ( limit < v26 + 11 )
      return plen;
    *v26 = 0;
    v26[1] = 0;
    v26[2] = 41;
    v26[3] = HIBYTE(udp_sz);
    v26[4] = udp_sz;
    v26[5] = HIBYTE(rcode);
    v26[6] = rcode;
    v26[7] = HIBYTE(flags);
    v26[8] = flags;
    v26[9] = BYTE1(rdlen);
    v26[10] = rdlen;
    if ( ptr )
    {
      v19 = &v28[rdlen];
      if ( limit < &v28[rdlen] )
      {
        free(ptr);
        return plen;
      }
      memcpy(p, ptr, rdlen);
      free(ptr);
    }
    else
    {
      v19 = v26 + 11;
    }
    v21 = v19 + 4;
    if ( limit - (v19 + 4) < (int)optlen )
      return plen;
    v22 = v27 + 9;
    header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    goto LABEL_23;
  }
  v10 = t_cp;
  v11 = *t_cp;
  v12 = t_cp[1];
  v13 = t_cp[2];
  v29 = t_cp[3];
  v14 = _byteswap_ushort(*((_WORD *)t_cp + 2));
  if ( set_do )
  {
    flags = v14 | 0x8000;
    t_cp[4] = (unsigned __int16)(v14 | 0x8000) >> 8;
    v10[5] = v14;
  }
  else
  {
    flags = v14;
  }
  v15 = (v10[6] << 8) | v10[7];
  p = v10 + 8;
  if ( plen < v15 + v10 + 8 - (unsigned __int8 *)header || !optno )
    return plen;
  udp_sz = v12 | (unsigned __int16)(v11 << 8);
  rcode = v29 | (unsigned __int16)(v13 << 8);
  if ( v15 <= 4 )
  {
    if ( is_last[0] )
    {
      v19 = v10 + 8;
      goto LABEL_21;
    }
    goto LABEL_30;
  }
  v16 = _byteswap_ushort(*((_WORD *)v10 + 4));
  v17 = _byteswap_ushort(*((_WORD *)v10 + 5));
  v30 = v10 + 12;
  v18 = v17;
  if ( v15 < v17 + 4 )
  {
LABEL_11:
    is_last[0] = 0;
    ptr = 0;
LABEL_12:
    plen = rrfilter(header, plen, 0);
    goto LABEL_38;
  }
  v19 = v10 + 8;
  v33 = v10;
  v20 = 0;
  while ( 1 )
  {
    if ( v16 == optno )
    {
      if ( !replace )
        return plen;
      v15 -= v18 + 4;
      memcpy(v19, &v19[v17 + 4], v15 - v20);
      v33[6] = BYTE1(v15);
      v33[7] = v15;
    }
    else
    {
      v19 = &v30[v17];
      v20 += v18 + 4;
    }
    if ( v20 + 4 >= v15 )
      break;
    v16 = _byteswap_ushort(*(_WORD *)v19);
    v17 = _byteswap_ushort(*((_WORD *)v19 + 1));
    v30 = v19 + 4;
    v18 = v17;
    if ( v17 + v20 + 4 > v15 )
      goto LABEL_11;
  }
  v10 = v33;
  if ( !is_last[0] )
  {
LABEL_30:
    if ( v15 )
    {
      v24 = (unsigned __int8 *)whine_malloc(v15);
      ptr = v24;
      rdlen = v15;
      if ( v24 )
      {
        memcpy(v24, p, v15);
        rdlen = v15;
      }
    }
    else
    {
      rdlen = 0;
      ptr = 0;
    }
    goto LABEL_12;
  }
  if ( !v19 )
  {
    rdlen = v15;
    ptr = 0;
    goto LABEL_38;
  }
LABEL_21:
  v21 = v19 + 4;
  if ( limit - (v19 + 4) < (int)optlen )
    return plen;
  v22 = v10 + 6;
LABEL_23:
  if ( !optno || replace == 2 )
    return v19 - (unsigned __int8 *)header;
  if ( limit >= v21 )
  {
    *v19 = BYTE1(optno);
    v19[1] = optno;
    v19[2] = BYTE1(optlen);
    v19[3] = optlen;
    v19 = &v21[optlen];
    if ( limit >= &v21[optlen] )
    {
      memcpy(v21, opt, optlen);
      *v22 = (unsigned __int16)((_WORD)v19 - (_WORD)p) >> 8;
      v22[1] = (_BYTE)v19 - (_BYTE)p;
      return v19 - (unsigned __int8 *)header;
    }
  }
  return plen;
}
