int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        signed int optlen,
        int set_do,
        int replace)
{
  size_t v9; // esi
  unsigned __int8 *pseudoheader; // eax
  unsigned __int8 *v11; // edx
  __int16 v13; // bx
  unsigned __int8 *v14; // edx
  __int16 v15; // ax
  __int16 v16; // bx
  signed int v17; // esi
  unsigned __int16 *v18; // ebp
  int v19; // edi
  unsigned __int32 v20; // eax
  unsigned __int16 *v21; // ebx
  unsigned __int8 *v22; // ebx
  char v23; // cl
  int v24; // eax
  signed int v25; // eax
  char *v26; // edi
  signed int v27; // ebx
  unsigned __int8 *v28; // esi
  unsigned __int16 *v29; // edi
  int v30; // eax
  int v31; // edi
  char *v32; // ebx
  __uint16_t v33; // ax
  int v34; // eax
  int v35; // edx
  int v36; // edi
  unsigned __int8 *v37; // edi
  void *v38; // ecx
  void *v39; // eax
  void *v40; // ebp
  unsigned __int8 *v41; // edi
  __uint16_t v42; // ax
  u16 v43; // ax
  _BYTE *v44; // [esp-Ch] [ebp-48h]
  size_t n; // [esp+8h] [ebp-34h]
  __int16 v46; // [esp+Eh] [ebp-2Eh]
  void *src; // [esp+10h] [ebp-2Ch]
  __int16 v49; // [esp+14h] [ebp-28h]
  __int16 v50; // [esp+14h] [ebp-28h]
  int v51; // [esp+14h] [ebp-28h]
  void *v52; // [esp+18h] [ebp-24h]
  void *v53; // [esp+18h] [ebp-24h]
  __int16 v54; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v57; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0, &v57, &is_sign, &is_last);
  if ( is_sign )
    return v9;
  HIBYTE(v13) = 0;
  LOBYTE(v11) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    v54 = v13 << 15;
    v50 = 0;
    n = 0;
    src = 0;
    v21 = 0;
    goto LABEL_23;
  }
  v14 = v57;
  v15 = *(_WORD *)v57;
  v49 = *((_WORD *)v57 + 1);
  v16 = __ROL2__(*((_WORD *)v57 + 2), 8);
  if ( set_do )
  {
    v16 |= 0x8000u;
    v57[4] = HIBYTE(v16);
  }
  v17 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
  v18 = (unsigned __int16 *)(v14 + 8);
  src = 0;
  v54 = v16;
  v52 = v14 + 8;
  v46 = v15;
  if ( !optno || v17 + (char *)v18 - (char *)header > plen )
  {
    n = v17;
    v23 = 0;
    goto LABEL_20;
  }
  if ( (unsigned int)v17 < 5 )
  {
LABEL_19:
    n = v17;
    v23 = 1;
    if ( !is_last )
    {
      v37 = v14;
      v21 = 0;
      v38 = 0;
      if ( v17 )
      {
        v39 = (void *)whine_malloc(v17);
        v38 = 0;
        if ( v39 )
        {
          v40 = v39;
          memcpy(v39, v52, v17);
          v38 = v40;
        }
      }
      src = v38;
      v24 = rrfilter(header, plen, 0);
      v14 = v37;
      goto LABEL_22;
    }
LABEL_20:
    v21 = v18;
    goto LABEL_21;
  }
  v19 = 0;
  while ( 1 )
  {
    v20 = _byteswap_ulong(v18[1] << 16);
    v21 = v18 + 2;
    n = v17;
    if ( (int)(v20 + v19) > v17 )
    {
      is_last = 0;
      v18 += 2;
      v17 = 0;
      goto LABEL_19;
    }
    if ( _byteswap_ulong(*v18 << 16) == optno )
      break;
    v19 += v20 + 4;
    v18 = (unsigned __int16 *)((char *)v21 + v20);
LABEL_11:
    if ( v19 + 4 >= v17 )
      goto LABEL_19;
  }
  if ( replace )
  {
    v17 = v17 - v20 - 4;
    v44 = (char *)v21 + v20;
    v22 = v14;
    memcpy(v18, v44, n - v20 - 4 - v19);
    v14 = v22;
    *((_WORD *)v22 + 3) = __ROL2__(v17, 8);
    goto LABEL_11;
  }
  v23 = 0;
  src = 0;
LABEL_21:
  v9 = plen;
  v24 = plen;
  if ( v23 )
  {
LABEL_22:
    udp_sz = __ROL2__(v46, 8);
    v50 = __ROL2__(v49, 8);
    v11 = v14 + 6;
    v9 = v24;
LABEL_23:
    v25 = optlen;
    if ( v21 )
    {
LABEL_24:
      v26 = (char *)(v21 + 2);
      if ( limit - (unsigned __int8 *)(v21 + 2) >= v25 )
      {
        if ( optno && replace != 2 )
        {
          *(_BYTE *)v21 = BYTE1(optno);
          *((_BYTE *)v21 + 1) = optno;
          *((_BYTE *)v21 + 2) = BYTE1(v25);
          *((_BYTE *)v21 + 3) = v25;
          v27 = v25;
          v28 = v11;
          memcpy(v26, opt, v25);
          v29 = (unsigned __int16 *)&v26[v27];
          *(_WORD *)v28 = __ROL2__((_WORD)v29 - (_WORD)v52, 8);
          v21 = v29;
        }
        return (char *)v21 - (char *)header;
      }
    }
    else
    {
      v30 = skip_questions(header, v9);
      if ( v30 )
      {
        v31 = v30;
        v53 = (void *)_bswap_16(header->ancount);
        v32 = (char *)v53 + _bswap_16(header->nscount);
        v33 = _bswap_16(header->arcount);
        v34 = skip_section(v31, &v32[v33], header, v9);
        if ( v34 )
        {
          v35 = v34;
          *(_WORD *)v34 = 0;
          *(_BYTE *)(v34 + 2) = 41;
          *(_BYTE *)(v34 + 3) = HIBYTE(udp_sz);
          *(_BYTE *)(v34 + 4) = udp_sz;
          *(_BYTE *)(v34 + 5) = HIBYTE(v50);
          *(_BYTE *)(v34 + 6) = v50;
          *(_BYTE *)(v34 + 7) = HIBYTE(v54);
          *(_BYTE *)(v34 + 8) = v54;
          *(_BYTE *)(v34 + 9) = BYTE1(n);
          *(_BYTE *)(v34 + 10) = n;
          v36 = v34 + 11;
          v21 = (unsigned __int16 *)(v34 + 11);
          if ( src )
          {
            v51 = v34;
            memcpy((void *)(v34 + 11), src, n);
            free(src);
            v35 = v51;
            v21 = (unsigned __int16 *)(v36 + n);
          }
          LOWORD(v52) = v36;
          v11 = (unsigned __int8 *)(v35 + 9);
          if ( limit - (unsigned __int8 *)v21 - 4 >= optlen )
          {
            v41 = v11;
            v42 = _bswap_16(header->arcount);
            v43 = _bswap_16(v42 + 1);
            v11 = v41;
            header->arcount = v43;
          }
          v25 = optlen;
          goto LABEL_24;
        }
      }
    }
  }
  return v9;
}
