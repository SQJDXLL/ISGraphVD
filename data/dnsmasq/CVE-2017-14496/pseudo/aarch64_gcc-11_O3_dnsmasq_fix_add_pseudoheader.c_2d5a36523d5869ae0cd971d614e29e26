size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  uint32x2_t v9; // d8
  unsigned __int64 v11; // x19
  unsigned __int32 v15; // w25
  unsigned __int8 *pseudoheader; // x0
  int v18; // w27
  unsigned __int8 *v19; // x5
  unsigned __int16 *v20; // x24
  int v21; // w0
  unsigned __int16 *v22; // x25
  unsigned __int16 v23; // w0
  signed int v24; // w26
  unsigned __int64 v25; // x0
  bool v26; // cc
  unsigned __int16 *v27; // x2
  int v28; // w3
  int v29; // w1
  int v30; // w0
  int v31; // w21
  int v32; // w8
  unsigned int v33; // w0
  size_t v34; // x3
  __int64 v36; // x0
  __int64 v37; // x0
  uint32x2_t v38; // d0
  uint32x2_t v39; // d1
  __int64 v40; // x21
  char *v41; // x7
  __int64 v42; // d0
  unsigned __int8 *v43; // x0
  _WORD *v44; // x21
  bool v45; // zf
  unsigned __int8 *v46; // x5
  unsigned __int8 *v47; // x0
  int t_s; // [xsp+78h] [xbp+78h]
  unsigned __int8 *p; // [xsp+80h] [xbp+80h]
  unsigned __int8 *pa; // [xsp+80h] [xbp+80h]
  unsigned __int16 buff; // [xsp+88h] [xbp+88h]
  unsigned __int8 *buffa; // [xsp+88h] [xbp+88h]
  unsigned __int16 v54; // [xsp+94h] [xbp+94h]
  unsigned __int8 *v55; // [xsp+98h] [xbp+98h]
  int is_sign; // [xsp+A8h] [xbp+A8h] BYREF
  int is_last; // [xsp+ACh] [xbp+ACh] BYREF
  unsigned __int8 *udp_len; // [xsp+B0h] [xbp+B0h] BYREF

  v11 = plen;
  v15 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v11;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v9.n64_u32[0] = 0;
    t_s = (set_do != 0) << 15;
    goto LABEL_26;
  }
  v20 = (unsigned __int16 *)udp_len;
  v54 = *(_WORD *)udp_len;
  buff = *((_WORD *)udp_len + 1);
  v21 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
  t_s = v21;
  if ( set_do )
  {
    t_s = v21 | 0x8000;
    *((_WORD *)udp_len + 2) = __rev16(v21 | 0x8000);
  }
  v22 = v20 + 4;
  p = (unsigned __int8 *)(v20 + 4);
  v23 = __rev16(v20[3]);
  v24 = v23;
  v25 = (char *)(v20 + 4) - (char *)header + v23;
  if ( optno )
    v26 = v25 > v11;
  else
    v26 = 1;
  if ( v26 )
    return v11;
  if ( v24 <= 4 )
    goto LABEL_34;
  v27 = v20 + 6;
  v28 = (unsigned __int16)__rev16(v20[5]);
  v29 = v28 + 4;
  v30 = (unsigned __int16)__rev16(v20[4]);
  if ( v24 >= v28 + 4 )
  {
    if ( !replace )
    {
      v32 = 0;
      while ( v30 != optno )
      {
        v32 += v28 + 4;
        v22 = (unsigned __int16 *)((char *)v27 + (unsigned __int16)v28);
        if ( v32 + 4 >= v24 )
          goto LABEL_34;
        v33 = *(unsigned __int16 *)((char *)v27 + (unsigned __int16)v28);
        v27 = v22 + 2;
        v28 = (unsigned __int16)__rev16(v22[1]);
        v30 = (unsigned __int16)__rev16(v33);
        if ( v28 + v32 + 4 > v24 )
          goto LABEL_45;
      }
      return v11;
    }
    v31 = 0;
    while ( 1 )
    {
      if ( v30 == optno )
      {
        v24 -= v29;
        memcpy(v22, (char *)v22 + (unsigned __int16)v28 + 4, v24 - v31);
        v20[3] = __rev16(v24);
      }
      else
      {
        v22 = (unsigned __int16 *)((char *)v27 + (unsigned __int16)v28);
        v31 += v29;
      }
      if ( v31 + 4 >= v24 )
        break;
      v27 = v22 + 2;
      v28 = (unsigned __int16)__rev16(v22[1]);
      v30 = (unsigned __int16)__rev16(*v22);
      if ( v28 + v31 + 4 > v24 )
        goto LABEL_45;
      v29 = v28 + 4;
    }
LABEL_34:
    if ( is_last )
    {
      v43 = (unsigned __int8 *)(v22 + 2);
      if ( limit - (unsigned __int8 *)(v22 + 2) >= (__int64)optlen )
      {
        v44 = v20 + 3;
        goto LABEL_37;
      }
      return v11;
    }
    if ( v24 )
    {
      v18 = v24;
      v47 = (unsigned __int8 *)whine_malloc(v24);
      v46 = v47;
      if ( v47 )
      {
        v55 = v47;
        memcpy(v47, p, v24);
        v46 = v55;
      }
    }
    else
    {
      v18 = 0;
      v46 = 0LL;
    }
    goto LABEL_46;
  }
LABEL_45:
  v46 = 0LL;
  is_last = 0;
LABEL_46:
  pa = v46;
  v15 = (unsigned __int16)__rev16(v54);
  v9.n64_u32[0] = (unsigned __int16)__rev16(buff);
  v11 = rrfilter(header, v11, 0LL);
  v19 = pa;
LABEL_26:
  buffa = v19;
  v36 = skip_questions(header, v11);
  v34 = v11;
  if ( !v36 )
    return v34;
  v37 = skip_section(
          v36,
          (unsigned __int16)__rev16(header->nscount)
        + (unsigned __int16)__rev16(header->ancount)
        + (unsigned int)(unsigned __int16)__rev16(header->arcount),
          header);
  v40 = v37;
  v34 = v11;
  if ( !v37 )
    return v34;
  v41 = (char *)(v37 + 0xB);
  if ( (unsigned __int64)limit < v37 + 0xB )
    return v34;
  v38.n64_u32[0] = v15;
  v39.n64_u32[0] = t_s;
  LOBYTE(v42) = vshr_n_u32(v38, 8uLL).n64_u8[0];
  *(_BYTE *)(v37 + 2) = 41;
  *(_WORD *)v37 = 0;
  BYTE1(v42) = v15;
  LODWORD(p) = v37 + 0xB;
  BYTE2(v42) = vshr_n_u32(v9, 8uLL).n64_u8[0];
  BYTE3(v42) = v9.n64_u8[0];
  BYTE4(v42) = vshr_n_u32(v39, 8uLL).n64_u8[0];
  BYTE5(v42) = t_s;
  BYTE6(v42) = BYTE1(v18);
  HIBYTE(v42) = v18;
  *(_QWORD *)(v37 + 3) = v42;
  if ( buffa )
  {
    v22 = (unsigned __int16 *)&v41[v18];
    if ( v22 > (unsigned __int16 *)limit )
    {
      free(buffa);
      return v11;
    }
    memcpy(v41, buffa, v18);
    free(buffa);
  }
  else
  {
    v22 = (unsigned __int16 *)(v37 + 0xB);
  }
  v43 = (unsigned __int8 *)(v22 + 2);
  v34 = v11;
  if ( limit - (unsigned __int8 *)(v22 + 2) < (__int64)optlen )
    return v34;
  v44 = (_WORD *)(v40 + 9);
  header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_37:
  if ( optno )
    v45 = replace == 2;
  else
    v45 = 1;
  if ( v45 )
    return (char *)v22 - (char *)header;
  v34 = v11;
  if ( limit >= v43 )
  {
    *v22 = __rev16(optno);
    v22[1] = __rev16(optlen);
    v22 = (unsigned __int16 *)&v43[optlen];
    if ( &v43[optlen] <= limit )
    {
      memcpy(v43, opt, optlen);
      *v44 = __rev16((_DWORD)v22 - (_DWORD)p);
      return (char *)v22 - (char *)header;
    }
  }
  return v34;
}
