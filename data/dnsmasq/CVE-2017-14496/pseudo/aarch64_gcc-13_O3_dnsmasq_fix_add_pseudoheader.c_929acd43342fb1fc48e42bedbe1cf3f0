size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  uint32x2_t v9; // d8
  unsigned __int64 v11; // x19
  unsigned __int32 v15; // w25
  unsigned __int8 *pseudoheader; // x0
  int v18; // w24
  unsigned __int8 *v19; // x27
  unsigned __int16 *v20; // x27
  int v21; // w0
  char *v22; // x25
  unsigned __int16 v23; // w0
  int v24; // w2
  unsigned __int64 v25; // x0
  bool v26; // cc
  signed int v27; // w26
  unsigned __int16 *v28; // x9
  unsigned int v29; // w3
  unsigned int v30; // w0
  int v31; // w1
  int v32; // w21
  unsigned __int8 *v33; // x0
  _WORD *v34; // x27
  bool v35; // zf
  __int64 v37; // x0
  __int64 v38; // x0
  uint32x2_t v39; // d0
  uint32x2_t v40; // d1
  __int64 v41; // x21
  char *v42; // x3
  __int64 v43; // d0
  unsigned __int8 *v44; // x0
  int v45; // w10
  unsigned int v46; // w1
  int v48; // [xsp+7Ch] [xbp+7Ch]
  unsigned __int8 *p; // [xsp+80h] [xbp+80h]
  unsigned __int16 v50; // [xsp+88h] [xbp+88h]
  unsigned __int16 v51; // [xsp+8Ch] [xbp+8Ch]
  int is_sign; // [xsp+98h] [xbp+98h] BYREF
  int is_last; // [xsp+9Ch] [xbp+9Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+A0h] [xbp+A0h] BYREF

  v11 = plen;
  v15 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v11;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v9.n64_u32[0] = 0;
    v48 = (set_do != 0) << 15;
LABEL_30:
    v37 = skip_questions(header, v11);
    if ( !v37 )
      return v11;
    v38 = skip_section(
            v37,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    v41 = v38;
    if ( !v38 )
      return v11;
    v42 = (char *)(v38 + 0xB);
    LODWORD(p) = v38 + 0xB;
    if ( v38 + 0xB > (unsigned __int64)limit )
      return v11;
    v39.n64_u32[0] = v15;
    v40.n64_u32[0] = v48;
    LOBYTE(v43) = vshr_n_u32(v39, 8uLL).n64_u8[0];
    *(_BYTE *)(v38 + 2) = 41;
    *(_WORD *)v38 = 0;
    BYTE1(v43) = v15;
    BYTE2(v43) = vshr_n_u32(v9, 8uLL).n64_u8[0];
    BYTE3(v43) = v9.n64_u8[0];
    BYTE4(v43) = vshr_n_u32(v40, 8uLL).n64_u8[0];
    BYTE5(v43) = v48;
    BYTE6(v43) = BYTE1(v18);
    HIBYTE(v43) = v18;
    *(_QWORD *)(v38 + 3) = v43;
    if ( v19 )
    {
      v22 = &v42[v18];
      if ( v22 > (char *)limit )
      {
        free(v19);
        return v11;
      }
      memcpy(v42, v19, v18);
      free(v19);
    }
    else
    {
      v22 = (char *)(v38 + 0xB);
    }
    v33 = (unsigned __int8 *)(v22 + 4);
    if ( limit - (unsigned __int8 *)(v22 + 4) >= (__int64)optlen )
    {
      v34 = (_WORD *)(v41 + 9);
      header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_21:
      if ( optno )
        v35 = replace == 2;
      else
        v35 = 1;
      if ( !v35 )
      {
        if ( limit < v33 )
          return v11;
        *(_WORD *)v22 = __rev16(optno);
        *((_WORD *)v22 + 1) = __rev16(optlen);
        v22 = (char *)&v33[optlen];
        if ( &v33[optlen] > limit )
          return v11;
        memcpy(v33, opt, optlen);
        *v34 = __rev16((_DWORD)v22 - (_DWORD)p);
      }
      return v22 - (char *)header;
    }
    return v11;
  }
  v20 = (unsigned __int16 *)udp_len;
  v50 = *(_WORD *)udp_len;
  v51 = *((_WORD *)udp_len + 1);
  v21 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
  v48 = v21;
  if ( set_do )
  {
    v48 = v21 | 0x8000;
    *((_WORD *)udp_len + 2) = __rev16(v21 | 0x8000);
  }
  v22 = (char *)(v20 + 4);
  p = (unsigned __int8 *)(v20 + 4);
  v23 = __rev16(v20[3]);
  v24 = v23;
  v25 = (char *)(v20 + 4) - (char *)header + v23;
  if ( optno )
    v26 = v25 > v11;
  else
    v26 = 1;
  if ( v26 )
    return v11;
  v27 = v24;
  if ( v24 > 4 )
  {
    v28 = v20 + 6;
    v29 = (unsigned __int16)__rev16(v20[5]);
    v30 = v29 + 4;
    v31 = (unsigned __int16)__rev16(v20[4]);
    if ( v24 < (int)(v29 + 4) )
    {
LABEL_40:
      is_last = 0;
      goto LABEL_41;
    }
    if ( !replace )
    {
      v45 = 0;
      while ( v31 != optno )
      {
        v22 = (char *)v28 + (unsigned __int16)v29;
        v45 += v29 + 4;
        if ( v45 + 4 >= v24 )
          goto LABEL_19;
        v46 = *(unsigned __int16 *)((char *)v28 + v29);
        v28 = (unsigned __int16 *)(v22 + 4);
        v29 = (unsigned __int16)__rev16(*((unsigned __int16 *)v22 + 1));
        v31 = (unsigned __int16)__rev16(v46);
        if ( (int)(v29 + v45 + 4) > v24 )
          goto LABEL_40;
      }
      return v11;
    }
    v32 = 0;
    while ( 1 )
    {
      if ( v31 == optno )
      {
        v27 -= v30;
        memcpy(v22, &v22[v29 + 4], v27 - v32);
        v20[3] = __rev16(v27);
      }
      else
      {
        v22 = (char *)v28 + (unsigned __int16)v29;
        v32 += v30;
      }
      if ( v32 + 4 >= v27 )
        break;
      v28 = (unsigned __int16 *)(v22 + 4);
      v29 = (unsigned __int16)__rev16(*((unsigned __int16 *)v22 + 1));
      v31 = (unsigned __int16)__rev16(*(unsigned __int16 *)v22);
      if ( (int)(v32 + 4 + v29) > v27 )
        goto LABEL_40;
      v30 = v29 + 4;
    }
  }
LABEL_19:
  if ( !is_last )
  {
    if ( v27 )
    {
      v44 = (unsigned __int8 *)whine_malloc(v27);
      v19 = v44;
      if ( v44 )
        memcpy(v44, p, v27);
      v18 = v27;
      goto LABEL_42;
    }
LABEL_41:
    v19 = 0LL;
LABEL_42:
    v15 = (unsigned __int16)__rev16(v50);
    v9.n64_u32[0] = (unsigned __int16)__rev16(v51);
    v11 = rrfilter(header, v11, 0LL);
    goto LABEL_30;
  }
  v33 = (unsigned __int8 *)(v22 + 4);
  v34 = v20 + 3;
  if ( limit - (unsigned __int8 *)(v22 + 4) >= (__int64)optlen )
    goto LABEL_21;
  return v11;
}
