int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s3
  unsigned __int8 *v19; // $fp
  unsigned __int8 *v20; // $fp
  unsigned __int16 v21; // $s6
  int v22; // $t0
  unsigned __int8 *v23; // $s7
  int v24; // $v1
  int v25; // $v0
  unsigned __int8 *v26; // $a1
  int v27; // $t3
  int v28; // $v0
  int v29; // $v1
  unsigned __int8 *v30; // $a0
  int result; // $v0
  _WORD *v32; // $s1
  int v33; // $a0
  int v34; // $v0
  int v35; // $v1
  int v36; // $t0
  unsigned __int8 *v37; // $s7
  unsigned __int8 *v38; // $v0
  int v39; // $t0
  int t_sa; // [sp+24h] [-24h]
  int t_sb; // [sp+24h] [-24h]
  size_t t_s; // [sp+24h] [-24h]
  int i; // [sp+28h] [-20h]
  unsigned __int8 *t_cp; // [sp+30h] [-18h]
  unsigned __int16 v45; // [sp+36h] [-12h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( pseudoheader )
  {
    v20 = udp_len;
    v21 = _byteswap_ushort(*((_WORD *)udp_len + 2));
    udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
    v45 = _byteswap_ushort(*((_WORD *)udp_len + 1));
    if ( set_do )
    {
      v21 |= 0x8000u;
      udp_len[4] = HIBYTE(v21);
      v20[5] = v21;
    }
    v22 = v20[7] | (v20[6] << 8);
    t_cp = v20 + 8;
    if ( v17 < v20 + 8 - (unsigned __int8 *)header + v22 || !optno )
      return v17;
    v23 = v20 + 8;
    if ( v22 < 5 )
    {
      v28 = is_last;
LABEL_17:
      if ( v28 )
      {
        v30 = v23 + 4;
        result = v17;
        if ( limit - (v23 + 4) < (int)optlen )
          return result;
        v32 = v20 + 6;
        goto LABEL_20;
      }
      if ( v22 )
      {
        t_s = v22;
        v38 = (unsigned __int8 *)whine_malloc(v22);
        v19 = v38;
        v39 = t_s;
        if ( v38 )
        {
          memcpy(v38, t_cp, t_s);
          v39 = t_s;
        }
        v18 = v39;
        goto LABEL_38;
      }
    }
    else
    {
      v24 = v20[11] | (v20[10] << 8);
      v25 = v20[9] | (v20[8] << 8);
      v26 = v20 + 0xC;
      if ( v22 >= v24 + 4 )
      {
        v23 = v20 + 8;
        v27 = 0;
        do
        {
          if ( v25 == optno )
          {
            v29 = v24 + 4;
            if ( !replace )
              return v17;
            i = v27;
            t_sa = v22 - v29;
            memcpy(v23, &v23[v29], v22 - v29 - v27);
            v22 = t_sa;
            v27 = i;
            *((_WORD *)v20 + 3) = t_sa;
          }
          else
          {
            v23 = &v26[v24];
            v27 += v24 + 4;
          }
          v28 = is_last;
          if ( v27 + 4 >= v22 )
            goto LABEL_17;
          v24 = v23[3] | (v23[2] << 8);
          v25 = v23[1] | (*v23 << 8);
          v26 = v23 + 4;
        }
        while ( v22 >= v24 + v27 + 4 );
      }
      is_last = 0;
    }
    v19 = 0;
LABEL_38:
    v17 = rrfilter(header, v17, 0);
    goto LABEL_25;
  }
  v45 = 0;
  v21 = (set_do != 0) << 15;
LABEL_25:
  v33 = skip_questions(header, v17);
  if ( !v33 )
    return v17;
  v34 = skip_section(v33, header->ancount + header->nscount + header->arcount, header, v17);
  v35 = v34;
  if ( !v34 )
    return v17;
  v36 = v34 + 0xB;
  t_cp = (unsigned __int8 *)(v34 + 0xB);
  if ( (unsigned int)limit < v34 + 0xB )
    return v17;
  *(_BYTE *)v34 = 0;
  *(_WORD *)(v34 + 1) = 41;
  *(_WORD *)(v34 + 3) = udp_sz;
  *(_WORD *)(v34 + 5) = v45;
  *(_WORD *)(v34 + 7) = v21;
  *(_WORD *)(v34 + 9) = v18;
  if ( !v19 )
  {
    v23 = (unsigned __int8 *)(v34 + 0xB);
    goto LABEL_31;
  }
  v23 = (unsigned __int8 *)(v36 + v18);
  if ( (unsigned int)limit < v36 + v18 )
  {
    free(v19);
    return v17;
  }
  t_sb = v34;
  memcpy(t_cp, v19, v18);
  free(v19);
  v35 = t_sb;
LABEL_31:
  v30 = v23 + 4;
  result = v17;
  if ( limit - (v23 + 4) >= (int)optlen )
  {
    ++header->arcount;
    result = v23 - (unsigned __int8 *)header;
    if ( optno )
    {
      v32 = (_WORD *)(v35 + 9);
LABEL_20:
      result = v23 - (unsigned __int8 *)header;
      if ( replace == 2 )
        return result;
      if ( limit >= v30 )
      {
        *v23 = BYTE2(optno);
        v23[2] = BYTE2(optlen);
        v23[1] = optno;
        v23[3] = optlen;
        v37 = &v30[optlen];
        if ( limit >= &v30[optlen] )
        {
          memcpy(v30, opt, optlen);
          *v32 = (_WORD)v37 - (_WORD)t_cp;
          return v37 - (unsigned __int8 *)header;
        }
      }
      return v17;
    }
  }
  return result;
}
