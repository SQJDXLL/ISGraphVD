signed __int64 __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v15; // x24
  unsigned __int8 *pseudoheader; // x0
  char v19; // w10
  unsigned __int8 *v20; // x21
  unsigned __int8 v21; // w10
  _WORD *v22; // x20
  unsigned __int64 v23; // x23
  int v24; // w27
  unsigned __int16 *v25; // x28
  unsigned __int16 *v26; // x26
  unsigned __int64 v27; // x8
  unsigned __int8 v28; // w12
  unsigned __int8 v29; // w13
  unsigned __int8 v30; // w11
  void *v31; // x15
  unsigned __int8 v32; // w14
  int v33; // w8
  __int64 v34; // x0
  void *v35; // x0
  _BYTE *v36; // x25
  __int64 v37; // x0
  __int64 v38; // x26
  __uint16_t v39; // w28
  int v40; // w20
  __uint16_t v41; // w0
  __int64 v42; // x0
  __int64 v43; // x28
  __uint16_t v44; // w0
  void *v45; // [xsp+8h] [xbp-58h]
  void *v46; // [xsp+8h] [xbp-58h]
  size_t v47; // [xsp+10h] [xbp-50h]
  unsigned __int8 *v48; // [xsp+18h] [xbp-48h]
  unsigned __int8 *v49; // [xsp+18h] [xbp-48h]
  void *src; // [xsp+20h] [xbp-40h]
  unsigned __int8 v51; // [xsp+2Ch] [xbp-34h]
  unsigned __int8 v52; // [xsp+2Ch] [xbp-34h]
  unsigned __int8 v53; // [xsp+30h] [xbp-30h]
  unsigned __int8 v54; // [xsp+30h] [xbp-30h]
  unsigned __int8 v55; // [xsp+34h] [xbp-2Ch]
  unsigned __int8 v56; // [xsp+34h] [xbp-2Ch]
  unsigned __int8 v57; // [xsp+38h] [xbp-28h]
  unsigned __int8 v58; // [xsp+38h] [xbp-28h]
  unsigned __int8 v59; // [xsp+3Ch] [xbp-24h]
  char v60; // [xsp+3Ch] [xbp-24h]
  unsigned __int8 *limita; // [xsp+40h] [xbp-20h]
  int is_last; // [xsp+50h] [xbp-10h] BYREF
  int is_sign; // [xsp+54h] [xbp-Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+58h] [xbp-8h] BYREF

  v15 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( set_do )
    v19 = 0x80;
  else
    v19 = 0;
  if ( !pseudoheader )
  {
    v28 = 0;
    v29 = 0;
    v30 = 0;
    LODWORD(v23) = 0;
    v31 = 0LL;
    v32 = HIBYTE(udp_sz);
    goto LABEL_38;
  }
  limita = limit;
  v20 = udp_len;
  v21 = udp_len[4];
  if ( set_do )
  {
    v21 |= 0x80u;
    udp_len[4] = v21;
  }
  LOBYTE(udp_sz) = v20[1];
  v22 = v20 + 6;
  v23 = bswap64((unsigned __int64)*((unsigned __int16 *)v20 + 3) << 48);
  src = v20 + 8;
  if ( !optno || v20 + 8 - (unsigned __int8 *)header + v23 > v15 )
    return v15;
  v47 = optlen;
  v48 = opt;
  v57 = v20[5];
  v59 = v21;
  v55 = v20[3];
  v51 = *v20;
  v53 = v20[2];
  if ( (unsigned int)v23 < 5 )
  {
    v25 = (unsigned __int16 *)(v20 + 8);
LABEL_22:
    if ( is_last )
    {
      v31 = 0LL;
      v33 = 1;
      v26 = v25;
      goto LABEL_24;
    }
LABEL_27:
    if ( (_DWORD)v23 && (v35 = (void *)whine_malloc((int)v23)) != 0LL )
    {
      v45 = v35;
      memcpy(v35, src, (int)v23);
    }
    else
    {
      v45 = 0LL;
    }
    optlen = v47;
    opt = v48;
    limit = limita;
    v34 = rrfilter(header, v15, 0LL);
    v30 = v57;
    v19 = v59;
    v28 = v55;
    v32 = v51;
    v29 = v53;
    v31 = v45;
    v26 = 0LL;
LABEL_32:
    v15 = v34;
    if ( v26 )
    {
LABEL_33:
      v36 = v26 + 2;
      if ( limit - (unsigned __int8 *)(v26 + 2) >= (int)optlen )
      {
        if ( optno && replace != 2 )
        {
          *((_BYTE *)v26 + 1) = optno;
          *(_BYTE *)v26 = BYTE1(optno);
          *((_BYTE *)v26 + 2) = BYTE1(optlen);
          *((_BYTE *)v26 + 3) = optlen;
          memcpy(v26 + 2, opt, optlen);
          v26 = (unsigned __int16 *)&v36[optlen];
          *v22 = bswap32((_DWORD)v36 + optlen - (_DWORD)src) >> 16;
        }
        return (char *)v26 - (char *)header;
      }
      return v15;
    }
LABEL_38:
    v46 = v31;
    v52 = v32;
    v54 = v29;
    v56 = v28;
    v58 = v30;
    v60 = v19;
    v37 = skip_questions(header, v15);
    if ( !v37 )
      return v15;
    v38 = v37;
    v49 = opt;
    v39 = _bswap_16(header->ancount);
    v40 = _bswap_16(header->nscount) + v39;
    v41 = _bswap_16(header->arcount);
    v42 = skip_section(v38, v40 + (unsigned int)v41, header, v15);
    if ( !v42 )
      return v15;
    *(_BYTE *)(v42 + 2) = 41;
    *(_BYTE *)(v42 + 3) = v52;
    v43 = v42 + 0xB;
    *(_WORD *)v42 = 0;
    *(_BYTE *)(v42 + 5) = v54;
    *(_BYTE *)(v42 + 4) = udp_sz;
    v26 = (unsigned __int16 *)(v42 + 0xB);
    *(_BYTE *)(v42 + 6) = v56;
    *(_BYTE *)(v42 + 7) = v60;
    *(_BYTE *)(v42 + 8) = v58;
    *(_BYTE *)(v42 + 9) = BYTE1(v23);
    v22 = (_WORD *)(v42 + 9);
    *(_BYTE *)(v42 + 10) = v23;
    if ( v46 )
    {
      memcpy((void *)(v42 + 0xB), v46, (int)v23);
      free(v46);
      v26 = (unsigned __int16 *)(v43 + (int)v23);
    }
    LODWORD(src) = v43;
    opt = v49;
    if ( limit - (unsigned __int8 *)v26 - 4 >= (int)optlen )
    {
      v44 = _bswap_16(header->arcount);
      header->arcount = _bswap_16(v44 + 1);
    }
    goto LABEL_33;
  }
  v24 = 0;
  v25 = (unsigned __int16 *)(v20 + 8);
  while ( 1 )
  {
    v26 = v25 + 2;
    v27 = bswap64((unsigned __int64)v25[1] << 48);
    if ( (int)v27 + v24 > (int)v23 )
    {
      LODWORD(v23) = 0;
      is_last = 0;
      goto LABEL_27;
    }
    if ( bswap32(*v25 << 16) == optno )
      break;
    v25 = (unsigned __int16 *)((char *)v26 + (unsigned int)v27);
    v24 += v27 + 4;
LABEL_14:
    if ( v24 + 4 >= (int)v23 )
      goto LABEL_22;
  }
  if ( replace )
  {
    LODWORD(v23) = v23 - v27 - 4;
    memcpy(v25, (char *)v26 + v27, (int)v23 - v24);
    *((_WORD *)v20 + 3) = bswap32(v23) >> 16;
    goto LABEL_14;
  }
  v33 = 0;
  v31 = 0LL;
LABEL_24:
  optlen = v47;
  opt = v48;
  limit = limita;
  v30 = v57;
  v19 = v59;
  v28 = v55;
  v32 = v51;
  v29 = v53;
  v34 = v15;
  if ( v33 )
    goto LABEL_32;
  return v15;
}
