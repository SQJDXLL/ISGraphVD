size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  char *v9; // r9
  unsigned int v10; // r4
  unsigned int v12; // r8
  dns_header *v13; // r7
  unsigned __int8 *pseudoheader; // r0
  int v16; // r3
  char v17; // r5
  unsigned __int8 *v18; // r7
  unsigned __int8 v19; // r12
  unsigned __int8 v20; // lr
  int v21; // r6
  unsigned __int8 *v22; // r9
  int v23; // r10
  int v24; // r0
  int v25; // r2
  unsigned __int8 *v26; // r11
  unsigned int v27; // r12
  int v28; // r7
  int v29; // r0
  void *v30; // r0
  void *v31; // r9
  int v32; // r2
  unsigned __int8 *v33; // r0
  bool v34; // zf
  int v35; // r0
  int v36; // r11
  int v37; // r9
  int v38; // r9
  int v39; // r0
  _BYTE *v40; // r0
  _BYTE *v41; // r7
  __uint16_t v42; // r0
  __uint16_t v43; // r0
  unsigned __int8 *v44; // [sp+Ch] [bp-54h]
  void *src; // [sp+10h] [bp-50h]
  _BYTE *v46; // [sp+14h] [bp-4Ch]
  unsigned __int8 v47; // [sp+1Ch] [bp-44h]
  char v48; // [sp+1Ch] [bp-44h]
  unsigned __int8 v49; // [sp+20h] [bp-40h]
  unsigned __int8 v50; // [sp+24h] [bp-3Ch]
  void *ptr; // [sp+28h] [bp-38h]
  dns_header *v52; // [sp+2Ch] [bp-34h]
  dns_header *v53; // [sp+2Ch] [bp-34h]
  int v54; // [sp+30h] [bp-30h] BYREF
  int v55; // [sp+34h] [bp-2Ch] BYREF
  unsigned __int8 *v56; // [sp+38h] [bp-28h] BYREF

  v10 = udp_sz;
  v12 = plen;
  v13 = header;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v56, &v55, &v54);
  if ( v55 )
    return v12;
  v16 = optno;
  v17 = set_do;
  if ( set_do )
    v17 = 0x80;
  if ( !pseudoheader )
  {
    v50 = 0;
    v27 = v10 >> 8;
    v20 = 0;
    v49 = 0;
    v21 = 0;
    ptr = 0;
    v26 = 0;
    goto LABEL_30;
  }
  v52 = v13;
  v18 = v56;
  v49 = v56[5];
  v17 = v56[4];
  v19 = *v56;
  LOBYTE(v10) = v56[1];
  v20 = v56[2];
  v50 = v56[3];
  if ( set_do )
  {
    v17 |= 0x80u;
    v56[4] = v17;
  }
  v21 = v18[7] | (v18[6] << 8);
  v46 = v18 + 6;
  v22 = v18 + 8;
  ptr = 0;
  if ( optno && v22 - (unsigned __int8 *)v52 + v21 <= v12 )
  {
    v44 = limit;
    src = v18 + 8;
    v47 = v19;
    if ( (unsigned int)v21 >= 5 )
    {
      v23 = 0;
      v24 = 4;
      do
      {
        v25 = v22[3] | (v22[2] << 8);
        v26 = v22 + 4;
        if ( v25 + v24 > v21 )
        {
          v21 = 0;
          v54 = 0;
          v22 += 4;
          break;
        }
        if ( (v22[1] | (*v22 << 8)) == v16 )
        {
          if ( !replace )
          {
            v28 = 0;
            ptr = 0;
LABEL_23:
            v29 = v12;
            limit = v44;
            goto LABEL_28;
          }
          v21 = v21 - v25 - 4;
          memcpy(v22, &v26[v25], v21 - v23);
          v16 = optno;
          v18[7] = v21;
          v18[6] = BYTE1(v21);
        }
        else
        {
          v22 = &v26[v25];
          v23 += v25 + 4;
        }
        v24 = v23 + 4;
      }
      while ( v23 + 4 < v21 );
    }
    v28 = 1;
    if ( v54 )
    {
      v26 = v22;
      goto LABEL_23;
    }
    v26 = 0;
    v30 = 0;
    if ( v21 )
    {
      v31 = (void *)whine_malloc(v21);
      v30 = 0;
      if ( v31 )
      {
        memcpy(v31, src, v21);
        v30 = v31;
      }
    }
    ptr = v30;
    v29 = rrfilter(v52, v12, 0);
    limit = v44;
    v16 = optno;
LABEL_28:
    LOWORD(v9) = (_WORD)src;
    LOBYTE(v27) = v47;
    if ( v28 )
    {
      v12 = v29;
      v13 = v52;
LABEL_30:
      v32 = optlen;
      if ( !v26 )
      {
        v48 = v27;
        v35 = skip_questions(v13, v12, optlen, v16);
        if ( !v35 )
          return v12;
        v36 = v35;
        v37 = _bswap_16(v13->ancount);
        v38 = _bswap_16(v13->nscount) + v37;
        v39 = _bswap_16(v13->arcount);
        v53 = v13;
        v40 = (_BYTE *)skip_section(v36, v38 + v39, v13, v12);
        if ( !v40 )
          return v12;
        v9 = v40 + 0xB;
        if ( v40 + 0xB > limit )
          return v12;
        v40[10] = v21;
        v40[8] = v49;
        v40[7] = v17;
        v40[6] = v50;
        v40[5] = v20;
        v40[4] = v10;
        v40[3] = v48;
        v40[2] = 41;
        v40[1] = 0;
        *v40 = 0;
        v40[9] = BYTE1(v21);
        v41 = v40 + 9;
        v26 = v40 + 0xB;
        if ( ptr )
        {
          v26 = (unsigned __int8 *)&v9[v21];
          if ( &v9[v21] > (char *)limit )
          {
            free(ptr);
            return v12;
          }
          memcpy(v9, ptr, v21);
          free(ptr);
        }
        v32 = optlen;
        v46 = v41;
        if ( limit - v26 - 4 >= (int)optlen )
        {
          v13 = v53;
          v42 = _bswap_16(v53->arcount);
          v43 = _bswap_16(v42 + 1);
          v32 = optlen;
          v53->arcount = v43;
          v16 = optno;
        }
        else
        {
          v16 = optno;
          v13 = v53;
        }
      }
      v33 = v26 + 4;
      if ( limit - (v26 + 4) < v32 )
        return v12;
      v34 = v16 == 0;
      if ( v16 )
        v34 = replace == 2;
      if ( !v34 )
      {
        if ( v33 > limit )
          return v12;
        v26[3] = v32;
        v26[1] = v16;
        v26[2] = BYTE1(v32);
        *v26 = BYTE1(v16);
        v26 = &v33[v32];
        if ( &v33[v32] > limit )
          return v12;
        memcpy(v33, opt, v32);
        v46[1] = (_BYTE)v26 - (_BYTE)v9;
        *v46 = (unsigned __int16)((_WORD)v26 - (_WORD)v9) >> 8;
      }
      return v26 - (unsigned __int8 *)v13;
    }
  }
  return v12;
}
