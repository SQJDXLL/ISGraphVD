size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // eax
  int v11; // ecx
  unsigned __int8 *ptr; // ebp
  unsigned __int8 *v13; // ebx
  __int16 v14; // ax
  int v15; // edi
  signed int v16; // esi
  int v17; // ebp
  unsigned __int16 v18; // dx
  int v19; // eax
  unsigned __int8 *v20; // ebx
  int v21; // eax
  __int16 v22; // di
  char *v24; // esi
  _WORD *v25; // ebp
  int v26; // eax
  int v27; // edx
  int v28; // esi
  unsigned __int8 *v29; // eax
  int rdlen; // [esp+28h] [ebp-44h]
  int rdlena; // [esp+28h] [ebp-44h]
  int rdlenb; // [esp+28h] [ebp-44h]
  __int16 t_s; // [esp+2Ch] [ebp-40h]
  int t_sa; // [esp+2Ch] [ebp-40h]
  unsigned __int8 *datap; // [esp+30h] [ebp-3Ch]
  unsigned __int8 *datapa; // [esp+30h] [ebp-3Ch]
  __int16 v37; // [esp+34h] [ebp-38h]
  __int16 v38; // [esp+36h] [ebp-36h]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  pseudoheader = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  v11 = is_sign;
  if ( is_sign )
    return plen;
  ptr = pseudoheader;
  if ( !pseudoheader )
  {
    v22 = 0;
    t_s = (set_do != 0) << 15;
    goto LABEL_17;
  }
  v13 = t_cp;
  v38 = *(_WORD *)t_cp;
  v37 = *((_WORD *)t_cp + 1);
  v14 = __ROL2__(*((_WORD *)t_cp + 2), 8);
  t_s = v14;
  if ( set_do )
  {
    t_s = v14 | 0x8000;
    *((_WORD *)t_cp + 2) = __ROL2__(v14 | 0x8000, 8);
  }
  v15 = (int)(v13 + 8);
  datap = v13 + 8;
  v16 = (unsigned __int16)__ROL2__(*((_WORD *)v13 + 3), 8);
  if ( plen < (unsigned int)(unsigned __int16)v16 + v13 + 8 - (unsigned __int8 *)header || !optno )
    return plen;
  if ( (unsigned __int16)v16 <= 4u )
  {
    v15 = (int)(v13 + 8);
  }
  else
  {
    v17 = 0;
    v18 = __ROL2__(*((_WORD *)v13 + 4), 8);
    v19 = (unsigned __int16)__ROL2__(*((_WORD *)v13 + 5), 8);
    if ( (unsigned __int16)v16 < (int)(unsigned __int16)v19 )
    {
LABEL_20:
      is_last[0] = 0;
      goto LABEL_21;
    }
    rdlen = (int)v13;
    v20 = v13 + 12;
    while ( 1 )
    {
      if ( v18 == optno )
      {
        if ( !replace )
          return plen;
        v21 = v19 + 4;
        v16 -= v21;
        memcpy((void *)v15, (const void *)(v15 + v21), v16 - v17);
        *(_WORD *)(rdlen + 6) = __ROL2__(v16, 8);
      }
      else
      {
        v15 = (int)&v20[v19];
        v17 += v19 + 4;
      }
      if ( v17 + 4 >= v16 )
        break;
      v20 = (unsigned __int8 *)(v15 + 4);
      v18 = __ROL2__(*(_WORD *)v15, 8);
      v19 = (unsigned __int16)__ROL2__(*(_WORD *)(v15 + 2), 8);
      if ( (unsigned __int16)v19 + v17 > v16 )
      {
        v11 = 0;
        goto LABEL_20;
      }
    }
    v11 = 0;
    v13 = (unsigned __int8 *)rdlen;
  }
  if ( !is_last[0] )
  {
    if ( v16 )
    {
      v29 = (unsigned __int8 *)whine_malloc(v16);
      ptr = v29;
      if ( v29 )
        memcpy(v29, datap, v16);
      v11 = v16;
      goto LABEL_22;
    }
LABEL_21:
    ptr = 0;
LABEL_22:
    rdlenb = v11;
    udp_sz = __ROL2__(v38, 8);
    v22 = __ROL2__(v37, 8);
    plen = rrfilter(header, plen, 0);
    v11 = rdlenb;
LABEL_17:
    rdlena = v11;
    datapa = (unsigned __int8 *)skip_questions(header, plen);
    if ( datapa )
    {
      v26 = skip_section(
              datapa,
              (unsigned __int16)__ROL2__(header->arcount, 8)
            + (unsigned __int16)__ROL2__(header->ancount, 8)
            + (unsigned __int16)__ROL2__(header->nscount, 8),
              header,
              plen);
      v27 = v26;
      if ( v26 )
      {
        *(_BYTE *)(v26 + 2) = 41;
        *(_WORD *)v26 = 0;
        *(_WORD *)(v26 + 3) = __ROL2__(udp_sz, 8);
        *(_WORD *)(v26 + 5) = __ROL2__(v22, 8);
        *(_WORD *)(v26 + 7) = __ROL2__(t_s, 8);
        *(_WORD *)(v26 + 9) = __ROL2__(rdlena, 8);
        LOWORD(datap) = v26 + 11;
        v28 = v26 + 11;
        v15 = v26 + 11;
        if ( ptr )
        {
          t_sa = v26;
          memcpy((void *)(v26 + 11), ptr, rdlena);
          free(ptr);
          v27 = t_sa;
          v15 = v28 + rdlena;
        }
        v24 = (char *)(v15 + 4);
        if ( (int)&limit[-v15 - 4] >= (int)optlen )
        {
          v25 = (_WORD *)(v27 + 9);
          header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
          goto LABEL_26;
        }
      }
    }
    return plen;
  }
  v24 = (char *)(v15 + 4);
  v25 = v13 + 6;
  if ( (int)&limit[-v15 - 4] < (int)optlen )
    return plen;
LABEL_26:
  if ( optno )
  {
    if ( replace != 2 )
    {
      *(_WORD *)v15 = __ROL2__(optno, 8);
      *(_WORD *)(v15 + 2) = __ROL2__(optlen, 8);
      memcpy(v24, opt, optlen);
      v15 = (int)&v24[optlen];
      *v25 = __ROL2__(optlen + (_WORD)v24 - (_WORD)datap, 8);
    }
  }
  return v15 - (_DWORD)header;
}
