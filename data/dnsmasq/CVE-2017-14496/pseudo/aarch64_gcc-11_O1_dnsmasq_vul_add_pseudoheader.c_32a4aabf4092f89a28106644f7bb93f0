size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // x24
  unsigned __int8 *pseudoheader; // x0
  int v15; // w27
  unsigned __int8 *v16; // x19
  unsigned __int8 *v17; // x22
  __int16 v18; // w28
  __int16 v19; // w3
  __int16 v20; // w2
  __int16 v21; // w1
  unsigned __int16 v22; // w26
  int v23; // w20
  unsigned __int64 v24; // x0
  bool v25; // cc
  int v27; // w0
  int v28; // w1
  unsigned __int8 *v29; // x4
  int v30; // w2
  int v31; // w21
  _BYTE *v32; // x22
  bool v33; // zf
  unsigned __int8 *v34; // x0
  char *v35; // x19
  __int64 v36; // x0
  _BYTE *v37; // x0
  _BYTE *v38; // x22
  void *v39; // x0
  unsigned __int8 *p; // [xsp+80h] [xbp+80h]
  __int16 rcode; // [xsp+8Ch] [xbp+8Ch]
  int is_sign; // [xsp+98h] [xbp+98h] BYREF
  int is_last; // [xsp+9Ch] [xbp+9Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+A0h] [xbp+A0h] BYREF

  v10 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v15 = is_sign;
  if ( is_sign )
    return v10;
  v16 = pseudoheader;
  if ( pseudoheader )
  {
    v17 = udp_len;
    v18 = *udp_len;
    v19 = udp_len[1];
    v20 = udp_len[2];
    v21 = udp_len[3];
    v22 = _byteswap_ushort(*((_WORD *)udp_len + 2));
    if ( set_do )
    {
      v22 |= 0x8000u;
      udp_len[4] = HIBYTE(v22);
      v17[5] = v22;
    }
    v23 = v17[7] | (v17[6] << 8);
    v16 = v17 + 8;
    p = v17 + 8;
    v24 = v17 + 8 - (unsigned __int8 *)header + _byteswap_ushort(*((_WORD *)v17 + 3));
    if ( optno )
      v25 = v24 > v10;
    else
      v25 = 1;
    if ( v25 )
      return v10;
    udp_sz = v19 | (v18 << 8);
    rcode = v21 | (v20 << 8);
    if ( v23 <= 4 )
    {
      if ( is_last )
      {
        v16 = v17 + 8;
        goto LABEL_24;
      }
    }
    else
    {
      v27 = v17[9] | (v17[8] << 8);
      v28 = v17[11] | (v17[10] << 8);
      v29 = v17 + 0xC;
      v30 = v28;
      if ( v23 < v28 )
      {
LABEL_14:
        is_last = 0;
        v16 = 0LL;
LABEL_15:
        v10 = rrfilter(header, v10, 0LL);
        goto LABEL_44;
      }
      v31 = 0;
      while ( 1 )
      {
        if ( v27 == optno )
        {
          if ( !replace )
            return v10;
          v23 -= v30 + 4;
          memcpy(v16, &v16[(unsigned __int16)v28 + 4], v23 - v31);
          v17[6] = BYTE1(v23);
          v17[7] = v23;
        }
        else
        {
          v16 = &v29[(unsigned __int16)v28];
          v31 += v30 + 4;
        }
        if ( v31 + 4 >= v23 )
          break;
        v27 = v16[1] | (*v16 << 8);
        v28 = v16[3] | (v16[2] << 8);
        v29 = v16 + 4;
        v30 = v28;
        if ( v28 + v31 > v23 )
          goto LABEL_14;
      }
      if ( is_last )
      {
        if ( v16 )
        {
LABEL_24:
          if ( limit - (v16 + 4) < (__int64)optlen )
            return v10;
          v32 = v17 + 6;
          goto LABEL_26;
        }
        v15 = v23;
        goto LABEL_44;
      }
    }
    if ( v23 )
    {
      v34 = (unsigned __int8 *)whine_malloc(v23);
      v16 = v34;
      v15 = v23;
      if ( v34 )
        memcpy(v34, p, v23);
    }
    else
    {
      v15 = 0;
      v16 = 0LL;
    }
    goto LABEL_15;
  }
  v22 = (set_do != 0) << 15;
  rcode = 0;
LABEL_44:
  v36 = skip_questions(header, v10);
  if ( v36 )
  {
    v37 = (_BYTE *)skip_section(
                     v36,
                     (unsigned __int16)__rev16(header->nscount)
                   + (unsigned __int16)__rev16(header->ancount)
                   + (unsigned int)(unsigned __int16)__rev16(header->arcount),
                     header,
                     v10);
    v38 = v37;
    if ( v37 )
    {
      *v37 = 0;
      v37[1] = 0;
      v37[2] = 41;
      v37[3] = HIBYTE(udp_sz);
      v37[4] = udp_sz;
      v37[5] = HIBYTE(rcode);
      v37[6] = rcode;
      v37[7] = HIBYTE(v22);
      v37[8] = v22;
      v37[9] = BYTE1(v15);
      v37[10] = v15;
      v39 = v37 + 0xB;
      LOWORD(p) = (_WORD)v38 + 0xB;
      if ( v16 )
      {
        memcpy(v39, v16, v15);
        free(v16);
        v16 = &v38[v15 + 0xB];
      }
      else
      {
        v16 = v38 + 0xB;
      }
      if ( limit - (v16 + 4) >= (__int64)optlen )
      {
        v32 = v38 + 9;
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_26:
        if ( optno )
          v33 = replace == 2;
        else
          v33 = 1;
        if ( !v33 )
        {
          *v16 = BYTE1(optno);
          v16[1] = optno;
          v16[2] = BYTE1(optlen);
          v16[3] = optlen;
          v35 = (char *)(v16 + 4);
          memcpy(v35, opt, optlen);
          v16 = (unsigned __int8 *)&v35[optlen];
          *v32 = (unsigned __int16)((_WORD)v16 - (_WORD)p) >> 8;
          v32[1] = (_BYTE)v16 - (_BYTE)p;
        }
        return v16 - (unsigned __int8 *)header;
      }
    }
  }
  return v10;
}
