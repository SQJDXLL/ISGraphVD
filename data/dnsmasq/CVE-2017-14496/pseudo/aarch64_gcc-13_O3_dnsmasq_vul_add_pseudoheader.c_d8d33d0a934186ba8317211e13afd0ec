size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  uint32x2_t v9; // d8
  unsigned __int64 v11; // x19
  unsigned __int32 v15; // w25
  unsigned __int8 *pseudoheader; // x0
  int v18; // w27
  unsigned __int8 *v19; // x6
  unsigned __int16 *v20; // x25
  unsigned int v21; // w22
  unsigned __int16 *v22; // x5
  unsigned __int16 v23; // w0
  int v24; // w2
  unsigned __int64 v25; // x0
  signed int v27; // w24
  unsigned __int16 *v28; // x9
  unsigned int v29; // w3
  int v30; // w1
  int v31; // w26
  unsigned int v32; // w0
  int v33; // w0
  unsigned int v34; // w1
  __int64 v36; // x0
  __int64 v37; // x24
  uint32x2_t v38; // d0
  uint32x2_t v39; // d1
  __int64 v40; // d0
  void *v41; // x3
  unsigned __int8 *v42; // x0
  unsigned __int8 *v43; // x6
  _WORD *v44; // x19
  bool v45; // zf
  _BYTE *v46; // x0
  unsigned __int8 *buff; // [xsp+80h] [xbp+80h]
  unsigned __int8 *buffa; // [xsp+80h] [xbp+80h]
  unsigned __int8 *buffb; // [xsp+80h] [xbp+80h]
  unsigned __int16 src; // [xsp+88h] [xbp+88h]
  unsigned __int8 *srca; // [xsp+88h] [xbp+88h]
  unsigned __int16 v53; // [xsp+94h] [xbp+94h]
  unsigned __int8 *v54; // [xsp+98h] [xbp+98h]
  int is_sign; // [xsp+A8h] [xbp+A8h] BYREF
  int is_last; // [xsp+ACh] [xbp+ACh] BYREF
  unsigned __int8 *udp_len; // [xsp+B0h] [xbp+B0h] BYREF

  v11 = plen;
  v15 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v11;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v9.n64_u32[0] = 0;
    v21 = (set_do != 0) << 15;
LABEL_25:
    buffa = v19;
    v36 = skip_questions(header, v11);
    if ( !v36 )
      return v11;
    srca = buffa;
    v37 = skip_section(
            v36,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    if ( !v37 )
      return v11;
    v38.n64_u32[0] = v15;
    v39.n64_u32[0] = v21;
    LOBYTE(v40) = vshr_n_u32(v38, 8uLL).n64_u8[0];
    *(_WORD *)v37 = 0;
    BYTE1(v40) = v15;
    *(_BYTE *)(v37 + 2) = 41;
    LODWORD(buff) = v37 + 0xB;
    v22 = (unsigned __int16 *)(v37 + 0xB);
    BYTE2(v40) = vshr_n_u32(v9, 8uLL).n64_u8[0];
    BYTE3(v40) = v9.n64_u8[0];
    BYTE4(v40) = vshr_n_u32(v39, 8uLL).n64_u8[0];
    BYTE5(v40) = v21;
    BYTE6(v40) = BYTE1(v18);
    HIBYTE(v40) = v18;
    *(_QWORD *)(v37 + 3) = v40;
    if ( srca )
    {
      memcpy((void *)(v37 + 0xB), srca, v18);
      free(srca);
      v22 = (unsigned __int16 *)(v37 + 0xB + v18);
    }
    v41 = v22 + 2;
    if ( limit - (unsigned __int8 *)(v22 + 2) < (__int64)optlen )
      return v11;
    v44 = (_WORD *)(v37 + 9);
    header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
    goto LABEL_38;
  }
  v20 = (unsigned __int16 *)udp_len;
  v53 = *(_WORD *)udp_len;
  src = *((_WORD *)udp_len + 1);
  v21 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
  if ( set_do )
  {
    v21 |= 0x8000u;
    *((_WORD *)udp_len + 2) = __rev16(v21);
  }
  v22 = v20 + 4;
  buff = (unsigned __int8 *)(v20 + 4);
  v23 = __rev16(v20[3]);
  v24 = v23;
  v25 = (char *)(v20 + 4) - (char *)header + v23;
  if ( !optno || v25 > v11 )
    return v11;
  v27 = v24;
  if ( v24 > 4 )
  {
    v28 = v20 + 6;
    v29 = (unsigned __int16)__rev16(v20[5]);
    v30 = (unsigned __int16)__rev16(v20[4]);
    if ( v24 < (int)v29 )
    {
LABEL_44:
      is_last = 0;
      goto LABEL_45;
    }
    if ( !replace )
    {
      v33 = 0;
      while ( v30 != optno )
      {
        v22 = (unsigned __int16 *)((char *)v28 + (unsigned __int16)v29);
        v33 += v29 + 4;
        if ( v33 + 4 >= v24 )
          goto LABEL_31;
        v34 = *(unsigned __int16 *)((char *)v28 + v29);
        v28 = v22 + 2;
        v29 = (unsigned __int16)__rev16(v22[1]);
        v30 = (unsigned __int16)__rev16(v34);
        if ( (int)(v29 + v33) > v24 )
          goto LABEL_44;
      }
      return v11;
    }
    v31 = 0;
    while ( 1 )
    {
      v32 = v29 + 4;
      if ( v30 == optno )
      {
        v27 -= v32;
        v22 = (unsigned __int16 *)memcpy(v22, (char *)v22 + v29 + 4, v27 - v31);
        v20[3] = __rev16(v27);
      }
      else
      {
        v22 = (unsigned __int16 *)((char *)v28 + (unsigned __int16)v29);
        v31 += v32;
      }
      if ( v31 + 4 >= v27 )
        break;
      v28 = v22 + 2;
      v29 = (unsigned __int16)__rev16(v22[1]);
      v30 = (unsigned __int16)__rev16(*v22);
      if ( (int)(v31 + v29) > v27 )
        goto LABEL_44;
    }
  }
LABEL_31:
  if ( !is_last )
  {
    if ( v27 )
    {
      v42 = (unsigned __int8 *)whine_malloc(v27);
      v43 = v42;
      if ( v42 )
      {
        v54 = v42;
        memcpy(v42, buff, v27);
        v43 = v54;
      }
      v18 = v27;
      goto LABEL_46;
    }
LABEL_45:
    v43 = 0LL;
LABEL_46:
    buffb = v43;
    v15 = (unsigned __int16)__rev16(v53);
    v9.n64_u32[0] = (unsigned __int16)__rev16(src);
    v11 = rrfilter(header, v11, 0LL);
    v19 = buffb;
    goto LABEL_25;
  }
  v41 = v22 + 2;
  if ( limit - (unsigned __int8 *)(v22 + 2) < (__int64)optlen )
    return v11;
  v44 = v20 + 3;
LABEL_38:
  if ( optno )
    v45 = replace == 2;
  else
    v45 = 1;
  if ( v45 )
    return (char *)v22 - (char *)header;
  *v22 = __rev16(optno);
  v22[1] = __rev16(optlen);
  v46 = memcpy(v41, opt, optlen);
  *v44 = __rev16((_DWORD)v46 + optlen - (_DWORD)buff);
  return &v46[optlen] - (_BYTE *)header;
}
