int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  _BYTE *v13; // $fp
  size_t v16; // $s1
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $fp
  unsigned __int8 v21; // $a3
  unsigned __int8 v22; // $v0
  unsigned __int8 v23; // $a0
  unsigned __int8 v24; // $a2
  unsigned __int8 v25; // $a1
  char v26; // $at
  unsigned int v27; // $a1
  unsigned __int8 v28; // $a2
  unsigned __int8 v29; // $a3
  int v30; // $s5
  void *v31; // $v1
  unsigned __int8 *v32; // $s4
  int v33; // $v0
  int v34; // $s2
  unsigned __int8 *v35; // $s7
  int v36; // $v0
  unsigned __int8 *v37; // $s4
  void *v38; // $v0
  void *v39; // $s7
  void *v40; // $s7
  _BYTE *v41; // $s3
  __int16 v42; // $at
  int v43; // $v0
  int v44; // $s4
  int v45; // $fp
  int v46; // $v0
  int v47; // $s2
  _BYTE *v48; // $v0
  _BYTE *v49; // $fp
  __uint16_t v50; // $v0
  void *src; // [sp+1Ch] [-2Ch]
  void *srca; // [sp+1Ch] [-2Ch]
  unsigned __int8 v53; // [sp+20h] [-28h]
  unsigned __int8 v54; // [sp+20h] [-28h]
  unsigned __int8 v55; // [sp+24h] [-24h]
  unsigned __int8 v56; // [sp+24h] [-24h]
  unsigned __int8 v57; // [sp+28h] [-20h]
  char v58; // [sp+28h] [-20h]
  unsigned __int8 v59; // [sp+2Ch] [-1Ch]
  unsigned __int8 v60; // [sp+30h] [-18h]
  unsigned __int8 *v61; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v64; // [sp+44h] [-4h] BYREF

  v16 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v64, &is_sign, &is_last);
  if ( is_sign )
    return v16;
  v61 = limit;
  if ( pseudoheader )
  {
    v20 = v64;
    v21 = v64[5];
    v22 = v64[4];
    v23 = v64[3];
    v24 = v64[2];
    LOBYTE(udp_sz) = v64[1];
    v25 = *v64;
    if ( set_do )
    {
      v59 = v22 | 0x80;
      v64[4] = v22 | 0x80;
    }
    else
    {
      v59 = v64[4];
    }
    v30 = (v20[6] << 8) | v20[7];
    v60 = v23;
    src = v20 + 8;
    if ( !optno || v16 < v20 + 8 - (unsigned __int8 *)header + v30 )
      return v16;
    v53 = v21;
    v55 = v24;
    v57 = v25;
    if ( (unsigned int)v30 < 5 )
    {
      v35 = v20 + 8;
    }
    else
    {
      v34 = 0;
      v35 = v20 + 8;
      while ( 1 )
      {
        v36 = (v35[2] << 8) | v35[3];
        v37 = v35 + 4;
        if ( v30 < v36 + v34 )
          break;
        if ( ((*v35 << 8) | v35[1]) == optno )
        {
          if ( !replace )
            return v16;
          v30 = v30 - v36 - 4;
          memcpy(v35, &v37[v36], v30 - v34);
          v20[7] = v30;
          v20[6] = BYTE1(v30);
        }
        else
        {
          v35 = &v37[v36];
          v34 += v36 + 4;
        }
        if ( v34 + 4 >= v30 )
          goto LABEL_24;
      }
      is_last = 0;
      v30 = 0;
      v35 += 4;
    }
LABEL_24:
    if ( is_last )
    {
      v32 = v35;
      v33 = v16;
      LOBYTE(v27) = v57;
      v28 = v55;
      v29 = v53;
      v31 = 0;
      v13 = v20 + 6;
    }
    else
    {
      v32 = 0;
      v38 = 0;
      if ( v30 )
      {
        v39 = (void *)whine_malloc(v30);
        v38 = 0;
        if ( v39 )
        {
          memcpy(v39, src, v30);
          v38 = v39;
        }
      }
      v40 = v38;
      v33 = rrfilter(header, v16, 0);
      v31 = v40;
      LOBYTE(v27) = v57;
      v28 = v55;
      v29 = v53;
      v13 = v20 + 6;
    }
  }
  else
  {
    v60 = 0;
    v26 = 0x80;
    if ( !set_do )
      v26 = 0;
    v59 = v26;
    v27 = udp_sz >> 8;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = v16;
  }
  v16 = v33;
  if ( !v32 )
  {
    srca = v31;
    v54 = v29;
    v56 = v28;
    v58 = v27;
    v43 = skip_questions(header, v33);
    if ( !v43 )
      return v16;
    v44 = v43;
    v45 = _bswap_16(header->ancount);
    v47 = _bswap_16(header->nscount) + v45;
    v46 = _bswap_16(header->arcount);
    v48 = (_BYTE *)skip_section(v44, v47 + v46, header, v16);
    if ( !v48 )
      return v16;
    v49 = v48;
    v48[10] = v30;
    v48[8] = v54;
    v48[7] = v59;
    v48[6] = v60;
    v48[5] = v56;
    v48[4] = udp_sz;
    v48[3] = v58;
    v48[2] = 41;
    v48[1] = 0;
    *v48 = 0;
    v48[9] = BYTE1(v30);
    v32 = v48 + 0xB;
    if ( srca )
    {
      memcpy(v48 + 0xB, srca, v30);
      free(srca);
      v32 = &v49[v30 + 0xB];
    }
    LOWORD(src) = (_WORD)v49 + 0xB;
    v13 = v49 + 9;
    if ( v61 - v32 - 4 >= (int)optlen )
    {
      v50 = _bswap_16(header->arcount);
      header->arcount = _bswap_16(v50 + 1);
    }
  }
  v41 = v32 + 4;
  if ( v61 - (v32 + 4) >= (int)optlen )
  {
    if ( optno && replace != 2 )
    {
      v32[3] = optlen;
      v32[1] = optno;
      v32[2] = BYTE1(optlen);
      *v32 = BYTE1(optno);
      memcpy(v32 + 4, opt, optlen);
      v32 = &v41[optlen];
      v42 = (_WORD)v41 + optlen - (_WORD)src;
      v13[1] = v42;
      *v13 = HIBYTE(v42);
    }
    return v32 - (unsigned __int8 *)header;
  }
  return v16;
}
