size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // x24
  unsigned __int8 *pseudoheader; // x0
  int v16; // w27
  unsigned __int8 *v17; // x21
  unsigned __int8 *v18; // x22
  unsigned __int16 v19; // w0
  int v20; // w20
  _BYTE *v21; // x28
  unsigned __int64 v22; // x0
  bool v23; // cc
  int v25; // w0
  int v26; // w1
  unsigned __int8 *v27; // x4
  int v28; // w2
  int v29; // w21
  unsigned __int8 *v30; // x19
  __int16 v31; // w19
  char *v32; // x20
  _BYTE *v33; // x22
  bool v34; // zf
  __int16 v35; // w28
  __int64 v36; // x0
  _BYTE *v37; // x0
  _BYTE *v38; // x22
  unsigned __int8 *v39; // x0
  __int16 t_s; // [xsp+7Ch] [xbp+7Ch]
  __int16 v43; // [xsp+80h] [xbp+80h]
  __int16 v44; // [xsp+84h] [xbp+84h]
  __int16 v45; // [xsp+88h] [xbp+88h]
  __int16 v46; // [xsp+8Ch] [xbp+8Ch]
  int is_sign; // [xsp+98h] [xbp+98h] BYREF
  int is_last; // [xsp+9Ch] [xbp+9Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+A0h] [xbp+A0h] BYREF

  v10 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v10;
  v17 = pseudoheader;
  if ( pseudoheader )
  {
    v18 = udp_len;
    v43 = *udp_len;
    v44 = udp_len[1];
    v45 = udp_len[2];
    v46 = udp_len[3];
    v19 = _byteswap_ushort(*((_WORD *)udp_len + 2));
    if ( set_do )
    {
      t_s = v19 | 0x8000;
      udp_len[4] = (unsigned __int16)(v19 | 0x8000) >> 8;
      v18[5] = v19;
    }
    else
    {
      t_s = v19;
    }
    v20 = v18[7] | (v18[6] << 8);
    LOWORD(v21) = (_WORD)v18 + 8;
    v22 = v18 + 8 - (unsigned __int8 *)header + _byteswap_ushort(*((_WORD *)v18 + 3));
    if ( optno )
      v23 = v22 > v10;
    else
      v23 = 1;
    if ( v23 )
      return v10;
    if ( v20 <= 4 )
    {
      v30 = v18 + 8;
      if ( is_last )
      {
LABEL_24:
        v32 = (char *)(v30 + 4);
        if ( limit - (v30 + 4) < (__int64)optlen )
          return v10;
        v33 = v18 + 6;
        goto LABEL_26;
      }
    }
    else
    {
      v25 = _byteswap_ushort(*((_WORD *)v18 + 4));
      v26 = _byteswap_ushort(*((_WORD *)v18 + 5));
      v27 = v18 + 0xC;
      v28 = v26;
      if ( v20 < v26 )
      {
LABEL_15:
        is_last = 0;
        v17 = 0LL;
LABEL_16:
        udp_sz = v44 | (v43 << 8);
        v31 = v46 | (v45 << 8);
        v10 = rrfilter(header, v10, 0LL);
        goto LABEL_38;
      }
      v29 = 0;
      v30 = v18 + 8;
      while ( 1 )
      {
        if ( v25 == optno )
        {
          if ( !replace )
            return v10;
          v20 -= v28 + 4;
          memcpy(v30, &v30[v26 + 4], v20 - v29);
          v18[6] = BYTE1(v20);
          v18[7] = v20;
        }
        else
        {
          v30 = &v27[(unsigned __int16)v26];
          v29 += v28 + 4;
        }
        if ( v29 + 4 >= v20 )
          break;
        v25 = _byteswap_ushort(*(_WORD *)v30);
        v26 = _byteswap_ushort(*((_WORD *)v30 + 1));
        v27 = v30 + 4;
        v28 = v26;
        if ( v26 + v29 > v20 )
          goto LABEL_15;
      }
      if ( is_last )
        goto LABEL_24;
    }
    if ( v20 )
    {
      v39 = (unsigned __int8 *)whine_malloc(v20);
      v17 = v39;
      v16 = v20;
      if ( v39 )
        memcpy(v39, v18 + 8, v20);
    }
    else
    {
      v16 = 0;
      v17 = 0LL;
    }
    goto LABEL_16;
  }
  t_s = (set_do != 0) << 15;
  v31 = 0;
LABEL_38:
  v36 = skip_questions(header, v10);
  if ( v36 )
  {
    v37 = (_BYTE *)skip_section(
                     v36,
                     (unsigned __int16)__rev16(header->nscount)
                   + (unsigned __int16)__rev16(header->ancount)
                   + (unsigned int)(unsigned __int16)__rev16(header->arcount),
                     header,
                     v10);
    v38 = v37;
    if ( v37 )
    {
      *v37 = 0;
      v37[1] = 0;
      v37[2] = 41;
      v37[3] = HIBYTE(udp_sz);
      v37[4] = udp_sz;
      v37[5] = HIBYTE(v31);
      v37[6] = v31;
      v37[7] = HIBYTE(t_s);
      v37[8] = t_s;
      v37[9] = BYTE1(v16);
      v37[10] = v16;
      v21 = v37 + 0xB;
      v30 = v37 + 0xB;
      if ( v17 )
      {
        memcpy(v37 + 0xB, v17, v16);
        free(v17);
        v30 = &v21[v16];
      }
      v32 = (char *)(v30 + 4);
      if ( limit - (v30 + 4) >= (__int64)optlen )
      {
        v33 = v38 + 9;
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_26:
        if ( optno )
          v34 = replace == 2;
        else
          v34 = 1;
        if ( !v34 )
        {
          *v30 = BYTE1(optno);
          v30[1] = optno;
          v30[2] = BYTE1(optlen);
          v30[3] = optlen;
          memcpy(v32, opt, optlen);
          v30 = (unsigned __int8 *)&v32[optlen];
          v35 = (_WORD)v32 + optlen - (_WORD)v21;
          *v33 = HIBYTE(v35);
          v33[1] = v35;
        }
        return v30 - (unsigned __int8 *)header;
      }
    }
  }
  return v10;
}
