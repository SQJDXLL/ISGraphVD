size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // rax
  __int64 v14; // rdx
  size_t v15; // r15
  __int16 v17; // si
  unsigned __int8 *v18; // rbp
  __int16 v19; // r12
  __int16 v20; // ax
  __int16 v21; // bx
  __int64 v22; // r8
  dns_header *v23; // rcx
  unsigned __int64 v24; // rdx
  _BYTE *v25; // rsi
  char *v26; // rbx
  int v27; // r13d
  char *v28; // r12
  unsigned __int64 v29; // rax
  _BYTE *v30; // rsi
  unsigned __int64 v31; // r14
  __int16 v32; // r13
  unsigned __int16 v33; // bx
  dns_header *v34; // r14
  _WORD *v35; // rbp
  signed __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  size_t v38; // rbx
  void *v39; // rax
  __int16 v40; // bx
  __int64 v41; // rax
  __m128i v42; // xmm0
  __m128i v43; // xmm0
  __int64 v44; // rax
  __int64 v45; // rbp
  int v46; // eax
  char *v47; // rdi
  unsigned int v48; // [rsp+4h] [rbp-84h]
  __int16 v49; // [rsp+8h] [rbp-80h]
  __int16 v50; // [rsp+Ch] [rbp-7Ch]
  void *ptr; // [rsp+10h] [rbp-78h]
  __int16 v52; // [rsp+18h] [rbp-70h]
  int is_last; // [rsp+1Ch] [rbp-6Ch] BYREF
  unsigned __int64 v54; // [rsp+20h] [rbp-68h]
  unsigned __int8 *v55; // [rsp+28h] [rbp-60h]
  unsigned __int64 v56; // [rsp+30h] [rbp-58h]
  dns_header *v57; // [rsp+38h] [rbp-50h]
  void *src; // [rsp+40h] [rbp-48h]
  unsigned __int8 *v59; // [rsp+48h] [rbp-40h] BYREF
  int is_sign[13]; // [rsp+54h] [rbp-34h] BYREF

  v56 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v59, is_sign, &is_last);
  if ( is_sign[0] )
    return v56;
  v54 = 0LL;
  src = opt;
  v55 = limit;
  v48 = optno;
  HIBYTE(v17) = 0;
  LOBYTE(v14) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v17) = set_do != 0;
    v52 = v17 << 15;
    ptr = 0LL;
    v32 = 0;
    v33 = udp_sz;
    v34 = header;
    v15 = v56;
    goto LABEL_30;
  }
  v18 = v59;
  v19 = *(_WORD *)v59;
  v20 = *((_WORD *)v59 + 1);
  v21 = __ROL2__(*((_WORD *)v59 + 2), 8);
  if ( set_do )
  {
    v21 |= 0x8000u;
    v59[4] = HIBYTE(v21);
  }
  v22 = v48;
  v23 = header;
  v15 = v56;
  if ( !v48 )
    return v15;
  v50 = v20;
  v24 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v18 + 3) << 48);
  v25 = v18 + 8;
  if ( v24 + v18 + 8 - (unsigned __int8 *)header > v56 )
    return v15;
  v57 = header;
  v52 = v21;
  v49 = v19;
  if ( (unsigned int)v24 >= 5 )
  {
    v26 = (char *)(v18 + 8);
    v27 = 0;
    LODWORD(v23) = 4;
    v28 = (char *)(v18 + 8);
    while ( 1 )
    {
      v29 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v26 + 1) << 48);
      if ( (int)v29 + (int)v23 > (int)v24 )
        break;
      v30 = v26 + 4;
      if ( _byteswap_ulong(*(unsigned __int16 *)v26 << 16) == (_DWORD)v22 )
      {
        if ( !replace )
          return v15;
        v25 = &v30[v29];
        v31 = (unsigned int)(v24 - v29 - 4);
        memcpy(v26, v25, (int)v31 - v27);
        v24 = v31;
        v22 = v48;
        *((_WORD *)v18 + 3) = __ROL2__(v31, 8);
      }
      else
      {
        v25 = &v30[(unsigned int)v29];
        v27 += v29 + 4;
        v26 = v25;
      }
      v23 = (dns_header *)(unsigned int)(v27 + 4);
      if ( (int)v23 >= (int)v24 )
        goto LABEL_20;
    }
    is_last = 0;
    v54 = 0LL;
    ptr = 0LL;
    v40 = v49;
    v34 = v57;
    goto LABEL_29;
  }
  v28 = (char *)(v18 + 8);
  v26 = (char *)(v18 + 8);
LABEL_20:
  v34 = v57;
  if ( !is_last )
  {
    if ( (_DWORD)v24 )
    {
      v54 = v24;
      v38 = (int)v24;
      v39 = (void *)whine_malloc((int)v24, v25, v24, v23, v22);
      if ( v39 )
      {
        ptr = v39;
        memcpy(v39, v28, v38);
LABEL_28:
        v40 = v49;
LABEL_29:
        v33 = __ROL2__(v40, 8);
        v32 = __ROL2__(v50, 8);
        v15 = rrfilter(v34, v15, 0LL);
LABEL_30:
        v41 = skip_questions(v34, v15, v14);
        if ( !v41 )
          return v15;
        v42 = _mm_cvtsi32_si128(*(_DWORD *)&v34->ancount);
        v43 = _mm_unpacklo_epi16(_mm_or_si128(_mm_slli_epi16(v42, 8u), _mm_srli_epi16(v42, 8u)), (__m128i)0LL);
        v44 = skip_section(
                v41,
                _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v43, 229), v43))
              + (unsigned int)(unsigned __int16)__ROL2__(v34->arcount, 8),
                v34,
                v15);
        if ( !v44 )
          return v15;
        v45 = v44;
        v28 = (char *)(v44 + 11);
        v37 = (unsigned __int64)v55;
        if ( v44 + 11 > (unsigned __int64)v55 )
          return v15;
        *(_WORD *)v44 = 0;
        *(_BYTE *)(v44 + 2) = 41;
        *(_BYTE *)(v44 + 3) = HIBYTE(v33);
        *(_BYTE *)(v44 + 4) = v33;
        *(_BYTE *)(v44 + 5) = HIBYTE(v32);
        *(_BYTE *)(v44 + 6) = v32;
        *(_BYTE *)(v44 + 7) = HIBYTE(v52);
        *(_BYTE *)(v44 + 8) = v52;
        v46 = v54;
        *(_BYTE *)(v45 + 9) = BYTE1(v54);
        *(_BYTE *)(v45 + 10) = v46;
        v26 = v28;
        if ( ptr )
        {
          v26 = &v28[v46];
          if ( (unsigned __int64)v26 > v37 )
          {
            free(ptr);
            return v15;
          }
          memcpy(v28, ptr, v46);
          free(ptr);
          v37 = (unsigned __int64)v55;
        }
        v35 = (_WORD *)(v45 + 9);
        v36 = optlen;
        if ( (__int64)(v37 - (_QWORD)v26 - 4) >= (__int64)optlen )
          v34->arcount = __ROL2__(__ROL2__(v34->arcount, 8) + 1, 8);
        LODWORD(v22) = v48;
        goto LABEL_40;
      }
    }
    else
    {
      v54 = 0LL;
    }
    ptr = 0LL;
    goto LABEL_28;
  }
  v35 = v18 + 6;
  v36 = optlen;
  v37 = (unsigned __int64)v55;
LABEL_40:
  v47 = v26 + 4;
  if ( (__int64)(v37 - (_QWORD)(v26 + 4)) < v36 )
    return v15;
  if ( !(_DWORD)v22 || replace == 2 )
    return v26 - (char *)v34;
  if ( (unsigned __int64)v47 <= v37 )
  {
    *v26 = BYTE1(v22);
    v26[1] = v22;
    v26[2] = BYTE1(v36);
    v26[3] = v36;
    v26 = &v47[v36];
    if ( (unsigned __int64)&v47[v36] <= v37 )
    {
      memcpy(v47, src, v36);
      *v35 = __ROL2__((_WORD)v26 - (_WORD)v28, 8);
      return v26 - (char *)v34;
    }
  }
  return v15;
}
