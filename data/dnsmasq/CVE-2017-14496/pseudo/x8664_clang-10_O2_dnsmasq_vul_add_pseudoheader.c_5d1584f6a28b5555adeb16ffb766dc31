size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v13; // r14
  unsigned __int8 *pseudoheader; // rax
  __int64 v16; // rdx
  __int16 v18; // si
  unsigned __int8 *v19; // rsi
  __int16 v20; // ax
  __int16 v21; // dx
  unsigned __int64 v22; // rdx
  unsigned __int8 *v23; // r13
  int v24; // ebp
  unsigned __int8 *v25; // rdi
  unsigned __int64 v26; // rax
  char *v27; // rsi
  unsigned __int64 v28; // r12
  unsigned __int8 *v29; // rsi
  _WORD *v30; // rbp
  __int16 v31; // dx
  size_t v32; // rbx
  void *v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  int v36; // ecx
  __int64 v37; // rbp
  __int64 v38; // rbp
  __int64 v39; // rdi
  __int16 v40; // bx
  int v41; // [rsp+4h] [rbp-84h]
  __int16 v42; // [rsp+8h] [rbp-80h]
  __int16 v43; // [rsp+8h] [rbp-80h]
  __int64 v44; // [rsp+8h] [rbp-80h]
  __int16 v45; // [rsp+14h] [rbp-74h]
  unsigned __int8 *v46; // [rsp+18h] [rbp-70h]
  unsigned __int8 *v47; // [rsp+20h] [rbp-68h]
  void *ptr; // [rsp+28h] [rbp-60h]
  __int16 v49; // [rsp+30h] [rbp-58h]
  int is_last; // [rsp+34h] [rbp-54h] BYREF
  void *src; // [rsp+38h] [rbp-50h]
  unsigned __int64 v52; // [rsp+40h] [rbp-48h]
  int is_sign; // [rsp+4Ch] [rbp-3Ch] BYREF
  unsigned __int8 *v54; // [rsp+50h] [rbp-38h] BYREF

  v13 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v54, &is_sign, &is_last);
  if ( is_sign )
    return v13;
  v52 = 0LL;
  HIBYTE(v18) = 0;
  LOBYTE(v16) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v18) = set_do != 0;
    v49 = v18 << 15;
    ptr = 0LL;
    v43 = 0;
    goto LABEL_27;
  }
  v19 = v54;
  v20 = *(_WORD *)v54;
  v42 = *((_WORD *)v54 + 1);
  v21 = __ROL2__(*((_WORD *)v54 + 2), 8);
  if ( set_do )
  {
    v21 |= 0x8000u;
    v54[4] = HIBYTE(v21);
  }
  if ( optno )
  {
    v49 = v21;
    v45 = v20;
    v22 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v19 + 3) << 48);
    if ( v22 + v19 + 8 - (unsigned __int8 *)header <= v13 )
    {
      v46 = opt;
      v23 = v19;
      v47 = limit;
      v41 = optno;
      src = v19 + 8;
      if ( (unsigned int)v22 < 5 )
      {
        v25 = v19 + 8;
LABEL_18:
        if ( is_last )
        {
          v29 = v46;
          v30 = v23 + 6;
          limit = v47;
          v31 = (__int16)src;
LABEL_33:
          if ( limit - (v25 + 4) >= (__int64)optlen )
          {
            if ( v41 && replace != 2 )
            {
              *v25 = BYTE1(v41);
              v25[1] = v41;
              v25[2] = BYTE1(optlen);
              v25[3] = optlen;
              v40 = v31;
              memcpy(v25 + 4, v29, optlen);
              *v30 = __ROL2__(optlen + (_WORD)v25 + 4 - v40, 8);
              v25 += optlen + 4;
            }
            return v25 - (unsigned __int8 *)header;
          }
          return v13;
        }
        if ( (_DWORD)v22 )
        {
          v52 = v22;
          v32 = (int)v22;
          v33 = (void *)whine_malloc((int)v22);
          if ( v33 )
          {
            ptr = v33;
            memcpy(v33, src, v32);
LABEL_26:
            optno = v41;
            limit = v47;
            opt = v46;
            udp_sz = __ROL2__(v45, 8);
            v43 = __ROL2__(v42, 8);
            v13 = rrfilter(header, v13, 0LL);
LABEL_27:
            v34 = skip_questions(header, v13, v16);
            if ( !v34 )
              return v13;
            v35 = skip_section(
                    v34,
                    (unsigned __int16)__ROL2__(header->ancount, 8)
                  + (unsigned __int16)__ROL2__(header->nscount, 8)
                  + (unsigned int)(unsigned __int16)__ROL2__(header->arcount, 8),
                    header,
                    v13);
            if ( !v35 )
              return v13;
            v41 = optno;
            *(_WORD *)v35 = 0;
            *(_BYTE *)(v35 + 2) = 41;
            *(_BYTE *)(v35 + 3) = HIBYTE(udp_sz);
            *(_BYTE *)(v35 + 4) = udp_sz;
            *(_BYTE *)(v35 + 5) = HIBYTE(v43);
            *(_BYTE *)(v35 + 6) = v43;
            *(_BYTE *)(v35 + 7) = HIBYTE(v49);
            *(_BYTE *)(v35 + 8) = v49;
            v36 = v52;
            *(_BYTE *)(v35 + 9) = BYTE1(v52);
            *(_BYTE *)(v35 + 10) = v36;
            v31 = v35 + 11;
            v25 = (unsigned __int8 *)(v35 + 11);
            v37 = v35;
            if ( ptr )
            {
              v44 = v35;
              v38 = v36;
              src = (void *)(v35 + 11);
              memcpy((void *)(v35 + 11), ptr, v36);
              free(ptr);
              v31 = (__int16)src;
              v39 = v38;
              v37 = v44;
              v25 = (unsigned __int8 *)src + v39;
            }
            v30 = (_WORD *)(v37 + 9);
            v29 = opt;
            if ( limit - v25 - 4 >= (__int64)optlen )
              header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
            goto LABEL_33;
          }
LABEL_25:
          ptr = 0LL;
          goto LABEL_26;
        }
      }
      else
      {
        v24 = 0;
        v25 = v19 + 8;
        while ( 1 )
        {
          v26 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v25 + 1) << 48);
          if ( (int)v26 + v24 > (int)v22 )
            break;
          v27 = (char *)(v25 + 4);
          if ( _byteswap_ulong(*(unsigned __int16 *)v25 << 16) == optno )
          {
            if ( !replace )
              return v13;
            v28 = (unsigned int)(v22 - v26 - 4);
            memcpy(v25, &v27[v26], (int)v28 - v24);
            v22 = v28;
            *((_WORD *)v23 + 3) = __ROL2__(v28, 8);
          }
          else
          {
            v24 += v26 + 4;
            v25 = (unsigned __int8 *)&v27[(unsigned int)v26];
          }
          if ( v24 + 4 >= (int)v22 )
            goto LABEL_18;
        }
        is_last = 0;
      }
      v52 = 0LL;
      goto LABEL_25;
    }
  }
  return v13;
}
