int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        signed int optlen,
        int set_do,
        int replace)
{
  int v9; // ebp
  dns_header *v10; // esi
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // bx
  unsigned __int8 *v14; // edi
  __int16 v15; // dx
  __int16 v16; // bx
  __int16 v17; // ax
  signed int v18; // ebx
  int v19; // esi
  int v20; // ebp
  int v21; // ecx
  unsigned __int32 v22; // eax
  int v23; // ecx
  signed int v24; // edx
  unsigned __int8 *v25; // ebx
  _WORD *v26; // edi
  size_t v27; // esi
  void *v28; // eax
  void *v29; // edi
  int v30; // eax
  int v31; // edx
  unsigned __int32 v32; // ecx
  int v33; // eax
  int v34; // eax
  char *v35; // ecx
  int v36; // edi
  unsigned __int8 *v37; // eax
  size_t v38; // [esp-Ch] [ebp-48h]
  __int16 v39; // [esp+Eh] [ebp-2Eh]
  void *ptr; // [esp+10h] [ebp-2Ch]
  __int16 v42; // [esp+14h] [ebp-28h]
  __int16 v43; // [esp+14h] [ebp-28h]
  void *src; // [esp+18h] [ebp-24h]
  __int16 v45; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v48; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v48, &is_sign, &is_last);
  if ( is_sign )
    return v9;
  HIBYTE(v13) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    ptr = 0;
    v43 = 0;
    v45 = v13 << 15;
    v18 = 0;
    goto LABEL_31;
  }
  v14 = v48;
  v15 = *(_WORD *)v48;
  v16 = *((_WORD *)v48 + 1);
  v17 = __ROL2__(*((_WORD *)v48 + 2), 8);
  if ( set_do )
  {
    v17 |= 0x8000u;
    v48[4] = HIBYTE(v17);
  }
  if ( optno )
  {
    v42 = v16;
    v45 = v17;
    v18 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
    if ( v18 + v14 + 8 - (unsigned __int8 *)header <= plen )
    {
      v39 = v15;
      src = v14 + 8;
      if ( (unsigned int)v18 < 5 )
      {
        v19 = (int)(v14 + 8);
LABEL_18:
        if ( is_last )
        {
          v9 = plen;
          v24 = optlen;
          v25 = limit;
          v26 = v14 + 6;
          goto LABEL_40;
        }
        v27 = plen;
        if ( v18 )
        {
          ptr = 0;
          v28 = (void *)whine_malloc(v18);
          if ( v28 )
          {
            v29 = v28;
            memcpy(v28, src, v18);
            ptr = v29;
          }
        }
        else
        {
          ptr = 0;
          v18 = 0;
        }
      }
      else
      {
        if ( replace )
        {
          v19 = (int)(v14 + 8);
          v20 = 0;
          v21 = 4;
          while ( 1 )
          {
            v22 = _byteswap_ulong(*(unsigned __int16 *)(v19 + 2) << 16);
            if ( (int)(v22 + v21) > v18 )
              break;
            v23 = v19 + 4;
            if ( _byteswap_ulong(*(unsigned __int16 *)v19 << 16) == optno )
            {
              v18 = v18 - v22 - 4;
              memcpy((void *)v19, (const void *)(v22 + v23), v18 - v20);
              *((_WORD *)v14 + 3) = __ROL2__(v18, 8);
              v21 = v20 + 4;
              if ( v20 + 4 >= v18 )
                goto LABEL_18;
            }
            else
            {
              v20 += v22 + 4;
              v19 = v22 + v23;
              v21 = v20 + 4;
              if ( v20 + 4 >= v18 )
                goto LABEL_18;
            }
          }
        }
        else
        {
          v30 = 0;
          v31 = 4;
          v19 = (int)(v14 + 8);
          while ( 1 )
          {
            v32 = _byteswap_ulong(*(unsigned __int16 *)(v19 + 2) << 16);
            if ( (int)(v32 + v31) > v18 )
              break;
            if ( _byteswap_ulong(*(unsigned __int16 *)v19 << 16) == optno )
              return plen;
            v31 = v30 + v32 + 8;
            v30 += v32 + 4;
            v19 += v32 + 4;
            if ( v31 >= v18 )
              goto LABEL_18;
          }
        }
        v27 = plen;
        is_last = 0;
        v18 = 0;
        ptr = 0;
      }
      udp_sz = __ROL2__(v39, 8);
      v43 = __ROL2__(v42, 8);
      v38 = v27;
      v10 = header;
      v9 = rrfilter(header, v38, 0);
LABEL_31:
      v33 = skip_questions(v10, v9);
      if ( !v33 )
        return v9;
      v34 = skip_section(
              v33,
              (unsigned __int16)__ROL2__(v10->ancount, 8)
            + (unsigned __int16)__ROL2__(v10->nscount, 8)
            + (unsigned __int16)__ROL2__(v10->arcount, 8),
              v10,
              v9);
      if ( !v34 )
        return v9;
      v35 = (char *)(v34 + 11);
      v36 = v34;
      if ( v34 + 11 > (unsigned int)limit )
        return v9;
      *(_WORD *)v34 = 0;
      *(_BYTE *)(v34 + 2) = 41;
      v19 = v34 + 11;
      LOWORD(src) = v34 + 11;
      *(_BYTE *)(v34 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v34 + 4) = udp_sz;
      *(_BYTE *)(v34 + 5) = HIBYTE(v43);
      *(_BYTE *)(v34 + 6) = v43;
      *(_BYTE *)(v34 + 7) = HIBYTE(v45);
      *(_BYTE *)(v34 + 8) = v45;
      *(_BYTE *)(v34 + 9) = BYTE1(v18);
      *(_BYTE *)(v34 + 10) = v18;
      if ( ptr )
      {
        v19 = (int)&v35[v18];
        if ( &v35[v18] > (char *)limit )
        {
          free(ptr);
          return v9;
        }
        memcpy(v35, ptr, v18);
        free(ptr);
      }
      v25 = limit;
      v24 = optlen;
      v26 = (_WORD *)(v36 + 9);
      if ( (int)&limit[-v19 - 4] >= optlen )
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_40:
      v37 = (unsigned __int8 *)(v19 + 4);
      if ( (int)&v25[-v19 - 4] < v24 )
        return v9;
      if ( optno && replace != 2 )
      {
        if ( v37 > v25 )
          return v9;
        *(_BYTE *)v19 = BYTE1(optno);
        *(_BYTE *)(v19 + 1) = optno;
        *(_BYTE *)(v19 + 2) = BYTE1(v24);
        *(_BYTE *)(v19 + 3) = v24;
        v19 = (int)&v37[v24];
        if ( &v37[v24] > v25 )
          return v9;
        memcpy(v37, opt, v24);
        *v26 = __ROL2__(v19 - (_WORD)src, 8);
      }
      return v19 - (_DWORD)header;
    }
  }
  return v9;
}
