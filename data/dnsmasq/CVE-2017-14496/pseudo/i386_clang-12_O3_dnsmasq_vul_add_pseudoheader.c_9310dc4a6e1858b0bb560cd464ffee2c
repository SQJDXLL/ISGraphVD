int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        int optlen,
        int set_do,
        int replace)
{
  int v9; // esi
  dns_header *v10; // ebp
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // bx
  unsigned __int8 *v14; // edi
  __int16 v15; // ax
  signed int v16; // ebx
  int v17; // ebp
  unsigned __int16 *v18; // esi
  unsigned __int32 v19; // eax
  unsigned __int16 *v20; // ecx
  _WORD *v21; // edi
  __int16 v22; // cx
  void *v23; // eax
  size_t v24; // esi
  void *v25; // edi
  int v26; // eax
  unsigned __int32 v27; // ecx
  int v28; // edx
  int v29; // eax
  __m128i v30; // xmm0
  __m128i v31; // xmm0
  int v32; // eax
  int v33; // edi
  char *v34; // ebx
  unsigned __int16 *v35; // ebx
  __int16 v36; // [esp+Ah] [ebp-32h]
  void *dest; // [esp+Ch] [ebp-30h]
  __int16 desta; // [esp+Ch] [ebp-30h]
  __int16 v40; // [esp+10h] [ebp-2Ch]
  __int16 v41; // [esp+10h] [ebp-2Ch]
  void *src; // [esp+14h] [ebp-28h]
  size_t v43; // [esp+18h] [ebp-24h]
  __int16 v44; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v47; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v47, &is_sign, &is_last);
  if ( is_sign )
    return v9;
  HIBYTE(v13) = 0;
  if ( pseudoheader )
  {
    v14 = v47;
    v15 = __ROL2__(*((_WORD *)v47 + 2), 8);
    if ( set_do )
    {
      v15 |= 0x8000u;
      v47[4] = HIBYTE(v15);
    }
    v43 = plen;
    if ( !optno )
      return v43;
    v44 = v15;
    v16 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
    if ( v16 + v14 + 8 - (unsigned __int8 *)header > plen )
      return v43;
    dest = v14 + 8;
    v36 = *(_WORD *)v14;
    v40 = *((_WORD *)v14 + 1);
    if ( (unsigned int)v16 < 5 )
    {
      v18 = (unsigned __int16 *)(v14 + 8);
LABEL_19:
      v10 = header;
      if ( is_last )
      {
        v21 = v14 + 6;
        v22 = (__int16)dest;
LABEL_39:
        v34 = (char *)(v18 + 2);
        if ( limit - (unsigned __int8 *)(v18 + 2) < optlen )
          return v43;
        if ( optno && replace != 2 )
        {
          desta = v22;
          *(_BYTE *)v18 = BYTE1(optno);
          *((_BYTE *)v18 + 1) = optno;
          *((_BYTE *)v18 + 2) = BYTE1(optlen);
          *((_BYTE *)v18 + 3) = optlen;
          memcpy(v34, opt, optlen);
          v35 = (unsigned __int16 *)&v34[optlen];
          *v21 = __ROL2__((_WORD)v35 - desta, 8);
          v18 = v35;
        }
        return (char *)v18 - (char *)v10;
      }
      src = 0;
      if ( v16 )
      {
        v23 = (void *)whine_malloc(v16);
        v24 = plen;
        if ( v23 )
        {
          v25 = v23;
          memcpy(v23, dest, v16);
          src = v25;
        }
        goto LABEL_32;
      }
      v16 = 0;
    }
    else
    {
      if ( replace )
      {
        v17 = 0;
        v18 = (unsigned __int16 *)(v14 + 8);
        while ( 1 )
        {
          v19 = _byteswap_ulong(v18[1] << 16);
          if ( (int)(v19 + v17) > v16 )
            break;
          v20 = v18 + 2;
          if ( _byteswap_ulong(*v18 << 16) == optno )
          {
            v16 = v16 - v19 - 4;
            memcpy(v18, (char *)v20 + v19, v16 - v17);
            *((_WORD *)v14 + 3) = __ROL2__(v16, 8);
            if ( v17 + 4 >= v16 )
              goto LABEL_19;
          }
          else
          {
            v17 += v19 + 4;
            v18 = (unsigned __int16 *)((char *)v20 + v19);
            if ( v17 + 4 >= v16 )
              goto LABEL_19;
          }
        }
      }
      else
      {
        v26 = 0;
        v18 = (unsigned __int16 *)(v14 + 8);
        while ( 1 )
        {
          v27 = _byteswap_ulong(v18[1] << 16);
          if ( (int)(v27 + v26) > v16 )
            break;
          if ( _byteswap_ulong(*v18 << 16) == optno )
            return v43;
          v18 = (unsigned __int16 *)((char *)v18 + v27 + 4);
          v28 = v26 + v27 + 8;
          v26 += v27 + 4;
          if ( v28 >= v16 )
            goto LABEL_19;
        }
      }
      is_last = 0;
      v16 = 0;
      src = 0;
      v10 = header;
    }
    v24 = plen;
LABEL_32:
    udp_sz = __ROL2__(v36, 8);
    v41 = __ROL2__(v40, 8);
    v9 = rrfilter(v10, v24, 0);
    goto LABEL_33;
  }
  LOBYTE(v13) = set_do != 0;
  v44 = v13 << 15;
  src = 0;
  v16 = 0;
  v41 = 0;
LABEL_33:
  v29 = skip_questions(v10, v9);
  v43 = v9;
  if ( v29 )
  {
    v30 = _mm_cvtsi32_si128(*(_DWORD *)&v10->ancount);
    v31 = _mm_or_si128(_mm_slli_epi16(v30, 8u), _mm_srli_epi16(v30, 8u));
    v32 = skip_section(
            v29,
            _mm_cvtsi128_si32(_mm_add_epi32(_mm_srli_epi32(v31, 0x10u), _mm_unpacklo_epi16(v31, (__m128i)0LL)))
          + (unsigned __int16)__ROL2__(v10->arcount, 8),
            v10,
            v9);
    if ( v32 )
    {
      v33 = v32;
      *(_WORD *)v32 = 0;
      *(_BYTE *)(v32 + 2) = 41;
      *(_BYTE *)(v32 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v32 + 4) = udp_sz;
      *(_BYTE *)(v32 + 5) = HIBYTE(v41);
      *(_BYTE *)(v32 + 6) = v41;
      *(_BYTE *)(v32 + 7) = HIBYTE(v44);
      *(_BYTE *)(v32 + 8) = v44;
      *(_BYTE *)(v32 + 9) = BYTE1(v16);
      *(_BYTE *)(v32 + 10) = v16;
      v22 = v32 + 11;
      v18 = (unsigned __int16 *)(v32 + 11);
      if ( src )
      {
        memcpy((void *)(v32 + 11), src, v16);
        free(src);
        v22 = v33 + 11;
        v18 = (unsigned __int16 *)(v33 + 11 + v16);
      }
      v21 = (_WORD *)(v33 + 9);
      if ( limit - (unsigned __int8 *)v18 - 4 >= optlen )
        v10->arcount = __ROL2__(__ROL2__(v10->arcount, 8) + 1, 8);
      goto LABEL_39;
    }
  }
  return v43;
}
