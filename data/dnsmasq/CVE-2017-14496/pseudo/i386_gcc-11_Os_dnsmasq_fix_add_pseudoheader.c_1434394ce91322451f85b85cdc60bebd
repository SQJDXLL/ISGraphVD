size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *v10; // eax
  __int16 v11; // dx
  unsigned __int16 v12; // dx
  unsigned __int8 *v13; // edx
  unsigned __int16 v14; // cx
  unsigned __int16 v15; // si
  int v16; // esi
  __int16 v17; // cx
  unsigned __int8 *v18; // eax
  __int16 v19; // si
  size_t v20; // eax
  u16 v21; // ax
  char v22; // t1
  unsigned int v23; // eax
  __int16 v24; // cx
  unsigned __int8 *v25; // edi
  __int16 v26; // ax
  unsigned __int16 v27; // cx
  unsigned __int16 v28; // ax
  unsigned __int16 v29; // dx
  int v30; // eax
  __int16 v31; // cx
  __int16 v33; // [esp+6h] [ebp-46h]
  __int16 v34; // [esp+8h] [ebp-44h]
  unsigned __int8 *v35; // [esp+8h] [ebp-44h]
  __int16 flags; // [esp+Ch] [ebp-40h]
  _WORD *flagsa; // [esp+Ch] [ebp-40h]
  unsigned __int8 *datap; // [esp+14h] [ebp-38h]
  unsigned __int8 *datapa; // [esp+14h] [ebp-38h]
  unsigned __int8 *i; // [esp+18h] [ebp-34h]
  int ia; // [esp+18h] [ebp-34h]
  signed int rdlen; // [esp+20h] [ebp-2Ch]
  unsigned __int8 *t_cp; // [esp+24h] [ebp-28h] BYREF
  int is_sign; // [esp+28h] [ebp-24h] BYREF
  int is_last[8]; // [esp+2Ch] [ebp-20h] BYREF

  is_last[1] = __readgsdword(0x14u);
  i = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( i )
  {
    v10 = t_cp;
    v33 = *(_WORD *)t_cp;
    v34 = *((_WORD *)t_cp + 1);
    flags = __ROL2__(*((_WORD *)t_cp + 2), 8);
    if ( set_do )
    {
      flags |= 0x8000u;
      LOBYTE(v11) = HIBYTE(flags);
      HIBYTE(v11) = flags;
      *((_WORD *)t_cp + 2) = v11;
    }
    HIBYTE(v12) = *((_WORD *)v10 + 3);
    LOBYTE(v12) = HIBYTE(*((_WORD *)v10 + 3));
    rdlen = v12;
    datap = v10 + 8;
    if ( (unsigned int)v12 + v10 + 8 - (unsigned __int8 *)header > plen || !optno )
      return plen;
    ia = 0;
    v13 = v10 + 8;
    while ( ia + 4 < rdlen )
    {
      v15 = __ROL2__(*((_WORD *)v13 + 1), 8);
      if ( v15 + ia + 4 > rdlen )
      {
        is_last[0] = 0;
        rdlen = 0;
        i = 0;
        goto LABEL_20;
      }
      LOBYTE(v14) = HIBYTE(*(_WORD *)v13);
      HIBYTE(v14) = *(_WORD *)v13;
      if ( v14 == optno )
      {
        if ( !replace )
          return plen;
        v16 = v15 + 4;
        rdlen -= v16;
        qmemcpy(v13, &v13[v16], rdlen - ia);
        LOBYTE(v17) = BYTE1(rdlen);
        HIBYTE(v17) = rdlen;
        *((_WORD *)v10 + 3) = v17;
      }
      else
      {
        v13 += v15 + 4;
        ia += v15 + 4;
      }
    }
    if ( is_last[0] )
    {
      flagsa = v10 + 6;
      goto LABEL_24;
    }
    i = 0;
    if ( rdlen )
    {
      v18 = (unsigned __int8 *)whine_malloc(rdlen);
      i = v18;
      if ( v18 )
        qmemcpy(v18, datap, rdlen);
    }
LABEL_20:
    udp_sz = __ROL2__(v33, 8);
    v19 = __ROL2__(v34, 8);
    v20 = rrfilter(header, plen, 0, v13);
    plen = v20;
  }
  else
  {
    v19 = 0;
    v20 = (set_do != 0) << 15;
    flags = (set_do != 0) << 15;
  }
  datapa = (unsigned __int8 *)skip_questions(header, plen, v20, v20);
  if ( datapa )
  {
    HIBYTE(v27) = header->ancount;
    LOBYTE(v27) = HIBYTE(header->ancount);
    HIBYTE(v28) = header->nscount;
    LOBYTE(v28) = HIBYTE(header->nscount);
    HIBYTE(v29) = header->arcount;
    LOBYTE(v29) = HIBYTE(header->arcount);
    v30 = skip_section(datapa, v29 + v27 + v28, header, plen);
    if ( v30 )
    {
      if ( (unsigned int)limit >= v30 + 11 )
      {
        *(_WORD *)v30 = 0;
        *(_WORD *)(v30 + 3) = __ROL2__(udp_sz, 8);
        LOBYTE(v31) = HIBYTE(flags);
        HIBYTE(v31) = flags;
        *(_BYTE *)(v30 + 2) = 41;
        *(_WORD *)(v30 + 5) = __ROL2__(v19, 8);
        flagsa = (_WORD *)(v30 + 9);
        datap = (unsigned __int8 *)(v30 + 11);
        *(_WORD *)(v30 + 7) = v31;
        LOBYTE(v31) = BYTE1(rdlen);
        HIBYTE(v31) = rdlen;
        *(_WORD *)(v30 + 9) = v31;
        if ( i )
        {
          if ( rdlen + v30 + 11 > (unsigned int)limit )
          {
            free(i);
            return plen;
          }
          v35 = (unsigned __int8 *)(rdlen + v30 + 11);
          qmemcpy(datap, i, rdlen);
          free(i);
          v13 = v35;
        }
        else
        {
          v13 = (unsigned __int8 *)(v30 + 11);
        }
        if ( limit - (v13 + 4) >= (int)optlen )
        {
          HIBYTE(v21) = header->arcount;
          LOBYTE(v21) = HIBYTE(header->arcount);
          ++v21;
          v22 = HIBYTE(v21);
          HIBYTE(v21) = v21;
          LOBYTE(v21) = v22;
          header->arcount = v21;
        }
LABEL_24:
        v23 = (unsigned int)(v13 + 4);
        if ( limit - (v13 + 4) >= (int)optlen )
        {
          if ( !optno || replace == 2 )
            return v13 - (unsigned __int8 *)header;
          if ( v23 <= (unsigned int)limit )
          {
            LOBYTE(v24) = BYTE1(optno);
            HIBYTE(v24) = optno;
            *(_WORD *)v13 = v24;
            LOBYTE(v24) = BYTE1(optlen);
            HIBYTE(v24) = optlen;
            *((_WORD *)v13 + 1) = v24;
            v13 = (unsigned __int8 *)(v23 + optlen);
            if ( v23 + optlen <= (unsigned int)limit )
            {
              v25 = (unsigned __int8 *)v23;
              HIBYTE(v26) = (_BYTE)v13 - (_BYTE)datap;
              LOBYTE(v26) = (unsigned __int16)((_WORD)v13 - (_WORD)datap) >> 8;
              qmemcpy(v25, opt, optlen);
              *flagsa = v26;
              return v13 - (unsigned __int8 *)header;
            }
          }
        }
      }
    }
  }
  return plen;
}
