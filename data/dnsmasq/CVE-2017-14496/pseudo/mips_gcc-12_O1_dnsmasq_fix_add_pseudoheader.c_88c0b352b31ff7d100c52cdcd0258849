size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v14; // $s4
  unsigned __int8 *pseudoheader; // $v0
  int v16; // $s7
  unsigned __int8 *v17; // $s2
  unsigned __int8 *v18; // $s2
  __int16 v19; // $a0
  __int16 v20; // $a2
  __int16 v21; // $v1
  __int16 v22; // $a1
  unsigned __int16 v23; // $v0
  int v24; // $s1
  char *v25; // $fp
  __int16 v26; // $v1
  unsigned __int8 *v27; // $a2
  int v28; // $v1
  int v29; // $a1
  int v30; // $a0
  int v31; // $s3
  unsigned __int8 *v32; // $s0
  int v33; // $a1
  unsigned int v34; // $a0
  _WORD *v35; // $s2
  unsigned __int8 *v36; // $v0
  int v37; // $a0
  int v38; // $v0
  int v39; // $s1
  u16 t_s; // [sp+2Ah] [-16h]
  u16 t_s_1; // [sp+2Eh] [-12h]
  unsigned __int8 *udp_len; // [sp+30h] [-10h] BYREF
  int is_sign; // [sp+34h] [-Ch] BYREF
  int is_last; // [sp+38h] [-8h] BYREF

  v14 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v14;
  v17 = pseudoheader;
  if ( !pseudoheader )
  {
    t_s = (set_do != 0) << 15;
    t_s_1 = 0;
LABEL_38:
    v37 = skip_questions(header, v14);
    if ( !v37 )
      return v14;
    v38 = skip_section(v37, header->ancount + header->nscount + header->arcount, header, v14);
    v39 = v38;
    if ( !v38 )
      return v14;
    v25 = (char *)(v38 + 0xB);
    if ( (unsigned int)limit < v38 + 0xB )
      return v14;
    *(_BYTE *)v38 = 0;
    *(_WORD *)(v38 + 1) = 41;
    *(_WORD *)(v38 + 3) = udp_sz;
    *(_WORD *)(v38 + 5) = t_s_1;
    *(_WORD *)(v38 + 7) = t_s;
    *(_WORD *)(v38 + 9) = v16;
    if ( v17 )
    {
      v32 = (unsigned __int8 *)&v25[v16];
      if ( limit < (unsigned __int8 *)&v25[v16] )
      {
        free(v17);
        return v14;
      }
      memcpy(v25, v17, v16);
      free(v17);
    }
    else
    {
      v32 = (unsigned __int8 *)(v38 + 0xB);
    }
    v34 = (unsigned int)(v32 + 4);
    if ( limit - (v32 + 4) < (int)optlen )
      return v14;
    ++header->arcount;
    v35 = (_WORD *)(v39 + 9);
    if ( !optno )
      return v32 - (unsigned __int8 *)header;
    goto LABEL_24;
  }
  v18 = udp_len;
  v19 = *udp_len;
  v20 = udp_len[1];
  v21 = udp_len[2];
  v22 = udp_len[3];
  v23 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  if ( set_do )
  {
    t_s = v23 | 0x8000;
    udp_len[4] = (unsigned __int16)(v23 | 0x8000) >> 8;
    v18[5] = v23;
  }
  else
  {
    t_s = v23;
  }
  v24 = (v18[6] << 8) | v18[7];
  v25 = (char *)(v18 + 8);
  if ( v14 < v18 + 8 - (unsigned __int8 *)header + v24 )
    return v14;
  v26 = v21 << 8;
  if ( !optno )
    return v14;
  udp_sz = (v19 << 8) | v20;
  t_s_1 = v26 | v22;
  v27 = v18 + 0xC;
  if ( v24 < 5 )
  {
    v32 = v18 + 8;
    if ( is_last )
    {
      v34 = (unsigned int)(v18 + 0xC);
      goto LABEL_22;
    }
    goto LABEL_28;
  }
  v28 = (v18[8] << 8) | v18[9];
  v29 = (v18[10] << 8) | v18[11];
  v30 = v29;
  if ( v24 < v29 + 4 )
  {
LABEL_11:
    is_last = 0;
    v17 = 0;
LABEL_12:
    v14 = rrfilter(header, v14, 0);
    goto LABEL_38;
  }
  v31 = 0;
  v32 = v18 + 8;
  while ( 1 )
  {
    if ( v28 == optno )
    {
      v33 = v29 + 4;
      if ( !replace )
        return v14;
      v24 -= v30 + 4;
      memcpy(v32, &v32[v33], v24 - v31);
      *((_WORD *)v18 + 3) = v24;
    }
    else
    {
      v32 = &v27[v29];
      v31 += v30 + 4;
    }
    v27 = v32 + 4;
    if ( v31 + 4 >= v24 )
      break;
    v28 = (*v32 << 8) | v32[1];
    v29 = (v32[2] << 8) | v32[3];
    v30 = v29;
    if ( v24 < v29 + v31 + 4 )
      goto LABEL_11;
  }
  if ( !is_last )
  {
LABEL_28:
    if ( v24 )
    {
      v36 = (unsigned __int8 *)whine_malloc(v24);
      v17 = v36;
      if ( v36 )
        memcpy(v36, v25, v24);
      v16 = v24;
    }
    else
    {
      v16 = 0;
      v17 = 0;
    }
    goto LABEL_12;
  }
  v16 = v24;
  if ( !v32 )
  {
    v17 = 0;
    goto LABEL_38;
  }
  v34 = (unsigned int)(v32 + 4);
LABEL_22:
  if ( (int)&limit[-v34] < (int)optlen )
    return v14;
  v35 = v18 + 6;
LABEL_24:
  if ( replace == 2 )
    return v32 - (unsigned __int8 *)header;
  if ( (unsigned int)limit >= v34 )
  {
    *(_WORD *)v32 = optno;
    *((_WORD *)v32 + 1) = optlen;
    v32 = (unsigned __int8 *)(v34 + optlen);
    if ( (unsigned int)limit >= v34 + optlen )
    {
      memcpy((void *)v34, opt, optlen);
      *v35 = (_WORD)v32 - (_WORD)v25;
      return v32 - (unsigned __int8 *)header;
    }
  }
  return v14;
}
