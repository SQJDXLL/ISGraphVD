int __usercall add_pseudoheader@<eax>(
        _WORD *a1@<ebp>,
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        signed int optlen,
        int set_do,
        int replace)
{
  dns_header *v10; // edi
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // dx
  unsigned __int8 *v14; // ebp
  __int16 v15; // bx
  unsigned __int32 v16; // ecx
  unsigned __int16 *v17; // esi
  unsigned __int32 v18; // eax
  int v19; // ebp
  int v20; // ecx
  unsigned __int16 *v21; // ebx
  signed int v22; // edx
  unsigned __int32 v23; // eax
  unsigned __int16 *v24; // esi
  int v25; // edi
  unsigned __int16 *v26; // ecx
  __int16 v27; // bx
  char v28; // cl
  int v29; // eax
  unsigned __int8 *v30; // ebp
  size_t v31; // edi
  void *v32; // eax
  void *v33; // ebx
  signed int v34; // edx
  unsigned __int8 *v35; // esi
  unsigned __int8 *v36; // eax
  unsigned __int8 *v37; // esi
  int v38; // eax
  dns_header *v39; // ebx
  int v40; // edi
  int v41; // ebp
  __uint16_t v42; // ax
  int v43; // eax
  int v44; // ebp
  char *v45; // esi
  unsigned __int8 *v46; // ebx
  int v47; // edx
  unsigned __int16 *v48; // esi
  __uint16_t v49; // ax
  __uint16_t v50; // ax
  void *ptr; // [esp+0h] [ebp-3Ch]
  __int16 v52; // [esp+6h] [ebp-36h]
  unsigned __int8 *v54; // [esp+8h] [ebp-34h]
  int v55; // [esp+8h] [ebp-34h]
  __int16 v56; // [esp+Ch] [ebp-30h]
  __int16 v57; // [esp+Ch] [ebp-30h]
  size_t n; // [esp+10h] [ebp-2Ch]
  __int16 v59; // [esp+14h] [ebp-28h]
  __int16 v60; // [esp+14h] [ebp-28h]
  size_t v61; // [esp+18h] [ebp-24h]
  void *src; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v65; // [esp+28h] [ebp-14h] BYREF

  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v65, &is_sign, &is_last);
  v61 = plen;
  if ( is_sign )
    return v61;
  HIBYTE(v13) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    v60 = 0;
    n = 0;
    ptr = 0;
    v26 = 0;
    v27 = v13 << 15;
    goto LABEL_29;
  }
  v14 = v65;
  v52 = *(_WORD *)v65;
  v59 = *((_WORD *)v65 + 1);
  v15 = __ROL2__(*((_WORD *)v65 + 2), 8);
  if ( set_do )
  {
    v15 |= 0x8000u;
    v65[4] = HIBYTE(v15);
  }
  v16 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
  v17 = (unsigned __int16 *)(v14 + 8);
  ptr = 0;
  src = v14 + 8;
  if ( !optno || v16 + (char *)v17 - (char *)header > plen )
    return v61;
  v18 = v16;
  v56 = v15;
  v54 = v14;
  if ( v16 < 5 )
  {
    v21 = (unsigned __int16 *)(v14 + 8);
    v22 = v16;
LABEL_20:
    v28 = 1;
    n = v22;
    if ( is_last )
    {
      v24 = v21;
      goto LABEL_22;
    }
    ptr = 0;
    if ( v22 )
    {
      v31 = v22;
      v32 = (void *)whine_malloc(v22);
      ptr = 0;
      if ( v32 )
      {
        v33 = v32;
        memcpy(v32, src, v31);
        ptr = v33;
      }
    }
    v10 = header;
    v29 = rrfilter(header, plen, 0);
    v27 = v56;
    v30 = v54;
    v24 = 0;
LABEL_28:
    udp_sz = __ROL2__(v52, 8);
    v60 = __ROL2__(v59, 8);
    v26 = v24;
    a1 = v30 + 6;
    v61 = v29;
LABEL_29:
    v34 = optlen;
    v35 = limit;
    if ( !v26 )
    {
      v57 = v27;
      v38 = skip_questions(v10, v61);
      if ( !v38 )
        return v61;
      v55 = v38;
      v39 = v10;
      v40 = _bswap_16(v10->ancount);
      v41 = v40 + _bswap_16(v39->nscount);
      v10 = v39;
      v42 = _bswap_16(v39->arcount);
      v43 = skip_section(v55, v41 + v42, v39, v61);
      if ( !v43 )
        return v61;
      v44 = v43;
      v45 = (char *)(v43 + 11);
      v46 = limit;
      if ( v43 + 11 > (unsigned int)limit )
        return v61;
      *(_WORD *)v43 = 0;
      *(_BYTE *)(v43 + 2) = 41;
      *(_BYTE *)(v43 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v43 + 4) = udp_sz;
      *(_BYTE *)(v43 + 5) = HIBYTE(v60);
      *(_BYTE *)(v43 + 6) = v60;
      *(_BYTE *)(v43 + 7) = HIBYTE(v57);
      *(_BYTE *)(v43 + 8) = v57;
      *(_BYTE *)(v43 + 9) = BYTE1(n);
      *(_BYTE *)(v43 + 10) = n;
      v47 = v43 + 11;
      if ( ptr )
      {
        if ( &v45[n] > (char *)limit )
        {
          free(ptr);
          return v61;
        }
        memcpy(v45, ptr, n);
        free(ptr);
        v47 = (int)&v45[n];
        v46 = limit;
      }
      a1 = (_WORD *)(v44 + 9);
      v26 = (unsigned __int16 *)v47;
      LOWORD(src) = (_WORD)v45;
      if ( (int)&v46[-v47 - 4] >= optlen )
      {
        v48 = (unsigned __int16 *)v47;
        v49 = _bswap_16(v10->arcount);
        v50 = _bswap_16(v49 + 1);
        v26 = v48;
        v10->arcount = v50;
      }
      v34 = optlen;
      v35 = v46;
    }
    v36 = (unsigned __int8 *)(v26 + 2);
    if ( v35 - (unsigned __int8 *)(v26 + 2) < v34 )
      return v61;
    if ( !optno || replace == 2 )
    {
      v37 = (unsigned __int8 *)v26;
    }
    else
    {
      if ( v36 > v35 )
        return v61;
      *(_BYTE *)v26 = BYTE1(optno);
      *((_BYTE *)v26 + 1) = optno;
      *((_BYTE *)v26 + 2) = BYTE1(v34);
      *((_BYTE *)v26 + 3) = v34;
      if ( &v36[v34] > v35 )
        return v61;
      v37 = &v36[v34];
      memcpy(v36, opt, v34);
      *a1 = __ROL2__((_WORD)v37 - (_WORD)src, 8);
    }
    return v37 - (unsigned __int8 *)v10;
  }
  v19 = 0;
  v20 = 4;
  v21 = v17;
  v22 = v18;
  while ( 1 )
  {
    v23 = _byteswap_ulong(v21[1] << 16);
    v24 = v21 + 2;
    if ( (int)(v23 + v20) > v22 )
    {
      is_last = 0;
      v22 = 0;
      v21 += 2;
      goto LABEL_20;
    }
    if ( _byteswap_ulong(*v21 << 16) == optno )
      break;
    v19 += v23 + 4;
    v21 = (unsigned __int16 *)((char *)v24 + v23);
LABEL_11:
    v20 = v19 + 4;
    if ( v19 + 4 >= v22 )
      goto LABEL_20;
  }
  if ( replace )
  {
    v25 = v22 - v23 - 4;
    memcpy(v21, (char *)v24 + v23, v25 - v19);
    v22 = v25;
    *((_WORD *)v54 + 3) = __ROL2__(v25, 8);
    goto LABEL_11;
  }
  n = v22;
  v28 = 0;
  ptr = 0;
LABEL_22:
  v29 = plen;
  v10 = header;
  v27 = v56;
  v30 = v54;
  if ( v28 )
    goto LABEL_28;
  return v61;
}
