size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *v10; // edx
  unsigned __int16 v11; // ax
  __int16 v12; // ax
  unsigned __int16 v13; // ax
  unsigned __int8 *v14; // eax
  int v15; // ebx
  unsigned __int16 v16; // cx
  unsigned __int16 v17; // si
  int v18; // esi
  __int16 v19; // cx
  unsigned __int8 *v20; // eax
  __int16 v21; // si
  size_t v22; // eax
  int v23; // ebx
  unsigned __int16 v24; // cx
  unsigned __int16 v25; // ax
  unsigned __int16 v26; // dx
  int v27; // eax
  __int16 v28; // dx
  __int16 v29; // cx
  unsigned __int8 *v30; // edi
  u16 v31; // cx
  char v32; // tt
  __int16 v33; // cx
  __int16 v35; // [esp-8h] [ebp-4Ch]
  __int16 v36; // [esp-6h] [ebp-4Ah]
  unsigned __int16 flags; // [esp+0h] [ebp-44h]
  unsigned __int8 *flagsa; // [esp+0h] [ebp-44h]
  unsigned __int8 *datap; // [esp+8h] [ebp-3Ch]
  unsigned __int8 *buff; // [esp+Ch] [ebp-38h]
  signed int rdlen; // [esp+14h] [ebp-30h]
  unsigned __int8 *t_cp; // [esp+18h] [ebp-2Ch] BYREF
  int is_sign; // [esp+1Ch] [ebp-28h] BYREF
  int is_last[9]; // [esp+20h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  buff = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( buff )
  {
    v10 = t_cp;
    v35 = *(_WORD *)t_cp;
    v36 = *((_WORD *)t_cp + 1);
    HIBYTE(v11) = *((_WORD *)t_cp + 2);
    LOBYTE(v11) = HIBYTE(*((_WORD *)t_cp + 2));
    flags = v11;
    if ( set_do )
    {
      flags = v11 | 0x8000;
      LOBYTE(v12) = (unsigned __int16)(v11 | 0x8000) >> 8;
      HIBYTE(v12) = HIBYTE(*((_WORD *)t_cp + 2));
      *((_WORD *)t_cp + 2) = v12;
    }
    HIBYTE(v13) = *((_WORD *)v10 + 3);
    LOBYTE(v13) = HIBYTE(*((_WORD *)v10 + 3));
    rdlen = v13;
    datap = v10 + 8;
    if ( (unsigned int)v13 + v10 + 8 - (unsigned __int8 *)header > plen || !optno )
      return plen;
    v14 = v10 + 8;
    v15 = 0;
    while ( v15 + 4 < rdlen )
    {
      v17 = __ROL2__(*((_WORD *)v14 + 1), 8);
      if ( v17 + v15 > rdlen )
      {
        is_last[0] = 0;
        rdlen = 0;
        buff = 0;
        goto LABEL_19;
      }
      LOBYTE(v16) = HIBYTE(*(_WORD *)v14);
      HIBYTE(v16) = *(_WORD *)v14;
      if ( v16 == optno )
      {
        if ( !replace )
          return plen;
        v18 = v17 + 4;
        rdlen -= v18;
        qmemcpy(v14, &v14[v18], rdlen - v15);
        LOBYTE(v19) = BYTE1(rdlen);
        HIBYTE(v19) = rdlen;
        *((_WORD *)v10 + 3) = v19;
      }
      else
      {
        v14 += v17 + 4;
        v15 += v17 + 4;
      }
    }
    v10 += 6;
    if ( is_last[0] )
      goto LABEL_27;
    buff = 0;
    if ( rdlen )
    {
      v20 = (unsigned __int8 *)whine_malloc(rdlen);
      buff = v20;
      if ( v20 )
        qmemcpy(v20, datap, rdlen);
    }
LABEL_19:
    udp_sz = __ROL2__(v35, 8);
    v21 = __ROL2__(v36, 8);
    v22 = rrfilter(header, plen, 0, v10);
    plen = v22;
  }
  else
  {
    v21 = 0;
    v22 = (set_do != 0) << 15;
    flags = (set_do != 0) << 15;
  }
  v23 = skip_questions(header, plen, v22, v22);
  if ( v23 )
  {
    HIBYTE(v24) = header->ancount;
    LOBYTE(v24) = HIBYTE(header->ancount);
    HIBYTE(v25) = header->nscount;
    LOBYTE(v25) = HIBYTE(header->nscount);
    HIBYTE(v26) = header->arcount;
    LOBYTE(v26) = HIBYTE(header->arcount);
    v27 = skip_section(v23, v26 + v24 + v25, header, plen);
    if ( v27 )
    {
      *(_WORD *)v27 = 0;
      LOBYTE(v28) = HIBYTE(flags);
      HIBYTE(v28) = flags;
      *(_BYTE *)(v27 + 2) = 41;
      LOBYTE(v29) = BYTE1(rdlen);
      HIBYTE(v29) = rdlen;
      *(_WORD *)(v27 + 3) = __ROL2__(udp_sz, 8);
      *(_WORD *)(v27 + 5) = __ROL2__(v21, 8);
      *(_WORD *)(v27 + 7) = v28;
      v10 = (unsigned __int8 *)(v27 + 9);
      v14 = (unsigned __int8 *)(v27 + 11);
      *((_WORD *)v14 - 1) = v29;
      LOWORD(datap) = (_WORD)v14;
      if ( buff )
      {
        qmemcpy(v14, buff, rdlen);
        v30 = &v14[rdlen];
        flagsa = v10;
        free(buff);
        v10 = flagsa;
        v14 = v30;
      }
      if ( limit - (v14 + 4) >= (int)optlen )
      {
        HIBYTE(v31) = header->arcount;
        LOBYTE(v31) = HIBYTE(header->arcount);
        ++v31;
        v32 = HIBYTE(v31);
        HIBYTE(v31) = v31;
        LOBYTE(v31) = v32;
        header->arcount = v31;
      }
LABEL_27:
      if ( limit - (v14 + 4) >= (int)optlen )
      {
        if ( optno && replace != 2 )
        {
          LOBYTE(v33) = BYTE1(optno);
          HIBYTE(v33) = optno;
          *(_WORD *)v14 = v33;
          LOBYTE(v33) = BYTE1(optlen);
          HIBYTE(v33) = optlen;
          *((_WORD *)v14 + 1) = v33;
          qmemcpy(v14 + 4, opt, optlen);
          v14 += optlen + 4;
          HIBYTE(v33) = (_BYTE)v14 - (_BYTE)datap;
          LOBYTE(v33) = (unsigned __int16)((_WORD)v14 - (_WORD)datap) >> 8;
          *(_WORD *)v10 = v33;
        }
        return v14 - (unsigned __int8 *)header;
      }
    }
  }
  return plen;
}
