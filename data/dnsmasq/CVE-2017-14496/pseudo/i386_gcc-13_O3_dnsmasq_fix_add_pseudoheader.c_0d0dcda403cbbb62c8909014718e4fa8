size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *ptr; // ebp
  unsigned __int8 *v11; // ebx
  u16 v12; // ax
  int v13; // edi
  signed int v14; // esi
  unsigned __int16 v15; // dx
  int v16; // eax
  int v17; // ecx
  int v18; // ebp
  unsigned __int8 *v19; // ebx
  unsigned __int8 *v20; // eax
  _WORD *v21; // esi
  __int16 v23; // di
  int v24; // ebx
  int v25; // eax
  int v26; // ecx
  int v27; // ebx
  unsigned __int8 *v28; // eax
  unsigned __int8 *v29; // edi
  __int16 v30; // ax
  __int16 v31; // dx
  size_t rdlen; // [esp+24h] [ebp-48h]
  unsigned __int8 *v33; // [esp+2Ch] [ebp-40h]
  int v34; // [esp+2Ch] [ebp-40h]
  u16 t_s; // [esp+32h] [ebp-3Ah]
  unsigned __int8 *datap; // [esp+34h] [ebp-38h]
  __int16 v37; // [esp+38h] [ebp-34h]
  __int16 v38; // [esp+3Ah] [ebp-32h]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  ptr = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !ptr )
  {
    v23 = 0;
    t_s = (set_do != 0) << 15;
    goto LABEL_26;
  }
  v11 = t_cp;
  v37 = *(_WORD *)t_cp;
  v38 = *((_WORD *)t_cp + 1);
  v12 = __ROL2__(*((_WORD *)t_cp + 2), 8);
  t_s = v12;
  if ( set_do )
  {
    t_s = v12 | 0x8000;
    *((_WORD *)t_cp + 2) = __ROL2__(v12 | 0x8000, 8);
  }
  v13 = (int)(v11 + 8);
  datap = v11 + 8;
  v14 = (unsigned __int16)__ROL2__(*((_WORD *)v11 + 3), 8);
  if ( plen < (unsigned int)(unsigned __int16)v14 + v11 + 8 - (unsigned __int8 *)header || !optno )
    return plen;
  if ( (unsigned __int16)v14 > 4u )
  {
    v15 = __ROL2__(*((_WORD *)v11 + 4), 8);
    v16 = (unsigned __int16)__ROL2__(*((_WORD *)v11 + 5), 8);
    v17 = (unsigned __int16)v16 + 4;
    if ( (unsigned __int16)v14 < v17 )
    {
LABEL_36:
      is_last[0] = 0;
      goto LABEL_37;
    }
    v18 = 0;
    if ( !replace )
    {
      v33 = v11;
      v29 = v11 + 12;
      while ( v15 != optno )
      {
        v18 += v16 + 4;
        v13 = (int)&v29[v16];
        if ( v18 + 4 >= (unsigned __int16)v14 )
          goto LABEL_17;
        v30 = *(_WORD *)(v13 + 2);
        v31 = *(_WORD *)v13;
        v29 = (unsigned __int8 *)(v13 + 4);
        v15 = __ROL2__(v31, 8);
        v16 = (unsigned __int16)__ROL2__(v30, 8);
        if ( (unsigned __int16)v16 + v18 + 4 > (unsigned __int16)v14 )
          goto LABEL_36;
      }
      return plen;
    }
    v33 = v11;
    v19 = v11 + 12;
    while ( 1 )
    {
      if ( v15 == optno )
      {
        v14 -= v17;
        memcpy((void *)v13, (const void *)(v13 + v16 + 4), v14 - v18);
        *((_WORD *)v33 + 3) = __ROL2__(v14, 8);
      }
      else
      {
        v13 = (int)&v19[v16];
        v18 += v17;
      }
      if ( v18 + 4 >= v14 )
        break;
      v19 = (unsigned __int8 *)(v13 + 4);
      v15 = __ROL2__(*(_WORD *)v13, 8);
      v16 = (unsigned __int16)__ROL2__(*(_WORD *)(v13 + 2), 8);
      if ( (unsigned __int16)v16 + v18 + 4 > v14 )
        goto LABEL_36;
      v17 = (unsigned __int16)v16 + 4;
    }
LABEL_17:
    v11 = v33;
  }
  if ( !is_last[0] )
  {
    if ( v14 )
    {
      v28 = (unsigned __int8 *)whine_malloc(v14);
      ptr = v28;
      if ( v28 )
        memcpy(v28, datap, v14);
      rdlen = v14;
      goto LABEL_38;
    }
LABEL_37:
    ptr = 0;
LABEL_38:
    udp_sz = __ROL2__(v37, 8);
    v23 = __ROL2__(v38, 8);
    plen = rrfilter(header, plen, 0);
LABEL_26:
    v24 = skip_questions(header, plen);
    if ( !v24 )
      return plen;
    v25 = skip_section(
            v24,
            (unsigned __int16)__ROL2__(header->arcount, 8)
          + (unsigned __int16)__ROL2__(header->ancount, 8)
          + (unsigned __int16)__ROL2__(header->nscount, 8),
            header,
            plen);
    v26 = v25;
    if ( !v25 )
      return plen;
    v27 = v25 + 11;
    datap = (unsigned __int8 *)(v25 + 11);
    if ( (unsigned int)limit < v25 + 11 )
      return plen;
    *(_BYTE *)(v25 + 2) = 41;
    *(_WORD *)v25 = 0;
    *(_WORD *)(v25 + 3) = __ROL2__(udp_sz, 8);
    *(_WORD *)(v25 + 5) = __ROL2__(v23, 8);
    *(_WORD *)(v25 + 7) = __ROL2__(t_s, 8);
    *(_WORD *)(v25 + 9) = __ROL2__(rdlen, 8);
    if ( ptr )
    {
      v13 = v27 + rdlen;
      if ( (unsigned int)limit < v27 + rdlen )
      {
        free(ptr);
        return plen;
      }
      v34 = v25;
      memcpy(datap, ptr, rdlen);
      free(ptr);
      v26 = v34;
    }
    else
    {
      v13 = v25 + 11;
    }
    v20 = (unsigned __int8 *)(v13 + 4);
    if ( (int)&limit[-v13 - 4] >= (int)optlen )
    {
      v21 = (_WORD *)(v26 + 9);
      header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
      goto LABEL_20;
    }
    return plen;
  }
  v20 = (unsigned __int8 *)(v13 + 4);
  v21 = v11 + 6;
  if ( (int)&limit[-v13 - 4] < (int)optlen )
    return plen;
LABEL_20:
  if ( optno && replace != 2 )
  {
    if ( limit < v20 )
      return plen;
    *(_WORD *)v13 = __ROL2__(optno, 8);
    *(_WORD *)(v13 + 2) = __ROL2__(optlen, 8);
    v13 = (int)&v20[optlen];
    if ( limit < &v20[optlen] )
      return plen;
    memcpy(v20, opt, optlen);
    *v21 = __ROL2__(v13 - (_WORD)datap, 8);
  }
  return v13 - (_DWORD)header;
}
