size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *v10; // edx
  u16 v11; // ax
  __int16 v12; // ax
  unsigned __int16 v13; // ax
  unsigned __int8 *v14; // eax
  int v15; // ebx
  unsigned __int16 v16; // cx
  unsigned __int16 v17; // si
  int v18; // esi
  __int16 v19; // cx
  int v20; // esi
  unsigned __int8 *v21; // eax
  __int16 v22; // si
  size_t v23; // eax
  _WORD *v24; // edx
  int v25; // ebx
  unsigned __int16 v26; // cx
  unsigned __int16 v27; // ax
  unsigned __int16 v28; // dx
  int v29; // eax
  int v30; // edx
  __int16 v31; // ax
  unsigned __int8 *v32; // edi
  u16 v33; // cx
  char v34; // tt
  __int16 v35; // cx
  __int16 v37; // [esp-8h] [ebp-4Ch]
  __int16 v38; // [esp-6h] [ebp-4Ah]
  u16 t_s; // [esp+0h] [ebp-44h]
  int t_sa; // [esp+0h] [ebp-44h]
  unsigned __int8 *datap; // [esp+4h] [ebp-40h]
  unsigned __int8 *code; // [esp+Ch] [ebp-38h]
  int t_s_0; // [esp+14h] [ebp-30h]
  unsigned __int8 *t_cp; // [esp+18h] [ebp-2Ch] BYREF
  int is_sign; // [esp+1Ch] [ebp-28h] BYREF
  int is_last[9]; // [esp+20h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  code = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  t_s_0 = is_sign;
  if ( is_sign )
    return plen;
  if ( code )
  {
    v10 = t_cp;
    v37 = *(_WORD *)t_cp;
    v38 = *((_WORD *)t_cp + 1);
    HIBYTE(v11) = *((_WORD *)t_cp + 2);
    LOBYTE(v11) = HIBYTE(*((_WORD *)t_cp + 2));
    t_s = v11;
    if ( set_do )
    {
      t_s = v11 | 0x8000;
      LOBYTE(v12) = (unsigned __int16)(v11 | 0x8000) >> 8;
      HIBYTE(v12) = HIBYTE(*((_WORD *)t_cp + 2));
      *((_WORD *)t_cp + 2) = v12;
    }
    HIBYTE(v13) = *((_WORD *)v10 + 3);
    LOBYTE(v13) = HIBYTE(*((_WORD *)v10 + 3));
    t_s_0 = v13;
    datap = v10 + 8;
    if ( plen >= (unsigned int)v13 + v10 + 8 - (unsigned __int8 *)header && optno )
    {
      v14 = v10 + 8;
      v15 = 0;
      while ( v15 + 4 < t_s_0 )
      {
        v17 = __ROL2__(*((_WORD *)v14 + 1), 8);
        if ( v17 + v15 > t_s_0 )
        {
          is_last[0] = 0;
          goto LABEL_17;
        }
        LOBYTE(v16) = HIBYTE(*(_WORD *)v14);
        HIBYTE(v16) = *(_WORD *)v14;
        if ( v16 == optno )
        {
          if ( !replace )
            return plen;
          v18 = v17 + 4;
          t_s_0 -= v18;
          qmemcpy(v14, &v14[v18], t_s_0 - v15);
          LOBYTE(v19) = BYTE1(t_s_0);
          HIBYTE(v19) = t_s_0;
          *((_WORD *)v10 + 3) = v19;
        }
        else
        {
          v20 = v17 + 4;
          v14 += v20;
          v15 += v20;
        }
      }
      if ( !is_last[0] )
      {
        if ( t_s_0 )
        {
          v21 = (unsigned __int8 *)whine_malloc(t_s_0);
          code = v21;
          if ( v21 )
            qmemcpy(v21, datap, t_s_0);
        }
        else
        {
LABEL_17:
          t_s_0 = 0;
          code = 0;
        }
        udp_sz = __ROL2__(v37, 8);
        v22 = __ROL2__(v38, 8);
        v23 = rrfilter(header, plen, 0, v10);
        plen = v23;
        goto LABEL_23;
      }
      v24 = v10 + 6;
      goto LABEL_30;
    }
  }
  else
  {
    v22 = 0;
    v23 = (set_do != 0) << 15;
    t_s = (set_do != 0) << 15;
LABEL_23:
    v25 = skip_questions(header, plen, v23, v23);
    if ( v25 )
    {
      HIBYTE(v26) = header->ancount;
      LOBYTE(v26) = HIBYTE(header->ancount);
      HIBYTE(v27) = header->nscount;
      LOBYTE(v27) = HIBYTE(header->nscount);
      HIBYTE(v28) = header->arcount;
      LOBYTE(v28) = HIBYTE(header->arcount);
      v29 = skip_section(v25, v28 + v26 + v27, header, plen);
      v30 = v29;
      if ( v29 )
      {
        *(_WORD *)v29 = 0;
        *(_BYTE *)(v29 + 2) = 41;
        *(_WORD *)(v29 + 3) = __ROL2__(udp_sz, 8);
        *(_WORD *)(v29 + 5) = __ROL2__(v22, 8);
        LOBYTE(v31) = HIBYTE(t_s);
        HIBYTE(v31) = t_s;
        *(_WORD *)(v30 + 7) = v31;
        LOBYTE(v31) = BYTE1(t_s_0);
        HIBYTE(v31) = t_s_0;
        *(_WORD *)(v30 + 9) = v31;
        v14 = (unsigned __int8 *)(v30 + 11);
        LOWORD(datap) = v30 + 11;
        if ( code )
        {
          t_sa = v30;
          qmemcpy(v14, code, t_s_0);
          v32 = &v14[t_s_0];
          free(code);
          v30 = t_sa;
          v14 = v32;
        }
        if ( limit - (v14 + 4) >= (int)optlen )
        {
          HIBYTE(v33) = header->arcount;
          LOBYTE(v33) = HIBYTE(header->arcount);
          ++v33;
          v34 = HIBYTE(v33);
          HIBYTE(v33) = v33;
          LOBYTE(v33) = v34;
          header->arcount = v33;
        }
        v24 = (_WORD *)(v30 + 9);
LABEL_30:
        if ( limit - (v14 + 4) >= (int)optlen )
        {
          if ( optno && replace != 2 )
          {
            LOBYTE(v35) = BYTE1(optno);
            HIBYTE(v35) = optno;
            *(_WORD *)v14 = v35;
            LOBYTE(v35) = BYTE1(optlen);
            HIBYTE(v35) = optlen;
            *((_WORD *)v14 + 1) = v35;
            qmemcpy(v14 + 4, opt, optlen);
            v14 += optlen + 4;
            HIBYTE(v35) = (_BYTE)v14 - (_BYTE)datap;
            LOBYTE(v35) = (unsigned __int16)((_WORD)v14 - (_WORD)datap) >> 8;
            *v24 = v35;
          }
          return v14 - (unsigned __int8 *)header;
        }
      }
    }
  }
  return plen;
}
