size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *v10; // eax
  __int16 v11; // dx
  unsigned __int16 v12; // dx
  int v13; // edx
  int v14; // ebx
  unsigned __int16 v15; // cx
  unsigned __int16 v16; // si
  int v17; // esi
  __int16 v18; // cx
  int v19; // esi
  unsigned __int8 *v20; // eax
  __int16 v21; // si
  size_t v22; // eax
  _WORD *v23; // ebx
  int v24; // eax
  u16 v25; // cx
  char v26; // t1
  unsigned __int8 *v27; // eax
  __int16 v28; // cx
  __int16 v29; // ax
  int v30; // ebx
  unsigned __int16 v31; // cx
  unsigned __int16 v32; // ax
  unsigned __int16 v33; // dx
  int v34; // ebx
  __int16 v35; // dx
  __int16 v37; // [esp-6h] [ebp-4Eh]
  __int16 v38; // [esp-4h] [ebp-4Ch]
  int v39; // [esp-4h] [ebp-4Ch]
  u16 t_s; // [esp+0h] [ebp-48h]
  unsigned __int8 *datap; // [esp+Ch] [ebp-3Ch]
  unsigned __int8 *code; // [esp+10h] [ebp-38h]
  int t_s_0; // [esp+18h] [ebp-30h]
  unsigned __int8 *udp_len; // [esp+1Ch] [ebp-2Ch] BYREF
  int is_sign; // [esp+20h] [ebp-28h] BYREF
  int is_last[9]; // [esp+24h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  code = find_pseudoheader(header, plen, 0, &udp_len, &is_sign, is_last);
  t_s_0 = is_sign;
  if ( is_sign )
    return plen;
  if ( code )
  {
    v10 = udp_len;
    v37 = *(_WORD *)udp_len;
    v38 = *((_WORD *)udp_len + 1);
    t_s = __ROL2__(*((_WORD *)udp_len + 2), 8);
    if ( set_do )
    {
      t_s |= 0x8000u;
      LOBYTE(v11) = HIBYTE(t_s);
      HIBYTE(v11) = t_s;
      *((_WORD *)udp_len + 2) = v11;
    }
    HIBYTE(v12) = *((_WORD *)v10 + 3);
    LOBYTE(v12) = HIBYTE(*((_WORD *)v10 + 3));
    t_s_0 = v12;
    datap = v10 + 8;
    if ( plen < (unsigned int)v12 + v10 + 8 - (unsigned __int8 *)header || !optno )
      return plen;
    v13 = (int)(v10 + 8);
    v14 = 0;
    while ( v14 + 4 < t_s_0 )
    {
      v16 = __ROL2__(*(_WORD *)(v13 + 2), 8);
      if ( v16 + v14 + 4 > t_s_0 )
      {
        is_last[0] = 0;
        goto LABEL_17;
      }
      LOBYTE(v15) = HIBYTE(*(_WORD *)v13);
      HIBYTE(v15) = *(_WORD *)v13;
      if ( v15 == optno )
      {
        if ( !replace )
          return plen;
        v17 = v16 + 4;
        t_s_0 -= v17;
        qmemcpy((void *)v13, (const void *)(v13 + v17), t_s_0 - v14);
        LOBYTE(v18) = BYTE1(t_s_0);
        HIBYTE(v18) = t_s_0;
        *((_WORD *)v10 + 3) = v18;
      }
      else
      {
        v19 = v16 + 4;
        v13 += v19;
        v14 += v19;
      }
    }
    if ( !is_last[0] )
    {
      if ( t_s_0 )
      {
        v20 = (unsigned __int8 *)whine_malloc(t_s_0);
        code = v20;
        if ( v20 )
          qmemcpy(v20, datap, t_s_0);
      }
      else
      {
LABEL_17:
        t_s_0 = 0;
        code = 0;
      }
      udp_sz = __ROL2__(v37, 8);
      v21 = __ROL2__(v38, 8);
      v22 = rrfilter(header, plen, 0, v13);
      plen = v22;
      goto LABEL_35;
    }
    v23 = v10 + 6;
  }
  else
  {
    v21 = 0;
    v22 = (set_do != 0) << 15;
    t_s = (set_do != 0) << 15;
LABEL_35:
    v30 = skip_questions(header, plen, v22, v22);
    if ( !v30 )
      return plen;
    HIBYTE(v31) = header->ancount;
    LOBYTE(v31) = HIBYTE(header->ancount);
    HIBYTE(v32) = header->nscount;
    LOBYTE(v32) = HIBYTE(header->nscount);
    HIBYTE(v33) = header->arcount;
    LOBYTE(v33) = HIBYTE(header->arcount);
    v24 = skip_section(v30, v33 + v31 + v32, header, plen);
    if ( !v24 )
      return plen;
    v34 = v24 + 11;
    datap = (unsigned __int8 *)(v24 + 11);
    if ( (unsigned int)limit < v24 + 11 )
      return plen;
    *(_WORD *)v24 = 0;
    *(_BYTE *)(v24 + 2) = 41;
    LOBYTE(v35) = HIBYTE(t_s);
    HIBYTE(v35) = t_s;
    *(_WORD *)(v24 + 3) = __ROL2__(udp_sz, 8);
    *(_WORD *)(v24 + 5) = __ROL2__(v21, 8);
    *(_WORD *)(v24 + 7) = v35;
    LOBYTE(v35) = BYTE1(t_s_0);
    HIBYTE(v35) = t_s_0;
    *(_WORD *)(v24 + 9) = v35;
    if ( code )
    {
      if ( (unsigned int)limit < v34 + t_s_0 )
      {
        free(code);
        return plen;
      }
      v39 = v24;
      qmemcpy(datap, code, t_s_0);
      free(code);
      v13 = v34 + t_s_0;
      v24 = v39;
    }
    else
    {
      v13 = v24 + 11;
    }
    if ( (int)&limit[-v13 - 4] >= (int)optlen )
    {
      HIBYTE(v25) = header->arcount;
      LOBYTE(v25) = HIBYTE(header->arcount);
      ++v25;
      v26 = HIBYTE(v25);
      HIBYTE(v25) = v25;
      LOBYTE(v25) = v26;
      header->arcount = v25;
    }
    v23 = (_WORD *)(v24 + 9);
  }
  v27 = (unsigned __int8 *)(v13 + 4);
  if ( (int)&limit[-v13 - 4] >= (int)optlen )
  {
    if ( !optno || replace == 2 )
      return v13 - (_DWORD)header;
    if ( limit >= v27 )
    {
      LOBYTE(v28) = BYTE1(optno);
      HIBYTE(v28) = optno;
      *(_WORD *)v13 = v28;
      LOBYTE(v28) = BYTE1(optlen);
      HIBYTE(v28) = optlen;
      *(_WORD *)(v13 + 2) = v28;
      v13 = (int)&v27[optlen];
      if ( limit >= &v27[optlen] )
      {
        qmemcpy(v27, opt, optlen);
        HIBYTE(v29) = v13 - (_BYTE)datap;
        LOBYTE(v29) = (unsigned __int16)(v13 - (_WORD)datap) >> 8;
        *v23 = v29;
        return v13 - (_DWORD)header;
      }
    }
  }
  return plen;
}
