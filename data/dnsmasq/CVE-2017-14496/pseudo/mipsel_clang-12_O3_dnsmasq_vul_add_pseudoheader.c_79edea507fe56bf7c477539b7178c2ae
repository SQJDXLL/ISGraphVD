int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s1
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  int v20; // $s7
  unsigned __int8 *v21; // $s2
  char v22; // $s3
  int v23; // $s5
  unsigned __int8 *v24; // $s7
  int v25; // $fp
  int v26; // $v0
  int v27; // $v1
  unsigned __int8 *v28; // $a0
  int v29; // $v0
  signed int v30; // $v0
  unsigned __int8 *v31; // $v1
  _BYTE *v32; // $s4
  _BYTE *v33; // $s3
  void *v34; // $v0
  void *v35; // $s2
  int v36; // $v0
  int v37; // $v1
  int v38; // $v0
  bool v39; // dc
  _BYTE *v40; // $v0
  _BYTE *v41; // $s2
  unsigned __int8 *v42; // $s2
  signed int v43; // $s1
  __int16 v44; // $at
  void *src; // [sp+1Ch] [-2Ch]
  int v46; // [sp+20h] [-28h]
  unsigned __int8 v47; // [sp+24h] [-24h]
  unsigned __int8 v48; // [sp+28h] [-20h]
  unsigned __int8 v49; // [sp+2Ch] [-1Ch]
  unsigned int v50; // [sp+30h] [-18h]
  signed int v51; // [sp+34h] [-14h]
  unsigned __int8 *v52; // [sp+38h] [-10h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v55; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v55, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  v20 = replace;
  if ( pseudoheader )
  {
    v21 = v55;
    v22 = v55[4];
    if ( set_do )
    {
      v22 |= 0x80u;
      v55[4] = v22;
    }
    if ( optno )
    {
      v52 = limit;
      v23 = (v21[6] << 8) | v21[7];
      if ( v15 >= v21 + 8 - (unsigned __int8 *)header + v23 )
      {
        src = v21 + 8;
        LOBYTE(udp_sz) = v21[1];
        v51 = optlen;
        v46 = replace;
        LOBYTE(v50) = *v21;
        v49 = v21[5];
        v48 = v21[2];
        v47 = v21[3];
        if ( (unsigned int)v23 < 5 )
        {
          v24 = v21 + 8;
LABEL_21:
          if ( is_last )
          {
            v30 = optlen;
            v31 = v52;
            LOWORD(v32) = (_WORD)v21 + 8;
            v33 = v21 + 6;
LABEL_39:
            v42 = v24 + 4;
            if ( v31 - (v24 + 4) >= v30 )
            {
              if ( optno && v46 != 2 )
              {
                v24[3] = v30;
                v24[1] = optno;
                v43 = v30;
                v24[2] = BYTE1(v30);
                *v24 = BYTE1(optno);
                memcpy(v24 + 4, opt, v30);
                v24 = &v42[v43];
                v44 = (_WORD)v42 + v43 - (_WORD)v32;
                v33[1] = v44;
                *v33 = HIBYTE(v44);
              }
              return v24 - (unsigned __int8 *)header;
            }
            return v15;
          }
          v17 = 0;
          if ( v23 )
          {
            v34 = (void *)whine_malloc(v23);
            v20 = replace;
            if ( v34 )
            {
              v35 = v34;
              memcpy(v34, src, v23);
              v17 = v35;
            }
          }
          else
          {
            v20 = replace;
            v23 = 0;
          }
        }
        else
        {
          if ( replace )
          {
            v24 = v21 + 8;
            v25 = 0;
            while ( 1 )
            {
              v26 = (v24[2] << 8) | v24[3];
              v27 = v26 + v25;
              if ( v23 < v26 + v25 )
                break;
              v28 = v24 + 4;
              if ( ((*v24 << 8) | v24[1]) == optno )
              {
                v23 = v23 - v26 - 4;
                memcpy(v24, &v28[v26], v23 - v25);
                v21[7] = v23;
                v21[6] = BYTE1(v23);
                if ( v25 + 4 >= v23 )
                  goto LABEL_21;
              }
              else
              {
                v25 = v27 + 4;
                v24 = &v28[v26];
                if ( v27 + 8 >= v23 )
                  goto LABEL_21;
              }
            }
          }
          else
          {
            v24 = v21 + 8;
            v36 = 0;
            while ( 1 )
            {
              v37 = (v24[2] << 8) | v24[3];
              v38 = v37 + v36;
              if ( v23 < v38 )
                break;
              if ( ((*v24 << 8) | v24[1]) == optno )
                return v15;
              v24 += v37 + 4;
              v39 = v38 + 8 < v23;
              v36 = v38 + 4;
              if ( !v39 )
                goto LABEL_21;
            }
          }
          v20 = replace;
          is_last = 0;
          v23 = 0;
          v17 = 0;
        }
        v15 = rrfilter(header, v15, 0);
        v29 = skip_questions(header, v15);
        if ( !v29 )
          return v15;
LABEL_34:
        v40 = (_BYTE *)skip_section(
                         v29,
                         (_bswapw(header->nscount) >> 16)
                       + (_bswapw(header->ancount) >> 16)
                       + (_bswapw(header->arcount) >> 16),
                         header,
                         v15);
        if ( !v40 )
          return v15;
        v41 = v40;
        v40[10] = v23;
        v46 = v20;
        v40[8] = v49;
        v40[7] = v22;
        v40[6] = v47;
        v40[5] = v48;
        v40[4] = udp_sz;
        v32 = v40 + 0xB;
        v24 = v40 + 0xB;
        v40[3] = v50;
        v40[2] = 41;
        v40[1] = 0;
        *v40 = 0;
        v40[9] = BYTE1(v23);
        if ( v17 )
        {
          memcpy(v40 + 0xB, v17, v23);
          free(v17);
          v24 = &v32[v23];
        }
        v31 = v52;
        v30 = v51;
        v33 = v41 + 9;
        if ( v52 - v24 - 4 >= v51 )
          header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
        goto LABEL_39;
      }
    }
  }
  else
  {
    v22 = 0x80;
    v52 = limit;
    v51 = optlen;
    v23 = 0;
    v50 = udp_sz >> 8;
    if ( !set_do )
      v22 = 0;
    v49 = 0;
    v48 = 0;
    v47 = 0;
    v29 = skip_questions(header, v15);
    if ( v29 )
      goto LABEL_34;
  }
  return v15;
}
