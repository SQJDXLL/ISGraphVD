int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  int v13; // $v0
  _BYTE *v14; // $at
  uint16_t v15; // $v0
  int v17; // [sp+1Ch] [+1Ch]
  int v18; // [sp+20h] [+20h]
  void *v19; // [sp+24h] [+24h]
  _BYTE *v20; // [sp+28h] [+28h]
  char v21; // [sp+2Ch] [+2Ch]
  _BYTE *v22; // [sp+30h] [+30h]
  _BYTE *v23; // [sp+38h] [+38h]
  _BYTE *v24; // [sp+40h] [+40h]
  char v25; // [sp+44h] [+44h]
  _BYTE *v26; // [sp+48h] [+48h]
  _BYTE *v27; // [sp+50h] [+50h]
  _BYTE *v28; // [sp+58h] [+58h]
  char v29; // [sp+5Ch] [+5Ch]
  _BYTE *v30; // [sp+60h] [+60h]
  _BYTE *v31; // [sp+68h] [+68h]
  char v32; // [sp+6Ch] [+6Ch]
  _BYTE *v33; // [sp+7Ch] [+7Ch]
  unsigned __int16 v34; // [sp+90h] [+90h]
  unsigned __int16 v35; // [sp+94h] [+94h]
  int v36; // [sp+98h] [+98h]
  unsigned __int16 v37; // [sp+9Ch] [+9Ch]
  unsigned __int16 v38; // [sp+A0h] [+A0h]
  int v39; // [sp+A4h] [+A4h] BYREF
  int v40; // [sp+A8h] [+A8h] BYREF
  size_t n; // [sp+ACh] [+ACh]
  void *ptr; // [sp+B0h] [+B0h]
  unsigned __int8 *v43; // [sp+B4h] [+B4h] BYREF
  void *dest; // [sp+B8h] [+B8h]
  void *src; // [sp+BCh] [+BCh]
  _BYTE *v46; // [sp+C0h] [+C0h]
  unsigned __int16 v47; // [sp+C4h] [+C4h]
  unsigned __int8 *v48; // [sp+C8h] [+C8h]
  size_t plena; // [sp+CCh] [+CCh]
  dns_header *headera; // [sp+D0h] [+D0h]

  headera = header;
  plena = plen;
  v48 = limit;
  v47 = udp_sz;
  ptr = 0;
  n = 0;
  v38 = (set_do != 0) << 15;
  v37 = 0;
  dest = find_pseudoheader(header, plen, 0u, &v43, &v40, &v39);
  if ( v40 )
    return plena;
  if ( dest )
  {
    dest = v43;
    v47 = _byteswap_ushort(*(_WORD *)v43);
    dest = v43 + 2;
    v37 = _byteswap_ushort(*((_WORD *)v43 + 1));
    dest = v43 + 4;
    v38 = _byteswap_ushort(*((_WORD *)v43 + 2));
    dest = v43 + 6;
    if ( set_do )
    {
      dest = (char *)dest - 2;
      v38 |= 0x8000u;
      v33 = (char *)dest + 1;
      *(_BYTE *)dest = HIBYTE(v38);
      *v33 = v38;
      dest = (char *)dest + 2;
    }
    v46 = dest;
    n = (*(unsigned __int8 *)dest << 8) | *((unsigned __int8 *)dest + 1);
    dest = (char *)dest + 2;
    if ( plena < (_BYTE *)dest - (_BYTE *)headera + n )
      return plena;
    src = dest;
    if ( !optno )
      return plena;
    v36 = 0;
    while ( v36 + 4 < (int)n )
    {
      v35 = _byteswap_ushort(*(_WORD *)dest);
      dest = (char *)dest + 2;
      v34 = _byteswap_ushort(*(_WORD *)dest);
      dest = (char *)dest + 2;
      if ( (int)n < v36 + v34 + 4 )
      {
        n = 0;
        v39 = 0;
        break;
      }
      if ( v35 == optno )
      {
        if ( !replace )
          return plena;
        dest = (char *)dest - 4;
        n = n - v34 - 4;
        memcpy(dest, (char *)dest + v34 + 4, n - v36);
        v32 = n;
        v31 = v46 + 1;
        *v46 = BYTE1(n);
        *v31 = v32;
        v46 += 2;
        v46 -= 2;
      }
      else
      {
        dest = (char *)dest + v34;
        v36 += v34 + 4;
      }
    }
    if ( !v39 )
    {
      if ( n )
      {
        ptr = (void *)whine_malloc(n);
        if ( ptr )
          memcpy(ptr, src, n);
      }
      plena = rrfilter(headera, plena, 0);
      dest = 0;
    }
  }
  if ( !dest )
  {
    dest = (void *)skip_questions(headera, plena);
    if ( !dest )
      return plena;
    v19 = dest;
    v17 = ntohs(headera->ancount);
    v18 = v17 + ntohs(headera->nscount);
    v13 = ntohs(headera->arcount);
    dest = (void *)skip_section(v19, v18 + v13, headera, plena);
    if ( !dest )
      return plena;
    if ( v48 < (unsigned __int8 *)((char *)dest + 0xB) )
      return plena;
    v14 = dest;
    dest = (char *)dest + 1;
    *v14 = 0;
    v30 = (char *)dest + 1;
    *(_BYTE *)dest = 0;
    *v30 = 41;
    dest = (char *)dest + 2;
    v29 = v47;
    v28 = (char *)dest + 1;
    *(_BYTE *)dest = HIBYTE(v47);
    *v28 = v29;
    dest = (char *)dest + 2;
    v27 = (char *)dest + 1;
    *(_BYTE *)dest = HIBYTE(v37);
    *v27 = v37;
    dest = (char *)dest + 2;
    v26 = (char *)dest + 1;
    *(_BYTE *)dest = HIBYTE(v38);
    *v26 = v38;
    dest = (char *)dest + 2;
    v46 = dest;
    v25 = n;
    v24 = (char *)dest + 1;
    *(_BYTE *)dest = BYTE1(n);
    *v24 = v25;
    dest = (char *)dest + 2;
    src = dest;
    if ( ptr )
    {
      if ( v48 < (unsigned __int8 *)((char *)dest + n) )
      {
        free(ptr);
        return plena;
      }
      memcpy(dest, ptr, n);
      free(ptr);
      dest = (char *)dest + n;
    }
    if ( v48 - (_BYTE *)dest - 4 >= (int)optlen )
    {
      v15 = ntohs(headera->arcount);
      headera->arcount = htons(v15 + 1);
    }
  }
  if ( v48 - (_BYTE *)dest - 4 >= (int)optlen )
  {
    if ( optno && replace != 2 )
    {
      if ( v48 < (unsigned __int8 *)((char *)dest + 4) )
        return plena;
      v23 = (char *)dest + 1;
      *(_BYTE *)dest = BYTE1(optno);
      *v23 = optno;
      dest = (char *)dest + 2;
      v22 = (char *)dest + 1;
      *(_BYTE *)dest = BYTE1(optlen);
      *v22 = optlen;
      dest = (char *)dest + 2;
      if ( v48 < (unsigned __int8 *)((char *)dest + optlen) )
        return plena;
      memcpy(dest, opt, optlen);
      dest = (char *)dest + optlen;
      v21 = (_BYTE)dest - (_BYTE)src;
      v20 = v46 + 1;
      *v46 = (unsigned __int16)((_WORD)dest - (_WORD)src) >> 8;
      *v20 = v21;
      v46 += 2;
    }
    return (_BYTE *)dest - (_BYTE *)headera;
  }
  return plena;
}
