size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v11; // x22
  unsigned int v12; // w25
  unsigned __int8 *pseudoheader; // x0
  int v14; // w28
  unsigned __int8 *v15; // x21
  unsigned __int8 *v16; // x21
  unsigned int v17; // w25
  unsigned int v18; // w23
  unsigned int v19; // w19
  char *v20; // x27
  unsigned __int16 v21; // w0
  signed int v22; // w26
  unsigned __int8 *v23; // x28
  int v24; // w6
  _WORD *v25; // x21
  unsigned __int8 *v26; // x0
  bool v27; // zf
  __int64 v28; // x1
  int v29; // w2
  __int64 v30; // x1
  unsigned __int8 *v31; // x0
  unsigned int v32; // w23
  __int64 v33; // x0
  __int64 v34; // x0
  __int64 v35; // x3
  size_t v36; // x2
  int ia; // [xsp+78h] [xbp+78h]
  __int64 ib; // [xsp+78h] [xbp+78h]
  int is_sign; // [xsp+88h] [xbp+88h] BYREF
  int is_last; // [xsp+8Ch] [xbp+8Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF

  v11 = plen;
  v12 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v14 = is_sign;
  if ( is_sign )
    return v11;
  v15 = pseudoheader;
  if ( pseudoheader )
  {
    v16 = udp_len;
    v17 = *(unsigned __int16 *)udp_len;
    v18 = *((unsigned __int16 *)udp_len + 1);
    v19 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
    if ( set_do )
    {
      v19 |= 0x8000u;
      *((_WORD *)udp_len + 2) = __rev16(v19);
    }
    v20 = (char *)(v16 + 8);
    v21 = __rev16(*((unsigned __int16 *)v16 + 3));
    if ( v16 + 8 - (unsigned __int8 *)header + (unsigned __int64)v21 > v11 || !optno )
      return v11;
    v22 = v21;
    v23 = v16 + 8;
    v24 = 0;
    while ( v24 + 4 < v22 )
    {
      v28 = (unsigned __int16)__rev16(*((unsigned __int16 *)v23 + 1));
      v29 = (unsigned __int16)__rev16(*(unsigned __int16 *)v23);
      if ( v24 + 4 + (int)v28 > v22 )
      {
        is_last = 0;
LABEL_22:
        v22 = 0;
        v15 = 0LL;
        goto LABEL_30;
      }
      if ( v29 == optno )
      {
        if ( !replace )
          return v11;
        v30 = v28 + 4;
        v22 -= v30;
        ia = v24;
        memcpy(v23, &v23[v30], v22 - v24);
        v24 = ia;
        *((_WORD *)v16 + 3) = __rev16(v22);
      }
      else
      {
        v24 += v28 + 4;
        v23 += (unsigned int)v28 + 4;
      }
    }
    if ( is_last )
    {
      v25 = v16 + 6;
      goto LABEL_11;
    }
    if ( !v22 )
      goto LABEL_22;
    v31 = (unsigned __int8 *)whine_malloc(v22);
    v15 = v31;
    if ( v31 )
      memcpy(v31, v20, v22);
LABEL_30:
    v12 = (unsigned __int16)__rev16(v17);
    v32 = (unsigned __int16)__rev16(v18);
    v11 = rrfilter(header, v11, 0LL);
    v14 = v22;
  }
  else
  {
    v32 = 0;
    v19 = (set_do != 0) << 15;
  }
  v33 = skip_questions(header, v11);
  if ( v33 )
  {
    v34 = skip_section(
            v33,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    v35 = v34;
    if ( v34 )
    {
      v20 = (char *)(v34 + 0xB);
      if ( v34 + 0xB <= (unsigned __int64)limit )
      {
        *(_WORD *)v34 = 0;
        *(_BYTE *)(v34 + 2) = 41;
        *(_WORD *)(v34 + 3) = __rev16(v12);
        *(_WORD *)(v34 + 5) = __rev16(v32);
        *(_WORD *)(v34 + 7) = __rev16(v19);
        *(_WORD *)(v34 + 9) = __rev16(v14);
        if ( v15 )
        {
          v36 = v14;
          v23 = (unsigned __int8 *)&v20[v14];
          if ( v23 > limit )
          {
            free(v15);
            return v11;
          }
          ib = v34;
          memcpy(v20, v15, v36);
          free(v15);
          v35 = ib;
        }
        else
        {
          v23 = (unsigned __int8 *)(v34 + 0xB);
        }
        if ( limit - (v23 + 4) >= (__int64)optlen )
          header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
        v25 = (_WORD *)(v35 + 9);
LABEL_11:
        v26 = v23 + 4;
        if ( limit - (v23 + 4) >= (__int64)optlen )
        {
          if ( optno )
            v27 = replace == 2;
          else
            v27 = 1;
          if ( v27 )
            return v23 - (unsigned __int8 *)header;
          if ( v26 <= limit )
          {
            *(_WORD *)v23 = __rev16((unsigned __int16)optno);
            *((_WORD *)v23 + 1) = __rev16((unsigned __int16)optlen);
            v23 = &v26[optlen];
            if ( &v26[optlen] <= limit )
            {
              memcpy(v26, opt, optlen);
              *v25 = __rev16((_DWORD)v23 - (_DWORD)v20);
              return v23 - (unsigned __int8 *)header;
            }
          }
        }
      }
    }
  }
  return v11;
}
