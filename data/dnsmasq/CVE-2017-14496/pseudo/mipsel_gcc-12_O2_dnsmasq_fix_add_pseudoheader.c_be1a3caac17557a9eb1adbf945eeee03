int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s7
  unsigned __int8 *v19; // $fp
  unsigned __int8 *v20; // $fp
  unsigned int v21; // $v0
  __int16 v22; // $s4
  unsigned int v23; // $v0
  int v24; // $t0
  int result; // $v0
  unsigned int v26; // $a0
  unsigned int v27; // $v0
  int v28; // $v1
  int v29; // $a0
  unsigned __int8 *v30; // $a1
  unsigned __int8 *v31; // $s6
  int v32; // $t3
  unsigned int v33; // $a1
  unsigned int v34; // $a0
  int v35; // $v1
  signed int v36; // $v1
  unsigned __int8 *v37; // $a0
  _BYTE *v38; // $fp
  int v39; // $a0
  _BYTE *v40; // $v0
  _BYTE *v41; // $t0
  _BYTE *v42; // $a3
  unsigned __int8 *v43; // $s6
  unsigned __int8 *v44; // $v0
  int v45; // $t0
  int t_sb; // [sp+20h] [-28h]
  __int16 t_s; // [sp+20h] [-28h]
  _BYTE *t_sc; // [sp+20h] [-28h]
  size_t t_sa; // [sp+20h] [-28h]
  int i; // [sp+24h] [-24h]
  unsigned __int8 *t_cp; // [sp+2Ch] [-1Ch]
  unsigned int v52; // [sp+30h] [-18h]
  unsigned int v53; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( pseudoheader )
  {
    v20 = udp_len;
    v21 = (udp_len[5] << 8) | udp_len[4];
    v52 = (udp_len[1] << 8) | *udp_len;
    v53 = (udp_len[3] << 8) | udp_len[2];
    v22 = ((_WORD)v21 << 8) | (v21 >> 8);
    if ( set_do )
    {
      v22 |= 0x8000u;
      udp_len[4] = HIBYTE(v22);
      v20[5] = v22;
    }
    v23 = (v20[7] << 8) | v20[6];
    t_cp = v20 + 8;
    v24 = (unsigned __int16)(((_WORD)v23 << 8) | (v23 >> 8));
    result = v17;
    if ( v17 < v20 + 8 - (unsigned __int8 *)header + v24 )
      return result;
    if ( !optno )
      return v17;
    if ( v24 < 5 )
    {
      v31 = v20 + 8;
      if ( is_last )
      {
        v36 = optlen;
LABEL_17:
        v37 = v31 + 4;
        result = v17;
        if ( limit - (v31 + 4) < v36 )
          return result;
        v38 = v20 + 6;
        goto LABEL_19;
      }
    }
    else
    {
      v26 = (v20[11] << 8) | v20[10];
      v27 = (v20[9] << 8) | v20[8];
      v28 = (unsigned __int16)(((_WORD)v26 << 8) | (v26 >> 8));
      v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
      v30 = v20 + 0xC;
      if ( v24 < v28 + 4 )
      {
LABEL_33:
        is_last = 0;
        goto LABEL_34;
      }
      v31 = v20 + 8;
      v32 = 0;
      while ( 1 )
      {
        if ( v29 == optno )
        {
          v35 = v28 + 4;
          if ( !replace )
            return v17;
          i = v32;
          t_sb = v24 - v35;
          memcpy(v31, &v31[(unsigned __int16)v35], v24 - v35 - v32);
          v24 = t_sb;
          v32 = i;
          v20[6] = BYTE1(t_sb);
          v20[7] = t_sb;
        }
        else
        {
          v31 = &v30[v28];
          v32 += v28 + 4;
        }
        if ( v32 + 4 >= v24 )
          break;
        v33 = (v31[3] << 8) | v31[2];
        v34 = (v31[1] << 8) | *v31;
        v28 = (unsigned __int16)(((_WORD)v33 << 8) | (v33 >> 8));
        v29 = (unsigned __int16)(((_WORD)v34 << 8) | (v34 >> 8));
        v30 = v31 + 4;
        if ( v24 < v28 + v32 + 4 )
          goto LABEL_33;
      }
      v36 = optlen;
      if ( is_last )
        goto LABEL_17;
    }
    if ( v24 )
    {
      t_sa = v24;
      v44 = (unsigned __int8 *)whine_malloc(v24);
      v19 = v44;
      v45 = t_sa;
      if ( v44 )
      {
        memcpy(v44, t_cp, t_sa);
        v45 = t_sa;
      }
      v18 = v45;
      goto LABEL_35;
    }
LABEL_34:
    v19 = 0;
LABEL_35:
    t_s = ((_WORD)v53 << 8) | (v53 >> 8);
    udp_sz = ((_WORD)v52 << 8) | (v52 >> 8);
    v17 = rrfilter(header, v17, 0);
    goto LABEL_24;
  }
  t_s = 0;
  v22 = (set_do != 0) << 15;
LABEL_24:
  v39 = skip_questions(header, v17);
  if ( !v39 )
    return v17;
  v40 = (_BYTE *)skip_section(
                   v39,
                   (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                 + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                 + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                   header,
                   v17);
  v41 = v40;
  if ( !v40 )
    return v17;
  v42 = v40 + 0xB;
  t_cp = v40 + 0xB;
  if ( limit < v40 + 0xB )
    return v17;
  *v40 = 0;
  v40[1] = 0;
  v40[2] = 41;
  v40[3] = HIBYTE(udp_sz);
  v40[4] = udp_sz;
  v40[5] = HIBYTE(t_s);
  v40[6] = t_s;
  v40[7] = HIBYTE(v22);
  v40[8] = v22;
  v40[9] = BYTE1(v18);
  v40[10] = v18;
  if ( v19 )
  {
    v31 = &v42[v18];
    if ( limit >= &v42[v18] )
    {
      t_sc = v40;
      memcpy(t_cp, v19, v18);
      free(v19);
      v41 = t_sc;
      goto LABEL_30;
    }
    free(v19);
    return v17;
  }
  v31 = v40 + 0xB;
LABEL_30:
  v37 = v31 + 4;
  result = v17;
  if ( limit - (v31 + 4) >= (int)optlen )
  {
    v38 = v41 + 9;
    header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
    if ( !optno )
      return v31 - (unsigned __int8 *)header;
LABEL_19:
    result = v31 - (unsigned __int8 *)header;
    if ( replace == 2 )
      return result;
    if ( limit >= v37 )
    {
      v31[2] = BYTE1(optlen);
      *v31 = BYTE1(optno);
      v31[1] = optno;
      v31[3] = optlen;
      v43 = &v37[optlen];
      if ( limit >= &v37[optlen] )
      {
        memcpy(v37, opt, optlen);
        *v38 = (unsigned __int16)((_WORD)v43 - (_WORD)t_cp) >> 8;
        v38[1] = (_BYTE)v43 - (_BYTE)t_cp;
        return v43 - (unsigned __int8 *)header;
      }
    }
    return v17;
  }
  return result;
}
