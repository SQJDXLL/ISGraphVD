size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  uint32x2_t v9; // d8
  unsigned __int64 v11; // x19
  unsigned __int32 v16; // w25
  unsigned __int8 *pseudoheader; // x0
  int v18; // w27
  unsigned __int8 *v19; // x5
  unsigned __int16 *v20; // x25
  unsigned int v21; // w22
  unsigned __int16 *v22; // x7
  unsigned __int16 v23; // w0
  signed int v24; // w28
  unsigned __int64 v25; // x0
  unsigned __int16 *v27; // x2
  int v28; // w26
  signed int v29; // w3
  int v30; // w1
  __int64 v32; // x0
  __int64 v33; // x26
  uint32x2_t v34; // d0
  uint32x2_t v35; // d1
  __int64 v36; // d0
  void *v37; // x3
  unsigned __int8 *v38; // x0
  unsigned __int8 *v39; // x5
  _WORD *v40; // x19
  bool v41; // zf
  _BYTE *v42; // x0
  unsigned __int8 *buff; // [xsp+80h] [xbp+80h]
  unsigned __int8 *buffa; // [xsp+80h] [xbp+80h]
  unsigned __int8 *buffb; // [xsp+80h] [xbp+80h]
  unsigned __int16 src; // [xsp+88h] [xbp+88h]
  unsigned __int8 *srca; // [xsp+88h] [xbp+88h]
  unsigned __int16 v49; // [xsp+94h] [xbp+94h]
  unsigned __int8 *v50; // [xsp+98h] [xbp+98h]
  int is_sign; // [xsp+A8h] [xbp+A8h] BYREF
  int is_last; // [xsp+ACh] [xbp+ACh] BYREF
  unsigned __int8 *udp_len; // [xsp+B0h] [xbp+B0h] BYREF

  v11 = plen;
  v16 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v11;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v9.n64_u32[0] = 0;
    v21 = (set_do != 0) << 15;
LABEL_21:
    buffa = v19;
    v32 = skip_questions(header, v11);
    if ( !v32 )
      return v11;
    srca = buffa;
    v33 = skip_section(
            v32,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    if ( !v33 )
      return v11;
    v34.n64_u32[0] = v16;
    v35.n64_u32[0] = v21;
    LOBYTE(v36) = vshr_n_u32(v34, 8uLL).n64_u8[0];
    *(_WORD *)v33 = 0;
    BYTE1(v36) = v16;
    *(_BYTE *)(v33 + 2) = 41;
    LODWORD(buff) = v33 + 0xB;
    v22 = (unsigned __int16 *)(v33 + 0xB);
    BYTE2(v36) = vshr_n_u32(v9, 8uLL).n64_u8[0];
    BYTE3(v36) = v9.n64_u8[0];
    BYTE4(v36) = vshr_n_u32(v35, 8uLL).n64_u8[0];
    BYTE5(v36) = v21;
    BYTE6(v36) = BYTE1(v18);
    HIBYTE(v36) = v18;
    *(_QWORD *)(v33 + 3) = v36;
    if ( srca )
    {
      memcpy((void *)(v33 + 0xB), srca, v18);
      free(srca);
      v22 = (unsigned __int16 *)(v33 + 0xB + v18);
    }
    v37 = v22 + 2;
    if ( limit - (unsigned __int8 *)(v22 + 2) < (__int64)optlen )
      return v11;
    v40 = (_WORD *)(v33 + 9);
    header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
    goto LABEL_35;
  }
  v20 = (unsigned __int16 *)udp_len;
  v49 = *(_WORD *)udp_len;
  src = *((_WORD *)udp_len + 1);
  v21 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
  if ( set_do )
  {
    v21 |= 0x8000u;
    *((_WORD *)udp_len + 2) = __rev16(v21);
  }
  v22 = v20 + 4;
  buff = (unsigned __int8 *)(v20 + 4);
  v23 = __rev16(v20[3]);
  v24 = v23;
  v25 = (char *)(v20 + 4) - (char *)header + v23;
  if ( !optno || v25 > v11 )
    return v11;
  if ( v24 > 4 )
  {
    v27 = v20 + 6;
    v28 = 0;
    v29 = (unsigned __int16)__rev16(v20[5]);
    v30 = (unsigned __int16)__rev16(v20[4]);
    if ( v24 >= v29 )
    {
      do
      {
        if ( v30 == optno )
        {
          if ( !replace )
            return v11;
          v24 -= v29 + 4;
          v22 = (unsigned __int16 *)memcpy(v22, (char *)v22 + (unsigned int)v29 + 4, v24 - v28);
          v20[3] = __rev16(v24);
        }
        else
        {
          v22 = (unsigned __int16 *)((char *)v27 + (unsigned __int16)v29);
          v28 += v29 + 4;
        }
        if ( v28 + 4 >= v24 )
          goto LABEL_28;
        v27 = v22 + 2;
        v29 = (unsigned __int16)__rev16(v22[1]);
        v30 = (unsigned __int16)__rev16(*v22);
      }
      while ( v29 + v28 <= v24 );
    }
    is_last = 0;
    goto LABEL_42;
  }
  v22 = v20 + 4;
LABEL_28:
  if ( !is_last )
  {
    if ( v24 )
    {
      v38 = (unsigned __int8 *)whine_malloc(v24);
      v39 = v38;
      if ( v38 )
      {
        v50 = v38;
        memcpy(v38, buff, v24);
        v39 = v50;
      }
      v18 = v24;
      goto LABEL_43;
    }
LABEL_42:
    v39 = 0LL;
LABEL_43:
    buffb = v39;
    v16 = (unsigned __int16)__rev16(v49);
    v9.n64_u32[0] = (unsigned __int16)__rev16(src);
    v11 = rrfilter(header, v11, 0LL);
    v19 = buffb;
    goto LABEL_21;
  }
  v37 = v22 + 2;
  if ( limit - (unsigned __int8 *)(v22 + 2) < (__int64)optlen )
    return v11;
  v40 = v20 + 3;
LABEL_35:
  if ( optno )
    v41 = replace == 2;
  else
    v41 = 1;
  if ( v41 )
    return (char *)v22 - (char *)header;
  *v22 = __rev16(optno);
  v22[1] = __rev16(optlen);
  v42 = memcpy(v37, opt, optlen);
  *v40 = __rev16((_DWORD)v42 + optlen - (_DWORD)buff);
  return &v42[optlen] - (_BYTE *)header;
}
