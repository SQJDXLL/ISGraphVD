size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v9; // r7
  unsigned __int8 *pseudoheader; // r0
  int v12; // r10
  unsigned __int8 *v13; // r6
  unsigned __int8 *v14; // r6
  int v15; // r3
  __int16 v16; // r9
  unsigned int v17; // r3
  int v18; // r5
  unsigned __int8 *v19; // r4
  _BOOL4 v20; // r3
  int v22; // r0
  int v23; // r1
  unsigned __int8 *v24; // r12
  int v25; // r3
  int v26; // r11
  __int16 v27; // r11
  unsigned __int8 *v28; // r0
  _BYTE *v29; // r6
  bool v30; // zf
  unsigned __int8 *v31; // r0
  __int16 v32; // r9
  int v33; // r0
  _BYTE *v34; // r0
  _BYTE *v35; // r5
  _BYTE *v36; // r2
  unsigned __int16 v37; // r3
  void *dest; // [sp+14h] [bp-4Ch]
  __int16 v41; // [sp+18h] [bp-48h]
  __int16 v42; // [sp+1Ch] [bp-44h]
  __int16 v43; // [sp+20h] [bp-40h]
  __int16 v44; // [sp+24h] [bp-3Ch]
  unsigned __int8 *udp_len; // [sp+28h] [bp-38h] BYREF
  int is_sign; // [sp+2Ch] [bp-34h] BYREF
  int is_last; // [sp+30h] [bp-30h] BYREF

  v9 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v12 = is_sign;
  if ( is_sign )
    return v9;
  v13 = pseudoheader;
  if ( !pseudoheader )
  {
    v32 = set_do;
    if ( set_do )
      v32 = 1;
    v16 = v32 << 15;
    v27 = 0;
    goto LABEL_41;
  }
  v14 = udp_len;
  v41 = *udp_len;
  v42 = udp_len[1];
  v43 = udp_len[2];
  v44 = udp_len[3];
  v15 = (__int16)_byteswap_ushort(*((_WORD *)udp_len + 2));
  if ( set_do )
  {
    v17 = ~((unsigned int)~(v15 << 17) >> 17);
    v16 = v17;
    udp_len[4] = v17 << 16 >> 24;
    v14[5] = v17;
  }
  else
  {
    v16 = v15;
  }
  v18 = v14[7] | (v14[6] << 8);
  v19 = v14 + 8;
  dest = v14 + 8;
  v20 = optno == 0;
  if ( v14 + 8 - (unsigned __int8 *)header + v18 > v9 )
    v20 = 1;
  if ( !v20 )
  {
    if ( v18 <= 4 )
    {
      if ( is_last )
      {
        v19 = v14 + 8;
LABEL_22:
        v28 = v19 + 4;
        if ( limit - (v19 + 4) < (int)optlen )
          return v9;
        v29 = v14 + 6;
        goto LABEL_24;
      }
    }
    else
    {
      v22 = v14[9] | (v14[8] << 8);
      v23 = v14[11] | (v14[10] << 8);
      v24 = v14 + 0xC;
      v25 = v23;
      if ( v18 < v23 + 4 )
      {
LABEL_13:
        v13 = 0;
        is_last = 0;
LABEL_14:
        udp_sz = v42 | (v41 << 8);
        v27 = v44 | (v43 << 8);
        v9 = rrfilter(header, v9, 0);
LABEL_41:
        v33 = skip_questions(header, v9);
        if ( !v33 )
          return v9;
        v34 = (_BYTE *)skip_section(
                         v33,
                         (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                       + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                       + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                         header,
                         v9);
        v35 = v34;
        if ( !v34 )
          return v9;
        v36 = v34 + 0xB;
        dest = v34 + 0xB;
        if ( v34 + 0xB > limit )
          return v9;
        *v34 = 0;
        v34[1] = 0;
        v34[2] = 41;
        v34[3] = HIBYTE(udp_sz);
        v34[4] = udp_sz;
        v34[5] = HIBYTE(v27);
        v34[6] = v27;
        v34[7] = HIBYTE(v16);
        v34[8] = v16;
        v34[9] = (unsigned int)(v12 << 16) >> 24;
        v34[10] = v12;
        if ( v13 )
        {
          v19 = &v36[v12];
          if ( &v36[v12] > limit )
          {
            free(v13);
            return v9;
          }
          memcpy(dest, v13, v12);
          free(v13);
        }
        else
        {
          v19 = v34 + 0xB;
        }
        v28 = v19 + 4;
        if ( limit - (v19 + 4) < (int)optlen )
          return v9;
        v29 = v35 + 9;
        v37 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
        header->arcount = HIBYTE(v37) | (v37 << 8);
LABEL_24:
        v30 = optno == 0;
        if ( optno )
          v30 = replace == 2;
        if ( !v30 )
        {
          if ( limit < v28 )
            return v9;
          *v19 = (unsigned int)(optno << 16) >> 24;
          v19[1] = optno;
          v19[2] = optlen << 16 >> 24;
          v19[3] = optlen;
          v19 = &v28[optlen];
          if ( &v28[optlen] > limit )
            return v9;
          memcpy(v28, opt, optlen);
          *v29 = (unsigned int)((v19 - (_BYTE *)dest) << 16) >> 24;
          v29[1] = (_BYTE)v19 - (_BYTE)dest;
        }
        return v19 - (unsigned __int8 *)header;
      }
      v26 = 0;
      while ( 1 )
      {
        if ( v22 == optno )
        {
          if ( !replace )
            return v9;
          v18 -= v25 + 4;
          memcpy(v19, &v19[v23 + 4], v18 - v26);
          v14[6] = (unsigned int)(v18 << 16) >> 24;
          v14[7] = v18;
        }
        else
        {
          v19 = &v24[v23];
          v26 += v25 + 4;
        }
        if ( v26 + 4 >= v18 )
          break;
        v22 = v19[1] | (*v19 << 8);
        v23 = v19[3] | (v19[2] << 8);
        v24 = v19 + 4;
        v25 = v23;
        if ( v23 + v26 + 4 > v18 )
          goto LABEL_13;
      }
      if ( is_last )
        goto LABEL_22;
    }
    if ( v18 )
    {
      v31 = (unsigned __int8 *)whine_malloc(v18);
      v13 = v31;
      if ( v31 )
        memcpy(v31, dest, v18);
      v12 = v18;
    }
    else
    {
      v12 = 0;
      v13 = 0;
    }
    goto LABEL_14;
  }
  return v9;
}
