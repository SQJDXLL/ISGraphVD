size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  dns_header *v10; // r12
  size_t v12; // rbx
  unsigned __int8 *pseudoheader; // rax
  __int64 v14; // rcx
  __int64 v15; // r9
  unsigned __int8 *v16; // r10
  unsigned __int8 *v17; // rdi
  __int64 v18; // r8
  int v19; // r15d
  __int64 v20; // rdx
  unsigned __int8 *v21; // r11
  int v22; // r12d
  unsigned __int8 *v23; // r13
  unsigned __int8 *v24; // rdi
  int v25; // r14d
  int v26; // ebp
  unsigned int v27; // r15d
  unsigned __int64 v28; // r14
  unsigned __int8 *v29; // r8
  _WORD *v30; // r15
  __int16 v32; // r15
  __int16 v33; // r8
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rcx
  dns_header *v37; // r10
  __int64 v38; // rax
  dns_header *v39; // rax
  dns_header *v40; // rax
  void *rdlen; // [rsp+18h] [rbp-80h]
  int rdlena; // [rsp+18h] [rbp-80h]
  int rdlenb; // [rsp+18h] [rbp-80h]
  __int16 ptr; // [rsp+20h] [rbp-78h]
  __int16 ptra; // [rsp+20h] [rbp-78h]
  int ptrb; // [rsp+20h] [rbp-78h]
  __int16 buff; // [rsp+28h] [rbp-70h]
  unsigned __int8 *buffa; // [rsp+28h] [rbp-70h]
  __int16 buffb; // [rsp+28h] [rbp-70h]
  unsigned __int8 *buffc; // [rsp+28h] [rbp-70h]
  unsigned __int16 flags; // [rsp+30h] [rbp-68h]
  unsigned __int8 *flagsa; // [rsp+30h] [rbp-68h]
  __int16 flagsc; // [rsp+30h] [rbp-68h]
  __int16 flagsb; // [rsp+30h] [rbp-68h]
  dns_header *headera; // [rsp+38h] [rbp-60h]
  dns_header *headerb; // [rsp+38h] [rbp-60h]
  int is_sign; // [rsp+48h] [rbp-50h] BYREF
  int is_last; // [rsp+4Ch] [rbp-4Ch] BYREF
  unsigned __int8 *t_cp[9]; // [rsp+50h] [rbp-48h] BYREF

  v10 = header;
  v12 = plen;
  t_cp[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, t_cp, &is_sign, &is_last);
  v15 = (unsigned int)is_sign;
  if ( is_sign )
    return v12;
  v16 = pseudoheader;
  if ( !pseudoheader )
  {
    v32 = 0;
    v33 = (set_do != 0) << 15;
    goto LABEL_25;
  }
  v17 = t_cp[0];
  v18 = *((unsigned __int16 *)t_cp[0] + 2);
  ptr = *(_WORD *)t_cp[0];
  LOWORD(v18) = __ROL2__(v18, 8);
  buff = *((_WORD *)t_cp[0] + 1);
  if ( set_do )
  {
    LOWORD(v18) = v18 | 0x8000;
    *((_WORD *)t_cp[0] + 2) = __ROL2__(v18, 8);
  }
  rdlen = v17 + 8;
  LOWORD(v19) = __ROL2__(*((_WORD *)v17 + 3), 8);
  v20 = (unsigned __int16)v19;
  if ( plen < (unsigned __int64)(unsigned __int16)v19 + v17 + 8 - (unsigned __int8 *)v10 || !optno )
    return v12;
  v19 = (unsigned __int16)v19;
  if ( (unsigned __int16)v19 <= 4u )
  {
    if ( is_last )
    {
      v28 = (unsigned __int64)(v17 + 8);
      goto LABEL_17;
    }
LABEL_39:
    if ( v19 )
    {
      flagsb = v18;
      v39 = (dns_header *)whine_malloc(v19, plen, v20, v14, v18, v15);
      LOWORD(v18) = flagsb;
      v37 = v39;
      if ( v39 )
      {
        v40 = (dns_header *)memcpy(v39, rdlen, v19);
        LOWORD(v18) = flagsb;
        v37 = v40;
      }
      LODWORD(v15) = v19;
      goto LABEL_36;
    }
LABEL_35:
    v37 = 0LL;
LABEL_36:
    headerb = v37;
    flagsc = v18;
    udp_sz = __ROL2__(ptr, 8);
    rdlenb = v15;
    v32 = __ROL2__(buff, 8);
    v38 = rrfilter(v10, v12, 0LL, v14);
    LODWORD(v15) = rdlenb;
    v33 = flagsc;
    v16 = (unsigned __int8 *)headerb;
    v12 = v38;
LABEL_25:
    buffa = v16;
    ptra = v33;
    rdlena = v15;
    v34 = skip_questions(v10, v12);
    if ( !v34 )
      return v12;
    flagsa = buffa;
    buffb = ptra;
    ptrb = rdlena;
    v35 = skip_section(
            v34,
            (unsigned __int16)__ROL2__(v10->arcount, 8)
          + (unsigned __int16)__ROL2__(v10->nscount, 8)
          + (unsigned int)(unsigned __int16)__ROL2__(v10->ancount, 8),
            v10,
            v12);
    v36 = v35;
    if ( !v35 )
      return v12;
    rdlen = (void *)(v35 + 11);
    if ( (unsigned __int64)limit < v35 + 11 )
      return v12;
    *(_WORD *)v35 = 0;
    *(_BYTE *)(v35 + 2) = 41;
    *(_QWORD *)(v35 + 3) = HIBYTE(udp_sz) | (((unsigned __int8)udp_sz | ((HIBYTE(v32) | (((unsigned __int8)v32 | ((HIBYTE(buffb) | (((unsigned __int8)buffb | ((BYTE1(ptrb) | ((unsigned __int64)(unsigned __int8)ptrb << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
    if ( flagsa )
    {
      v28 = v35 + 11 + ptrb;
      if ( (unsigned __int64)limit < v28 )
      {
        free(flagsa);
        return v12;
      }
      buffc = (unsigned __int8 *)v35;
      memcpy(rdlen, flagsa, ptrb);
      free(flagsa);
      v36 = (__int64)buffc;
    }
    else
    {
      v28 = v35 + 11;
    }
    v29 = (unsigned __int8 *)(v28 + 4);
    if ( (__int64)&limit[-v28 - 4] >= (__int64)optlen )
    {
      v30 = (_WORD *)(v36 + 9);
      v10->arcount = __ROL2__(__ROL2__(v10->arcount, 8) + 1, 8);
      goto LABEL_19;
    }
    return v12;
  }
  v14 = *((unsigned __int16 *)v17 + 4);
  v21 = v17 + 12;
  LOWORD(v20) = __ROL2__(*((_WORD *)v17 + 5), 8);
  LOWORD(v14) = __ROL2__(v14, 8);
  plen = (unsigned __int16)v20;
  if ( (unsigned __int16)v19 < (unsigned __int16)v20 + 4 )
  {
LABEL_34:
    is_last = 0;
    goto LABEL_35;
  }
  headera = v10;
  v22 = 0;
  v23 = v17;
  v24 = v17 + 8;
  flags = v18;
  v25 = optno;
  v26 = (unsigned __int16)v19;
  v27 = v15;
  while ( 1 )
  {
    if ( (unsigned __int16)v14 == v25 )
    {
      if ( !replace )
        return v12;
      v26 -= plen + 4;
      plen = (size_t)&v24[(unsigned __int16)(v20 + 4)];
      v24 = (unsigned __int8 *)memcpy(v24, (const void *)plen, v26 - v22);
      *((_WORD *)v23 + 3) = __ROL2__(v26, 8);
    }
    else
    {
      v20 = (unsigned __int16)v20;
      v22 += plen + 4;
      v24 = &v21[(unsigned __int16)v20];
    }
    if ( v22 + 4 >= v26 )
      break;
    v14 = *(unsigned __int16 *)v24;
    v21 = v24 + 4;
    LOWORD(v20) = __ROL2__(*((_WORD *)v24 + 1), 8);
    LOWORD(v14) = __ROL2__(v14, 8);
    plen = (unsigned __int16)v20;
    if ( (unsigned __int16)v20 + v22 + 4 > v26 )
    {
      LOWORD(v18) = flags;
      v10 = headera;
      LODWORD(v15) = v27;
      optno = v25;
      goto LABEL_34;
    }
  }
  v14 = (unsigned int)is_last;
  v15 = v27;
  v18 = flags;
  v19 = v26;
  v10 = headera;
  optno = v25;
  v28 = (unsigned __int64)v24;
  v17 = v23;
  if ( !is_last )
    goto LABEL_39;
LABEL_17:
  v29 = (unsigned __int8 *)(v28 + 4);
  if ( (__int64)&limit[-v28 - 4] < (__int64)optlen )
    return v12;
  v30 = v17 + 6;
LABEL_19:
  if ( optno && replace != 2 )
  {
    if ( limit < v29 )
      return v12;
    *(_DWORD *)v28 = BYTE1(optno) | (((unsigned __int8)optno | ((BYTE1(optlen) | ((unsigned __int8)optlen << 8)) << 8)) << 8);
    v28 = (unsigned __int64)&v29[optlen];
    if ( limit < &v29[optlen] )
      return v12;
    memcpy(v29, opt, optlen);
    *v30 = __ROL2__(v28 - (_WORD)rdlen, 8);
  }
  return v28 - (_QWORD)v10;
}
