int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s0
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $s3
  char v21; // $s2
  int v22; // $s5
  unsigned __int8 *v23; // $s7
  int v24; // $fp
  int v25; // $v0
  int v26; // $v1
  unsigned __int8 *v27; // $v0
  int v28; // $v0
  signed int v29; // $a2
  unsigned __int8 *v30; // $v0
  _WORD *v31; // $s2
  void *v32; // $v0
  void *v33; // $s3
  int v34; // $v0
  int v35; // $v1
  int v36; // $a0
  int v37; // $v0
  _BYTE *v38; // $s3
  __int16 v39; // $s2
  unsigned __int8 *v40; // $a0
  __int16 v41; // $s3
  unsigned __int8 v42; // [sp+1Fh] [-29h]
  unsigned __int8 v43; // [sp+23h] [-25h]
  unsigned __int8 v44; // [sp+27h] [-21h]
  unsigned int v45; // [sp+28h] [-20h]
  void *src; // [sp+2Ch] [-1Ch]
  int n; // [sp+30h] [-18h]
  unsigned __int8 *v48; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v51; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v51, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( pseudoheader )
  {
    v20 = v51;
    v21 = v51[4];
    if ( set_do )
    {
      v21 |= 0x80u;
      v51[4] = v21;
    }
    if ( optno )
    {
      n = optlen;
      src = v20 + 8;
      v22 = (v20[6] << 8) | v20[7];
      if ( v15 >= v20 + 8 - (unsigned __int8 *)header + v22 )
      {
        LOBYTE(udp_sz) = v20[1];
        v48 = limit;
        LOBYTE(v45) = *v20;
        v44 = v20[5];
        v43 = v20[2];
        v42 = v20[3];
        if ( (unsigned int)v22 < 5 )
        {
          v23 = v20 + 8;
LABEL_21:
          if ( is_last )
          {
            v29 = optlen;
            LOWORD(v30) = (_WORD)v20 + 8;
            v31 = v20 + 6;
            goto LABEL_43;
          }
          v17 = 0;
          if ( v22 )
          {
            v32 = (void *)whine_malloc(v22);
            if ( v32 )
            {
              v33 = v32;
              memcpy(v32, src, v22);
              limit = v48;
              v17 = v33;
            }
            else
            {
              limit = v48;
            }
          }
          else
          {
            limit = v48;
            v22 = 0;
          }
        }
        else
        {
          if ( replace )
          {
            v23 = v20 + 8;
            v24 = 0;
            v25 = 4;
            while ( 1 )
            {
              v26 = (v23[2] << 8) | v23[3];
              if ( v22 < v26 + v25 )
                break;
              v27 = v23 + 4;
              if ( ((*v23 << 8) | v23[1]) == optno )
              {
                v22 = v22 - v26 - 4;
                memcpy(v23, &v27[v26], v22 - v24);
                *((_WORD *)v20 + 3) = v22;
                v25 = v24 + 4;
                if ( v24 + 4 >= v22 )
                  goto LABEL_21;
              }
              else
              {
                v23 = &v27[v26];
                v24 += v26 + 4;
                v25 = v24 + 4;
                if ( v24 + 4 >= v22 )
                  goto LABEL_21;
              }
            }
          }
          else
          {
            v23 = v20 + 8;
            v34 = 0;
            v35 = 4;
            while ( 1 )
            {
              v36 = (v23[2] << 8) | v23[3];
              if ( v22 < v36 + v35 )
                break;
              if ( ((*v23 << 8) | v23[1]) == optno )
                return v15;
              v23 += v36 + 4;
              v35 = v34 + v36 + 8;
              v34 += v36 + 4;
              if ( v35 >= v22 )
                goto LABEL_21;
            }
          }
          limit = v48;
          is_last = 0;
          v22 = 0;
          v17 = 0;
        }
        v15 = rrfilter(header, v15, 0);
        v28 = skip_questions(header, v15);
        if ( !v28 )
          return v15;
LABEL_35:
        v37 = skip_section(
                v28,
                (_bswapw(header->nscount) >> 16) + (_bswapw(header->ancount) >> 16) + (_bswapw(header->arcount) >> 16),
                header,
                v15);
        if ( !v37 )
          return v15;
        v38 = (_BYTE *)v37;
        v30 = (unsigned __int8 *)(v37 + 11);
        if ( limit < v30 )
          return v15;
        v38[10] = v22;
        v48 = limit;
        v23 = v30;
        v38[8] = v44;
        v38[7] = v21;
        v38[6] = v42;
        v38[5] = v43;
        v38[4] = udp_sz;
        v38[3] = v45;
        v38[2] = 41;
        v38[1] = 0;
        *v38 = 0;
        v38[9] = BYTE2(v22);
        if ( v17 )
        {
          v23 = &v30[v22];
          if ( v48 < &v30[v22] )
          {
            free(v17);
            return v15;
          }
          v39 = (__int16)v30;
          memcpy(v30, v17, v22);
          free(v17);
          LOWORD(v30) = v39;
        }
        v29 = n;
        v31 = v38 + 9;
        if ( v48 - v23 - 4 >= n )
          header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
LABEL_43:
        v40 = v23 + 4;
        if ( v48 - (v23 + 4) < v29 )
          return v15;
        if ( optno )
        {
          v41 = (__int16)v30;
          if ( replace != 2 )
          {
            if ( v48 < v40 )
              return v15;
            v23[3] = v29;
            v23[1] = optno;
            v23[2] = BYTE2(v29);
            *v23 = BYTE2(optno);
            v23 = &v40[v29];
            if ( v48 < &v40[v29] )
              return v15;
            memcpy(v40, opt, v29);
            *v31 = (_WORD)v23 - v41;
          }
        }
        return v23 - (unsigned __int8 *)header;
      }
    }
  }
  else
  {
    v21 = 0x80;
    n = optlen;
    v22 = 0;
    v45 = udp_sz >> 8;
    if ( !set_do )
      v21 = 0;
    v44 = 0;
    v43 = 0;
    v42 = 0;
    v28 = skip_questions(header, v15);
    if ( v28 )
      goto LABEL_35;
  }
  return v15;
}
