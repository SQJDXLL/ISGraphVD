int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        int optlen,
        int set_do,
        int replace)
{
  size_t v9; // ebx
  dns_header *v10; // ebp
  void *v11; // edi
  unsigned __int8 *pseudoheader; // eax
  __int16 v14; // cx
  unsigned __int8 *v15; // ebp
  __int16 v16; // cx
  __int16 v17; // ax
  unsigned __int8 *v18; // esi
  signed int v19; // ebx
  int v20; // edi
  unsigned __int32 v21; // eax
  unsigned __int8 *v22; // ecx
  _WORD *v23; // ebp
  void *v24; // eax
  void *v25; // ebp
  int v26; // esi
  int v27; // eax
  int v28; // eax
  _BYTE *v29; // ebp
  __int16 v30; // ax
  unsigned __int8 *v31; // edi
  __int16 v32; // [esp+Eh] [ebp-2Eh]
  __int16 v34; // [esp+10h] [ebp-2Ch]
  __int16 v35; // [esp+10h] [ebp-2Ch]
  int v36; // [esp+14h] [ebp-28h]
  void *src; // [esp+18h] [ebp-24h]
  __int16 v38; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  unsigned __int8 *v40; // [esp+24h] [ebp-18h] BYREF
  int is_sign[5]; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  v11 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0, &v40, is_sign, &is_last);
  if ( is_sign[0] )
    return v9;
  HIBYTE(v14) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v14) = set_do != 0;
    v36 = plen;
    v19 = 0;
    v35 = 0;
    v38 = v14 << 15;
    goto LABEL_26;
  }
  v15 = v40;
  v16 = *(_WORD *)v40;
  v34 = *((_WORD *)v40 + 1);
  v17 = __ROL2__(*((_WORD *)v40 + 2), 8);
  if ( set_do )
  {
    v17 |= 0x8000u;
    v40[4] = HIBYTE(v17);
  }
  if ( optno )
  {
    v32 = v16;
    v18 = v15 + 8;
    v38 = v17;
    v19 = _byteswap_ulong(*((unsigned __int16 *)v15 + 3) << 16);
    if ( v19 + v15 + 8 - (unsigned __int8 *)header > plen )
      return plen;
    src = v15 + 8;
    if ( (unsigned int)v19 < 5 )
    {
LABEL_16:
      if ( is_last )
      {
        v9 = plen;
        v23 = v15 + 6;
        goto LABEL_33;
      }
      v11 = 0;
      if ( v19 )
      {
        v24 = (void *)whine_malloc(v19);
        if ( v24 )
        {
          v25 = v24;
          memcpy(v24, src, v19);
          v11 = v25;
        }
      }
      else
      {
        v19 = 0;
      }
    }
    else
    {
      v20 = 0;
      while ( 1 )
      {
        v21 = _byteswap_ulong(*((unsigned __int16 *)v18 + 1) << 16);
        if ( (int)(v21 + v20) > v19 )
          break;
        v22 = v18 + 4;
        if ( _byteswap_ulong(*(unsigned __int16 *)v18 << 16) == optno )
        {
          if ( !replace )
            return plen;
          v19 = v19 - v21 - 4;
          memcpy(v18, &v22[v21], v19 - v20);
          *((_WORD *)v15 + 3) = __ROL2__(v19, 8);
        }
        else
        {
          v20 += v21 + 4;
          v18 = &v22[v21];
        }
        if ( v20 + 4 >= v19 )
          goto LABEL_16;
      }
      is_last = 0;
      v19 = 0;
      v11 = 0;
    }
    v10 = header;
    udp_sz = __ROL2__(v32, 8);
    v35 = __ROL2__(v34, 8);
    v36 = rrfilter(header, plen, 0);
LABEL_26:
    v26 = v36;
    v27 = skip_questions(v10, v36);
    if ( !v27 )
      return v26;
    v28 = skip_section(
            v27,
            (unsigned __int16)__ROL2__(v10->ancount, 8)
          + (unsigned __int16)__ROL2__(v10->nscount, 8)
          + (unsigned __int16)__ROL2__(v10->arcount, 8),
            v10,
            v36);
    if ( !v28 )
      return v36;
    *(_WORD *)v28 = 0;
    v29 = (_BYTE *)v28;
    *(_BYTE *)(v28 + 2) = 41;
    *(_BYTE *)(v28 + 3) = HIBYTE(udp_sz);
    *(_BYTE *)(v28 + 4) = udp_sz;
    *(_BYTE *)(v28 + 5) = HIBYTE(v35);
    *(_BYTE *)(v28 + 6) = v35;
    *(_BYTE *)(v28 + 7) = HIBYTE(v38);
    *(_BYTE *)(v28 + 8) = v38;
    v30 = v28 + 11;
    v29[9] = BYTE1(v19);
    v29[10] = v19;
    v18 = v29 + 11;
    if ( v11 )
    {
      memcpy(v29 + 11, v11, v19);
      free(v11);
      v30 = (_WORD)v29 + 11;
      v18 = &v29[v19 + 11];
    }
    v23 = v29 + 9;
    LOWORD(src) = v30;
    if ( limit - v18 - 4 >= optlen )
      header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    v9 = v36;
LABEL_33:
    v31 = v18 + 4;
    if ( limit - (v18 + 4) < optlen )
      return v9;
    if ( optno && replace != 2 )
    {
      *v18 = BYTE1(optno);
      v18[1] = optno;
      v18[2] = BYTE1(optlen);
      v18[3] = optlen;
      memcpy(v18 + 4, opt, optlen);
      v18 = &v31[optlen];
      *v23 = __ROL2__(optlen + (_WORD)v31 - (_WORD)src, 8);
    }
    return v18 - (unsigned __int8 *)header;
  }
  return v9;
}
