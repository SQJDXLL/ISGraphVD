size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v13; // r15
  dns_header *v14; // r12
  unsigned __int8 *pseudoheader; // rax
  unsigned __int8 *v17; // rsi
  __int16 v18; // ax
  __int16 v19; // dx
  __int16 v20; // bx
  __int16 v21; // cx
  void *v22; // rdi
  unsigned __int16 *v23; // rbp
  __int64 v24; // rdx
  unsigned __int16 *v25; // rbx
  char v26; // r13
  int v27; // r13d
  int v28; // ecx
  int v29; // r12d
  unsigned __int64 v30; // rax
  _BYTE *v31; // rbp
  size_t v32; // rdx
  unsigned __int8 *v33; // rax
  const void *v34; // rsi
  unsigned __int8 *v35; // rbp
  __int64 v36; // rax
  signed __int64 v37; // r15
  unsigned __int8 *v38; // rdi
  __int16 v39; // cx
  __int64 v40; // rax
  __int64 v41; // rbx
  int v42; // r13d
  int v43; // ebp
  __uint16_t v44; // ax
  __int64 v45; // rax
  __int64 v46; // rsi
  unsigned __int8 *v47; // rax
  unsigned __int8 *v48; // rbx
  unsigned __int8 *v49; // rdx
  void *v50; // rax
  size_t v51; // rdx
  bool v52; // cc
  unsigned __int16 *v53; // rbx
  __uint16_t v54; // ax
  __int16 v55; // [rsp+8h] [rbp-90h]
  __int16 v56; // [rsp+8h] [rbp-90h]
  unsigned int v57; // [rsp+Ch] [rbp-8Ch]
  size_t v58; // [rsp+10h] [rbp-88h]
  __int16 v59; // [rsp+1Ch] [rbp-7Ch]
  __int16 v60; // [rsp+1Ch] [rbp-7Ch]
  unsigned __int16 v61; // [rsp+20h] [rbp-78h]
  __int16 v62; // [rsp+20h] [rbp-78h]
  unsigned __int8 *v63; // [rsp+20h] [rbp-78h]
  void *ptr; // [rsp+28h] [rbp-70h]
  dns_header *v65; // [rsp+30h] [rbp-68h]
  unsigned __int8 *v66; // [rsp+38h] [rbp-60h]
  unsigned __int8 *v67; // [rsp+38h] [rbp-60h]
  int is_last; // [rsp+44h] [rbp-54h] BYREF
  void *src; // [rsp+48h] [rbp-50h]
  int is_sign; // [rsp+54h] [rbp-44h] BYREF
  void *v71; // [rsp+58h] [rbp-40h]
  unsigned __int8 *v72; // [rsp+60h] [rbp-38h] BYREF

  v13 = plen;
  v14 = header;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v72, &is_sign, &is_last);
  if ( is_sign )
    return v13;
  v71 = opt;
  LODWORD(opt) = 0;
  v61 = udp_sz;
  v57 = optno;
  HIBYTE(udp_sz) = 0;
  if ( !pseudoheader )
  {
    v58 = plen;
    LOBYTE(udp_sz) = set_do != 0;
    v20 = udp_sz << 15;
    v21 = 0;
    v22 = 0LL;
    v23 = 0LL;
    v24 = v57;
    goto LABEL_26;
  }
  v17 = v72;
  v18 = *(_WORD *)v72;
  v59 = *((_WORD *)v72 + 1);
  v19 = __ROL2__(*((_WORD *)v72 + 2), 8);
  v66 = limit;
  if ( set_do )
  {
    v55 = v19 | 0x8000;
    v72[4] = (unsigned __int16)(v19 | 0x8000) >> 8;
  }
  else
  {
    v55 = v19;
  }
  v24 = (unsigned int)optno;
  opt = (unsigned __int8 *)_byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v17 + 3) << 48);
  v25 = (unsigned __int16 *)(v17 + 8);
  v22 = 0LL;
  v26 = 0;
  v62 = v18;
  src = v17 + 8;
  if ( !optno || (unsigned __int64)&opt[(char *)v25 - (char *)v14] > v13 )
  {
    v23 = (unsigned __int16 *)(v17 + 8);
    v36 = v13;
    goto LABEL_24;
  }
  v65 = v14;
  if ( (unsigned int)opt < 5 )
  {
    v29 = (int)opt;
LABEL_21:
    LODWORD(opt) = v29;
    v26 = 1;
    if ( is_last )
    {
      v22 = 0LL;
      v23 = v25;
      goto LABEL_23;
    }
    if ( v29 && (v50 = (void *)whine_malloc(v29, v17, v24)) != 0LL )
    {
      ptr = v50;
      memcpy(v50, src, v29);
    }
    else
    {
      ptr = 0LL;
    }
    v14 = v65;
    v20 = v55;
    v23 = 0LL;
    v36 = rrfilter(v65, v13, 0LL);
    v24 = v57;
    v22 = ptr;
    goto LABEL_25;
  }
  v27 = 0;
  v28 = 4;
  v29 = (int)opt;
  while ( 1 )
  {
    v30 = _byteswap_uint64((unsigned __int64)v25[1] << 48);
    v23 = v25 + 2;
    if ( (int)v30 + v28 > v29 )
    {
      is_last = 0;
      v29 = 0;
      v25 += 2;
      goto LABEL_21;
    }
    LODWORD(opt) = v29;
    if ( _byteswap_ulong(*v25 << 16) == (_DWORD)v24 )
      break;
    v27 += v30 + 4;
    v25 = (unsigned __int16 *)((char *)v23 + (unsigned int)v30);
LABEL_13:
    v28 = v27 + 4;
    if ( v27 + 4 >= v29 )
      goto LABEL_21;
  }
  if ( replace )
  {
    v29 = v29 - v30 - 4;
    v31 = (char *)v23 + v30;
    v32 = (int)opt - (int)v30 - 4 - v27;
    v33 = v17;
    v34 = v31;
    v35 = v33;
    memcpy(v25, v34, v32);
    v17 = v35;
    v24 = v57;
    *((_WORD *)v35 + 3) = __ROL2__(v29, 8);
    goto LABEL_13;
  }
  v26 = 0;
  v22 = 0LL;
LABEL_23:
  v36 = v13;
  v14 = v65;
LABEL_24:
  v20 = v55;
  if ( v26 )
  {
LABEL_25:
    v61 = __ROL2__(v62, 8);
    v21 = __ROL2__(v59, 8);
    plen = (size_t)(v17 + 6);
    v58 = v36;
    limit = v66;
LABEL_26:
    v37 = optlen;
    if ( v23 )
    {
LABEL_27:
      v38 = (unsigned __int8 *)(v23 + 2);
      if ( limit - (unsigned __int8 *)(v23 + 2) < v37 )
        return v58;
      v39 = v24;
      if ( (_DWORD)v24 && replace != 2 )
      {
        if ( v38 > limit )
          return v58;
        v51 = v37;
        *(_BYTE *)v23 = HIBYTE(v39);
        *((_BYTE *)v23 + 1) = v39;
        *((_BYTE *)v23 + 2) = BYTE1(v37);
        *((_BYTE *)v23 + 3) = v37;
        v23 = (unsigned __int16 *)&v38[v37];
        v52 = &v38[v37] <= limit;
        v13 = v58;
        if ( !v52 )
          return v13;
        memcpy(v38, v71, v51);
        *(_WORD *)plen = __ROL2__((_WORD)v23 - (_WORD)src, 8);
      }
      return (char *)v23 - (char *)v14;
    }
    v60 = v21;
    v56 = v20;
    v13 = v58;
    v40 = skip_questions(v14, v58, v24);
    if ( v40 )
    {
      v41 = v40;
      v67 = limit;
      v42 = _bswap_16(v14->ancount);
      v43 = v42 + _bswap_16(v14->nscount);
      v44 = _bswap_16(v14->arcount);
      v45 = skip_section(v41, v43 + (unsigned int)v44, v14, v58);
      if ( v45 )
      {
        v46 = v45;
        v47 = (unsigned __int8 *)(v45 + 11);
        limit = v67;
        if ( v47 <= v67 )
        {
          *(_WORD *)v46 = 0;
          *(_BYTE *)(v46 + 2) = 41;
          *(_BYTE *)(v46 + 3) = HIBYTE(v61);
          *(_BYTE *)(v46 + 4) = v61;
          *(_BYTE *)(v46 + 5) = HIBYTE(v60);
          *(_BYTE *)(v46 + 6) = v60;
          *(_BYTE *)(v46 + 7) = HIBYTE(v56);
          *(_BYTE *)(v46 + 8) = v56;
          *(_BYTE *)(v46 + 9) = BYTE1(opt);
          *(_BYTE *)(v46 + 10) = (_BYTE)opt;
          v48 = v47;
          v49 = v47;
          if ( v22 )
          {
            v63 = &v47[(int)opt];
            if ( v63 > v67 )
            {
              free(v22);
              return v13;
            }
            memcpy(v47, v22, (int)opt);
            free(v22);
            limit = v67;
            v49 = v63;
          }
          src = v48;
          plen = v46 + 9;
          v53 = (unsigned __int16 *)v49;
          v37 = optlen;
          if ( limit - v49 - 4 >= (__int64)optlen )
          {
            v54 = _bswap_16(v14->arcount);
            limit = v67;
            v14->arcount = _bswap_16(v54 + 1);
          }
          LODWORD(v24) = v57;
          v23 = v53;
          goto LABEL_27;
        }
      }
    }
  }
  return v13;
}
