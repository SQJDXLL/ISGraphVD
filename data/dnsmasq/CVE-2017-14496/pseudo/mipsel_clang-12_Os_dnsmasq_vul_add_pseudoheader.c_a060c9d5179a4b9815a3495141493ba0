int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s1
  void *v17; // $s7
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $s2
  char v21; // $s6
  unsigned __int8 *v22; // $fp
  int v23; // $s5
  int v24; // $s7
  int v25; // $v0
  unsigned __int8 *v26; // $a0
  signed int v27; // $s5
  unsigned __int8 *v28; // $v0
  _BYTE *v29; // $s4
  unsigned int v30; // $fp
  void *v31; // $v0
  void *v32; // $s2
  int v33; // $v0
  _BYTE *v34; // $v0
  _BYTE *v35; // $s2
  _BYTE *v36; // $s4
  unsigned __int8 *v37; // $s2
  __int16 v38; // $at
  unsigned __int8 v39; // [sp+1Ch] [-2Ch]
  void *src; // [sp+20h] [-28h]
  unsigned __int8 v41; // [sp+24h] [-24h]
  unsigned __int8 v42; // [sp+28h] [-20h]
  unsigned __int8 v43; // [sp+2Ch] [-1Ch]
  signed int v44; // [sp+30h] [-18h]
  unsigned __int8 *v45; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v48; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v48, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  v45 = limit;
  if ( !pseudoheader )
  {
    v44 = optlen;
    v21 = 0x80;
    if ( !set_do )
      v21 = 0;
    v30 = udp_sz >> 8;
    v23 = 0;
    v43 = 0;
    v42 = 0;
    v41 = 0;
    goto LABEL_28;
  }
  v20 = v48;
  v21 = v48[4];
  if ( set_do )
  {
    v21 |= 0x80u;
    v48[4] = v21;
  }
  if ( optno )
  {
    v44 = optlen;
    v22 = v20 + 8;
    v23 = (v20[6] << 8) | v20[7];
    if ( v15 >= v20 + 8 - (unsigned __int8 *)header + v23 )
    {
      v43 = v20[5];
      v41 = v20[3];
      v42 = v20[2];
      LOBYTE(udp_sz) = v20[1];
      v39 = *v20;
      src = v20 + 8;
      if ( (unsigned int)v23 < 5 )
      {
LABEL_16:
        if ( is_last )
        {
          v27 = optlen;
          v28 = v45;
          v29 = v20 + 6;
LABEL_34:
          v37 = v22 + 4;
          if ( v28 - (v22 + 4) >= v27 )
          {
            if ( optno && replace != 2 )
            {
              v22[3] = v27;
              v22[1] = optno;
              v22[2] = BYTE1(v27);
              *v22 = BYTE1(optno);
              memcpy(v22 + 4, opt, v27);
              v22 = &v37[v27];
              v38 = (_WORD)v37 + v27 - (_WORD)src;
              v29[1] = v38;
              *v29 = HIBYTE(v38);
            }
            return v22 - (unsigned __int8 *)header;
          }
          return v15;
        }
        v17 = 0;
        if ( v23 )
        {
          v31 = (void *)whine_malloc(v23);
          if ( v31 )
          {
            v32 = v31;
            memcpy(v31, src, v23);
            LOBYTE(v30) = v39;
            v17 = v32;
          }
          else
          {
            LOBYTE(v30) = v39;
          }
        }
        else
        {
          LOBYTE(v30) = v39;
          v23 = 0;
        }
      }
      else
      {
        v24 = 0;
        while ( 1 )
        {
          v25 = (v22[2] << 8) | v22[3];
          if ( v23 < v25 + v24 )
            break;
          v26 = v22 + 4;
          if ( ((*v22 << 8) | v22[1]) == optno )
          {
            if ( !replace )
              return v15;
            v23 = v23 - v25 - 4;
            memcpy(v22, &v26[v25], v23 - v24);
            v20[7] = v23;
            v20[6] = BYTE1(v23);
          }
          else
          {
            v22 = &v26[v25];
            v24 += v25 + 4;
          }
          if ( v24 + 4 >= v23 )
            goto LABEL_16;
        }
        is_last = 0;
        v23 = 0;
        LOBYTE(v30) = v39;
        v17 = 0;
      }
      v15 = rrfilter(header, v15, 0);
LABEL_28:
      v33 = skip_questions(header, v15);
      if ( !v33 )
        return v15;
      v34 = (_BYTE *)skip_section(
                       v33,
                       (_bswapw(header->nscount) >> 16)
                     + (_bswapw(header->ancount) >> 16)
                     + (_bswapw(header->arcount) >> 16),
                       header,
                       v15);
      if ( !v34 )
        return v15;
      v35 = v34;
      v34[10] = v23;
      v34[8] = v43;
      v34[7] = v21;
      v34[6] = v41;
      v34[5] = v42;
      v34[4] = udp_sz;
      v34[3] = v30;
      v34[2] = 41;
      v34[1] = 0;
      *v34 = 0;
      v34[9] = BYTE1(v23);
      v36 = v34 + 0xB;
      v22 = v34 + 0xB;
      if ( v17 )
      {
        memcpy(v34 + 0xB, v17, v23);
        free(v17);
        v22 = &v36[v23];
      }
      LOWORD(src) = (_WORD)v35 + 0xB;
      v28 = v45;
      v27 = v44;
      v29 = v35 + 9;
      if ( v45 - v22 - 4 >= v44 )
        header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
      goto LABEL_34;
    }
  }
  return v15;
}
