size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v11; // x22
  unsigned int v12; // w25
  unsigned __int8 *pseudoheader; // x0
  int v14; // w28
  unsigned __int8 *v15; // x21
  unsigned __int8 *v16; // x21
  unsigned int v17; // w25
  unsigned int v18; // w23
  unsigned int v19; // w19
  char *v20; // x27
  unsigned __int16 v21; // w0
  signed int v22; // w26
  unsigned __int8 *v23; // x28
  int v24; // w6
  unsigned __int8 *v25; // x0
  __int64 v26; // x1
  int v27; // w2
  unsigned int v28; // w23
  __int64 v29; // x0
  __int64 v30; // x0
  __int64 v31; // x3
  size_t v32; // x2
  __int64 v33; // x1
  _WORD *v34; // x21
  unsigned __int8 *v35; // x0
  bool v36; // zf
  int ia; // [xsp+78h] [xbp+78h]
  __int64 ib; // [xsp+78h] [xbp+78h]
  int is_sign; // [xsp+88h] [xbp+88h] BYREF
  int is_last; // [xsp+8Ch] [xbp+8Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF

  v11 = plen;
  v12 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v14 = is_sign;
  if ( is_sign )
    return v11;
  v15 = pseudoheader;
  if ( pseudoheader )
  {
    v16 = udp_len;
    v17 = *(unsigned __int16 *)udp_len;
    v18 = *((unsigned __int16 *)udp_len + 1);
    v19 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
    if ( set_do )
    {
      v19 |= 0x8000u;
      *((_WORD *)udp_len + 2) = __rev16(v19);
    }
    v20 = (char *)(v16 + 8);
    v21 = __rev16(*((unsigned __int16 *)v16 + 3));
    if ( v16 + 8 - (unsigned __int8 *)header + (unsigned __int64)v21 > v11 || !optno )
      return v11;
    v22 = v21;
    v23 = v16 + 8;
    v24 = 0;
    while ( v24 + 4 < v22 )
    {
      v26 = (unsigned __int16)__rev16(*((unsigned __int16 *)v23 + 1));
      v27 = (unsigned __int16)__rev16(*(unsigned __int16 *)v23);
      if ( v24 + 4 + (int)v26 > v22 )
      {
        is_last = 0;
LABEL_15:
        v22 = 0;
        v15 = 0LL;
LABEL_16:
        v12 = (unsigned __int16)__rev16(v17);
        v28 = (unsigned __int16)__rev16(v18);
        v11 = rrfilter(header, v11, 0LL);
        v14 = v22;
        goto LABEL_17;
      }
      if ( v27 == optno )
      {
        if ( !replace )
          return v11;
        v33 = v26 + 4;
        v22 -= v33;
        ia = v24;
        memcpy(v23, &v23[v33], v22 - v24);
        v24 = ia;
        *((_WORD *)v16 + 3) = __rev16(v22);
      }
      else
      {
        v24 += v26 + 4;
        v23 += (unsigned int)v26 + 4;
      }
    }
    if ( !is_last )
    {
      if ( !v22 )
        goto LABEL_15;
      v25 = (unsigned __int8 *)whine_malloc(v22);
      v15 = v25;
      if ( v25 )
        memcpy(v25, v20, v22);
      goto LABEL_16;
    }
    v34 = v16 + 6;
  }
  else
  {
    v28 = 0;
    v19 = (set_do != 0) << 15;
LABEL_17:
    v29 = skip_questions(header, v11);
    if ( !v29 )
      return v11;
    v30 = skip_section(
            v29,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    v31 = v30;
    if ( !v30 )
      return v11;
    v20 = (char *)(v30 + 0xB);
    if ( v30 + 0xB > (unsigned __int64)limit )
      return v11;
    *(_WORD *)v30 = 0;
    *(_BYTE *)(v30 + 2) = 41;
    *(_WORD *)(v30 + 3) = __rev16(v12);
    *(_WORD *)(v30 + 5) = __rev16(v28);
    *(_WORD *)(v30 + 7) = __rev16(v19);
    *(_WORD *)(v30 + 9) = __rev16(v14);
    if ( v15 )
    {
      v32 = v14;
      v23 = (unsigned __int8 *)&v20[v14];
      if ( v23 > limit )
      {
        free(v15);
        return v11;
      }
      ib = v30;
      memcpy(v20, v15, v32);
      free(v15);
      v31 = ib;
    }
    else
    {
      v23 = (unsigned __int8 *)(v30 + 0xB);
    }
    if ( limit - (v23 + 4) >= (__int64)optlen )
      header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
    v34 = (_WORD *)(v31 + 9);
  }
  v35 = v23 + 4;
  if ( limit - (v23 + 4) >= (__int64)optlen )
  {
    if ( optno )
      v36 = replace == 2;
    else
      v36 = 1;
    if ( v36 )
      return v23 - (unsigned __int8 *)header;
    if ( v35 <= limit )
    {
      *(_WORD *)v23 = __rev16((unsigned __int16)optno);
      *((_WORD *)v23 + 1) = __rev16((unsigned __int16)optlen);
      v23 = &v35[optlen];
      if ( &v35[optlen] <= limit )
      {
        memcpy(v35, opt, optlen);
        *v34 = __rev16((_DWORD)v23 - (_DWORD)v20);
        return v23 - (unsigned __int8 *)header;
      }
    }
  }
  return v11;
}
