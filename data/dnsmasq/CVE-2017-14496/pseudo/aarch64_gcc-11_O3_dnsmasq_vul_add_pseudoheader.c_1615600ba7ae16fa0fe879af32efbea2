size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  uint32x2_t v9; // d8
  unsigned __int64 v11; // x19
  unsigned __int32 v15; // w25
  unsigned __int8 *pseudoheader; // x0
  int v17; // w27
  unsigned __int8 *v18; // x5
  unsigned __int16 *v19; // x25
  unsigned int v20; // w22
  unsigned __int16 *v21; // x28
  unsigned __int16 v22; // w0
  signed int v23; // w26
  unsigned __int64 v24; // x0
  bool v25; // cc
  size_t v26; // x6
  unsigned __int16 *v28; // x2
  signed int v29; // w3
  int v30; // w0
  int v31; // w21
  int v32; // w0
  __int64 v33; // x0
  __int64 v34; // x26
  uint32x2_t v35; // d0
  uint32x2_t v36; // d1
  __int64 v37; // d0
  char *v38; // x0
  _WORD *v39; // x19
  bool v40; // zf
  unsigned __int8 *v41; // x5
  unsigned __int8 *v42; // x0
  int v43; // w1
  unsigned int v44; // w0
  unsigned __int8 *p; // [xsp+80h] [xbp+80h]
  unsigned __int8 *pa; // [xsp+80h] [xbp+80h]
  unsigned __int16 buff; // [xsp+88h] [xbp+88h]
  unsigned __int8 *buffa; // [xsp+88h] [xbp+88h]
  unsigned __int16 v51; // [xsp+94h] [xbp+94h]
  unsigned __int8 *v52; // [xsp+98h] [xbp+98h]
  int is_sign; // [xsp+A8h] [xbp+A8h] BYREF
  int is_last; // [xsp+ACh] [xbp+ACh] BYREF
  unsigned __int8 *udp_len; // [xsp+B0h] [xbp+B0h] BYREF

  v11 = plen;
  v15 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v11;
  v18 = pseudoheader;
  if ( !pseudoheader )
  {
    v9.n64_u32[0] = 0;
    v20 = (set_do != 0) << 15;
    goto LABEL_22;
  }
  v19 = (unsigned __int16 *)udp_len;
  buff = *(_WORD *)udp_len;
  v51 = *((_WORD *)udp_len + 1);
  v20 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
  if ( set_do )
  {
    v20 |= 0x8000u;
    *((_WORD *)udp_len + 2) = __rev16(v20);
  }
  v21 = v19 + 4;
  p = (unsigned __int8 *)(v19 + 4);
  v22 = __rev16(v19[3]);
  v23 = v22;
  v24 = (char *)(v19 + 4) - (char *)header + v22;
  if ( optno )
    v25 = v24 > v11;
  else
    v25 = 1;
  if ( v25 )
    return v11;
  if ( v23 <= 4 )
    goto LABEL_28;
  v28 = v19 + 6;
  v29 = (unsigned __int16)__rev16(v19[5]);
  v30 = (unsigned __int16)__rev16(v19[4]);
  if ( v29 <= v23 )
  {
    if ( !replace )
    {
      v43 = 0;
      while ( v30 != optno )
      {
        v43 += v29 + 4;
        v21 = (unsigned __int16 *)((char *)v28 + (unsigned __int16)v29);
        if ( v43 + 4 >= v23 )
          goto LABEL_28;
        v44 = *(unsigned __int16 *)((char *)v28 + (unsigned __int16)v29);
        v28 = v21 + 2;
        v29 = (unsigned __int16)__rev16(v21[1]);
        v30 = (unsigned __int16)__rev16(v44);
        if ( v29 + v43 > v23 )
          goto LABEL_37;
      }
      return v11;
    }
    v31 = 0;
    while ( 1 )
    {
      v40 = v30 == optno;
      v32 = v29 + 4;
      if ( v40 )
      {
        v23 -= v32;
        memcpy(v21, (char *)v21 + (unsigned __int16)v29 + 4, v23 - v31);
        v19[3] = __rev16(v23);
      }
      else
      {
        v21 = (unsigned __int16 *)((char *)v28 + (unsigned __int16)v29);
        v31 += v32;
      }
      if ( v31 + 4 >= v23 )
        break;
      v28 = v21 + 2;
      v29 = (unsigned __int16)__rev16(v21[1]);
      v30 = (unsigned __int16)__rev16(*v21);
      if ( v29 + v31 > v23 )
        goto LABEL_37;
    }
LABEL_28:
    if ( is_last )
    {
      v38 = (char *)(v21 + 2);
      if ( limit - (unsigned __int8 *)(v21 + 2) >= (__int64)optlen )
      {
        v39 = v19 + 3;
        goto LABEL_31;
      }
      return v11;
    }
    if ( v23 )
    {
      v17 = v23;
      v42 = (unsigned __int8 *)whine_malloc(v23);
      v41 = v42;
      if ( v42 )
      {
        v52 = v42;
        memcpy(v42, p, v23);
        v41 = v52;
      }
    }
    else
    {
      v17 = 0;
      v41 = 0LL;
    }
    goto LABEL_38;
  }
LABEL_37:
  v41 = 0LL;
  is_last = 0;
LABEL_38:
  pa = v41;
  v15 = (unsigned __int16)__rev16(buff);
  v9.n64_u32[0] = (unsigned __int16)__rev16(v51);
  v11 = rrfilter(header, v11, 0LL);
  v18 = pa;
LABEL_22:
  buffa = v18;
  v33 = skip_questions(header, v11);
  v26 = v11;
  if ( v33 )
  {
    v34 = skip_section(
            v33,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    v26 = v11;
    if ( v34 )
    {
      v35.n64_u32[0] = v15;
      v36.n64_u32[0] = v20;
      LOBYTE(v37) = vshr_n_u32(v35, 8uLL).n64_u8[0];
      *(_WORD *)v34 = 0;
      BYTE1(v37) = v15;
      *(_BYTE *)(v34 + 2) = 41;
      LODWORD(p) = v34 + 0xB;
      v21 = (unsigned __int16 *)(v34 + 0xB);
      BYTE2(v37) = vshr_n_u32(v9, 8uLL).n64_u8[0];
      BYTE3(v37) = v9.n64_u8[0];
      BYTE4(v37) = vshr_n_u32(v36, 8uLL).n64_u8[0];
      BYTE5(v37) = v20;
      BYTE6(v37) = BYTE1(v17);
      HIBYTE(v37) = v17;
      *(_QWORD *)(v34 + 3) = v37;
      if ( buffa )
      {
        v21 = (unsigned __int16 *)(v34 + 0xB + v17);
        memcpy((void *)(v34 + 0xB), buffa, v17);
        free(buffa);
      }
      v38 = (char *)(v21 + 2);
      v26 = v11;
      if ( limit - (unsigned __int8 *)(v21 + 2) >= (__int64)optlen )
      {
        v39 = (_WORD *)(v34 + 9);
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_31:
        if ( optno )
          v40 = replace == 2;
        else
          v40 = 1;
        if ( !v40 )
        {
          *v21 = __rev16(optno);
          v21[1] = __rev16(optlen);
          v21 = (unsigned __int16 *)&v38[optlen];
          memcpy(v38, opt, optlen);
          *v39 = __rev16((_DWORD)v21 - (_DWORD)p);
        }
        return (char *)v21 - (char *)header;
      }
    }
  }
  return v26;
}
