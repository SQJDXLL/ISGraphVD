size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // r13
  dns_header *v12; // rbp
  unsigned __int8 *pseudoheader; // rax
  __int64 v15; // rcx
  __int64 v16; // r8
  unsigned __int8 *v17; // r9
  unsigned __int8 *v18; // rsi
  __int16 v19; // r10
  unsigned __int8 *v20; // rdi
  int v21; // r14d
  unsigned __int8 *v22; // r11
  unsigned __int16 v23; // dx
  int v24; // eax
  int v25; // ebp
  unsigned int v26; // r14d
  int v27; // r12d
  int v28; // ebx
  __int16 v29; // r15
  __int16 v30; // r10
  __int64 v31; // rax
  dns_header *v33; // r9
  __int64 v34; // rax
  void *v35; // r8
  _WORD *v36; // r12
  char *v37; // rax
  __int64 v38; // rax
  __int64 v39; // rcx
  int v40; // r8d
  unsigned __int8 *v41; // r9
  __int64 v42; // r15
  __int64 v43; // r14
  dns_header *v44; // rax
  dns_header *v45; // rax
  const void *rdlen; // [rsp+10h] [rbp-88h]
  int rdlena; // [rsp+10h] [rbp-88h]
  __int16 ptr; // [rsp+18h] [rbp-80h]
  __int16 ptra; // [rsp+18h] [rbp-80h]
  unsigned __int8 *ptrb; // [rsp+18h] [rbp-80h]
  __int16 buff; // [rsp+20h] [rbp-78h]
  unsigned __int8 *buffa; // [rsp+20h] [rbp-78h]
  unsigned __int8 *buffb; // [rsp+20h] [rbp-78h]
  __int16 flags; // [rsp+28h] [rbp-70h]
  __int16 flagsa; // [rsp+28h] [rbp-70h]
  dns_header *headera; // [rsp+30h] [rbp-68h]
  dns_header *headerc; // [rsp+30h] [rbp-68h]
  __int16 headerb; // [rsp+30h] [rbp-68h]
  unsigned __int8 *limita; // [rsp+38h] [rbp-60h]
  int is_sign; // [rsp+48h] [rbp-50h] BYREF
  int is_last; // [rsp+4Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+50h] [rbp-48h] BYREF

  v10 = plen;
  v12 = header;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v16 = (unsigned int)is_sign;
  if ( is_sign )
    return v10;
  v17 = pseudoheader;
  if ( !pseudoheader )
  {
    v29 = 0;
    v30 = (set_do != 0) << 15;
    goto LABEL_17;
  }
  v18 = udp_len[0];
  buff = *(_WORD *)udp_len[0];
  v19 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
  ptr = *((_WORD *)udp_len[0] + 1);
  if ( set_do )
  {
    v19 |= 0x8000u;
    *((_WORD *)udp_len[0] + 2) = __ROL2__(v19, 8);
  }
  v20 = v18 + 8;
  rdlen = v18 + 8;
  LOWORD(v21) = __ROL2__(*((_WORD *)v18 + 3), 8);
  if ( v10 < (unsigned __int64)(unsigned __int16)v21 + v18 + 8 - (unsigned __int8 *)v12 || !optno )
    return v10;
  v21 = (unsigned __int16)v21;
  if ( (unsigned __int16)v21 <= 4u )
  {
    v20 = v18 + 8;
  }
  else
  {
    v15 = *((unsigned __int16 *)v18 + 4);
    v22 = v18 + 12;
    v23 = __ROL2__(*((_WORD *)v18 + 5), 8);
    LOWORD(v15) = __ROL2__(v15, 8);
    v24 = v23;
    if ( (unsigned __int16)v21 < (int)v23 )
    {
LABEL_20:
      is_last = 0;
      goto LABEL_21;
    }
    headera = v12;
    v25 = (unsigned __int16)v21;
    v26 = v16;
    limita = limit;
    v27 = optno;
    v28 = 0;
    flags = v19;
    while ( 1 )
    {
      v15 = (unsigned __int16)v15;
      if ( (unsigned __int16)v15 == v27 )
      {
        if ( !replace )
          return v10;
        v25 -= v24 + 4;
        v20 = (unsigned __int8 *)memcpy(v20, &v20[v23 + 4], v25 - v28);
        *((_WORD *)v18 + 3) = __ROL2__(v25, 8);
      }
      else
      {
        v28 += v24 + 4;
        v20 = &v22[v23];
      }
      if ( v28 + 4 >= v25 )
        break;
      v15 = *(unsigned __int16 *)v20;
      v22 = v20 + 4;
      v23 = __ROL2__(*((_WORD *)v20 + 1), 8);
      LOWORD(v15) = __ROL2__(v15, 8);
      v24 = v23;
      if ( v23 + v28 > v25 )
      {
        optno = v27;
        v12 = headera;
        limit = limita;
        LODWORD(v16) = v26;
        v19 = flags;
        goto LABEL_20;
      }
    }
    v16 = v26;
    optno = v27;
    v21 = v25;
    v19 = flags;
    v12 = headera;
    limit = limita;
  }
  if ( !is_last )
  {
    if ( v21 )
    {
      headerb = v19;
      v44 = (dns_header *)whine_malloc(v21, v18, v21, v15, v16);
      v19 = headerb;
      v33 = v44;
      if ( v44 )
      {
        v45 = (dns_header *)memcpy(v44, rdlen, v21);
        v19 = headerb;
        v33 = v45;
      }
      LODWORD(v16) = v21;
      goto LABEL_22;
    }
LABEL_21:
    v33 = 0LL;
LABEL_22:
    headerc = v33;
    flagsa = v19;
    udp_sz = __ROL2__(buff, 8);
    rdlena = v16;
    v29 = __ROL2__(ptr, 8);
    v34 = rrfilter(v12, v10, 0LL, v15);
    LODWORD(v16) = rdlena;
    v30 = flagsa;
    v17 = (unsigned __int8 *)headerc;
    v10 = v34;
LABEL_17:
    buffa = v17;
    ptra = v30;
    LODWORD(rdlen) = v16;
    v31 = skip_questions(v12, v10);
    if ( v31 )
    {
      v38 = skip_section(
              v31,
              (unsigned __int16)__ROL2__(v12->arcount, 8)
            + (unsigned __int16)__ROL2__(v12->nscount, 8)
            + (unsigned int)(unsigned __int16)__ROL2__(v12->ancount, 8),
              v12,
              v10);
      v39 = v38;
      if ( v38 )
      {
        v40 = (int)rdlen;
        *(_BYTE *)(v38 + 2) = 41;
        *(_WORD *)v38 = 0;
        v41 = buffa;
        *(_QWORD *)(v38 + 3) = HIBYTE(udp_sz) | (((unsigned __int8)udp_sz | ((HIBYTE(v29) | (((unsigned __int8)v29 | ((HIBYTE(ptra) | (((unsigned __int8)ptra | ((BYTE1(rdlen) | ((unsigned __int64)(unsigned __int8)rdlen << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
        LOWORD(rdlen) = v38 + 11;
        v42 = v38 + 11;
        v20 = (unsigned __int8 *)(v38 + 11);
        if ( buffa )
        {
          v43 = v40;
          buffb = (unsigned __int8 *)v38;
          ptrb = v41;
          memcpy(v20, v41, v40);
          free(ptrb);
          v39 = (__int64)buffb;
          v20 = (unsigned __int8 *)(v42 + v43);
        }
        v35 = v20 + 4;
        if ( limit - (v20 + 4) >= (__int64)optlen )
        {
          v36 = (_WORD *)(v39 + 9);
          v12->arcount = __ROL2__(__ROL2__(v12->arcount, 8) + 1, 8);
          goto LABEL_27;
        }
      }
    }
    return v10;
  }
  v35 = v20 + 4;
  if ( limit - (v20 + 4) < (__int64)optlen )
    return v10;
  v36 = v18 + 6;
LABEL_27:
  if ( optno )
  {
    if ( replace != 2 )
    {
      *(_DWORD *)v20 = BYTE1(optno) | (((unsigned __int8)optno | ((BYTE1(optlen) | ((unsigned __int8)optlen << 8)) << 8)) << 8);
      v37 = (char *)memcpy(v35, opt, optlen);
      v20 = (unsigned __int8 *)&v37[optlen];
      *v36 = __ROL2__((_WORD)v37 + optlen - (_WORD)rdlen, 8);
    }
  }
  return v20 - (unsigned __int8 *)v12;
}
