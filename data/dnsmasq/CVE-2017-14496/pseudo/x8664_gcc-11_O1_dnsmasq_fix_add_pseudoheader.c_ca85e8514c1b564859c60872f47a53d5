size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // rax
  int v11; // r15d
  unsigned __int8 *v12; // r12
  unsigned __int8 *v13; // r12
  __int16 v14; // di
  unsigned __int8 v15; // si
  __int16 v16; // cx
  unsigned __int8 v17; // dl
  unsigned __int16 v18; // ax
  int v19; // ebp
  unsigned __int64 v20; // rbx
  unsigned __int16 v21; // dx
  unsigned __int16 v22; // ax
  unsigned __int8 *v23; // rdi
  int v24; // ecx
  int v25; // r13d
  unsigned __int64 v26; // rax
  _BYTE *v27; // r12
  void *v28; // rdi
  unsigned __int8 *v30; // rax
  __int64 v31; // rdi
  _BYTE *v32; // rax
  _BYTE *v33; // rbp
  _BYTE *v34; // rax
  unsigned __int64 plena; // [rsp+0h] [rbp-88h]
  unsigned __int8 *p; // [rsp+20h] [rbp-68h]
  unsigned __int16 flags; // [rsp+2Ch] [rbp-5Ch]
  unsigned __int16 rcode; // [rsp+2Eh] [rbp-5Ah]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  plena = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v11 = is_sign;
  if ( is_sign )
    return plena;
  v12 = pseudoheader;
  if ( !pseudoheader )
  {
    flags = (set_do != 0) << 15;
    rcode = 0;
LABEL_37:
    v31 = skip_questions(header, plena);
    if ( !v31 )
      return plena;
    v32 = (_BYTE *)skip_section(
                     v31,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8)
                   + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8),
                     header,
                     plena);
    v33 = v32;
    if ( !v32 || limit < v32 + 11 )
      return plena;
    *v32 = 0;
    v32[1] = 0;
    v32[2] = 41;
    v32[3] = HIBYTE(udp_sz);
    v32[4] = udp_sz;
    v32[5] = HIBYTE(rcode);
    v32[6] = rcode;
    v32[7] = HIBYTE(flags);
    v32[8] = flags;
    v32[9] = BYTE1(v11);
    v32[10] = v11;
    v34 = v32 + 11;
    p = v33 + 11;
    if ( v12 )
    {
      v20 = (unsigned __int64)&v34[v11];
      if ( v20 > (unsigned __int64)limit )
      {
        free(v12);
        return plena;
      }
      memcpy(p, v12, v11);
      free(v12);
    }
    else
    {
      v20 = (unsigned __int64)(v33 + 11);
    }
    v26 = v20 + 4;
    if ( (__int64)&limit[-v20 - 4] < (__int64)optlen )
      return plena;
    v27 = v33 + 9;
    header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    goto LABEL_22;
  }
  v13 = udp_len[0];
  v14 = *udp_len[0];
  v15 = udp_len[0][1];
  v16 = udp_len[0][2];
  v17 = udp_len[0][3];
  v18 = _byteswap_ushort(*((_WORD *)udp_len[0] + 2));
  flags = v18;
  if ( set_do )
  {
    flags = v18 | 0x8000;
    udp_len[0][4] = (unsigned __int16)(v18 | 0x8000) >> 8;
    v13[5] = v18;
  }
  v19 = v13[7] | (v13[6] << 8);
  v20 = (unsigned __int64)(v13 + 8);
  p = v13 + 8;
  if ( v19 + v13 + 8 - (unsigned __int8 *)header > plena || !optno )
    return plena;
  udp_sz = v15 | (unsigned __int16)(v14 << 8);
  rcode = v17 | (unsigned __int16)(v16 << 8);
  if ( v19 <= 4 )
  {
    if ( is_last )
    {
      v20 = (unsigned __int64)(v13 + 8);
      goto LABEL_20;
    }
    goto LABEL_29;
  }
  v21 = _byteswap_ushort(*((_WORD *)v13 + 4));
  v22 = _byteswap_ushort(*((_WORD *)v13 + 5));
  v23 = v13 + 12;
  v24 = v22;
  if ( v19 < v22 + 4 )
  {
LABEL_10:
    is_last = 0;
    v12 = 0LL;
LABEL_11:
    plena = rrfilter(header, plena, 0LL);
    goto LABEL_37;
  }
  v25 = v11;
  while ( 1 )
  {
    if ( v21 == optno )
    {
      if ( !replace )
        return plena;
      v19 -= v24 + 4;
      memcpy((void *)v20, (const void *)(v20 + v22 + 4), v19 - v25);
      v13[6] = BYTE1(v19);
      v13[7] = v19;
    }
    else
    {
      v20 = (unsigned __int64)&v23[v22];
      v25 += v24 + 4;
    }
    if ( v25 + 4 >= v19 )
      break;
    v21 = _byteswap_ushort(*(_WORD *)v20);
    v22 = _byteswap_ushort(*(_WORD *)(v20 + 2));
    v23 = (unsigned __int8 *)(v20 + 4);
    v24 = v22;
    if ( v22 + v25 + 4 > v19 )
      goto LABEL_10;
  }
  if ( !is_last )
  {
LABEL_29:
    if ( v19 )
    {
      v30 = (unsigned __int8 *)whine_malloc(v19);
      v12 = v30;
      v11 = v19;
      if ( v30 )
        memcpy(v30, p, v19);
    }
    else
    {
      v11 = 0;
      v12 = 0LL;
    }
    goto LABEL_11;
  }
  if ( !v20 )
  {
    v11 = v19;
    v12 = 0LL;
    goto LABEL_37;
  }
LABEL_20:
  v26 = v20 + 4;
  if ( (__int64)&limit[-v20 - 4] < (__int64)optlen )
    return plena;
  v27 = v13 + 6;
LABEL_22:
  if ( !optno || replace == 2 )
    return v20 - (_QWORD)header;
  if ( (unsigned __int64)limit >= v26 )
  {
    *(_BYTE *)v20 = BYTE1(optno);
    *(_BYTE *)(v20 + 1) = optno;
    *(_BYTE *)(v20 + 2) = BYTE1(optlen);
    *(_BYTE *)(v20 + 3) = optlen;
    v28 = (void *)(v20 + 4);
    v20 += optlen + 4;
    if ( v20 <= (unsigned __int64)limit )
    {
      memcpy(v28, opt, optlen);
      *v27 = (unsigned __int16)(v20 - (_WORD)p) >> 8;
      v27[1] = v20 - (_BYTE)p;
      return v20 - (_QWORD)header;
    }
  }
  return plena;
}
