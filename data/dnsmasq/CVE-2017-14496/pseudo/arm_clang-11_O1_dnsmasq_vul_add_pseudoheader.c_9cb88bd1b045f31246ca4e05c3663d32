size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v9; // r7
  unsigned int v11; // r6
  unsigned __int8 *pseudoheader; // r0
  int v15; // r4
  char v16; // r3
  unsigned __int8 *v17; // r8
  unsigned __int8 v18; // r3
  unsigned __int8 v19; // r12
  unsigned __int8 v20; // r7
  unsigned __int8 v21; // lr
  int v22; // r5
  unsigned __int8 *v23; // r11
  int v24; // r10
  int v25; // r0
  unsigned int v26; // r12
  void *v27; // r1
  int v28; // r8
  int v29; // r0
  void *v30; // r1
  void *v31; // r0
  void *v32; // r7
  void *v33; // r4
  int v34; // r8
  unsigned __int8 *v35; // r5
  bool v36; // zf
  __int16 v37; // r0
  char v38; // r4
  int v39; // r0
  int v40; // r7
  int v41; // r8
  int v42; // r8
  int v43; // r0
  _BYTE *v44; // r0
  _BYTE *v45; // r4
  _BYTE *v46; // r7
  __uint16_t v47; // r0
  unsigned __int8 v48; // [sp+10h] [bp-50h]
  unsigned __int8 *v49; // [sp+14h] [bp-4Ch]
  _BYTE *v50; // [sp+18h] [bp-48h]
  void *src; // [sp+1Ch] [bp-44h]
  void *srca; // [sp+1Ch] [bp-44h]
  unsigned __int8 v53; // [sp+20h] [bp-40h]
  char v54; // [sp+20h] [bp-40h]
  unsigned __int8 v55; // [sp+24h] [bp-3Ch]
  char v56; // [sp+24h] [bp-3Ch]
  unsigned __int8 v57; // [sp+28h] [bp-38h]
  unsigned __int8 v58; // [sp+2Ch] [bp-34h]
  int v59; // [sp+30h] [bp-30h] BYREF
  int v60; // [sp+34h] [bp-2Ch] BYREF
  unsigned __int8 *v61; // [sp+38h] [bp-28h] BYREF

  v9 = udp_sz;
  v11 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v61, &v60, &v59);
  if ( v60 )
    return v11;
  v15 = optno;
  v16 = set_do;
  if ( set_do )
    v16 = 0x80;
  if ( pseudoheader )
  {
    v17 = v61;
    v18 = v61[4];
    v19 = *v61;
    v20 = v61[1];
    v21 = v61[2];
    v58 = v61[3];
    v57 = v61[5];
    if ( set_do )
    {
      v18 |= 0x80u;
      v61[4] = v18;
    }
    v22 = v17[7] | (v17[6] << 8);
    v50 = v17 + 6;
    v23 = v17 + 8;
    src = v17 + 8;
    if ( !optno || v23 - (unsigned __int8 *)header + v22 > v11 )
      return v11;
    v53 = v19;
    v48 = v18;
    v55 = v20;
    v49 = limit;
    if ( (unsigned int)v22 >= 5 )
    {
      v24 = 0;
      v9 = (unsigned int)(v17 + 8);
      while ( 1 )
      {
        v25 = *(unsigned __int8 *)(v9 + 3) | (*(unsigned __int8 *)(v9 + 2) << 8);
        v23 = (unsigned __int8 *)(v9 + 4);
        if ( v25 + v24 > v22 )
        {
          v22 = 0;
          v59 = 0;
          break;
        }
        if ( (*(unsigned __int8 *)(v9 + 1) | (*(unsigned __int8 *)v9 << 8)) == v15 )
        {
          if ( !replace )
          {
            v28 = 0;
            v27 = 0;
            v29 = v11;
            limit = v49;
            goto LABEL_29;
          }
          v22 = v22 - v25 - 4;
          memcpy((void *)v9, &v23[v25], v22 - v24);
          v15 = optno;
          v17[7] = v22;
          v17[6] = BYTE1(v22);
        }
        else
        {
          v9 = (unsigned int)&v23[v25];
          v24 += v25 + 4;
        }
        if ( v24 + 4 >= v22 )
          goto LABEL_22;
      }
    }
    v9 = (unsigned int)v23;
LABEL_22:
    v28 = 1;
    if ( v59 )
    {
      v23 = (unsigned __int8 *)v9;
      v29 = v11;
      limit = v49;
      LOBYTE(v9) = v55;
      v16 = v48;
      LOBYTE(v26) = v53;
      v27 = 0;
    }
    else
    {
      v23 = 0;
      v30 = 0;
      limit = v49;
      if ( v22 )
      {
        v31 = (void *)whine_malloc(v22, 0);
        v30 = 0;
        if ( v31 )
        {
          v32 = v31;
          memcpy(v31, src, v22);
          v30 = v32;
        }
      }
      v33 = v30;
      v29 = rrfilter(header, v11, 0);
      v27 = v33;
      v15 = optno;
LABEL_29:
      LOBYTE(v9) = v55;
      v16 = v48;
      LOBYTE(v26) = v53;
      if ( !v28 )
        return v11;
    }
    v11 = v29;
  }
  else
  {
    v58 = 0;
    v26 = v9 >> 8;
    v21 = 0;
    v57 = 0;
    v22 = 0;
    v27 = 0;
    v23 = 0;
  }
  v34 = optlen;
  if ( !v23 )
  {
    srca = v27;
    v54 = v26;
    v38 = v16;
    v56 = v9;
    v39 = skip_questions(header, v11);
    if ( !v39 )
      return v11;
    v40 = v39;
    v41 = _bswap_16(header->ancount);
    v42 = _bswap_16(header->nscount) + v41;
    v43 = _bswap_16(header->arcount);
    v44 = (_BYTE *)skip_section(v40, v42 + v43, header, v11);
    if ( !v44 )
      return v11;
    v44[10] = v22;
    v44[8] = v57;
    v44[7] = v38;
    v44[6] = v58;
    v44[5] = v21;
    v44[4] = v56;
    v44[3] = v54;
    v44[2] = 41;
    v44[1] = 0;
    *v44 = 0;
    v44[9] = BYTE1(v22);
    v45 = v44 + 9;
    v46 = v44 + 0xB;
    v23 = v44 + 0xB;
    if ( srca )
    {
      memcpy(v44 + 0xB, srca, v22);
      free(srca);
      v23 = &v46[v22];
    }
    LOWORD(src) = (_WORD)v46;
    v34 = optlen;
    v50 = v45;
    if ( limit - v23 - 4 >= (int)optlen )
    {
      v47 = _bswap_16(header->arcount);
      header->arcount = _bswap_16(v47 + 1);
    }
    v15 = optno;
  }
  v35 = v23 + 4;
  if ( limit - (v23 + 4) >= v34 )
  {
    v36 = v15 == 0;
    if ( v15 )
      v36 = replace == 2;
    if ( !v36 )
    {
      v23[3] = v34;
      v23[1] = v15;
      v23[2] = BYTE1(v34);
      *v23 = BYTE1(v15);
      memcpy(v23 + 4, opt, v34);
      v23 = &v35[v34];
      v37 = (_WORD)v35 + v34 - (_WORD)src;
      v50[1] = v37;
      *v50 = HIBYTE(v37);
    }
    return v23 - (unsigned __int8 *)header;
  }
  return v11;
}
