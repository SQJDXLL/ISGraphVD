signed __int64 __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v15; // x22
  unsigned __int8 *pseudoheader; // x0
  char v19; // w21
  unsigned __int8 *v20; // x20
  unsigned __int8 v21; // w12
  unsigned __int8 v22; // w10
  unsigned __int8 v23; // w11
  _WORD *v24; // x26
  unsigned __int64 v25; // x28
  unsigned __int16 *v26; // x27
  int v27; // w24
  unsigned __int64 v28; // x8
  unsigned __int16 *v29; // x9
  unsigned __int8 v30; // w26
  __int64 v31; // x0
  __int64 v32; // x21
  __int64 v33; // x8
  void *v34; // x0
  int v35; // w8
  unsigned __int64 v36; // x9
  int v37; // w8
  int v38; // w9
  __int64 v39; // x0
  unsigned __int16 *v40; // x25
  size_t n; // [xsp+0h] [xbp-50h]
  void *src; // [xsp+8h] [xbp-48h]
  unsigned __int8 *v43; // [xsp+10h] [xbp-40h]
  unsigned __int8 v44; // [xsp+18h] [xbp-38h]
  int v45; // [xsp+1Ch] [xbp-34h]
  unsigned __int8 *v46; // [xsp+20h] [xbp-30h]
  void *dest; // [xsp+28h] [xbp-28h]
  __int64 v48; // [xsp+34h] [xbp-1Ch]
  unsigned __int8 v49; // [xsp+3Ch] [xbp-14h]
  int is_last; // [xsp+40h] [xbp-10h] BYREF
  int is_sign; // [xsp+44h] [xbp-Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+48h] [xbp-8h] BYREF

  v15 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( set_do )
    v19 = 0x80;
  else
    v19 = 0;
  if ( !pseudoheader )
  {
    v45 = replace;
    src = 0LL;
    LODWORD(v25) = 0;
    v30 = 0;
    v49 = 0;
    v48 = HIBYTE(udp_sz);
    v31 = skip_questions(header, v15);
    if ( !v31 )
      return v15;
    goto LABEL_37;
  }
  v46 = limit;
  v20 = udp_len;
  v21 = *udp_len;
  LOBYTE(udp_sz) = udp_len[1];
  v22 = udp_len[2];
  v23 = udp_len[3];
  v19 = udp_len[4];
  v44 = udp_len[5];
  if ( set_do )
  {
    v19 |= 0x80u;
    udp_len[4] = v19;
  }
  v24 = v20 + 6;
  if ( optno )
  {
    v49 = v22;
    v25 = bswap64((unsigned __int64)*((unsigned __int16 *)v20 + 3) << 48);
    LOBYTE(v48) = v21;
    BYTE4(v48) = v23;
    dest = v20 + 8;
    if ( v20 + 8 - (unsigned __int8 *)header + v25 <= v15 )
    {
      n = optlen;
      v43 = opt;
      v45 = replace;
      if ( (unsigned int)v25 < 5 )
      {
        v26 = (unsigned __int16 *)(v20 + 8);
LABEL_22:
        if ( is_last )
        {
          optlen = n;
          limit = v46;
          LODWORD(v32) = (_DWORD)dest;
          v33 = (int)n;
LABEL_42:
          v40 = v26 + 2;
          if ( v33 <= limit - (unsigned __int8 *)(v26 + 2) )
          {
            if ( optno && v45 != 2 )
            {
              *((_BYTE *)v26 + 1) = optno;
              *(_BYTE *)v26 = BYTE1(optno);
              *((_BYTE *)v26 + 2) = BYTE1(optlen);
              *((_BYTE *)v26 + 3) = optlen;
              memcpy(v26 + 2, v43, optlen);
              v26 = (unsigned __int16 *)((char *)v40 + optlen);
              *v24 = bswap32((_DWORD)v40 + optlen - v32) >> 16;
            }
            return (char *)v26 - (char *)header;
          }
          return v15;
        }
        optlen = n;
        limit = v46;
        if ( (_DWORD)v25 )
        {
          v34 = (void *)whine_malloc((int)v25);
          v30 = v44;
          if ( v34 )
          {
            src = v34;
            memcpy(v34, dest, (int)v25);
          }
          else
          {
            src = 0LL;
          }
          opt = v43;
        }
        else
        {
          opt = v43;
          v30 = v44;
          src = 0LL;
        }
      }
      else
      {
        if ( replace )
        {
          v26 = (unsigned __int16 *)(v20 + 8);
          v27 = 0;
          while ( 1 )
          {
            v28 = bswap64((unsigned __int64)v26[1] << 48);
            if ( (int)v28 + v27 > (int)v25 )
              break;
            v29 = v26 + 2;
            if ( bswap32(*v26 << 16) == optno )
            {
              LODWORD(v25) = v25 - v28 - 4;
              memcpy(v26, (char *)v29 + v28, (int)v25 - v27);
              *((_WORD *)v20 + 3) = bswap32(v25) >> 16;
              if ( v27 + 4 >= (int)v25 )
                goto LABEL_22;
            }
            else
            {
              v26 = (unsigned __int16 *)((char *)v29 + v28);
              v27 += v28 + 4;
              if ( v27 + 4 >= (int)v25 )
                goto LABEL_22;
            }
          }
        }
        else
        {
          v26 = (unsigned __int16 *)(v20 + 8);
          v35 = 0;
          while ( 1 )
          {
            v36 = bswap64((unsigned __int64)v26[1] << 48);
            if ( (int)v36 + v35 > (int)v25 )
              break;
            if ( bswap32(*v26 << 16) == optno )
              return v15;
            v37 = v35 + v36;
            v26 = (unsigned __int16 *)((char *)v26 + v36 + 4);
            v38 = v37 + 8;
            v35 = v37 + 4;
            if ( v38 >= (int)v25 )
              goto LABEL_22;
          }
        }
        optlen = n;
        opt = v43;
        limit = v46;
        v30 = v44;
        LODWORD(v25) = 0;
        src = 0LL;
        is_last = 0;
      }
      v15 = rrfilter(header, v15, 0LL);
      v31 = skip_questions(header, v15);
      if ( !v31 )
        return v15;
LABEL_37:
      v39 = skip_section(
              v31,
              (bswap32(header->nscount) >> 0x10)
            + (bswap32(header->ancount) >> 0x10)
            + (bswap32(header->arcount) >> 0x10),
              header,
              v15);
      if ( !v39 )
        return v15;
      *(_BYTE *)(v39 + 2) = 41;
      *(_BYTE *)(v39 + 3) = v48;
      *(_BYTE *)(v39 + 7) = v19;
      *(_BYTE *)(v39 + 8) = v30;
      *(_BYTE *)(v39 + 5) = v49;
      v32 = v39 + 0xB;
      v43 = opt;
      *(_WORD *)v39 = 0;
      *(_BYTE *)(v39 + 6) = BYTE4(v48);
      *(_BYTE *)(v39 + 4) = udp_sz;
      *(_BYTE *)(v39 + 9) = BYTE1(v25);
      v24 = (_WORD *)(v39 + 9);
      v26 = (unsigned __int16 *)(v39 + 0xB);
      *(_BYTE *)(v39 + 10) = v25;
      if ( src )
      {
        memcpy((void *)(v39 + 0xB), src, (int)v25);
        free(src);
        v26 = (unsigned __int16 *)(v32 + (int)v25);
      }
      v33 = (int)optlen;
      if ( (int)optlen <= limit - (unsigned __int8 *)v26 - 4 )
        header->arcount = bswap32((bswap32(header->arcount) >> 0x10) + 1) >> 16;
      goto LABEL_42;
    }
  }
  return v15;
}
