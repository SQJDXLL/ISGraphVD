size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  __int16 v9; // w8
  uint16_t v10; // w0
  unsigned __int8 *v11; // x8
  uint16_t v12; // w0
  int v14; // [xsp+10h] [xbp-160h]
  uint16_t v15; // [xsp+14h] [xbp-15Ch]
  unsigned __int8 *v16; // [xsp+18h] [xbp-158h]
  unsigned __int8 *v17; // [xsp+20h] [xbp-150h]
  unsigned __int8 v18; // [xsp+2Eh] [xbp-142h]
  _BYTE *v19; // [xsp+30h] [xbp-140h]
  char v20; // [xsp+3Eh] [xbp-132h]
  _BYTE *v21; // [xsp+40h] [xbp-130h]
  char v22; // [xsp+4Eh] [xbp-122h]
  _BYTE *v23; // [xsp+50h] [xbp-120h]
  char v24; // [xsp+5Eh] [xbp-112h]
  _BYTE *v25; // [xsp+60h] [xbp-110h]
  _BYTE *v26; // [xsp+70h] [xbp-100h]
  _BYTE *v27; // [xsp+80h] [xbp-F0h]
  char v28; // [xsp+8Eh] [xbp-E2h]
  _BYTE *v29; // [xsp+90h] [xbp-E0h]
  unsigned __int8 *v30; // [xsp+A0h] [xbp-D0h]
  unsigned __int8 v31; // [xsp+AEh] [xbp-C2h]
  _BYTE *v32; // [xsp+C8h] [xbp-A8h]
  unsigned __int16 v33; // [xsp+F0h] [xbp-80h]
  unsigned __int16 v34; // [xsp+F2h] [xbp-7Eh]
  int v35; // [xsp+F4h] [xbp-7Ch]
  unsigned __int8 *t_cp_1; // [xsp+F8h] [xbp-78h] BYREF
  unsigned __int8 *t_cp_0; // [xsp+100h] [xbp-70h] BYREF
  unsigned __int8 *t_cp; // [xsp+108h] [xbp-68h]
  unsigned __int8 *len; // [xsp+110h] [xbp-60h] BYREF
  unsigned __int8 *rcode; // [xsp+118h] [xbp-58h]
  const void *is_sign; // [xsp+120h] [xbp-50h]
  unsigned __int8 *buff; // [xsp+128h] [xbp-48h]
  unsigned __int8 *udp_len; // [xsp+130h] [xbp-40h]
  unsigned __int8 *p; // [xsp+138h] [xbp-38h]
  unsigned __int8 *datap; // [xsp+140h] [xbp-30h]
  unsigned __int8 *lenp; // [xsp+148h] [xbp-28h]
  unsigned __int8 *replacea; // [xsp+150h] [xbp-20h]
  size_t optlena; // [xsp+158h] [xbp-18h]
  unsigned __int8 *opta; // [xsp+160h] [xbp-10h]

  opta = (unsigned __int8 *)header;
  optlena = plen;
  replacea = limit;
  HIWORD(lenp) = udp_sz;
  LODWORD(lenp) = optno;
  datap = opt;
  p = (unsigned __int8 *)optlen;
  HIDWORD(udp_len) = set_do;
  LODWORD(udp_len) = replace;
  t_cp = 0LL;
  HIDWORD(t_cp_0) = 0;
  if ( set_do )
    v9 = 0x8000;
  else
    v9 = 0;
  WORD1(t_cp_1) = v9;
  LOWORD(t_cp_1) = 0;
  rcode = find_pseudoheader((dns_header *)opta, optlena, 0uLL, &len, (int *)&t_cp_0, (int *)&t_cp_1 + 1);
  if ( (_DWORD)t_cp_0 )
    return optlena;
  if ( rcode )
  {
    rcode = len;
    HIWORD(lenp) = _byteswap_ushort(*(_WORD *)len);
    rcode = len + 2;
    LOWORD(t_cp_1) = _byteswap_ushort(*((_WORD *)len + 1));
    rcode = len + 4;
    WORD1(t_cp_1) = _byteswap_ushort(*((_WORD *)len + 2));
    rcode = len + 6;
    if ( HIDWORD(udp_len) )
    {
      rcode += -0x2;
      WORD1(t_cp_1) |= 0x8000u;
      v32 = rcode + 1;
      *rcode = BYTE3(t_cp_1);
      *v32 = BYTE2(t_cp_1);
      rcode += 2;
    }
    buff = rcode;
    HIDWORD(t_cp_0) = rcode[1] | (*rcode << 8);
    rcode += 2;
    if ( rcode - opta + SHIDWORD(t_cp_0) > optlena )
      return optlena;
    is_sign = rcode;
    if ( !(_DWORD)lenp )
      return optlena;
    v35 = 0;
    while ( v35 + 4 < SHIDWORD(t_cp_0) )
    {
      v34 = _byteswap_ushort(*(_WORD *)rcode);
      rcode += 2;
      v33 = _byteswap_ushort(*(_WORD *)rcode);
      rcode += 2;
      if ( v35 + v33 > SHIDWORD(t_cp_0) )
      {
        HIDWORD(t_cp_0) = 0;
        HIDWORD(t_cp_1) = 0;
        break;
      }
      if ( v34 == (_DWORD)lenp )
      {
        if ( !(_DWORD)udp_len )
          return optlena;
        rcode += -0x4;
        HIDWORD(t_cp_0) -= v33 + 4;
        memcpy(rcode, &rcode[v33 + 4], HIDWORD(t_cp_0) - v35);
        v31 = BYTE4(t_cp_0);
        v30 = buff + 1;
        *buff = BYTE5(t_cp_0);
        *v30 = v31;
        buff += 2;
        buff += -0x2;
      }
      else
      {
        rcode += v33;
        v35 += v33 + 4;
      }
    }
    if ( !HIDWORD(t_cp_1) )
    {
      if ( HIDWORD(t_cp_0) )
      {
        t_cp = (unsigned __int8 *)whine_malloc(SHIDWORD(t_cp_0));
        if ( t_cp )
          memcpy(t_cp, is_sign, SHIDWORD(t_cp_0));
      }
      optlena = rrfilter(opta, optlena, 0LL);
      rcode = 0LL;
    }
  }
  if ( !rcode )
  {
    rcode = (unsigned __int8 *)skip_questions(opta, optlena);
    if ( !rcode )
      return optlena;
    v16 = rcode;
    v15 = ntohs(*((_WORD *)opta + 3));
    v14 = ntohs(*((_WORD *)opta + 4)) + v15;
    v10 = ntohs(*((_WORD *)opta + 5));
    rcode = (unsigned __int8 *)skip_section(v16, v14 + (unsigned int)v10, opta, optlena);
    if ( !rcode )
      return optlena;
    v11 = rcode++;
    *v11 = 0;
    v29 = rcode + 1;
    *rcode = 0;
    *v29 = 41;
    rcode += 2;
    v28 = BYTE6(lenp);
    v27 = rcode + 1;
    *rcode = HIBYTE(lenp);
    *v27 = v28;
    rcode += 2;
    v26 = rcode + 1;
    *rcode = BYTE1(t_cp_1);
    *v26 = (_BYTE)t_cp_1;
    rcode += 2;
    v25 = rcode + 1;
    *rcode = BYTE3(t_cp_1);
    *v25 = BYTE2(t_cp_1);
    rcode += 2;
    buff = rcode;
    v24 = BYTE4(t_cp_0);
    v23 = rcode + 1;
    *rcode = BYTE5(t_cp_0);
    *v23 = v24;
    rcode += 2;
    is_sign = rcode;
    if ( t_cp )
    {
      memcpy(rcode, t_cp, SHIDWORD(t_cp_0));
      free(t_cp);
      rcode += SHIDWORD(t_cp_0);
    }
    if ( (int)p <= replacea - (rcode + 4) )
    {
      v12 = ntohs(*((_WORD *)opta + 5));
      *((_WORD *)opta + 5) = htons(v12 + 1);
    }
  }
  if ( (int)p > replacea - (rcode + 4) )
    return optlena;
  if ( (_DWORD)lenp && (_DWORD)udp_len != 2 )
  {
    v22 = (char)lenp;
    v21 = rcode + 1;
    *rcode = BYTE1(lenp);
    *v21 = v22;
    rcode += 2;
    v20 = (char)p;
    v19 = rcode + 1;
    *rcode = BYTE1(p);
    *v19 = v20;
    rcode += 2;
    memcpy(rcode, datap, (size_t)p);
    rcode = &p[(_QWORD)rcode];
    v18 = (_BYTE)rcode - (_BYTE)is_sign;
    v17 = buff + 1;
    *buff = (unsigned __int16)((_WORD)rcode - (_WORD)is_sign) >> 8;
    *v17 = v18;
    buff += 2;
  }
  return rcode - opta;
}
