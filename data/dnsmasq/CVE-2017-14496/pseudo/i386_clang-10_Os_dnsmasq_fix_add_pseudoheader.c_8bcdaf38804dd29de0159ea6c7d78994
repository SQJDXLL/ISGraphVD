int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        int optlen,
        int set_do,
        int replace)
{
  size_t v9; // ebx
  dns_header *v10; // ebp
  void *v11; // edi
  unsigned __int8 *pseudoheader; // eax
  __int16 v14; // cx
  unsigned __int8 *v15; // ebp
  __int16 v16; // cx
  __int16 v17; // ax
  int v18; // esi
  signed int v19; // ebx
  int v20; // edi
  int v21; // ecx
  unsigned __int32 v22; // eax
  int v23; // ecx
  unsigned __int8 *v24; // edi
  _WORD *v25; // ebp
  void *v26; // eax
  void *v27; // esi
  int v28; // esi
  int v29; // eax
  int v30; // eax
  char *v31; // ecx
  int v32; // ebp
  __int16 v33; // bx
  unsigned __int8 *v34; // eax
  size_t v35; // [esp-8h] [ebp-44h]
  __int16 v36; // [esp+Eh] [ebp-2Eh]
  int v38; // [esp+10h] [ebp-2Ch]
  __int16 v39; // [esp+14h] [ebp-28h]
  __int16 v40; // [esp+14h] [ebp-28h]
  void *src; // [esp+18h] [ebp-24h]
  __int16 v42; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  unsigned __int8 *v44; // [esp+24h] [ebp-18h] BYREF
  int is_sign[5]; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  v11 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0, &v44, is_sign, &is_last);
  if ( is_sign[0] )
    return v9;
  HIBYTE(v14) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v14) = set_do != 0;
    v38 = plen;
    v19 = 0;
    v40 = 0;
    v42 = v14 << 15;
    goto LABEL_26;
  }
  v15 = v44;
  v16 = *(_WORD *)v44;
  v39 = *((_WORD *)v44 + 1);
  v17 = __ROL2__(*((_WORD *)v44 + 2), 8);
  if ( set_do )
  {
    v17 |= 0x8000u;
    v44[4] = HIBYTE(v17);
  }
  if ( optno )
  {
    v36 = v16;
    v18 = (int)(v15 + 8);
    v42 = v17;
    v19 = _byteswap_ulong(*((unsigned __int16 *)v15 + 3) << 16);
    if ( v19 + v15 + 8 - (unsigned __int8 *)header > plen )
      return plen;
    src = v15 + 8;
    if ( (unsigned int)v19 < 5 )
    {
LABEL_16:
      if ( is_last )
      {
        v9 = plen;
        v24 = limit;
        v25 = v15 + 6;
        goto LABEL_37;
      }
      v11 = 0;
      if ( v19 )
      {
        v26 = (void *)whine_malloc(v19);
        if ( v26 )
        {
          v27 = v26;
          memcpy(v26, src, v19);
          v11 = v27;
        }
      }
      else
      {
        v19 = 0;
      }
    }
    else
    {
      v20 = 0;
      v21 = 4;
      while ( 1 )
      {
        v22 = _byteswap_ulong(*(unsigned __int16 *)(v18 + 2) << 16);
        if ( (int)(v22 + v21) > v19 )
          break;
        v23 = v18 + 4;
        if ( _byteswap_ulong(*(unsigned __int16 *)v18 << 16) == optno )
        {
          if ( !replace )
            return plen;
          v19 = v19 - v22 - 4;
          memcpy((void *)v18, (const void *)(v22 + v23), v19 - v20);
          *((_WORD *)v15 + 3) = __ROL2__(v19, 8);
        }
        else
        {
          v20 += v22 + 4;
          v18 = v22 + v23;
        }
        v21 = v20 + 4;
        if ( v20 + 4 >= v19 )
          goto LABEL_16;
      }
      is_last = 0;
      v19 = 0;
      v11 = 0;
    }
    v10 = header;
    udp_sz = __ROL2__(v36, 8);
    v40 = __ROL2__(v39, 8);
    v38 = rrfilter(header, plen, 0);
LABEL_26:
    v28 = v38;
    v29 = skip_questions(v10, v38);
    if ( !v29 )
      return v28;
    v30 = skip_section(
            v29,
            (unsigned __int16)__ROL2__(v10->ancount, 8)
          + (unsigned __int16)__ROL2__(v10->nscount, 8)
          + (unsigned __int16)__ROL2__(v10->arcount, 8),
            v10,
            v38);
    if ( !v30 )
      return v38;
    v31 = (char *)(v30 + 11);
    v32 = v30;
    if ( v30 + 11 > (unsigned int)limit )
      return v38;
    *(_WORD *)v30 = 0;
    *(_BYTE *)(v30 + 2) = 41;
    v18 = v30 + 11;
    *(_BYTE *)(v30 + 3) = HIBYTE(udp_sz);
    *(_BYTE *)(v30 + 4) = udp_sz;
    *(_BYTE *)(v30 + 5) = HIBYTE(v40);
    *(_BYTE *)(v30 + 6) = v40;
    *(_BYTE *)(v30 + 7) = HIBYTE(v42);
    *(_BYTE *)(v30 + 8) = v42;
    *(_BYTE *)(v30 + 9) = BYTE1(v19);
    *(_BYTE *)(v30 + 10) = v19;
    if ( v11 )
    {
      v18 = (int)&v31[v19];
      if ( &v31[v19] > (char *)limit )
      {
        free(v11);
        return v38;
      }
      v35 = v19;
      v33 = v30 + 11;
      memcpy(v31, v11, v35);
      free(v11);
      LOWORD(v31) = v33;
    }
    v24 = limit;
    v25 = (_WORD *)(v32 + 9);
    LOWORD(src) = (_WORD)v31;
    if ( (int)&limit[-v18 - 4] >= optlen )
      header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    v9 = v38;
LABEL_37:
    v34 = (unsigned __int8 *)(v18 + 4);
    if ( (int)&v24[-v18 - 4] < optlen )
      return v9;
    if ( optno && replace != 2 )
    {
      if ( v34 > v24 )
        return v9;
      *(_BYTE *)v18 = BYTE1(optno);
      *(_BYTE *)(v18 + 1) = optno;
      *(_BYTE *)(v18 + 2) = BYTE1(optlen);
      *(_BYTE *)(v18 + 3) = optlen;
      v18 = (int)&v34[optlen];
      if ( &v34[optlen] > v24 )
        return v9;
      memcpy(v34, opt, optlen);
      *v25 = __ROL2__(v18 - (_WORD)src, 8);
    }
    return v18 - (_DWORD)header;
  }
  return v9;
}
