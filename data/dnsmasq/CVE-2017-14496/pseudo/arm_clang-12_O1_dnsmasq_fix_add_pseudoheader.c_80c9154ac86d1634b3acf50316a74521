size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  char *v9; // r8
  unsigned int v10; // r6
  unsigned int v12; // r5
  unsigned __int8 *pseudoheader; // r0
  int v16; // r3
  char v17; // r4
  unsigned __int8 *v18; // r7
  unsigned __int8 v19; // lr
  int v20; // r6
  unsigned __int8 *v21; // r8
  int v22; // r10
  int v23; // r0
  int v24; // r2
  unsigned __int8 *v25; // r11
  unsigned int v26; // r12
  int v27; // r7
  int v28; // r0
  void *v29; // r0
  void *v30; // r8
  int v31; // r2
  unsigned __int8 *v32; // r0
  bool v33; // zf
  int v34; // r0
  int v35; // r7
  int v36; // r8
  int v37; // r8
  int v38; // r0
  _BYTE *v39; // r0
  _BYTE *v40; // r7
  __uint16_t v41; // r0
  u16 v42; // r0
  unsigned __int8 *v43; // [sp+10h] [bp-50h]
  void *src; // [sp+14h] [bp-4Ch]
  _BYTE *v45; // [sp+18h] [bp-48h]
  unsigned __int8 v46; // [sp+1Ch] [bp-44h]
  char v47; // [sp+1Ch] [bp-44h]
  unsigned __int8 v48; // [sp+20h] [bp-40h]
  unsigned __int8 v49; // [sp+24h] [bp-3Ch]
  unsigned __int8 v50; // [sp+28h] [bp-38h]
  void *ptr; // [sp+2Ch] [bp-34h]
  int v52; // [sp+30h] [bp-30h] BYREF
  int v53; // [sp+34h] [bp-2Ch] BYREF
  unsigned __int8 *v54; // [sp+38h] [bp-28h] BYREF

  v10 = udp_sz;
  v12 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v54, &v53, &v52);
  if ( v53 )
    return v12;
  v16 = optno;
  v17 = set_do;
  if ( set_do )
    v17 = 0x80;
  if ( !pseudoheader )
  {
    v49 = 0;
    v50 = v10;
    v26 = v10 >> 8;
    v19 = 0;
    v48 = 0;
    v20 = 0;
    ptr = 0;
    v25 = 0;
    goto LABEL_30;
  }
  v18 = v54;
  v17 = v54[4];
  if ( set_do )
  {
    v17 |= 0x80u;
    v54[4] = v17;
  }
  v48 = v18[5];
  v50 = v18[1];
  v19 = v18[2];
  v49 = v18[3];
  v20 = v18[7] | (v18[6] << 8);
  v45 = v18 + 6;
  v21 = v18 + 8;
  ptr = 0;
  if ( optno && v21 - (unsigned __int8 *)header + v20 <= v12 )
  {
    v43 = limit;
    src = v18 + 8;
    v46 = *v18;
    if ( (unsigned int)v20 >= 5 )
    {
      v22 = 0;
      v23 = 4;
      do
      {
        v24 = v21[3] | (v21[2] << 8);
        v25 = v21 + 4;
        if ( v24 + v23 > v20 )
        {
          v20 = 0;
          v52 = 0;
          v21 += 4;
          break;
        }
        if ( (v21[1] | (*v21 << 8)) == v16 )
        {
          if ( !replace )
          {
            v27 = 0;
            ptr = 0;
LABEL_23:
            v28 = v12;
            limit = v43;
            goto LABEL_28;
          }
          v20 = v20 - v24 - 4;
          memcpy(v21, &v25[v24], v20 - v22);
          v16 = optno;
          v18[7] = v20;
          v18[6] = BYTE1(v20);
        }
        else
        {
          v21 = &v25[v24];
          v22 += v24 + 4;
        }
        v23 = v22 + 4;
      }
      while ( v22 + 4 < v20 );
    }
    v27 = 1;
    if ( v52 )
    {
      v25 = v21;
      goto LABEL_23;
    }
    v25 = 0;
    v29 = 0;
    if ( v20 )
    {
      v30 = (void *)whine_malloc(v20);
      v29 = 0;
      if ( v30 )
      {
        memcpy(v30, src, v20);
        v29 = v30;
      }
    }
    ptr = v29;
    v28 = rrfilter(header, v12, 0);
    limit = v43;
    v16 = optno;
LABEL_28:
    LOWORD(v9) = (_WORD)src;
    LOBYTE(v26) = v46;
    if ( v27 )
    {
      v12 = v28;
LABEL_30:
      v31 = optlen;
      if ( !v25 )
      {
        v47 = v26;
        v34 = skip_questions(header, v12, optlen, v16);
        if ( !v34 )
          return v12;
        v35 = v34;
        v36 = _bswap_16(header->ancount);
        v37 = _bswap_16(header->nscount) + v36;
        v38 = _bswap_16(header->arcount);
        v39 = (_BYTE *)skip_section(v35, v37 + v38, header, v12);
        if ( !v39 )
          return v12;
        v9 = v39 + 0xB;
        if ( v39 + 0xB > limit )
          return v12;
        v39[10] = v20;
        v39[8] = v48;
        v39[7] = v17;
        v39[6] = v49;
        v39[5] = v19;
        v39[4] = v50;
        v39[3] = v47;
        v39[2] = 41;
        v39[1] = 0;
        *v39 = 0;
        v39[9] = BYTE1(v20);
        v40 = v39 + 9;
        v25 = v39 + 0xB;
        if ( ptr )
        {
          v25 = (unsigned __int8 *)&v9[v20];
          if ( &v9[v20] > (char *)limit )
          {
            free(ptr);
            return v12;
          }
          memcpy(v9, ptr, v20);
          free(ptr);
        }
        v31 = optlen;
        v45 = v40;
        if ( limit - v25 - 4 >= (int)optlen )
        {
          v41 = _bswap_16(header->arcount);
          v42 = _bswap_16(v41 + 1);
          v31 = optlen;
          header->arcount = v42;
        }
        v16 = optno;
      }
      v32 = v25 + 4;
      if ( limit - (v25 + 4) < v31 )
        return v12;
      v33 = v16 == 0;
      if ( v16 )
        v33 = replace == 2;
      if ( !v33 )
      {
        if ( v32 > limit )
          return v12;
        v25[3] = v31;
        v25[1] = v16;
        v25[2] = BYTE1(v31);
        *v25 = BYTE1(v16);
        v25 = &v32[v31];
        if ( &v32[v31] > limit )
          return v12;
        memcpy(v32, opt, v31);
        v45[1] = (_BYTE)v25 - (_BYTE)v9;
        *v45 = (unsigned __int16)((_WORD)v25 - (_WORD)v9) >> 8;
      }
      return v25 - (unsigned __int8 *)header;
    }
  }
  return v12;
}
