size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *ptr; // ebp
  unsigned __int8 *v11; // ebp
  unsigned __int16 v12; // ax
  int v13; // edi
  unsigned __int8 *v14; // esi
  unsigned __int16 v15; // dx
  unsigned __int16 v16; // ax
  int v17; // ebx
  int v18; // ebp
  unsigned __int8 *v19; // eax
  _BYTE *v20; // ebp
  unsigned __int8 *v22; // eax
  int v23; // ebx
  _BYTE *v24; // eax
  _BYTE *v25; // edi
  _BYTE *v26; // ebx
  unsigned __int8 *rcode; // [esp+18h] [ebp-54h]
  __int16 rcodea; // [esp+18h] [ebp-54h]
  size_t rdlen; // [esp+28h] [ebp-44h]
  unsigned __int8 *v30; // [esp+30h] [ebp-3Ch]
  unsigned __int8 *datap; // [esp+34h] [ebp-38h]
  unsigned __int16 flags; // [esp+38h] [ebp-34h]
  __int16 v33; // [esp+3Ah] [ebp-32h]
  __int16 v34; // [esp+3Ch] [ebp-30h]
  unsigned __int8 v35; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 v36; // [esp+3Fh] [ebp-2Dh]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  ptr = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !ptr )
  {
    flags = (set_do != 0) << 15;
    rcodea = 0;
LABEL_36:
    v23 = skip_questions(header, plen);
    if ( !v23 )
      return plen;
    v24 = (_BYTE *)skip_section(
                     v23,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->ancount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8),
                     header,
                     plen);
    v25 = v24;
    if ( !v24 )
      return plen;
    v26 = v24 + 11;
    datap = v24 + 11;
    if ( limit < v24 + 11 )
      return plen;
    *v24 = 0;
    v24[1] = 0;
    v24[2] = 41;
    v24[3] = HIBYTE(udp_sz);
    v24[4] = udp_sz;
    v24[5] = HIBYTE(rcodea);
    v24[6] = rcodea;
    v24[7] = HIBYTE(flags);
    v24[8] = flags;
    v24[9] = BYTE1(rdlen);
    v24[10] = rdlen;
    if ( ptr )
    {
      v14 = &v26[rdlen];
      if ( limit < &v26[rdlen] )
      {
        free(ptr);
        return plen;
      }
      memcpy(datap, ptr, rdlen);
      free(ptr);
    }
    else
    {
      v14 = v24 + 11;
    }
    v19 = v14 + 4;
    if ( limit - (v14 + 4) < (int)optlen )
      return plen;
    v20 = v25 + 9;
    header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    goto LABEL_22;
  }
  v11 = t_cp;
  LOBYTE(v33) = *t_cp;
  v35 = t_cp[1];
  LOBYTE(v34) = t_cp[2];
  v36 = t_cp[3];
  v12 = _byteswap_ushort(*((_WORD *)t_cp + 2));
  if ( set_do )
  {
    flags = v12 | 0x8000;
    t_cp[4] = (unsigned __int16)(v12 | 0x8000) >> 8;
    v11[5] = v12;
  }
  else
  {
    flags = v12;
  }
  v13 = v11[7] | (v11[6] << 8);
  v14 = v11 + 8;
  datap = v11 + 8;
  if ( plen < v13 + v11 + 8 - (unsigned __int8 *)header || !optno )
    return plen;
  if ( v13 > 4 )
  {
    v15 = _byteswap_ushort(*((_WORD *)v11 + 4));
    v16 = _byteswap_ushort(*((_WORD *)v11 + 5));
    rcode = v11 + 12;
    v17 = v16;
    if ( v13 < v16 + 4 )
    {
LABEL_11:
      is_last[0] = 0;
      ptr = 0;
LABEL_12:
      udp_sz = v35 | (unsigned __int16)(v33 << 8);
      rcodea = v36 | (unsigned __int16)(v34 << 8);
      plen = rrfilter(header, plen, 0);
      goto LABEL_36;
    }
    v30 = v11;
    v18 = 0;
    while ( 1 )
    {
      if ( v15 == optno )
      {
        if ( !replace )
          return plen;
        v13 -= v17 + 4;
        memcpy(v14, &v14[v16 + 4], v13 - v18);
        v30[6] = BYTE1(v13);
        v30[7] = v13;
      }
      else
      {
        v14 = &rcode[v16];
        v18 += v17 + 4;
      }
      if ( v18 + 4 >= v13 )
        break;
      v15 = _byteswap_ushort(*(_WORD *)v14);
      v16 = _byteswap_ushort(*((_WORD *)v14 + 1));
      rcode = v14 + 4;
      v17 = v16;
      if ( v16 + v18 + 4 > v13 )
        goto LABEL_11;
    }
    v11 = v30;
    if ( is_last[0] )
      goto LABEL_20;
LABEL_29:
    if ( v13 )
    {
      v22 = (unsigned __int8 *)whine_malloc(v13);
      ptr = v22;
      rdlen = v13;
      if ( v22 )
      {
        memcpy(v22, datap, v13);
        rdlen = v13;
      }
    }
    else
    {
      rdlen = 0;
      ptr = 0;
    }
    goto LABEL_12;
  }
  if ( !is_last[0] )
    goto LABEL_29;
  v14 = v11 + 8;
LABEL_20:
  v19 = v14 + 4;
  if ( limit - (v14 + 4) < (int)optlen )
    return plen;
  v20 = v11 + 6;
LABEL_22:
  if ( !optno || replace == 2 )
    return v14 - (unsigned __int8 *)header;
  if ( limit >= v19 )
  {
    *v14 = BYTE1(optno);
    v14[1] = optno;
    v14[2] = BYTE1(optlen);
    v14[3] = optlen;
    v14 = &v19[optlen];
    if ( limit >= &v19[optlen] )
    {
      memcpy(v19, opt, optlen);
      *v20 = (unsigned __int16)((_WORD)v14 - (_WORD)datap) >> 8;
      v20[1] = (_BYTE)v14 - (_BYTE)datap;
      return v14 - (unsigned __int8 *)header;
    }
  }
  return plen;
}
