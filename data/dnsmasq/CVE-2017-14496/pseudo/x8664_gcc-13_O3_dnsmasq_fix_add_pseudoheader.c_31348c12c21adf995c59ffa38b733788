size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  dns_header *v11; // r12
  size_t v13; // rbx
  unsigned __int8 *pseudoheader; // rax
  int v15; // r9d
  unsigned __int8 *v16; // r10
  unsigned __int8 *v17; // rdi
  __int16 v18; // r8
  unsigned __int64 v19; // r14
  int v20; // r15d
  unsigned __int8 *v21; // r11
  unsigned __int16 v22; // dx
  __int64 v23; // rcx
  int v24; // esi
  int v25; // eax
  int v26; // r10d
  int v27; // r12d
  int v28; // ebp
  int v29; // ebx
  unsigned __int8 *v30; // r15
  unsigned __int8 *v31; // rdi
  int v32; // r14d
  unsigned __int8 *v33; // r8
  _WORD *v34; // r15
  __int16 v36; // r15
  __int16 v37; // r8
  __int64 v38; // rax
  __int64 v39; // rax
  __int64 v40; // rcx
  void *v41; // rdi
  dns_header *v42; // r10
  __int64 v43; // rax
  dns_header *v44; // rax
  dns_header *v45; // rax
  const void *rdlen; // [rsp+10h] [rbp-88h]
  int rdlena; // [rsp+10h] [rbp-88h]
  int rdlenb; // [rsp+10h] [rbp-88h]
  __int16 ptr; // [rsp+18h] [rbp-80h]
  __int16 ptra; // [rsp+18h] [rbp-80h]
  int ptrb; // [rsp+18h] [rbp-80h]
  __int16 buff; // [rsp+20h] [rbp-78h]
  unsigned __int8 *buffa; // [rsp+20h] [rbp-78h]
  __int16 buffb; // [rsp+20h] [rbp-78h]
  unsigned __int8 *buffc; // [rsp+20h] [rbp-78h]
  __int16 flags; // [rsp+28h] [rbp-70h]
  unsigned __int8 *flagsa; // [rsp+28h] [rbp-70h]
  __int16 flagsc; // [rsp+28h] [rbp-70h]
  __int16 flagsb; // [rsp+28h] [rbp-70h]
  dns_header *headera; // [rsp+30h] [rbp-68h]
  dns_header *headerb; // [rsp+30h] [rbp-68h]
  size_t plena; // [rsp+38h] [rbp-60h]
  int is_sign; // [rsp+48h] [rbp-50h] BYREF
  int is_last; // [rsp+4Ch] [rbp-4Ch] BYREF
  unsigned __int8 *t_cp[9]; // [rsp+50h] [rbp-48h] BYREF

  v11 = header;
  v13 = plen;
  t_cp[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, t_cp, &is_sign, &is_last);
  v15 = is_sign;
  if ( is_sign )
    return v13;
  v16 = pseudoheader;
  if ( !pseudoheader )
  {
    v36 = 0;
    v37 = (set_do != 0) << 15;
    goto LABEL_26;
  }
  v17 = t_cp[0];
  ptr = *(_WORD *)t_cp[0];
  v18 = __ROL2__(*((_WORD *)t_cp[0] + 2), 8);
  buff = *((_WORD *)t_cp[0] + 1);
  if ( set_do )
  {
    v18 |= 0x8000u;
    *((_WORD *)t_cp[0] + 2) = __ROL2__(v18, 8);
  }
  v19 = (unsigned __int64)(v17 + 8);
  rdlen = v17 + 8;
  LOWORD(v20) = __ROL2__(*((_WORD *)v17 + 3), 8);
  if ( plen < (unsigned __int64)(unsigned __int16)v20 + v17 + 8 - (unsigned __int8 *)v11 || !optno )
    return v13;
  v20 = (unsigned __int16)v20;
  if ( (unsigned __int16)v20 > 4u )
  {
    v23 = *((unsigned __int16 *)v17 + 4);
    v21 = v17 + 12;
    v22 = __ROL2__(*((_WORD *)v17 + 5), 8);
    LOWORD(v23) = __ROL2__(v23, 8);
    v24 = v22;
    v25 = v22 + 4;
    if ( (unsigned __int16)v20 >= v25 )
    {
      v26 = 0;
      if ( !replace )
      {
        while ( (unsigned __int16)v23 != optno )
        {
          v26 += v24 + 4;
          v19 = (unsigned __int64)&v21[v22];
          if ( v26 + 4 >= (unsigned __int16)v20 )
            goto LABEL_18;
          v23 = *(unsigned __int16 *)v19;
          v21 = (unsigned __int8 *)(v19 + 4);
          v22 = __ROL2__(*(_WORD *)(v19 + 2), 8);
          LOWORD(v23) = __ROL2__(v23, 8);
          v24 = v22;
          if ( v22 + v26 + 4 > (unsigned __int16)v20 )
            goto LABEL_41;
        }
        return v13;
      }
      headera = v11;
      v27 = optno;
      v28 = 0;
      plena = v13;
      v29 = (unsigned __int16)v20;
      v30 = v17;
      v31 = v17 + 8;
      flags = v18;
      v32 = v15;
      while ( 1 )
      {
        if ( (unsigned __int16)v23 == v27 )
        {
          v29 -= v25;
          v31 = (unsigned __int8 *)memcpy(v31, &v31[v22 + 4], v29 - v28);
          *((_WORD *)v30 + 3) = __ROL2__(v29, 8);
        }
        else
        {
          v28 += v25;
          v31 = &v21[v22];
        }
        if ( v28 + 4 >= v29 )
        {
          v15 = v32;
          optno = v27;
          v19 = (unsigned __int64)v31;
          v18 = flags;
          v17 = v30;
          v11 = headera;
          v20 = v29;
          v13 = plena;
          goto LABEL_18;
        }
        v23 = *(unsigned __int16 *)v31;
        v21 = v31 + 4;
        v22 = __ROL2__(*((_WORD *)v31 + 1), 8);
        LOWORD(v23) = __ROL2__(v23, 8);
        if ( v22 + v28 + 4 > v29 )
          break;
        v25 = v22 + 4;
      }
      optno = v27;
      v13 = plena;
      v11 = headera;
      v15 = v32;
      v18 = flags;
    }
LABEL_41:
    is_last = 0;
    goto LABEL_42;
  }
LABEL_18:
  v23 = (unsigned int)is_last;
  if ( !is_last )
  {
    if ( v20 )
    {
      flagsb = v18;
      v44 = (dns_header *)whine_malloc(v20);
      v18 = flagsb;
      v42 = v44;
      if ( v44 )
      {
        v45 = (dns_header *)memcpy(v44, rdlen, v20);
        v18 = flagsb;
        v42 = v45;
      }
      v15 = v20;
      goto LABEL_43;
    }
LABEL_42:
    v42 = 0LL;
LABEL_43:
    headerb = v42;
    flagsc = v18;
    udp_sz = __ROL2__(ptr, 8);
    rdlenb = v15;
    v36 = __ROL2__(buff, 8);
    v43 = rrfilter(v11, v13, 0LL, v23);
    v15 = rdlenb;
    v37 = flagsc;
    v16 = (unsigned __int8 *)headerb;
    v13 = v43;
LABEL_26:
    buffa = v16;
    ptra = v37;
    rdlena = v15;
    v38 = skip_questions(v11, v13);
    if ( !v38 )
      return v13;
    flagsa = buffa;
    buffb = ptra;
    ptrb = rdlena;
    v39 = skip_section(
            v38,
            (unsigned __int16)__ROL2__(v11->arcount, 8)
          + (unsigned __int16)__ROL2__(v11->nscount, 8)
          + (unsigned int)(unsigned __int16)__ROL2__(v11->ancount, 8),
            v11,
            v13);
    v40 = v39;
    if ( !v39 )
      return v13;
    v41 = (void *)(v39 + 11);
    LOWORD(rdlen) = v39 + 11;
    if ( (unsigned __int64)limit < v39 + 11 )
      return v13;
    *(_BYTE *)(v39 + 2) = 41;
    *(_WORD *)v39 = 0;
    *(_QWORD *)(v39 + 3) = HIBYTE(udp_sz) | (((unsigned __int8)udp_sz | ((HIBYTE(v36) | (((unsigned __int8)v36 | ((HIBYTE(buffb) | (((unsigned __int8)buffb | ((BYTE1(ptrb) | ((unsigned __int64)(unsigned __int8)ptrb << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
    if ( flagsa )
    {
      v19 = (unsigned __int64)v41 + ptrb;
      if ( (unsigned __int64)limit < v19 )
      {
        free(flagsa);
        return v13;
      }
      buffc = (unsigned __int8 *)v39;
      memcpy(v41, flagsa, ptrb);
      free(flagsa);
      v40 = (__int64)buffc;
    }
    else
    {
      v19 = v39 + 11;
    }
    v33 = (unsigned __int8 *)(v19 + 4);
    if ( (__int64)&limit[-v19 - 4] >= (__int64)optlen )
    {
      v34 = (_WORD *)(v40 + 9);
      v11->arcount = __ROL2__(__ROL2__(v11->arcount, 8) + 1, 8);
      goto LABEL_20;
    }
    return v13;
  }
  v33 = (unsigned __int8 *)(v19 + 4);
  v34 = v17 + 6;
  if ( (__int64)&limit[-v19 - 4] < (__int64)optlen )
    return v13;
LABEL_20:
  if ( optno && replace != 2 )
  {
    if ( limit < v33 )
      return v13;
    *(_DWORD *)v19 = BYTE1(optno) | (((unsigned __int8)optno | ((BYTE1(optlen) | ((unsigned __int8)optlen << 8)) << 8)) << 8);
    v19 = (unsigned __int64)&v33[optlen];
    if ( limit < &v33[optlen] )
      return v13;
    memcpy(v33, opt, optlen);
    *v34 = __ROL2__(v19 - (_WORD)rdlen, 8);
  }
  return v19 - (_QWORD)v11;
}
