size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v12; // x21
  unsigned int v13; // w23
  unsigned __int8 *pseudoheader; // x0
  int v16; // w28
  int v17; // w7
  unsigned __int8 *v18; // x27
  unsigned __int8 *v19; // x27
  unsigned int v20; // w22
  unsigned int v21; // w19
  char *v22; // x23
  unsigned __int16 v23; // w0
  unsigned __int8 *v24; // x6
  int v25; // w7
  _WORD *v26; // x19
  bool v27; // zf
  char *v28; // x0
  unsigned __int16 v29; // w1
  int v30; // w2
  unsigned __int16 *v31; // x0
  unsigned __int8 *v32; // x0
  unsigned int v33; // w22
  __int64 v34; // x0
  __int64 v35; // x0
  unsigned __int16 set_dob; // [xsp+6Ch] [xbp+6Ch]
  int i; // [xsp+78h] [xbp+78h]
  int is_sign; // [xsp+88h] [xbp+88h] BYREF
  int is_last; // [xsp+8Ch] [xbp+8Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF

  v12 = plen;
  v13 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v12;
  v17 = set_do;
  v18 = pseudoheader;
  if ( pseudoheader )
  {
    v19 = udp_len;
    set_dob = *(_WORD *)udp_len;
    v20 = *((unsigned __int16 *)udp_len + 1);
    v21 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
    if ( v17 )
    {
      v21 |= 0x8000u;
      *((_WORD *)udp_len + 2) = __rev16(v21);
    }
    v22 = (char *)(v19 + 8);
    v23 = __rev16(*((unsigned __int16 *)v19 + 3));
    v16 = v23;
    if ( v19 + 8 - (unsigned __int8 *)header + (unsigned __int64)v23 > v12 || !optno )
      return v12;
    v24 = v19 + 8;
    v25 = 0;
    while ( v25 + 4 < v16 )
    {
      v29 = __rev16(*((unsigned __int16 *)v24 + 1));
      v30 = (unsigned __int16)__rev16(*(unsigned __int16 *)v24);
      if ( v25 + v29 > v16 )
      {
        v16 = 0;
        is_last = 0;
LABEL_21:
        v18 = 0LL;
        goto LABEL_29;
      }
      if ( v30 == optno )
      {
        if ( !replace )
          return v12;
        v16 -= v29 + 4;
        i = v25;
        v31 = (unsigned __int16 *)memcpy(v24, &v24[v29 + 4], v16 - v25);
        v25 = i;
        v24 = (unsigned __int8 *)v31;
        *((_WORD *)v19 + 3) = __rev16(v16);
      }
      else
      {
        v24 += v29 + 4;
        v25 += v29 + 4;
      }
    }
    if ( is_last )
    {
      v26 = v19 + 6;
      goto LABEL_11;
    }
    if ( !v16 )
      goto LABEL_21;
    v32 = (unsigned __int8 *)whine_malloc(v16);
    v18 = v32;
    if ( v32 )
      memcpy(v32, v22, v16);
LABEL_29:
    v33 = (unsigned __int16)__rev16(v20);
    v13 = (unsigned __int16)__rev16(set_dob);
    v12 = rrfilter(header, v12, 0LL);
  }
  else
  {
    v33 = 0;
    v21 = (set_do != 0) << 15;
  }
  v34 = skip_questions(header, v12);
  if ( v34 )
  {
    v35 = skip_section(
            v34,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v12);
    if ( v35 )
    {
      *(_WORD *)v35 = 0;
      *(_BYTE *)(v35 + 2) = 41;
      *(_WORD *)(v35 + 3) = __rev16(v13);
      v22 = (char *)(v35 + 0xB);
      *(_WORD *)(v35 + 5) = __rev16(v33);
      *(_WORD *)(v35 + 7) = __rev16(v21);
      v26 = (_WORD *)(v35 + 9);
      *(_WORD *)(v35 + 9) = __rev16(v16);
      if ( v18 )
      {
        memcpy((void *)(v35 + 0xB), v18, v16);
        free(v18);
        v24 = (unsigned __int8 *)&v22[v16];
      }
      else
      {
        v24 = (unsigned __int8 *)(v35 + 0xB);
      }
      if ( limit - (v24 + 4) >= (__int64)optlen )
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_11:
      if ( limit - (v24 + 4) >= (__int64)optlen )
      {
        if ( optno )
          v27 = replace == 2;
        else
          v27 = 1;
        if ( !v27 )
        {
          *(_WORD *)v24 = __rev16(optno);
          *((_WORD *)v24 + 1) = __rev16(optlen);
          v28 = (char *)memcpy(v24 + 4, opt, optlen);
          v24 = (unsigned __int8 *)&v28[optlen];
          *v26 = __rev16((_DWORD)v28 + optlen - (_DWORD)v22);
        }
        return v24 - (unsigned __int8 *)header;
      }
    }
  }
  return v12;
}
