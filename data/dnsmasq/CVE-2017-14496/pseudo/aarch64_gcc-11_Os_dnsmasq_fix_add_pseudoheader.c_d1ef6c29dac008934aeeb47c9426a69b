size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v10; // w24
  unsigned __int64 v12; // x21
  unsigned __int8 *pseudoheader; // x0
  int v15; // w28
  int v16; // w7
  unsigned __int8 *v17; // x27
  unsigned __int8 *v18; // x27
  unsigned int v19; // w24
  unsigned int v20; // w19
  const void *v21; // x22
  unsigned __int16 v22; // w0
  signed int v23; // w25
  unsigned __int64 v24; // x28
  int v25; // w7
  _WORD *v26; // x19
  unsigned __int8 *v27; // x0
  bool v28; // zf
  unsigned __int16 v29; // w1
  int v30; // w2
  unsigned __int8 *v31; // x0
  unsigned int v32; // w22
  __int64 v33; // x0
  __int64 v34; // x0
  size_t v35; // x2
  unsigned __int16 set_dob; // [xsp+78h] [xbp+78h]
  int i; // [xsp+7Ch] [xbp+7Ch]
  int is_sign; // [xsp+88h] [xbp+88h] BYREF
  int is_last; // [xsp+8Ch] [xbp+8Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF

  v10 = udp_sz;
  v12 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v15 = is_sign;
  if ( is_sign )
    return v12;
  v16 = set_do;
  v17 = pseudoheader;
  if ( pseudoheader )
  {
    v18 = udp_len;
    set_dob = *((_WORD *)udp_len + 1);
    v19 = *(unsigned __int16 *)udp_len;
    v20 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
    if ( v16 )
    {
      v20 |= 0x8000u;
      *((_WORD *)udp_len + 2) = __rev16(v20);
    }
    v21 = v18 + 8;
    v22 = __rev16(*((unsigned __int16 *)v18 + 3));
    v23 = v22;
    if ( v18 + 8 - (unsigned __int8 *)header + (unsigned __int64)v22 > v12 || !optno )
      return v12;
    v24 = (unsigned __int64)(v18 + 8);
    v25 = 0;
    while ( v25 + 4 < v23 )
    {
      v29 = __rev16(*(unsigned __int16 *)(v24 + 2));
      v30 = (unsigned __int16)__rev16(*(unsigned __int16 *)v24);
      if ( v25 + 4 + v29 > v23 )
      {
        v23 = 0;
        is_last = 0;
LABEL_22:
        v17 = 0LL;
        goto LABEL_30;
      }
      if ( v30 == optno )
      {
        if ( !replace )
          return v12;
        v23 -= v29 + 4;
        i = v25;
        memcpy((void *)v24, (const void *)(v24 + v29 + 4LL), v23 - v25);
        v25 = i;
        *((_WORD *)v18 + 3) = __rev16(v23);
      }
      else
      {
        v24 += 4LL + v29;
        v25 += v29 + 4;
      }
    }
    if ( is_last )
    {
      v26 = v18 + 6;
      goto LABEL_11;
    }
    if ( !v23 )
      goto LABEL_22;
    v31 = (unsigned __int8 *)whine_malloc(v23);
    v17 = v31;
    if ( v31 )
      memcpy(v31, v21, v23);
LABEL_30:
    v10 = (unsigned __int16)__rev16(v19);
    v32 = (unsigned __int16)__rev16(set_dob);
    v15 = v23;
    v12 = rrfilter(header, v12, 0LL);
  }
  else
  {
    v32 = 0;
    v20 = (set_do != 0) << 15;
  }
  v33 = skip_questions(header, v12);
  if ( v33 )
  {
    v34 = skip_section(
            v33,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v12);
    if ( v34 )
    {
      if ( (unsigned __int64)limit >= v34 + 0xB )
      {
        *(_WORD *)v34 = 0;
        *(_BYTE *)(v34 + 2) = 41;
        *(_WORD *)(v34 + 3) = __rev16(v10);
        *(_WORD *)(v34 + 5) = __rev16(v32);
        LODWORD(v21) = v34 + 0xB;
        *(_WORD *)(v34 + 7) = __rev16(v20);
        v26 = (_WORD *)(v34 + 9);
        *(_WORD *)(v34 + 9) = __rev16(v15);
        if ( v17 )
        {
          v35 = v15;
          v24 = v34 + 0xB + v15;
          if ( v24 > (unsigned __int64)limit )
          {
            free(v17);
            return v12;
          }
          memcpy((void *)(v34 + 0xB), v17, v35);
          free(v17);
        }
        else
        {
          v24 = v34 + 0xB;
        }
        if ( (__int64)&limit[-v24 - 4] >= (__int64)optlen )
          header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_11:
        v27 = (unsigned __int8 *)(v24 + 4);
        if ( (__int64)&limit[-v24 - 4] >= (__int64)optlen )
        {
          if ( optno )
            v28 = replace == 2;
          else
            v28 = 1;
          if ( v28 )
            return v24 - (_QWORD)header;
          if ( v27 <= limit )
          {
            *(_WORD *)v24 = __rev16((unsigned __int16)optno);
            *(_WORD *)(v24 + 2) = __rev16(optlen);
            v24 = (unsigned __int64)&v27[optlen];
            if ( &v27[optlen] <= limit )
            {
              memcpy(v27, opt, optlen);
              *v26 = __rev16(v24 - (_DWORD)v21);
              return v24 - (_QWORD)header;
            }
          }
        }
      }
    }
  }
  return v12;
}
