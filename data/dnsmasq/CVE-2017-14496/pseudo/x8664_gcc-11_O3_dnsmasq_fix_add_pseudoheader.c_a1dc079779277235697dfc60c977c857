size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v9; // r15
  unsigned __int8 v10; // r14
  unsigned __int8 *pseudoheader; // rax
  int v14; // r13d
  unsigned __int8 *v15; // r9
  unsigned __int8 *v16; // r14
  __int16 v17; // ax
  unsigned __int64 v18; // rbx
  __int64 v19; // rcx
  unsigned __int8 *v20; // r11
  unsigned __int16 v21; // ax
  unsigned __int16 v22; // dx
  int v23; // edi
  int v24; // esi
  int v25; // r9d
  unsigned __int8 *v26; // rdi
  int v27; // r13d
  int v28; // ebx
  int v29; // ebp
  unsigned __int8 *v30; // rbx
  __int16 v31; // ax
  __int16 v32; // dx
  size_t v33; // r11
  __int16 v35; // bx
  __int64 v36; // rax
  __int64 v37; // rax
  char *v38; // rcx
  void *v39; // rdx
  unsigned __int8 *v40; // r9
  unsigned __int8 *v41; // rdi
  _WORD *v42; // r13
  unsigned __int8 *v43; // r9
  __int64 v44; // rax
  size_t v45; // r14
  unsigned __int8 *v46; // rax
  __int16 t_s; // [rsp+10h] [rbp-78h]
  unsigned __int8 *t_sa; // [rsp+10h] [rbp-78h]
  unsigned __int8 *buff; // [rsp+18h] [rbp-70h]
  unsigned __int8 *buffa; // [rsp+18h] [rbp-70h]
  __int16 src; // [rsp+20h] [rbp-68h]
  unsigned __int8 *srca; // [rsp+20h] [rbp-68h]
  char *srcb; // [rsp+20h] [rbp-68h]
  __int16 v56; // [rsp+2Ah] [rbp-5Eh]
  int rdlen; // [rsp+2Ch] [rbp-5Ch]
  int rdlena; // [rsp+2Ch] [rbp-5Ch]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  v9 = plen;
  v10 = udp_sz;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v14 = is_sign;
  if ( is_sign )
    return v9;
  v15 = pseudoheader;
  if ( pseudoheader )
  {
    v16 = udp_len[0];
    v56 = *(_WORD *)udp_len[0];
    src = *((_WORD *)udp_len[0] + 1);
    v17 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
    t_s = v17;
    if ( set_do )
    {
      t_s = v17 | 0x8000;
      *((_WORD *)udp_len[0] + 2) = __ROL2__(v17 | 0x8000, 8);
    }
    v18 = (unsigned __int64)(v16 + 8);
    buff = v16 + 8;
    v19 = (unsigned __int16)__ROL2__(*((_WORD *)v16 + 3), 8);
    if ( v16 + 8 - (unsigned __int8 *)header + v19 <= plen && optno )
    {
      if ( (int)v19 <= 4 )
      {
LABEL_33:
        if ( !is_last )
        {
          if ( (_DWORD)v19 )
          {
            v45 = (int)v19;
            rdlena = v19;
            v46 = (unsigned __int8 *)whine_malloc((int)v19);
            v14 = rdlena;
            v43 = v46;
            if ( v46 )
              v43 = (unsigned __int8 *)memcpy(v46, buff, v45);
          }
          else
          {
            v14 = 0;
            v43 = 0LL;
          }
          goto LABEL_44;
        }
        v41 = (unsigned __int8 *)(v18 + 4);
        if ( (__int64)&limit[-v18 - 4] >= (__int64)optlen )
        {
          v42 = v16 + 6;
          goto LABEL_36;
        }
      }
      else
      {
        v20 = v16 + 12;
        v21 = __ROL2__(*((_WORD *)v16 + 5), 8);
        v22 = __ROL2__(*((_WORD *)v16 + 4), 8);
        v23 = v21;
        v24 = v21 + 4;
        if ( (int)v19 < v24 )
        {
LABEL_43:
          is_last = 0;
          v43 = 0LL;
LABEL_44:
          buffa = v43;
          v44 = rrfilter(header, v9, 0LL);
          v10 = __ROL2__(v56, 8);
          v15 = buffa;
          v35 = __ROL2__(src, 8);
          v9 = v44;
          goto LABEL_24;
        }
        v25 = 0;
        if ( replace )
        {
          rdlen = v14;
          v26 = v16 + 8;
          v27 = optno;
          v28 = v19;
          v29 = 0;
          while ( 1 )
          {
            if ( v22 == v27 )
            {
              v28 -= v24;
              v26 = (unsigned __int8 *)memcpy(v26, &v26[v21 + 4], v28 - v29);
              *((_WORD *)v16 + 3) = __ROL2__(v28, 8);
            }
            else
            {
              v29 += v24;
              v26 = &v20[v21];
            }
            if ( v29 + 4 >= v28 )
            {
              LODWORD(v19) = v28;
              optno = v27;
              v18 = (unsigned __int64)v26;
              goto LABEL_33;
            }
            v20 = v26 + 4;
            v21 = __ROL2__(*((_WORD *)v26 + 1), 8);
            v22 = __ROL2__(*(_WORD *)v26, 8);
            if ( v21 + v29 + 4 > v28 )
              break;
            v24 = v21 + 4;
          }
          optno = v27;
          v14 = rdlen;
          goto LABEL_43;
        }
        v30 = v16 + 12;
        while ( v22 != optno )
        {
          v25 += v23 + 4;
          v18 = (unsigned __int64)&v30[v21];
          if ( v25 + 4 >= (int)v19 )
            goto LABEL_33;
          v31 = *(_WORD *)(v18 + 2);
          v32 = *(_WORD *)v18;
          v30 = (unsigned __int8 *)(v18 + 4);
          v21 = __ROL2__(v31, 8);
          v22 = __ROL2__(v32, 8);
          v23 = v21;
          if ( v21 + v25 + 4 > (int)v19 )
            goto LABEL_43;
        }
      }
    }
    return v9;
  }
  v35 = 0;
  t_s = (set_do != 0) << 15;
LABEL_24:
  buff = v15;
  v36 = skip_questions(header, v9);
  v33 = v9;
  if ( !v36 )
    return v33;
  srca = buff;
  v37 = skip_section(
          v36,
          (unsigned __int16)__ROL2__(header->arcount, 8)
        + (unsigned __int16)__ROL2__(header->nscount, 8)
        + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8),
          header,
          v9);
  v33 = v9;
  v38 = (char *)v37;
  if ( !v37 )
    return v33;
  v39 = (void *)(v37 + 11);
  if ( (unsigned __int64)limit < v37 + 11 )
    return v33;
  *(_BYTE *)(v37 + 2) = 41;
  *(_WORD *)v37 = 0;
  v40 = buff;
  LOWORD(buff) = v37 + 11;
  *(_QWORD *)(v37 + 3) = (v10 | ((HIBYTE(v35) | (((unsigned __int8)v35 | ((HIBYTE(t_s) | (((unsigned __int8)t_s | ((BYTE1(v14) | ((unsigned __int64)(unsigned __int8)v14 << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8;
  if ( srca )
  {
    v18 = (unsigned __int64)v39 + v14;
    if ( v18 > (unsigned __int64)limit )
    {
      free(srca);
      return v9;
    }
    srcb = (char *)v37;
    t_sa = v40;
    memcpy(v39, v40, v14);
    free(t_sa);
    v38 = srcb;
  }
  else
  {
    v18 = v37 + 11;
  }
  v41 = (unsigned __int8 *)(v18 + 4);
  v33 = v9;
  if ( (__int64)&limit[-v18 - 4] < (__int64)optlen )
    return v33;
  v42 = v38 + 9;
  header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_36:
  if ( !optno || replace == 2 )
    return v18 - (_QWORD)header;
  v33 = v9;
  if ( limit >= v41 )
  {
    *(_WORD *)v18 = __ROL2__(optno, 8);
    *(_WORD *)(v18 + 2) = __ROL2__(optlen, 8);
    v18 = (unsigned __int64)&v41[optlen];
    if ( &v41[optlen] <= limit )
    {
      memcpy(v41, opt, optlen);
      *v42 = __ROL2__(v18 - (_WORD)buff, 8);
      return v18 - (_QWORD)header;
    }
  }
  return v33;
}
