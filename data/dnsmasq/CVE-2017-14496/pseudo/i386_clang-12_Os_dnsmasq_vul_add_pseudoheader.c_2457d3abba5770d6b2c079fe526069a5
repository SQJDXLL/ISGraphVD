int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        int optlen,
        int set_do,
        int replace)
{
  int v9; // edi
  dns_header *v10; // ebp
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // bx
  unsigned __int8 *v14; // edi
  __int16 v15; // ax
  signed int v16; // ebx
  char *v17; // esi
  int v18; // ebp
  unsigned __int32 v19; // eax
  _BYTE *v20; // ecx
  _WORD *v21; // edi
  __int16 v22; // si
  void *v23; // eax
  void *v24; // edi
  int v25; // eax
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  int v28; // eax
  int v29; // edi
  char *v30; // ebx
  char *v31; // ebx
  __int16 v32; // [esp+Ah] [ebp-32h]
  void *ptr; // [esp+Ch] [ebp-30h]
  char *src; // [esp+10h] [ebp-2Ch]
  size_t v36; // [esp+14h] [ebp-28h]
  __int16 v37; // [esp+18h] [ebp-24h]
  int is_last; // [esp+1Ch] [ebp-20h] BYREF
  int v39; // [esp+20h] [ebp-1Ch]
  unsigned __int8 *v40; // [esp+24h] [ebp-18h] BYREF
  int is_sign[5]; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v40, is_sign, &is_last);
  if ( is_sign[0] )
    return plen;
  HIBYTE(v13) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    v37 = v13 << 15;
    ptr = 0;
    v16 = 0;
    v22 = 0;
    goto LABEL_26;
  }
  v36 = plen;
  v14 = v40;
  v15 = __ROL2__(*((_WORD *)v40 + 2), 8);
  if ( set_do )
  {
    v15 |= 0x8000u;
    v40[4] = HIBYTE(v15);
  }
  if ( optno )
  {
    v37 = v15;
    v16 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
    v17 = (char *)(v14 + 8);
    if ( v16 + v14 + 8 - (unsigned __int8 *)header <= plen )
    {
      v32 = *(_WORD *)v14;
      v39 = *((unsigned __int16 *)v14 + 1);
      src = (char *)(v14 + 8);
      if ( (unsigned int)v16 < 5 )
      {
LABEL_17:
        v10 = header;
        if ( is_last )
        {
          v21 = v14 + 6;
LABEL_32:
          v30 = v17 + 4;
          if ( limit - (unsigned __int8 *)(v17 + 4) >= optlen )
          {
            if ( optno && replace != 2 )
            {
              *v17 = BYTE1(optno);
              v17[1] = optno;
              v17[2] = BYTE1(optlen);
              v17[3] = optlen;
              memcpy(v30, opt, optlen);
              v31 = &v30[optlen];
              *v21 = __ROL2__((_WORD)v31 - (_WORD)src, 8);
              v17 = v31;
            }
            return v17 - (char *)v10;
          }
          return v36;
        }
        if ( v16 )
        {
          ptr = 0;
          v23 = (void *)whine_malloc(v16);
          if ( v23 )
          {
            v24 = v23;
            memcpy(v23, src, v16);
            ptr = v24;
          }
        }
        else
        {
          ptr = 0;
          v16 = 0;
        }
      }
      else
      {
        v18 = 0;
        while ( 1 )
        {
          v19 = _byteswap_ulong(*((unsigned __int16 *)v17 + 1) << 16);
          if ( (int)(v19 + v18) > v16 )
            break;
          v20 = v17 + 4;
          if ( _byteswap_ulong(*(unsigned __int16 *)v17 << 16) == optno )
          {
            if ( !replace )
              return v36;
            v16 = v16 - v19 - 4;
            memcpy(v17, &v20[v19], v16 - v18);
            *((_WORD *)v14 + 3) = __ROL2__(v16, 8);
          }
          else
          {
            v18 += v19 + 4;
            v17 = &v20[v19];
          }
          if ( v18 + 4 >= v16 )
            goto LABEL_17;
        }
        is_last = 0;
        v16 = 0;
        ptr = 0;
        v10 = header;
      }
      udp_sz = __ROL2__(v32, 8);
      v22 = __ROL2__(v39, 8);
      v9 = rrfilter(v10, plen, 0);
LABEL_26:
      v25 = skip_questions(v10, v9);
      v36 = v9;
      if ( !v25 )
        return v36;
      v26 = _mm_cvtsi32_si128(*(_DWORD *)&v10->ancount);
      v27 = _mm_or_si128(_mm_slli_epi16(v26, 8u), _mm_srli_epi16(v26, 8u));
      v28 = skip_section(
              v25,
              _mm_cvtsi128_si32(_mm_add_epi32(_mm_srli_epi32(v27, 0x10u), _mm_unpacklo_epi16(v27, (__m128i)0LL)))
            + (unsigned __int16)__ROL2__(v10->arcount, 8),
              v10,
              v9);
      if ( !v28 )
        return v36;
      v29 = v28;
      *(_WORD *)v28 = 0;
      *(_BYTE *)(v28 + 2) = 41;
      *(_BYTE *)(v28 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v28 + 4) = udp_sz;
      *(_BYTE *)(v28 + 5) = HIBYTE(v22);
      *(_BYTE *)(v28 + 6) = v22;
      *(_BYTE *)(v28 + 7) = HIBYTE(v37);
      *(_BYTE *)(v28 + 8) = v37;
      *(_BYTE *)(v28 + 9) = BYTE1(v16);
      *(_BYTE *)(v28 + 10) = v16;
      v17 = (char *)(v28 + 11);
      src = (char *)(v28 + 11);
      if ( ptr )
      {
        memcpy((void *)(v28 + 11), ptr, v16);
        free(ptr);
        v17 = &src[v16];
      }
      v21 = (_WORD *)(v29 + 9);
      if ( limit - (unsigned __int8 *)v17 - 4 >= optlen )
        v10->arcount = __ROL2__(__ROL2__(v10->arcount, 8) + 1, 8);
      goto LABEL_32;
    }
  }
  return v36;
}
