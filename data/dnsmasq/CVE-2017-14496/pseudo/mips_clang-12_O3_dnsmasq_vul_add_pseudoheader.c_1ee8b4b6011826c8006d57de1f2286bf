int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s1
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  int v20; // $s7
  unsigned __int8 *v21; // $s2
  char v22; // $s3
  int v23; // $s5
  unsigned __int8 *v24; // $s7
  int v25; // $fp
  int v26; // $v0
  int v27; // $v1
  unsigned __int8 *v28; // $a0
  int v29; // $v0
  signed int v30; // $v0
  unsigned __int8 *v31; // $v1
  _BYTE *v32; // $s4
  _WORD *v33; // $s3
  void *v34; // $v0
  void *v35; // $s2
  int v36; // $v0
  int v37; // $v1
  int v38; // $v0
  bool v39; // dc
  _BYTE *v40; // $v0
  _BYTE *v41; // $s2
  unsigned __int8 *v42; // $s2
  signed int v43; // $s1
  void *src; // [sp+1Ch] [-2Ch]
  int v45; // [sp+20h] [-28h]
  unsigned __int8 v46; // [sp+27h] [-21h]
  unsigned __int8 v47; // [sp+2Bh] [-1Dh]
  unsigned __int8 v48; // [sp+2Fh] [-19h]
  unsigned int v49; // [sp+30h] [-18h]
  signed int v50; // [sp+34h] [-14h]
  unsigned __int8 *v51; // [sp+38h] [-10h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v54; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v54, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  v20 = replace;
  if ( pseudoheader )
  {
    v21 = v54;
    v22 = v54[4];
    if ( set_do )
    {
      v22 |= 0x80u;
      v54[4] = v22;
    }
    if ( optno )
    {
      v51 = limit;
      v23 = (v21[6] << 8) | v21[7];
      if ( v15 >= v21 + 8 - (unsigned __int8 *)header + v23 )
      {
        src = v21 + 8;
        LOBYTE(udp_sz) = v21[1];
        v50 = optlen;
        v45 = replace;
        LOBYTE(v49) = *v21;
        v48 = v21[5];
        v47 = v21[2];
        v46 = v21[3];
        if ( (unsigned int)v23 < 5 )
        {
          v24 = v21 + 8;
LABEL_21:
          if ( is_last )
          {
            v30 = optlen;
            v31 = v51;
            LOWORD(v32) = (_WORD)v21 + 8;
            v33 = v21 + 6;
LABEL_39:
            v42 = v24 + 4;
            if ( v31 - (v24 + 4) >= v30 )
            {
              if ( optno && v45 != 2 )
              {
                v24[3] = v30;
                v24[1] = optno;
                v43 = v30;
                v24[2] = BYTE2(v30);
                *v24 = BYTE2(optno);
                memcpy(v24 + 4, opt, v30);
                v24 = &v42[v43];
                *v33 = (_WORD)v42 + v43 - (_WORD)v32;
              }
              return v24 - (unsigned __int8 *)header;
            }
            return v15;
          }
          v17 = 0;
          if ( v23 )
          {
            v34 = (void *)whine_malloc(v23);
            v20 = replace;
            if ( v34 )
            {
              v35 = v34;
              memcpy(v34, src, v23);
              v17 = v35;
            }
          }
          else
          {
            v20 = replace;
            v23 = 0;
          }
        }
        else
        {
          if ( replace )
          {
            v24 = v21 + 8;
            v25 = 0;
            while ( 1 )
            {
              v26 = (v24[2] << 8) | v24[3];
              v27 = v26 + v25;
              if ( v23 < v26 + v25 )
                break;
              v28 = v24 + 4;
              if ( ((*v24 << 8) | v24[1]) == optno )
              {
                v23 = v23 - v26 - 4;
                memcpy(v24, &v28[v26], v23 - v25);
                *((_WORD *)v21 + 3) = v23;
                if ( v25 + 4 >= v23 )
                  goto LABEL_21;
              }
              else
              {
                v25 = v27 + 4;
                v24 = &v28[v26];
                if ( v27 + 8 >= v23 )
                  goto LABEL_21;
              }
            }
          }
          else
          {
            v24 = v21 + 8;
            v36 = 0;
            while ( 1 )
            {
              v37 = (v24[2] << 8) | v24[3];
              v38 = v37 + v36;
              if ( v23 < v38 )
                break;
              if ( ((*v24 << 8) | v24[1]) == optno )
                return v15;
              v24 += v37 + 4;
              v39 = v38 + 8 < v23;
              v36 = v38 + 4;
              if ( !v39 )
                goto LABEL_21;
            }
          }
          v20 = replace;
          is_last = 0;
          v23 = 0;
          v17 = 0;
        }
        v15 = rrfilter(header, v15, 0);
        v29 = skip_questions(header, v15);
        if ( !v29 )
          return v15;
LABEL_34:
        v40 = (_BYTE *)skip_section(
                         v29,
                         (_bswapw(header->nscount) >> 16)
                       + (_bswapw(header->ancount) >> 16)
                       + (_bswapw(header->arcount) >> 16),
                         header,
                         v15);
        if ( !v40 )
          return v15;
        v41 = v40;
        v40[10] = v23;
        v45 = v20;
        v40[8] = v48;
        v40[7] = v22;
        v40[6] = v46;
        v40[5] = v47;
        v40[4] = udp_sz;
        v32 = v40 + 0xB;
        v24 = v40 + 0xB;
        v40[3] = v49;
        v40[2] = 41;
        v40[1] = 0;
        *v40 = 0;
        v40[9] = BYTE2(v23);
        if ( v17 )
        {
          memcpy(v40 + 0xB, v17, v23);
          free(v17);
          v24 = &v32[v23];
        }
        v31 = v51;
        v30 = v50;
        v33 = v41 + 9;
        if ( v51 - v24 - 4 >= v50 )
          header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
        goto LABEL_39;
      }
    }
  }
  else
  {
    v22 = 0x80;
    v51 = limit;
    v50 = optlen;
    v23 = 0;
    v49 = udp_sz >> 8;
    if ( !set_do )
      v22 = 0;
    v48 = 0;
    v47 = 0;
    v46 = 0;
    v29 = skip_questions(header, v15);
    if ( v29 )
      goto LABEL_34;
  }
  return v15;
}
