int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  _BYTE *v13; // $fp
  size_t v16; // $s5
  unsigned __int8 v18; // $s1
  unsigned __int8 *pseudoheader; // $v0
  int v21; // $a1
  unsigned __int8 *v22; // $fp
  unsigned __int8 v23; // $t0
  unsigned __int8 v24; // $a0
  unsigned __int8 v25; // $a3
  unsigned __int8 v26; // $a2
  unsigned __int8 *v27; // $s7
  int v28; // $s4
  int v29; // $s6
  int v30; // $v0
  int v31; // $v1
  unsigned __int8 *v32; // $s3
  char v33; // $at
  unsigned int v34; // $a2
  unsigned __int8 v35; // $a3
  unsigned __int8 v36; // $t0
  void *v37; // $v0
  unsigned __int8 *v38; // $s3
  int v39; // $s7
  void *v40; // $v0
  void *v41; // $s7
  signed int v42; // $s5
  unsigned __int8 *v43; // $a0
  int v44; // $v0
  int v45; // $s3
  int v46; // $s5
  int v47; // $v0
  int v48; // $s5
  _BYTE *v49; // $v0
  char *v50; // $fp
  _BYTE *v51; // $s5
  size_t v52; // $a2
  bool v53; // dc
  __uint16_t v54; // $v0
  void *v55; // [sp+20h] [-30h]
  void *v56; // [sp+20h] [-30h]
  void *src; // [sp+24h] [-2Ch]
  unsigned __int8 v58; // [sp+28h] [-28h]
  unsigned __int8 v59; // [sp+28h] [-28h]
  unsigned __int8 v60; // [sp+2Ch] [-24h]
  unsigned __int8 v61; // [sp+2Ch] [-24h]
  unsigned __int8 v62; // [sp+30h] [-20h]
  char v63; // [sp+30h] [-20h]
  char v64; // [sp+34h] [-1Ch]
  unsigned __int8 *v65; // [sp+38h] [-18h]
  int is_last; // [sp+44h] [-Ch] BYREF
  int is_sign; // [sp+48h] [-8h] BYREF
  unsigned __int8 *v68; // [sp+4Ch] [-4h] BYREF

  v16 = plen;
  v18 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v68, &is_sign, &is_last);
  if ( is_sign )
    return v16;
  v21 = optno;
  v65 = limit;
  if ( pseudoheader )
  {
    v22 = v68;
    v23 = v68[5];
    v24 = v68[4];
    v18 = v68[3];
    v25 = v68[2];
    LOBYTE(udp_sz) = v68[1];
    v26 = *v68;
    if ( set_do )
    {
      v24 |= 0x80u;
      v68[4] = v24;
    }
    v27 = v22 + 8;
    v28 = (v22[6] << 8) | v22[7];
    src = v22 + 8;
    v64 = v24;
    if ( !optno || v16 < v27 - (unsigned __int8 *)header + v28 )
      return v16;
    v62 = v26;
    v60 = v25;
    v58 = v23;
    if ( (unsigned int)v28 >= 5 )
    {
      v29 = 0;
      v30 = 4;
      while ( 1 )
      {
        v31 = (v27[2] << 8) | v27[3];
        v32 = v27 + 4;
        if ( v28 < v31 + v30 )
          break;
        if ( ((*v27 << 8) | v27[1]) == v21 )
        {
          if ( !replace )
            return v16;
          v28 = v28 - v31 - 4;
          memcpy(v27, &v32[v31], v28 - v29);
          v21 = optno;
          v22[7] = v28;
          v22[6] = BYTE1(v28);
        }
        else
        {
          v27 = &v32[v31];
          v29 += v31 + 4;
        }
        v30 = v29 + 4;
        if ( v29 + 4 >= v28 )
          goto LABEL_22;
      }
      is_last = 0;
      v28 = 0;
      v27 += 4;
    }
LABEL_22:
    if ( is_last )
    {
      v38 = v27;
      v39 = v16;
      LOBYTE(v34) = v62;
      v35 = v60;
      v36 = v58;
      v37 = 0;
      v13 = v22 + 6;
    }
    else
    {
      v38 = 0;
      v40 = 0;
      if ( v28 )
      {
        v41 = (void *)whine_malloc(v28);
        v40 = 0;
        if ( v41 )
        {
          memcpy(v41, src, v28);
          v40 = v41;
        }
      }
      v55 = v40;
      v39 = rrfilter(header, v16, 0);
      v37 = v55;
      v21 = optno;
      LOBYTE(v34) = v62;
      v35 = v60;
      v36 = v58;
      v13 = v22 + 6;
    }
  }
  else
  {
    v33 = 0x80;
    if ( !set_do )
      v33 = 0;
    v64 = v33;
    v34 = udp_sz >> 8;
    v35 = 0;
    v36 = 0;
    v28 = 0;
    v37 = 0;
    v38 = 0;
    v39 = v16;
  }
  v42 = optlen;
  if ( !v38 )
  {
    v56 = v37;
    v59 = v36;
    v61 = v35;
    v63 = v34;
    v44 = skip_questions(header, v39);
    if ( !v44 )
      return v39;
    v45 = v44;
    v46 = _bswap_16(header->ancount);
    v48 = _bswap_16(header->nscount) + v46;
    v47 = _bswap_16(header->arcount);
    v49 = (_BYTE *)skip_section(v45, v48 + v47, header, v39);
    if ( !v49 )
      return v39;
    v50 = v49 + 0xB;
    v51 = v49;
    if ( v65 < v49 + 0xB )
      return v39;
    v49[10] = v28;
    v49[8] = v59;
    v49[7] = v64;
    v49[6] = v18;
    v49[5] = v61;
    v49[4] = udp_sz;
    v49[3] = v63;
    v49[2] = 41;
    v49[1] = 0;
    *v49 = 0;
    v49[9] = BYTE1(v28);
    v38 = v49 + 0xB;
    if ( v56 )
    {
      v38 = (unsigned __int8 *)&v50[v28];
      if ( v65 < (unsigned __int8 *)&v50[v28] )
      {
        free(v56);
        return v39;
      }
      memcpy(v50, v56, v28);
      free(v56);
    }
    LOWORD(src) = (_WORD)v50;
    v13 = v51 + 9;
    v42 = optlen;
    if ( v65 - v38 - 4 >= (int)optlen )
    {
      v54 = _bswap_16(header->arcount);
      header->arcount = _bswap_16(v54 + 1);
    }
    v21 = optno;
  }
  v43 = v38 + 4;
  if ( v65 - (v38 + 4) >= v42 )
  {
    if ( v21 && replace != 2 )
    {
      if ( v65 < v43 )
        return v39;
      v38[3] = v42;
      v38[1] = v21;
      v38[2] = BYTE1(v42);
      *v38 = BYTE1(v21);
      v38 = &v43[v42];
      v52 = v42;
      v53 = v65 < &v43[v42];
      v16 = v39;
      if ( v53 )
        return v16;
      memcpy(v43, opt, v52);
      v13[1] = (_BYTE)v38 - (_BYTE)src;
      *v13 = (unsigned __int16)((_WORD)v38 - (_WORD)src) >> 8;
    }
    return v38 - (unsigned __int8 *)header;
  }
  return v39;
}
