size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  int v14; // $s5
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s2
  int v18; // $v1
  unsigned __int8 *v19; // $s1
  unsigned __int8 *v20; // $s1
  unsigned int v21; // $s6
  unsigned int v22; // $v0
  __int16 v23; // $s3
  unsigned int v24; // $v0
  char *v25; // $fp
  signed int v26; // $s7
  int v27; // $a3
  unsigned __int8 *v28; // $s5
  _BYTE *v29; // $s1
  unsigned __int8 *v30; // $v0
  int v31; // $s6
  int v32; // $a0
  _BYTE *v33; // $v0
  _BYTE *v34; // $a3
  size_t v35; // $v1
  unsigned int v36; // $v0
  unsigned __int16 v37; // $a2
  unsigned int v38; // $v0
  int v39; // $a1
  int v40; // $a1
  int v41; // $a1
  signed int v42; // $v1
  unsigned __int8 *v43; // $a0
  unsigned int t_s; // [sp+20h] [-20h]
  int t_sa; // [sp+20h] [-20h]
  _BYTE *t_sb; // [sp+20h] [-20h]
  int i; // [sp+2Ch] [-14h]
  unsigned __int8 *udp_len; // [sp+30h] [-10h] BYREF
  int is_sign; // [sp+34h] [-Ch] BYREF
  int is_last; // [sp+38h] [-8h] BYREF

  LOWORD(v14) = udp_sz;
  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( pseudoheader )
  {
    v20 = udp_len;
    t_s = (udp_len[1] << 8) | *udp_len;
    v21 = (udp_len[3] << 8) | udp_len[2];
    v22 = (udp_len[5] << 8) | udp_len[4];
    v23 = ((_WORD)v22 << 8) | (v22 >> 8);
    if ( set_do )
    {
      v23 |= 0x8000u;
      udp_len[4] = HIBYTE(v23);
      v20[5] = v23;
    }
    v24 = (v20[7] << 8) | v20[6];
    v25 = (char *)(v20 + 8);
    v26 = (unsigned __int16)(((_WORD)v24 << 8) | (v24 >> 8));
    if ( v17 < v20 + 8 - (unsigned __int8 *)header + v26 )
      return v17;
    v27 = 0;
    if ( !optno )
      return v17;
    v28 = v20 + 8;
    while ( v27 + 4 < v26 )
    {
      v36 = (v28[1] << 8) | *v28;
      v37 = ((_WORD)v36 << 8) | (v36 >> 8);
      v38 = (v28[3] << 8) | v28[2];
      v39 = (unsigned __int16)(((_WORD)v38 << 8) | (v38 >> 8));
      if ( v26 < v39 + v27 + 4 )
      {
        is_last = 0;
LABEL_23:
        v26 = 0;
        v19 = 0;
        goto LABEL_13;
      }
      if ( v37 == optno )
      {
        v40 = v39 + 4;
        if ( !replace )
          return v17;
        v26 -= v40;
        i = v27;
        memcpy(v28, &v28[v40], v26 - v27);
        v27 = i;
        v20[6] = BYTE1(v26);
        v20[7] = v26;
      }
      else
      {
        v41 = v39 + 4;
        v28 += v41;
        v27 += v41;
      }
    }
    v29 = v20 + 6;
    if ( is_last )
      goto LABEL_31;
    if ( !v26 )
      goto LABEL_23;
    v30 = (unsigned __int8 *)whine_malloc(v26);
    v19 = v30;
    if ( v30 )
      memcpy(v30, v25, v26);
LABEL_13:
    v14 = (t_s << 8) | (t_s >> 8);
    v31 = (v21 << 8) | (v21 >> 8);
    v17 = rrfilter(header, v17, 0);
    v18 = v26;
  }
  else
  {
    LOWORD(v31) = 0;
    v23 = (set_do != 0) << 15;
  }
  t_sa = v18;
  v32 = skip_questions(header, v17);
  if ( v32 )
  {
    v33 = (_BYTE *)skip_section(
                     v32,
                     (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                   + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                   + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                     header,
                     v17);
    v34 = v33;
    if ( v33 )
    {
      v25 = v33 + 0xB;
      if ( limit >= v33 + 0xB )
      {
        v33[2] = 41;
        v35 = t_sa;
        v33[3] = BYTE1(v14);
        v33[5] = BYTE1(v31);
        v33[7] = HIBYTE(v23);
        *v33 = 0;
        v33[1] = 0;
        v33[4] = v14;
        v33[6] = v31;
        v33[8] = v23;
        v33[9] = BYTE1(t_sa);
        v33[10] = t_sa;
        if ( v19 )
        {
          v28 = (unsigned __int8 *)&v25[t_sa];
          if ( limit < (unsigned __int8 *)&v25[t_sa] )
          {
            free(v19);
            return v17;
          }
          t_sb = v33;
          memcpy(v25, v19, v35);
          free(v19);
          v34 = t_sb;
        }
        else
        {
          v28 = v33 + 0xB;
        }
        v42 = optlen;
        v29 = v34 + 9;
        if ( limit - (v28 + 4) >= (int)optlen )
        {
          header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
LABEL_31:
          v42 = optlen;
        }
        v43 = v28 + 4;
        if ( limit - (v28 + 4) >= v42 )
        {
          if ( !optno || replace == 2 )
            return v28 - (unsigned __int8 *)header;
          if ( limit >= v43 )
          {
            *v28 = BYTE1(optno);
            v28[1] = optno;
            v28[2] = BYTE1(optlen);
            v28[3] = optlen;
            v28 = &v43[optlen];
            if ( limit >= &v43[optlen] )
            {
              memcpy(v43, opt, optlen);
              *v29 = (unsigned __int16)((_WORD)v28 - (_WORD)v25) >> 8;
              v29[1] = (_BYTE)v28 - (_BYTE)v25;
              return v28 - (unsigned __int8 *)header;
            }
          }
        }
      }
    }
  }
  return v17;
}
