size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  dns_header *v11; // r12
  unsigned __int64 v13; // rbx
  unsigned __int8 *pseudoheader; // rax
  __int64 v15; // rcx
  int v16; // r9d
  unsigned __int8 *v17; // r15
  unsigned __int8 *v18; // rsi
  __int16 v19; // r8
  unsigned __int8 *v20; // rdi
  int v21; // r14d
  unsigned __int8 *v22; // r11
  unsigned __int16 v23; // dx
  int v24; // eax
  int v25; // r12d
  int v26; // ebp
  int v27; // ebx
  int v28; // r14d
  int v29; // r10d
  __int16 v31; // r8
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rcx
  int v35; // r9d
  __int64 v36; // r14
  void *v37; // r8
  _WORD *v38; // rbx
  char *v39; // rax
  __int64 v40; // rax
  unsigned __int8 *v41; // rax
  char *rcode; // [rsp+10h] [rbp-88h]
  __int16 rcodea; // [rsp+10h] [rbp-88h]
  __int16 rdlen; // [rsp+18h] [rbp-80h]
  int rdlena; // [rsp+18h] [rbp-80h]
  __int64 rdlenb; // [rsp+18h] [rbp-80h]
  __int16 v48; // [rsp+24h] [rbp-74h]
  __int16 v49; // [rsp+24h] [rbp-74h]
  __int16 flags; // [rsp+28h] [rbp-70h]
  int flagsa; // [rsp+28h] [rbp-70h]
  dns_header *headera; // [rsp+30h] [rbp-68h]
  __int16 headerc; // [rsp+30h] [rbp-68h]
  __int16 headerb; // [rsp+30h] [rbp-68h]
  size_t plena; // [rsp+38h] [rbp-60h]
  int is_sign; // [rsp+48h] [rbp-50h] BYREF
  int is_last; // [rsp+4Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+50h] [rbp-48h] BYREF

  v11 = header;
  v13 = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v13;
  v17 = pseudoheader;
  if ( !pseudoheader )
  {
    rcodea = 0;
    v31 = (set_do != 0) << 15;
    goto LABEL_22;
  }
  v18 = udp_len[0];
  v48 = *(_WORD *)udp_len[0];
  v19 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
  rdlen = *((_WORD *)udp_len[0] + 1);
  if ( set_do )
  {
    v19 |= 0x8000u;
    *((_WORD *)udp_len[0] + 2) = __ROL2__(v19, 8);
  }
  v20 = v18 + 8;
  rcode = (char *)(v18 + 8);
  LOWORD(v21) = __ROL2__(*((_WORD *)v18 + 3), 8);
  if ( v13 < (unsigned __int64)(unsigned __int16)v21 + v18 + 8 - (unsigned __int8 *)v11 || !optno )
    return v13;
  v21 = (unsigned __int16)v21;
  if ( (unsigned __int16)v21 > 4u )
  {
    v15 = *((unsigned __int16 *)v18 + 4);
    v22 = v18 + 12;
    v23 = __ROL2__(*((_WORD *)v18 + 5), 8);
    LOWORD(v15) = __ROL2__(v15, 8);
    v24 = v23;
    if ( (unsigned __int16)v21 >= (int)v23 )
    {
      if ( !replace )
      {
        v29 = 0;
        while ( 1 )
        {
          v15 = (unsigned __int16)v15;
          if ( (unsigned __int16)v15 == optno )
            return v13;
          v29 += v24 + 4;
          v20 = &v22[v23];
          if ( v29 + 4 >= (unsigned __int16)v21 )
            goto LABEL_29;
          v15 = *(unsigned __int16 *)v20;
          v22 = v20 + 4;
          v23 = __ROL2__(*((_WORD *)v20 + 1), 8);
          LOWORD(v15) = __ROL2__(v15, 8);
          v24 = v23;
          if ( v23 + v29 > (unsigned __int16)v21 )
            goto LABEL_37;
        }
      }
      headera = v11;
      v25 = optno;
      plena = v13;
      v26 = 0;
      v27 = (unsigned __int16)v21;
      flags = v19;
      v28 = v16;
      do
      {
        v15 = (unsigned __int16)v15;
        if ( (unsigned __int16)v15 == v25 )
        {
          v27 -= v24 + 4;
          v20 = (unsigned __int8 *)memcpy(v20, &v20[v23 + 4], v27 - v26);
          *((_WORD *)v18 + 3) = __ROL2__(v27, 8);
        }
        else
        {
          v26 += v24 + 4;
          v20 = &v22[v23];
        }
        if ( v26 + 4 >= v27 )
        {
          v16 = v28;
          optno = v25;
          v21 = v27;
          v19 = flags;
          v13 = plena;
          v11 = headera;
          goto LABEL_29;
        }
        v15 = *(unsigned __int16 *)v20;
        v22 = v20 + 4;
        v23 = __ROL2__(*((_WORD *)v20 + 1), 8);
        LOWORD(v15) = __ROL2__(v15, 8);
        v24 = v23;
      }
      while ( v26 + v23 <= v27 );
      optno = v25;
      v13 = plena;
      v11 = headera;
      v16 = v28;
      v19 = flags;
    }
LABEL_37:
    is_last = 0;
    goto LABEL_38;
  }
LABEL_29:
  if ( is_last )
  {
    v37 = v20 + 4;
    if ( limit - (v20 + 4) >= (__int64)optlen )
    {
      v38 = v18 + 6;
      goto LABEL_32;
    }
    return v13;
  }
  if ( v21 )
  {
    headerb = v19;
    v41 = (unsigned __int8 *)whine_malloc(v21, v18);
    v19 = headerb;
    v17 = v41;
    if ( v41 )
    {
      memcpy(v41, rcode, v21);
      v19 = headerb;
    }
    v16 = v21;
    goto LABEL_39;
  }
LABEL_38:
  v17 = 0LL;
LABEL_39:
  headerc = v19;
  flagsa = v16;
  udp_sz = __ROL2__(v48, 8);
  rcodea = __ROL2__(rdlen, 8);
  v40 = rrfilter(v11, v13, 0LL, v15);
  v16 = flagsa;
  v31 = headerc;
  v13 = v40;
LABEL_22:
  v49 = v31;
  rdlena = v16;
  v32 = skip_questions(v11, v13);
  if ( !v32 )
    return v13;
  v33 = skip_section(
          v32,
          (unsigned __int16)__ROL2__(v11->arcount, 8)
        + (unsigned __int16)__ROL2__(v11->nscount, 8)
        + (unsigned int)(unsigned __int16)__ROL2__(v11->ancount, 8),
          v11,
          v13);
  v34 = v33;
  if ( !v33 )
    return v13;
  v35 = rdlena;
  *(_BYTE *)(v33 + 2) = 41;
  *(_WORD *)v33 = 0;
  *(_QWORD *)(v33 + 3) = HIBYTE(udp_sz) | (((unsigned __int8)udp_sz | ((HIBYTE(rcodea) | (((unsigned __int8)rcodea | ((HIBYTE(v49) | (((unsigned __int8)v49 | ((BYTE1(rdlena) | ((unsigned __int64)(unsigned __int8)rdlena << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  rcode = (char *)(v33 + 11);
  v20 = (unsigned __int8 *)(v33 + 11);
  if ( v17 )
  {
    v36 = rdlena;
    rdlenb = v33;
    memcpy(v20, v17, v35);
    free(v17);
    v34 = rdlenb;
    v20 = (unsigned __int8 *)&rcode[v36];
  }
  v37 = v20 + 4;
  if ( limit - (v20 + 4) < (__int64)optlen )
    return v13;
  v38 = (_WORD *)(v34 + 9);
  v11->arcount = __ROL2__(__ROL2__(v11->arcount, 8) + 1, 8);
LABEL_32:
  if ( optno )
  {
    if ( replace != 2 )
    {
      *(_DWORD *)v20 = BYTE1(optno) | (((unsigned __int8)optno | ((BYTE1(optlen) | ((unsigned __int8)optlen << 8)) << 8)) << 8);
      v39 = (char *)memcpy(v37, opt, optlen);
      v20 = (unsigned __int8 *)&v39[optlen];
      *v38 = __ROL2__((_WORD)v39 + optlen - (_WORD)rcode, 8);
    }
  }
  return v20 - (unsigned __int8 *)v11;
}
