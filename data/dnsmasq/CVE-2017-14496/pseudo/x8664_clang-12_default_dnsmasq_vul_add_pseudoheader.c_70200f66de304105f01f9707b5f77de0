size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  __int16 v9; // ax
  uint16_t v10; // ax
  unsigned __int8 *v11; // rax
  uint16_t v12; // ax
  int v14; // [rsp+0h] [rbp-150h]
  int v15; // [rsp+4h] [rbp-14Ch]
  unsigned __int8 *v16; // [rsp+8h] [rbp-148h]
  unsigned __int8 *t_cp_14; // [rsp+10h] [rbp-140h]
  unsigned __int8 t_s_8; // [rsp+1Eh] [rbp-132h]
  unsigned __int8 *t_cp_13; // [rsp+20h] [rbp-130h]
  unsigned __int8 *t_cp_12; // [rsp+30h] [rbp-120h]
  unsigned __int8 t_s_6; // [rsp+3Eh] [rbp-112h]
  unsigned __int8 *t_cp_11; // [rsp+40h] [rbp-110h]
  unsigned __int8 t_s_5; // [rsp+4Eh] [rbp-102h]
  unsigned __int8 *t_cp_10; // [rsp+50h] [rbp-100h]
  unsigned __int8 *t_cp_9; // [rsp+60h] [rbp-F0h]
  unsigned __int8 *t_cp_8; // [rsp+70h] [rbp-E0h]
  unsigned __int8 t_s_2; // [rsp+7Eh] [rbp-D2h]
  unsigned __int8 *t_cp_7; // [rsp+80h] [rbp-D0h]
  unsigned __int8 *t_cp_6; // [rsp+90h] [rbp-C0h]
  unsigned __int8 t_s_0; // [rsp+9Eh] [rbp-B2h]
  unsigned __int8 *t_cp_2; // [rsp+B8h] [rbp-98h]
  unsigned __int16 len; // [rsp+E0h] [rbp-70h]
  unsigned __int16 code; // [rsp+E2h] [rbp-6Eh]
  int i; // [rsp+E4h] [rbp-6Ch]
  unsigned __int16 rcode; // [rsp+E8h] [rbp-68h]
  unsigned __int16 flags; // [rsp+EAh] [rbp-66h]
  int is_last; // [rsp+ECh] [rbp-64h] BYREF
  int is_sign; // [rsp+F0h] [rbp-60h] BYREF
  int rdlen; // [rsp+F4h] [rbp-5Ch]
  unsigned __int8 *buff; // [rsp+F8h] [rbp-58h]
  unsigned __int8 *udp_len; // [rsp+100h] [rbp-50h] BYREF
  unsigned __int8 *p; // [rsp+108h] [rbp-48h]
  unsigned __int8 *datap; // [rsp+110h] [rbp-40h]
  unsigned __int8 *lenp; // [rsp+118h] [rbp-38h]
  unsigned __int8 *opta; // [rsp+120h] [rbp-30h]
  int optnoa; // [rsp+128h] [rbp-28h]
  unsigned __int16 udp_sza; // [rsp+12Eh] [rbp-22h]
  unsigned __int8 *limita; // [rsp+130h] [rbp-20h]
  size_t plena; // [rsp+138h] [rbp-18h]
  dns_header *headera; // [rsp+140h] [rbp-10h]

  headera = header;
  plena = plen;
  limita = limit;
  udp_sza = udp_sz;
  optnoa = optno;
  opta = opt;
  buff = 0LL;
  rdlen = 0;
  v9 = 0;
  if ( set_do )
    v9 = 0x8000;
  flags = v9;
  rcode = 0;
  p = find_pseudoheader(headera, plena, 0LL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return plena;
  if ( p )
  {
    p = udp_len;
    udp_sza = _byteswap_ushort(*(_WORD *)udp_len);
    p = udp_len + 2;
    rcode = _byteswap_ushort(*((_WORD *)udp_len + 1));
    p = udp_len + 4;
    flags = _byteswap_ushort(*((_WORD *)udp_len + 2));
    p = udp_len + 6;
    if ( set_do )
    {
      p -= 2;
      flags |= 0x8000u;
      t_cp_2 = p + 1;
      *p = HIBYTE(flags);
      *t_cp_2 = flags;
      p += 2;
    }
    lenp = p;
    rdlen = p[1] | (*p << 8);
    p += 2;
    if ( rdlen + p - (unsigned __int8 *)headera > plena )
      return plena;
    datap = p;
    if ( !optnoa )
      return plena;
    i = 0;
    while ( i + 4 < rdlen )
    {
      code = _byteswap_ushort(*(_WORD *)p);
      p += 2;
      len = _byteswap_ushort(*(_WORD *)p);
      p += 2;
      if ( len + i > rdlen )
      {
        rdlen = 0;
        is_last = 0;
        break;
      }
      if ( code == optnoa )
      {
        if ( !replace )
          return plena;
        p -= 4;
        rdlen -= len + 4;
        memcpy(p, &p[len + 4], rdlen - i);
        t_s_0 = rdlen;
        t_cp_6 = lenp + 1;
        *lenp = BYTE1(rdlen);
        *t_cp_6 = t_s_0;
        lenp += 2;
        lenp -= 2;
      }
      else
      {
        p += len;
        i += len + 4;
      }
    }
    if ( !is_last )
    {
      if ( rdlen )
      {
        buff = (unsigned __int8 *)whine_malloc(rdlen);
        if ( buff )
          memcpy(buff, datap, rdlen);
      }
      plena = rrfilter(headera, plena, 0LL);
      p = 0LL;
    }
  }
  if ( !p )
  {
    p = (unsigned __int8 *)skip_questions(headera, plena);
    if ( !p )
      return plena;
    v16 = p;
    v14 = ntohs(headera->ancount);
    v15 = ntohs(headera->nscount) + v14;
    v10 = ntohs(headera->arcount);
    p = (unsigned __int8 *)skip_section(v16, (unsigned int)v10 + v15, headera, plena);
    if ( !p )
      return plena;
    v11 = p++;
    *v11 = 0;
    t_cp_7 = p + 1;
    *p = 0;
    *t_cp_7 = 41;
    p += 2;
    t_s_2 = udp_sza;
    t_cp_8 = p + 1;
    *p = HIBYTE(udp_sza);
    *t_cp_8 = t_s_2;
    p += 2;
    t_cp_9 = p + 1;
    *p = HIBYTE(rcode);
    *t_cp_9 = rcode;
    p += 2;
    t_cp_10 = p + 1;
    *p = HIBYTE(flags);
    *t_cp_10 = flags;
    p += 2;
    lenp = p;
    t_s_5 = rdlen;
    t_cp_11 = p + 1;
    *p = BYTE1(rdlen);
    *t_cp_11 = t_s_5;
    p += 2;
    datap = p;
    if ( buff )
    {
      memcpy(p, buff, rdlen);
      free(buff);
      p += rdlen;
    }
    if ( (__int64)optlen <= limita - (p + 4) )
    {
      v12 = ntohs(headera->arcount);
      headera->arcount = htons(v12 + 1);
    }
  }
  if ( (__int64)optlen > limita - (p + 4) )
    return plena;
  if ( optnoa && replace != 2 )
  {
    t_s_6 = optnoa;
    t_cp_12 = p + 1;
    *p = BYTE1(optnoa);
    *t_cp_12 = t_s_6;
    p += 2;
    t_cp_13 = p + 1;
    *p = BYTE1(optlen);
    *t_cp_13 = optlen;
    p += 2;
    memcpy(p, opta, optlen);
    p += optlen;
    t_s_8 = (_BYTE)p - (_BYTE)datap;
    t_cp_14 = lenp + 1;
    *lenp = (unsigned __int16)((_WORD)p - (_WORD)datap) >> 8;
    *t_cp_14 = t_s_8;
    lenp += 2;
  }
  return p - (unsigned __int8 *)headera;
}
