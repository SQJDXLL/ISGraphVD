int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s1
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  int v20; // $s7
  unsigned __int8 *v21; // $s2
  unsigned __int8 v22; // $a2
  char v23; // $s3
  unsigned __int8 v24; // $t0
  unsigned __int8 v25; // $a3
  unsigned __int8 v26; // $a1
  int v27; // $s5
  unsigned __int8 *v28; // $s7
  int v29; // $fp
  int v30; // $v0
  int v31; // $v1
  unsigned __int8 *v32; // $a0
  int v33; // $v0
  signed int v34; // $v0
  unsigned __int8 *v35; // $v1
  _BYTE *v36; // $s4
  _BYTE *v37; // $s3
  void *v38; // $v0
  void *v39; // $s2
  int v40; // $v0
  int v41; // $v1
  int v42; // $v0
  bool v43; // dc
  _BYTE *v44; // $v0
  _BYTE *v45; // $s2
  unsigned __int8 *v46; // $s2
  signed int v47; // $s1
  __int16 v48; // $at
  int v49; // [sp+1Ch] [-2Ch]
  unsigned __int8 v50; // [sp+20h] [-28h]
  unsigned __int8 v51; // [sp+24h] [-24h]
  unsigned __int8 v52; // [sp+28h] [-20h]
  unsigned int v53; // [sp+2Ch] [-1Ch]
  void *src; // [sp+30h] [-18h]
  signed int v55; // [sp+34h] [-14h]
  unsigned __int8 *v56; // [sp+38h] [-10h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v59; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v59, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  v20 = replace;
  if ( pseudoheader )
  {
    v21 = v59;
    v22 = v59[5];
    v23 = v59[4];
    v24 = v59[3];
    v25 = v59[2];
    LOBYTE(udp_sz) = v59[1];
    v26 = *v59;
    if ( set_do )
    {
      v23 |= 0x80u;
      v59[4] = v23;
    }
    if ( optno )
    {
      v56 = limit;
      src = v21 + 8;
      v27 = (v21[6] << 8) | v21[7];
      if ( v15 >= v21 + 8 - (unsigned __int8 *)header + v27 )
      {
        v55 = optlen;
        v49 = replace;
        LOBYTE(v53) = v26;
        v52 = v22;
        v51 = v25;
        v50 = v24;
        if ( (unsigned int)v27 < 5 )
        {
          v28 = v21 + 8;
LABEL_21:
          if ( is_last )
          {
            v34 = optlen;
            v35 = v56;
            LOWORD(v36) = (_WORD)v21 + 8;
            v37 = v21 + 6;
LABEL_39:
            v46 = v28 + 4;
            if ( v35 - (v28 + 4) >= v34 )
            {
              if ( optno && v49 != 2 )
              {
                v28[3] = v34;
                v28[1] = optno;
                v47 = v34;
                v28[2] = BYTE1(v34);
                *v28 = BYTE1(optno);
                memcpy(v28 + 4, opt, v34);
                v28 = &v46[v47];
                v48 = (_WORD)v46 + v47 - (_WORD)v36;
                v37[1] = v48;
                *v37 = HIBYTE(v48);
              }
              return v28 - (unsigned __int8 *)header;
            }
            return v15;
          }
          v17 = 0;
          if ( v27 )
          {
            v38 = (void *)whine_malloc(v27);
            v20 = replace;
            if ( v38 )
            {
              v39 = v38;
              memcpy(v38, src, v27);
              v17 = v39;
            }
          }
          else
          {
            v20 = replace;
            v27 = 0;
          }
        }
        else
        {
          if ( replace )
          {
            v28 = v21 + 8;
            v29 = 0;
            while ( 1 )
            {
              v30 = (v28[2] << 8) | v28[3];
              v31 = v30 + v29;
              if ( v27 < v30 + v29 )
                break;
              v32 = v28 + 4;
              if ( ((*v28 << 8) | v28[1]) == optno )
              {
                v27 = v27 - v30 - 4;
                memcpy(v28, &v32[v30], v27 - v29);
                v21[7] = v27;
                v21[6] = BYTE1(v27);
                if ( v29 + 4 >= v27 )
                  goto LABEL_21;
              }
              else
              {
                v29 = v31 + 4;
                v28 = &v32[v30];
                if ( v31 + 8 >= v27 )
                  goto LABEL_21;
              }
            }
          }
          else
          {
            v28 = v21 + 8;
            v40 = 0;
            while ( 1 )
            {
              v41 = (v28[2] << 8) | v28[3];
              v42 = v41 + v40;
              if ( v27 < v42 )
                break;
              if ( ((*v28 << 8) | v28[1]) == optno )
                return v15;
              v28 += v41 + 4;
              v43 = v42 + 8 < v27;
              v40 = v42 + 4;
              if ( !v43 )
                goto LABEL_21;
            }
          }
          v20 = replace;
          is_last = 0;
          v27 = 0;
          v17 = 0;
        }
        v15 = rrfilter(header, v15, 0);
        v33 = skip_questions(header, v15);
        if ( !v33 )
          return v15;
LABEL_34:
        v44 = (_BYTE *)skip_section(
                         v33,
                         (_bswapw(header->nscount) >> 16)
                       + (_bswapw(header->ancount) >> 16)
                       + (_bswapw(header->arcount) >> 16),
                         header,
                         v15);
        if ( !v44 )
          return v15;
        v45 = v44;
        v44[10] = v27;
        v49 = v20;
        v44[8] = v52;
        v44[7] = v23;
        v44[6] = v50;
        v44[5] = v51;
        v44[4] = udp_sz;
        v36 = v44 + 0xB;
        v28 = v44 + 0xB;
        v44[3] = v53;
        v44[2] = 41;
        v44[1] = 0;
        *v44 = 0;
        v44[9] = BYTE1(v27);
        if ( v17 )
        {
          memcpy(v44 + 0xB, v17, v27);
          free(v17);
          v28 = &v36[v27];
        }
        v35 = v56;
        v34 = v55;
        v37 = v45 + 9;
        if ( v56 - v28 - 4 >= v55 )
          header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
        goto LABEL_39;
      }
    }
  }
  else
  {
    v23 = 0x80;
    v56 = limit;
    v55 = optlen;
    v27 = 0;
    v53 = udp_sz >> 8;
    if ( !set_do )
      v23 = 0;
    v52 = 0;
    v51 = 0;
    v50 = 0;
    v33 = skip_questions(header, v15);
    if ( v33 )
      goto LABEL_34;
  }
  return v15;
}
