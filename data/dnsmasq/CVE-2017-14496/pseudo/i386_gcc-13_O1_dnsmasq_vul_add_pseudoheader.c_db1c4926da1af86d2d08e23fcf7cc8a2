size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // eax
  unsigned __int16 v11; // ax
  int v12; // ebp
  unsigned __int8 *v13; // edi
  unsigned __int16 v14; // dx
  unsigned __int16 v15; // ax
  int v16; // ecx
  int v17; // esi
  __int16 v18; // di
  char *v19; // esi
  _BYTE *v20; // ebp
  unsigned __int8 *v22; // eax
  int v23; // ebx
  _BYTE *v24; // eax
  _BYTE *v25; // ebp
  unsigned __int8 *buff; // [esp+10h] [ebp-54h]
  unsigned __int8 *buffa; // [esp+10h] [ebp-54h]
  unsigned __int8 *v28; // [esp+14h] [ebp-50h]
  size_t rdlen; // [esp+24h] [ebp-40h]
  unsigned __int8 *datap; // [esp+2Ch] [ebp-38h]
  unsigned __int16 flags; // [esp+30h] [ebp-34h]
  __int16 v32; // [esp+32h] [ebp-32h]
  __int16 v33; // [esp+34h] [ebp-30h]
  unsigned __int8 v34; // [esp+36h] [ebp-2Eh]
  unsigned __int8 v35; // [esp+37h] [ebp-2Dh]
  unsigned __int8 *t_cp; // [esp+38h] [ebp-2Ch] BYREF
  int is_sign; // [esp+3Ch] [ebp-28h] BYREF
  int is_last[9]; // [esp+40h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  pseudoheader = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  buff = pseudoheader;
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( pseudoheader )
  {
    v28 = t_cp;
    LOBYTE(v32) = *t_cp;
    v34 = t_cp[1];
    LOBYTE(v33) = t_cp[2];
    v35 = t_cp[3];
    v11 = _byteswap_ushort(*((_WORD *)t_cp + 2));
    if ( set_do )
    {
      flags = v11 | 0x8000;
      t_cp[4] = (unsigned __int16)(v11 | 0x8000) >> 8;
      v28[5] = v11;
    }
    else
    {
      flags = v11;
    }
    v12 = v28[7] | (v28[6] << 8);
    v13 = v28 + 8;
    datap = v28 + 8;
    if ( plen < v12 + v28 + 8 - (unsigned __int8 *)header || !optno )
      return plen;
    if ( v12 <= 4 )
    {
      if ( is_last[0] )
      {
        v13 = v28 + 8;
LABEL_20:
        v19 = (char *)(v13 + 4);
        if ( limit - (v13 + 4) < (int)optlen )
          return plen;
        v20 = v28 + 6;
        goto LABEL_22;
      }
    }
    else
    {
      v14 = _byteswap_ushort(*((_WORD *)v28 + 4));
      v15 = _byteswap_ushort(*((_WORD *)v28 + 5));
      buffa = v28 + 12;
      v16 = v15;
      if ( v12 < v15 )
      {
LABEL_11:
        is_last[0] = 0;
        buff = 0;
LABEL_12:
        udp_sz = v34 | (unsigned __int16)(v32 << 8);
        v18 = v35 | (unsigned __int16)(v33 << 8);
        plen = rrfilter(header, plen, 0);
        goto LABEL_32;
      }
      v17 = 0;
      while ( 1 )
      {
        if ( v14 == optno )
        {
          if ( !replace )
            return plen;
          v12 -= v16 + 4;
          memcpy(v13, &v13[v15 + 4], v12 - v17);
          v28[6] = BYTE1(v12);
          v28[7] = v12;
        }
        else
        {
          v13 = &buffa[v15];
          v17 += v16 + 4;
        }
        if ( v17 + 4 >= v12 )
          break;
        v14 = _byteswap_ushort(*(_WORD *)v13);
        v15 = _byteswap_ushort(*((_WORD *)v13 + 1));
        buffa = v13 + 4;
        v16 = v15;
        if ( v15 + v17 > v12 )
          goto LABEL_11;
      }
      if ( is_last[0] )
        goto LABEL_20;
    }
    if ( v12 )
    {
      v22 = (unsigned __int8 *)whine_malloc(v12);
      buff = v22;
      rdlen = v12;
      if ( v22 )
      {
        memcpy(v22, datap, v12);
        rdlen = v12;
      }
    }
    else
    {
      rdlen = 0;
      buff = 0;
    }
    goto LABEL_12;
  }
  flags = (set_do != 0) << 15;
  v18 = 0;
LABEL_32:
  v23 = skip_questions(header, plen);
  if ( v23 )
  {
    v24 = (_BYTE *)skip_section(
                     v23,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->ancount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8),
                     header,
                     plen);
    v25 = v24;
    if ( v24 )
    {
      *v24 = 0;
      v24[1] = 0;
      v24[2] = 41;
      v24[3] = HIBYTE(udp_sz);
      v24[4] = udp_sz;
      v24[5] = HIBYTE(v18);
      v24[6] = v18;
      v24[7] = HIBYTE(flags);
      v24[8] = flags;
      v24[9] = BYTE1(rdlen);
      v24[10] = rdlen;
      LOWORD(datap) = (_WORD)v24 + 11;
      v13 = v24 + 11;
      if ( buff )
      {
        memcpy(v24 + 11, buff, rdlen);
        free(buff);
        v13 = &v25[rdlen + 11];
      }
      v19 = (char *)(v13 + 4);
      if ( limit - (v13 + 4) >= (int)optlen )
      {
        v20 = v25 + 9;
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_22:
        if ( optno && replace != 2 )
        {
          *v13 = BYTE1(optno);
          v13[1] = optno;
          v13[2] = BYTE1(optlen);
          v13[3] = optlen;
          memcpy(v19, opt, optlen);
          v13 = (unsigned __int8 *)&v19[optlen];
          *v20 = (unsigned __int16)(optlen + (_WORD)v19 - (_WORD)datap) >> 8;
          v20[1] = optlen + (_BYTE)v19 - (_BYTE)datap;
        }
        return v13 - (unsigned __int8 *)header;
      }
    }
  }
  return plen;
}
