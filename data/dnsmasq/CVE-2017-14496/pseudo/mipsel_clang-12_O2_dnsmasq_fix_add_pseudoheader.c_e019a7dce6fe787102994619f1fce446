int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s0
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $s3
  char v21; // $s2
  int v22; // $s5
  int v23; // $fp
  unsigned __int8 *v24; // $s7
  int v25; // $v0
  int v26; // $v1
  unsigned __int8 *v27; // $v0
  signed int v28; // $a2
  _BYTE *v29; // $s2
  void *v30; // $v0
  void *v31; // $s3
  int v32; // $v0
  _BYTE *v33; // $v0
  char *v34; // $a0
  _BYTE *v35; // $s3
  __int16 v36; // $s2
  unsigned __int8 *v37; // $a0
  unsigned __int8 v38; // [sp+1Ch] [-2Ch]
  unsigned __int8 v39; // [sp+20h] [-28h]
  unsigned __int8 v40; // [sp+24h] [-24h]
  unsigned int v41; // [sp+28h] [-20h]
  void *src; // [sp+2Ch] [-1Ch]
  int n; // [sp+30h] [-18h]
  unsigned __int8 *v44; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v47; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v47, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( !pseudoheader )
  {
    n = optlen;
    v21 = 0x80;
    if ( !set_do )
      v21 = 0;
    v41 = udp_sz >> 8;
    v22 = 0;
    v40 = 0;
    v39 = 0;
    v38 = 0;
    goto LABEL_29;
  }
  v20 = v47;
  v21 = v47[4];
  if ( set_do )
  {
    v21 |= 0x80u;
    v47[4] = v21;
  }
  if ( optno )
  {
    n = optlen;
    src = v20 + 8;
    v22 = (v20[6] << 8) | v20[7];
    if ( v15 >= v20 + 8 - (unsigned __int8 *)header + v22 )
    {
      LOBYTE(udp_sz) = v20[1];
      v44 = limit;
      LOBYTE(v41) = *v20;
      v40 = v20[5];
      v39 = v20[2];
      v38 = v20[3];
      if ( (unsigned int)v22 < 5 )
      {
        v24 = v20 + 8;
LABEL_20:
        if ( is_last )
        {
          v28 = optlen;
          v29 = v20 + 6;
          goto LABEL_38;
        }
        v17 = 0;
        if ( v22 )
        {
          v30 = (void *)whine_malloc(v22);
          if ( v30 )
          {
            v31 = v30;
            memcpy(v30, src, v22);
            limit = v44;
            v17 = v31;
          }
          else
          {
            limit = v44;
          }
        }
        else
        {
          limit = v44;
          v22 = 0;
        }
      }
      else
      {
        v23 = 0;
        v24 = v20 + 8;
        v25 = 4;
        while ( 1 )
        {
          v26 = (v24[2] << 8) | v24[3];
          if ( v22 < v26 + v25 )
            break;
          v27 = v24 + 4;
          if ( ((*v24 << 8) | v24[1]) == optno )
          {
            if ( !replace )
              return v15;
            v22 = v22 - v26 - 4;
            memcpy(v24, &v27[v26], v22 - v23);
            v20[7] = v22;
            v20[6] = BYTE1(v22);
          }
          else
          {
            v24 = &v27[v26];
            v23 += v26 + 4;
          }
          v25 = v23 + 4;
          if ( v23 + 4 >= v22 )
            goto LABEL_20;
        }
        is_last = 0;
        v22 = 0;
        limit = v44;
        v17 = 0;
      }
      v15 = rrfilter(header, v15, 0);
LABEL_29:
      v32 = skip_questions(header, v15);
      if ( !v32 )
        return v15;
      v33 = (_BYTE *)skip_section(
                       v32,
                       (_bswapw(header->nscount) >> 16)
                     + (_bswapw(header->ancount) >> 16)
                     + (_bswapw(header->arcount) >> 16),
                       header,
                       v15);
      if ( !v33 )
        return v15;
      v34 = v33 + 0xB;
      v35 = v33;
      if ( limit < v33 + 0xB )
        return v15;
      v44 = limit;
      v33[10] = v22;
      v33[8] = v40;
      v33[7] = v21;
      v33[6] = v38;
      v33[5] = v39;
      v33[4] = udp_sz;
      v33[3] = v41;
      v33[2] = 41;
      v33[1] = 0;
      *v33 = 0;
      v33[9] = BYTE1(v22);
      v24 = v33 + 0xB;
      if ( v17 )
      {
        v24 = (unsigned __int8 *)&v34[v22];
        if ( v44 < (unsigned __int8 *)&v34[v22] )
        {
          free(v17);
          return v15;
        }
        v36 = (_WORD)v33 + 0xB;
        memcpy(v34, v17, v22);
        free(v17);
        LOWORD(v34) = v36;
      }
      v29 = v35 + 9;
      v28 = n;
      LOWORD(src) = (_WORD)v34;
      if ( v44 - v24 - 4 >= n )
        header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
LABEL_38:
      v37 = v24 + 4;
      if ( v44 - (v24 + 4) < v28 )
        return v15;
      if ( optno && replace != 2 )
      {
        if ( v44 < v37 )
          return v15;
        v24[3] = v28;
        v24[1] = optno;
        v24[2] = BYTE1(v28);
        *v24 = BYTE1(optno);
        v24 = &v37[v28];
        if ( v44 < &v37[v28] )
          return v15;
        memcpy(v37, opt, v28);
        v29[1] = (_BYTE)v24 - (_BYTE)src;
        *v29 = (unsigned __int16)((_WORD)v24 - (_WORD)src) >> 8;
      }
      return v24 - (unsigned __int8 *)header;
    }
  }
  return v15;
}
