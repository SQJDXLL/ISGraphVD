int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s0
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $s3
  unsigned __int8 v21; // $a2
  char v22; // $s2
  unsigned __int8 v23; // $t0
  unsigned __int8 v24; // $a3
  unsigned __int8 v25; // $a1
  int v26; // $s5
  unsigned __int8 *v27; // $s7
  int v28; // $fp
  int v29; // $v0
  int v30; // $v1
  unsigned __int8 *v31; // $v0
  int v32; // $v0
  signed int v33; // $a2
  _BYTE *v34; // $s2
  void *v35; // $v0
  void *v36; // $s3
  int v37; // $v0
  int v38; // $v1
  int v39; // $a0
  _BYTE *v40; // $v0
  char *v41; // $v1
  _BYTE *v42; // $s3
  __int16 v43; // $s2
  unsigned __int8 *v44; // $a0
  unsigned __int8 v45; // [sp+1Ch] [-2Ch]
  unsigned __int8 v46; // [sp+20h] [-28h]
  unsigned __int8 v47; // [sp+24h] [-24h]
  unsigned int v48; // [sp+28h] [-20h]
  void *src; // [sp+2Ch] [-1Ch]
  int n; // [sp+30h] [-18h]
  unsigned __int8 *v51; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v54; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v54, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( pseudoheader )
  {
    v20 = v54;
    v21 = v54[5];
    v22 = v54[4];
    v23 = v54[3];
    v24 = v54[2];
    LOBYTE(udp_sz) = v54[1];
    v25 = *v54;
    if ( set_do )
    {
      v22 |= 0x80u;
      v54[4] = v22;
    }
    if ( optno )
    {
      n = optlen;
      src = v20 + 8;
      v26 = (v20[6] << 8) | v20[7];
      if ( v15 >= v20 + 8 - (unsigned __int8 *)header + v26 )
      {
        v51 = limit;
        LOBYTE(v48) = v25;
        v47 = v21;
        v46 = v24;
        v45 = v23;
        if ( (unsigned int)v26 < 5 )
        {
          v27 = v20 + 8;
LABEL_21:
          if ( is_last )
          {
            v33 = optlen;
            v34 = v20 + 6;
            goto LABEL_43;
          }
          v17 = 0;
          if ( v26 )
          {
            v35 = (void *)whine_malloc(v26);
            if ( v35 )
            {
              v36 = v35;
              memcpy(v35, src, v26);
              limit = v51;
              v17 = v36;
            }
            else
            {
              limit = v51;
            }
          }
          else
          {
            limit = v51;
            v26 = 0;
          }
        }
        else
        {
          if ( replace )
          {
            v27 = v20 + 8;
            v28 = 0;
            v29 = 4;
            while ( 1 )
            {
              v30 = (v27[2] << 8) | v27[3];
              if ( v26 < v30 + v29 )
                break;
              v31 = v27 + 4;
              if ( ((*v27 << 8) | v27[1]) == optno )
              {
                v26 = v26 - v30 - 4;
                memcpy(v27, &v31[v30], v26 - v28);
                v20[7] = v26;
                v20[6] = BYTE1(v26);
                v29 = v28 + 4;
                if ( v28 + 4 >= v26 )
                  goto LABEL_21;
              }
              else
              {
                v27 = &v31[v30];
                v28 += v30 + 4;
                v29 = v28 + 4;
                if ( v28 + 4 >= v26 )
                  goto LABEL_21;
              }
            }
          }
          else
          {
            v27 = v20 + 8;
            v37 = 0;
            v38 = 4;
            while ( 1 )
            {
              v39 = (v27[2] << 8) | v27[3];
              if ( v26 < v39 + v38 )
                break;
              if ( ((*v27 << 8) | v27[1]) == optno )
                return v15;
              v27 += v39 + 4;
              v38 = v37 + v39 + 8;
              v37 += v39 + 4;
              if ( v38 >= v26 )
                goto LABEL_21;
            }
          }
          limit = v51;
          is_last = 0;
          v26 = 0;
          v17 = 0;
        }
        v15 = rrfilter(header, v15, 0);
        v32 = skip_questions(header, v15);
        if ( !v32 )
          return v15;
LABEL_35:
        v40 = (_BYTE *)skip_section(
                         v32,
                         (_bswapw(header->nscount) >> 16)
                       + (_bswapw(header->ancount) >> 16)
                       + (_bswapw(header->arcount) >> 16),
                         header,
                         v15);
        if ( !v40 )
          return v15;
        v41 = v40 + 0xB;
        v42 = v40;
        if ( limit < v40 + 0xB )
          return v15;
        v40[10] = v26;
        v51 = limit;
        v27 = v40 + 0xB;
        v40[8] = v47;
        v40[7] = v22;
        v43 = (_WORD)v40 + 0xB;
        v40[6] = v45;
        v40[5] = v46;
        v40[4] = udp_sz;
        v40[3] = v48;
        v40[2] = 41;
        v40[1] = 0;
        *v40 = 0;
        v40[9] = BYTE1(v26);
        if ( v17 )
        {
          v27 = (unsigned __int8 *)&v41[v26];
          if ( v51 < (unsigned __int8 *)&v41[v26] )
          {
            free(v17);
            return v15;
          }
          memcpy(v41, v17, v26);
          free(v17);
        }
        v33 = n;
        LOWORD(src) = v43;
        v34 = v42 + 9;
        if ( v51 - v27 - 4 >= n )
          header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
LABEL_43:
        v44 = v27 + 4;
        if ( v51 - (v27 + 4) < v33 )
          return v15;
        if ( optno && replace != 2 )
        {
          if ( v51 < v44 )
            return v15;
          v27[3] = v33;
          v27[1] = optno;
          v27[2] = BYTE1(v33);
          *v27 = BYTE1(optno);
          v27 = &v44[v33];
          if ( v51 < &v44[v33] )
            return v15;
          memcpy(v44, opt, v33);
          v34[1] = (_BYTE)v27 - (_BYTE)src;
          *v34 = (unsigned __int16)((_WORD)v27 - (_WORD)src) >> 8;
        }
        return v27 - (unsigned __int8 *)header;
      }
    }
  }
  else
  {
    v22 = 0x80;
    n = optlen;
    v26 = 0;
    v48 = udp_sz >> 8;
    if ( !set_do )
      v22 = 0;
    v47 = 0;
    v46 = 0;
    v45 = 0;
    v32 = skip_questions(header, v15);
    if ( v32 )
      goto LABEL_35;
  }
  return v15;
}
