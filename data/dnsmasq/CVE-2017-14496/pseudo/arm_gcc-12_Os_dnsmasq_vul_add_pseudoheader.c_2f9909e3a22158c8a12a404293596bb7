size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  int v9; // r9
  unsigned int v11; // r8
  unsigned __int8 *pseudoheader; // r0
  int v13; // r4
  unsigned __int8 *v14; // r7
  unsigned __int8 *v15; // r7
  unsigned int v16; // r3
  int v17; // r6
  unsigned int v18; // r3
  char *v19; // r9
  unsigned int v20; // r3
  int v21; // r3
  char *v22; // r10
  unsigned int v23; // r1
  int v24; // r2
  unsigned int v25; // r0
  int v26; // r1
  int v27; // r0
  unsigned __int8 *v28; // r0
  unsigned __int8 *v29; // r3
  unsigned __int16 v30; // r2
  _BYTE *v31; // r7
  int v32; // r1
  int v33; // r1
  unsigned __int8 *v34; // r0
  bool v35; // zf
  int v36; // r9
  unsigned int limita; // [sp+Ch] [bp-4Ch]
  unsigned __int8 *limitb; // [sp+Ch] [bp-4Ch]
  unsigned int v40; // [sp+10h] [bp-48h]
  int v42; // [sp+1Ch] [bp-3Ch]
  unsigned __int8 *udp_len; // [sp+20h] [bp-38h] BYREF
  int is_sign; // [sp+24h] [bp-34h] BYREF
  int is_last; // [sp+28h] [bp-30h] BYREF

  LOWORD(v9) = udp_sz;
  v11 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v13 = is_sign;
  if ( is_sign )
    return v11;
  v14 = pseudoheader;
  if ( pseudoheader )
  {
    v15 = udp_len;
    v40 = *udp_len | (udp_len[1] << 8);
    limita = udp_len[2] | (udp_len[3] << 8);
    v16 = udp_len[4] | (udp_len[5] << 8);
    v17 = (unsigned __int16)((v16 >> 8) | ((_WORD)v16 << 8));
    if ( set_do )
    {
      v18 = ~((unsigned int)~(v17 << 17) >> 17) << 16;
      LOWORD(v17) = ~((unsigned int)~(v17 << 17) >> 17);
      udp_len[4] = HIBYTE(v18);
      v15[5] = v17;
    }
    v19 = (char *)(v15 + 8);
    v20 = v15[6] | (v15[7] << 8);
    v13 = (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8));
    v21 = optno == 0;
    if ( v15 + 8 - (unsigned __int8 *)header + v13 > v11 )
      v21 = 1;
    if ( !v21 )
    {
      v22 = (char *)(v15 + 8);
      while ( v21 + 4 < v13 )
      {
        v23 = (unsigned __int8)*v22 | ((unsigned __int8)v22[1] << 8);
        v24 = (v23 >> 8) | (v23 << 8);
        v25 = (unsigned __int8)v22[2] | ((unsigned __int8)v22[3] << 8);
        v26 = (unsigned __int16)((v25 >> 8) | ((_WORD)v25 << 8));
        if ( v26 + v21 > v13 )
        {
          is_last = 0;
          goto LABEL_12;
        }
        if ( (unsigned __int16)v24 == optno )
        {
          if ( !replace )
            return v11;
          v33 = v26 + 4;
          v13 -= v33;
          v42 = v21;
          memcpy(v22, &v22[v33], v13 - v21);
          v21 = v42;
          v15[6] = (unsigned int)(v13 << 16) >> 24;
          v15[7] = v13;
        }
        else
        {
          v32 = v26 + 4;
          v22 += v32;
          v21 += v32;
        }
      }
      if ( !is_last )
      {
        if ( v13 )
        {
          v34 = (unsigned __int8 *)whine_malloc(v13);
          v14 = v34;
          if ( v34 )
            memcpy(v34, v19, v13);
        }
        else
        {
LABEL_12:
          v13 = 0;
          v14 = 0;
        }
        v9 = (v40 >> 8) | (v40 << 8);
        v22 = (char *)(unsigned __int16)((limita >> 8) | ((_WORD)limita << 8));
        v11 = rrfilter(header, v11, 0);
        goto LABEL_14;
      }
      v31 = v15 + 6;
      goto LABEL_33;
    }
  }
  else
  {
    LOWORD(v17) = (set_do != 0) << 15;
    v22 = 0;
LABEL_14:
    v27 = skip_questions(header, v11);
    if ( v27 )
    {
      v28 = (unsigned __int8 *)skip_section(
                                 v27,
                                 (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                               + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                               + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                                 header,
                                 v11);
      v29 = v28;
      if ( v28 )
      {
        *v28 = 0;
        v28[1] = 0;
        v28[2] = 41;
        v28[3] = BYTE1(v9);
        v28[5] = BYTE1(v22);
        v28[7] = BYTE1(v17);
        v28[4] = v9;
        v19 = (char *)(v28 + 0xB);
        v28[6] = (unsigned __int8)v22;
        v28[8] = v17;
        if ( !v14 )
          v22 = (char *)(v28 + 0xB);
        v28[9] = (unsigned int)(v13 << 16) >> 24;
        v28[10] = v13;
        if ( v14 )
        {
          limitb = v28;
          memcpy(v28 + 0xB, v14, v13);
          free(v14);
          v29 = limitb;
          v22 = &v19[v13];
        }
        if ( limit - (unsigned __int8 *)(v22 + 4) >= (int)optlen )
        {
          v30 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
          header->arcount = HIBYTE(v30) | (v30 << 8);
        }
        v31 = v29 + 9;
LABEL_33:
        if ( limit - (unsigned __int8 *)(v22 + 4) >= (int)optlen )
        {
          v35 = optno == 0;
          if ( optno )
            v35 = replace == 2;
          if ( !v35 )
          {
            *v22 = (unsigned int)(optno << 16) >> 24;
            v22[1] = optno;
            v22[2] = optlen << 16 >> 24;
            v22[3] = optlen;
            v22 = (char *)memcpy(v22 + 4, opt, optlen) + optlen;
            v36 = v22 - v19;
            *v31 = (unsigned int)(v36 << 16) >> 24;
            v31[1] = v36;
          }
          return v22 - (char *)header;
        }
      }
    }
  }
  return v11;
}
