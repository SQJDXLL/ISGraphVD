size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // x24
  unsigned __int8 *pseudoheader; // x0
  __int64 v16; // x3
  unsigned __int8 *v17; // x4
  int v18; // w27
  unsigned __int8 *v19; // x21
  unsigned __int8 *v20; // x21
  unsigned __int16 v21; // w0
  int v22; // w20
  void *v23; // x28
  unsigned __int64 v24; // x0
  bool v25; // cc
  int v27; // w0
  unsigned int v28; // w1
  int v29; // w22
  unsigned __int64 v30; // x19
  __int16 v31; // w22
  unsigned __int8 *v32; // x0
  _BYTE *v33; // x21
  bool v34; // zf
  __int16 v35; // w28
  __int64 v36; // x0
  _BYTE *v37; // x0
  _BYTE *v38; // x20
  unsigned __int8 *v39; // x0
  __int16 t_s; // [xsp+7Ch] [xbp+7Ch]
  __int16 v43; // [xsp+80h] [xbp+80h]
  __int16 v44; // [xsp+84h] [xbp+84h]
  __int16 v45; // [xsp+88h] [xbp+88h]
  __int16 v46; // [xsp+8Ch] [xbp+8Ch]
  int is_sign; // [xsp+98h] [xbp+98h] BYREF
  int is_last; // [xsp+9Ch] [xbp+9Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+A0h] [xbp+A0h] BYREF

  v10 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v10;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    t_s = (set_do != 0) << 15;
    v31 = 0;
    goto LABEL_45;
  }
  v20 = udp_len;
  v43 = *udp_len;
  v44 = udp_len[1];
  v45 = udp_len[2];
  v46 = udp_len[3];
  v21 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  if ( set_do )
  {
    t_s = v21 | 0x8000;
    udp_len[4] = (unsigned __int16)(v21 | 0x8000) >> 8;
    v20[5] = v21;
  }
  else
  {
    t_s = v21;
  }
  v22 = v20[7] | (v20[6] << 8);
  v23 = v20 + 8;
  v24 = v20 + 8 - (unsigned __int8 *)header + _byteswap_ushort(*((_WORD *)v20 + 3));
  if ( optno )
    v25 = v24 > v10;
  else
    v25 = 1;
  if ( v25 )
    return v10;
  if ( v22 <= 4 )
  {
    v30 = (unsigned __int64)(v20 + 8);
    if ( is_last )
    {
LABEL_24:
      v32 = (unsigned __int8 *)(v30 + 4);
      if ( (__int64)&limit[-v30 - 4] < (__int64)optlen )
        return v10;
      v33 = v20 + 6;
      goto LABEL_26;
    }
    goto LABEL_55;
  }
  v27 = _byteswap_ushort(*((_WORD *)v20 + 4));
  v28 = _byteswap_ushort(*((_WORD *)v20 + 5));
  v17 = v20 + 0xC;
  v16 = v28;
  if ( v22 >= (int)(v28 + 4) )
  {
    v29 = 0;
    v30 = (unsigned __int64)(v20 + 8);
    while ( 1 )
    {
      if ( v27 == optno )
      {
        if ( !replace )
          return v10;
        v22 -= v16 + 4;
        memcpy((void *)v30, (const void *)(v30 + v28 + 4LL), v22 - v29);
        v20[6] = BYTE1(v22);
        v20[7] = v22;
      }
      else
      {
        v30 = (unsigned __int64)&v17[(unsigned __int16)v28];
        v16 = (unsigned int)(v16 + 4);
        v29 += v16;
      }
      if ( v29 + 4 >= v22 )
        break;
      v27 = _byteswap_ushort(*(_WORD *)v30);
      v28 = _byteswap_ushort(*(_WORD *)(v30 + 2));
      v17 = (unsigned __int8 *)(v30 + 4);
      v16 = v28;
      if ( (int)(v28 + v29 + 4) > v22 )
        goto LABEL_15;
    }
    if ( is_last )
      goto LABEL_24;
LABEL_55:
    if ( v22 )
    {
      v39 = (unsigned __int8 *)whine_malloc(v22);
      v19 = v39;
      v18 = v22;
      if ( v39 )
        memcpy(v39, v23, v22);
    }
    else
    {
      v18 = 0;
      v19 = 0LL;
    }
    goto LABEL_16;
  }
LABEL_15:
  is_last = 0;
  v19 = 0LL;
LABEL_16:
  udp_sz = v44 | (v43 << 8);
  v31 = v46 | (v45 << 8);
  v10 = rrfilter(header, v10, 0LL, v16, v17);
LABEL_45:
  v36 = skip_questions(header, v10);
  if ( v36 )
  {
    v37 = (_BYTE *)skip_section(
                     v36,
                     (unsigned __int16)__rev16(header->nscount)
                   + (unsigned __int16)__rev16(header->ancount)
                   + (unsigned int)(unsigned __int16)__rev16(header->arcount),
                     header,
                     v10);
    v38 = v37;
    if ( v37 )
    {
      v23 = v37 + 0xB;
      if ( v37 + 0xB <= limit )
      {
        *v37 = 0;
        v37[1] = 0;
        v37[2] = 41;
        v37[3] = HIBYTE(udp_sz);
        v37[4] = udp_sz;
        v37[5] = HIBYTE(v31);
        v37[6] = v31;
        v37[7] = HIBYTE(t_s);
        v37[8] = t_s;
        v37[9] = BYTE1(v18);
        v37[10] = v18;
        if ( v19 )
        {
          v30 = (unsigned __int64)v23 + v18;
          if ( v30 > (unsigned __int64)limit )
          {
            free(v19);
            return v10;
          }
          memcpy(v23, v19, v18);
          free(v19);
        }
        else
        {
          v30 = (unsigned __int64)(v37 + 0xB);
        }
        v32 = (unsigned __int8 *)(v30 + 4);
        if ( (__int64)&limit[-v30 - 4] < (__int64)optlen )
          return v10;
        v33 = v38 + 9;
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_26:
        if ( optno )
          v34 = replace == 2;
        else
          v34 = 1;
        if ( !v34 )
        {
          if ( limit < v32 )
            return v10;
          *(_BYTE *)v30 = BYTE1(optno);
          *(_BYTE *)(v30 + 1) = optno;
          *(_BYTE *)(v30 + 2) = BYTE1(optlen);
          *(_BYTE *)(v30 + 3) = optlen;
          v30 = (unsigned __int64)&v32[optlen];
          if ( &v32[optlen] > limit )
            return v10;
          memcpy(v32, opt, optlen);
          v35 = v30 - (_WORD)v23;
          *v33 = HIBYTE(v35);
          v33[1] = v35;
        }
        return v30 - (_QWORD)header;
      }
    }
  }
  return v10;
}
