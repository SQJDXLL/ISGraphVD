size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // ebp
  unsigned __int8 *v11; // ecx
  u16 v12; // ax
  unsigned __int8 *v13; // edi
  signed int v14; // esi
  unsigned __int8 *v15; // ebx
  unsigned __int16 v16; // dx
  int v17; // eax
  int v18; // ebp
  int v19; // eax
  int v20; // ebx
  unsigned __int8 *v21; // edi
  __int16 v22; // ax
  __int16 v23; // dx
  size_t v24; // edx
  __int16 v26; // di
  int v27; // eax
  int v28; // eax
  int v29; // ecx
  size_t v30; // esi
  int v31; // eax
  char *v32; // esi
  _WORD *v33; // ebp
  unsigned __int8 *v34; // eax
  int rdlen; // [esp+28h] [ebp-44h]
  int rdlena; // [esp+28h] [ebp-44h]
  unsigned __int8 *t_cp; // [esp+30h] [ebp-3Ch]
  unsigned __int8 *datap; // [esp+34h] [ebp-38h]
  __int16 v39; // [esp+38h] [ebp-34h]
  u16 t_s; // [esp+3Ch] [ebp-30h]
  __int16 v41; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 *udp_len; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  pseudoheader = find_pseudoheader(header, plen, 0, &udp_len, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !pseudoheader )
  {
    v26 = 0;
    t_s = (set_do != 0) << 15;
    goto LABEL_23;
  }
  v11 = udp_len;
  v39 = *(_WORD *)udp_len;
  v41 = *((_WORD *)udp_len + 1);
  v12 = __ROL2__(*((_WORD *)udp_len + 2), 8);
  t_s = v12;
  if ( set_do )
  {
    t_s = v12 | 0x8000;
    *((_WORD *)udp_len + 2) = __ROL2__(v12 | 0x8000, 8);
  }
  v13 = v11 + 8;
  datap = v11 + 8;
  v14 = (unsigned __int16)__ROL2__(*((_WORD *)v11 + 3), 8);
  if ( (unsigned int)(unsigned __int16)v14 + v11 + 8 - (unsigned __int8 *)header > plen || !optno )
    return plen;
  if ( (unsigned __int16)v14 <= 4u )
    goto LABEL_30;
  v15 = v11 + 12;
  v16 = __ROL2__(*((_WORD *)v11 + 4), 8);
  v17 = (unsigned __int16)__ROL2__(*((_WORD *)v11 + 5), 8);
  if ( (unsigned __int16)v17 <= (int)(unsigned __int16)v14 )
  {
    if ( !replace )
    {
      t_cp = v11;
      v20 = 0;
      v21 = v11 + 12;
      while ( v16 != optno )
      {
        v20 += v17 + 4;
        v13 = &v21[v17];
        if ( v20 + 4 >= (unsigned __int16)v14 )
          goto LABEL_29;
        v22 = *((_WORD *)v13 + 1);
        v23 = *(_WORD *)v13;
        v21 = v13 + 4;
        v16 = __ROL2__(v23, 8);
        v17 = (unsigned __int16)__ROL2__(v22, 8);
        if ( (unsigned __int16)v17 + v20 > (unsigned __int16)v14 )
          goto LABEL_37;
      }
      return plen;
    }
    t_cp = v11;
    v18 = 0;
    while ( 1 )
    {
      if ( v16 == optno )
      {
        v19 = v17 + 4;
        v14 -= v19;
        memcpy(v13, &v13[v19], v14 - v18);
        *((_WORD *)t_cp + 3) = __ROL2__(v14, 8);
      }
      else
      {
        v13 = &v15[v17];
        v18 += v17 + 4;
      }
      if ( v18 + 4 >= v14 )
        break;
      v15 = v13 + 4;
      v16 = __ROL2__(*(_WORD *)v13, 8);
      v17 = (unsigned __int16)__ROL2__(*((_WORD *)v13 + 1), 8);
      if ( (unsigned __int16)v17 + v18 > v14 )
        goto LABEL_37;
    }
LABEL_29:
    v11 = t_cp;
LABEL_30:
    if ( is_last[0] )
    {
      v32 = (char *)(v13 + 4);
      if ( limit - (v13 + 4) >= (int)optlen )
      {
        v33 = v11 + 6;
LABEL_33:
        if ( optno && replace != 2 )
        {
          *(_WORD *)v13 = __ROL2__(optno, 8);
          *((_WORD *)v13 + 1) = __ROL2__(optlen, 8);
          memcpy(v32, opt, optlen);
          v13 = (unsigned __int8 *)&v32[optlen];
          *v33 = __ROL2__(optlen + (_WORD)v32 - (_WORD)datap, 8);
        }
        return v13 - (unsigned __int8 *)header;
      }
      return plen;
    }
    if ( v14 )
    {
      v34 = (unsigned __int8 *)whine_malloc(v14);
      pseudoheader = v34;
      rdlen = v14;
      if ( v34 )
        memcpy(v34, datap, v14);
    }
    else
    {
      rdlen = 0;
      pseudoheader = 0;
    }
    goto LABEL_38;
  }
LABEL_37:
  is_last[0] = 0;
  pseudoheader = 0;
LABEL_38:
  udp_sz = __ROL2__(v39, 8);
  v26 = __ROL2__(v41, 8);
  plen = rrfilter(header, plen, 0);
LABEL_23:
  v27 = skip_questions(header, plen);
  v24 = plen;
  if ( v27 )
  {
    v28 = skip_section(
            v27,
            (unsigned __int16)__ROL2__(header->arcount, 8)
          + (unsigned __int16)__ROL2__(header->ancount, 8)
          + (unsigned __int16)__ROL2__(header->nscount, 8),
            header,
            plen);
    v24 = plen;
    v29 = v28;
    if ( v28 )
    {
      *(_BYTE *)(v28 + 2) = 41;
      *(_WORD *)v28 = 0;
      *(_WORD *)(v28 + 3) = __ROL2__(udp_sz, 8);
      v30 = rdlen;
      *(_WORD *)(v28 + 5) = __ROL2__(v26, 8);
      *(_WORD *)(v28 + 7) = __ROL2__(t_s, 8);
      *(_WORD *)(v28 + 9) = __ROL2__(rdlen, 8);
      v31 = v28 + 11;
      LOWORD(datap) = v29 + 11;
      v13 = (unsigned __int8 *)(v29 + 11);
      if ( pseudoheader )
      {
        rdlena = v29;
        v13 = (unsigned __int8 *)(v31 + v30);
        memcpy((void *)(v29 + 11), pseudoheader, v30);
        free(pseudoheader);
        v29 = rdlena;
      }
      v32 = (char *)(v13 + 4);
      v24 = plen;
      if ( limit - (v13 + 4) >= (int)optlen )
      {
        v33 = (_WORD *)(v29 + 9);
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
        goto LABEL_33;
      }
    }
  }
  return v24;
}
