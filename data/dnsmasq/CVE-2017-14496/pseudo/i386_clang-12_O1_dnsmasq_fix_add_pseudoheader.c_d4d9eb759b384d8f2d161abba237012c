int __usercall add_pseudoheader@<eax>(
        _WORD *a1@<ebx>,
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        signed int optlen,
        int set_do,
        int replace)
{
  size_t v10; // esi
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // dx
  unsigned __int8 *v14; // ebx
  __int16 v15; // dx
  unsigned __int32 v16; // ecx
  unsigned __int16 *v17; // ebp
  unsigned __int32 v18; // eax
  int v19; // esi
  int v20; // ecx
  unsigned __int16 *v21; // ebx
  signed int v22; // edx
  unsigned __int32 v23; // eax
  int v24; // edi
  char v26; // cl
  int v27; // eax
  __int16 v28; // si
  signed int v29; // edi
  unsigned __int8 *v30; // eax
  unsigned __int16 *v31; // esi
  unsigned __int8 *v32; // ebp
  size_t v33; // edx
  dns_header *v34; // edi
  int v35; // eax
  int v36; // edi
  int v37; // ebp
  __uint16_t v38; // ax
  int v39; // eax
  int v40; // ebx
  char *v41; // ebp
  int v42; // edx
  void *v43; // eax
  size_t v44; // edi
  void *v45; // esi
  __uint16_t v46; // ax
  __int16 v47; // [esp+2h] [ebp-3Ah]
  unsigned __int16 v48; // [esp+2h] [ebp-3Ah]
  unsigned __int8 *v49; // [esp+4h] [ebp-38h]
  int v50; // [esp+4h] [ebp-38h]
  __int16 v51; // [esp+8h] [ebp-34h]
  __int16 v52; // [esp+8h] [ebp-34h]
  size_t n; // [esp+Ch] [ebp-30h]
  void *ptr; // [esp+10h] [ebp-2Ch]
  __int16 v55; // [esp+14h] [ebp-28h]
  __int16 v56; // [esp+14h] [ebp-28h]
  size_t v57; // [esp+18h] [ebp-24h]
  void *src; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v61; // [esp+28h] [ebp-14h] BYREF

  v10 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0, &v61, &is_sign, &is_last);
  if ( is_sign )
    return v10;
  HIBYTE(v13) = 0;
  LOBYTE(a1) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    v15 = v13 << 15;
    v56 = 0;
    n = 0;
    ptr = 0;
    v17 = 0;
    goto LABEL_26;
  }
  v14 = v61;
  v15 = __ROL2__(*((_WORD *)v61 + 2), 8);
  if ( set_do )
  {
    v15 |= 0x8000u;
    v61[4] = HIBYTE(v15);
  }
  v47 = *(_WORD *)v14;
  v55 = *((_WORD *)v14 + 1);
  v16 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
  v17 = (unsigned __int16 *)(v14 + 8);
  ptr = 0;
  src = v14 + 8;
  v57 = plen;
  if ( !optno || v16 + (char *)v17 - (char *)header > plen )
  {
    n = v16;
    v26 = 0;
    v27 = plen;
    goto LABEL_24;
  }
  v18 = v16;
  v51 = v15;
  v49 = v14;
  if ( v16 < 5 )
  {
    v21 = (unsigned __int16 *)(v14 + 8);
    v22 = v16;
LABEL_21:
    n = v22;
    if ( is_last )
    {
      v17 = v21;
      v26 = 1;
      goto LABEL_23;
    }
    v17 = 0;
    v43 = 0;
    if ( v22 )
    {
      v44 = v22;
      v45 = (void *)whine_malloc(v22);
      v43 = 0;
      if ( v45 )
      {
        memcpy(v45, src, v44);
        v43 = v45;
      }
    }
    ptr = v43;
    v27 = rrfilter(header, plen, 0);
    v15 = v51;
    v14 = v49;
    v28 = v47;
    goto LABEL_25;
  }
  v19 = 0;
  v20 = 4;
  v21 = (unsigned __int16 *)(v14 + 8);
  v22 = v18;
  while ( 1 )
  {
    v23 = _byteswap_ulong(v21[1] << 16);
    v17 = v21 + 2;
    if ( (int)(v23 + v20) > v22 )
    {
      is_last = 0;
      v22 = 0;
      v21 += 2;
      goto LABEL_21;
    }
    if ( _byteswap_ulong(*v21 << 16) == optno )
      break;
    v19 += v23 + 4;
    v21 = (unsigned __int16 *)((char *)v17 + v23);
LABEL_12:
    v20 = v19 + 4;
    if ( v19 + 4 >= v22 )
      goto LABEL_21;
  }
  if ( replace )
  {
    v24 = v22 - v23 - 4;
    memcpy(v21, (char *)v17 + v23, v24 - v19);
    v22 = v24;
    *((_WORD *)v49 + 3) = __ROL2__(v24, 8);
    goto LABEL_12;
  }
  n = v22;
  v26 = 0;
  ptr = 0;
LABEL_23:
  v27 = plen;
  v15 = v51;
  v14 = v49;
LABEL_24:
  v28 = v47;
  if ( !v26 )
    return v57;
LABEL_25:
  udp_sz = __ROL2__(v28, 8);
  v56 = __ROL2__(v55, 8);
  a1 = v14 + 6;
  v10 = v27;
LABEL_26:
  v29 = optlen;
  v30 = limit;
  v57 = v10;
  if ( v17 )
  {
LABEL_27:
    v31 = v17;
    v32 = (unsigned __int8 *)(v17 + 2);
    if ( v30 - v32 < v29 )
      return v57;
    if ( optno && replace != 2 )
    {
      v33 = v29;
      v34 = header;
      if ( v32 <= v30 )
      {
        *(_BYTE *)v31 = BYTE1(optno);
        *((_BYTE *)v31 + 1) = optno;
        *((_BYTE *)v31 + 2) = BYTE1(v33);
        *((_BYTE *)v31 + 3) = v33;
        if ( &v32[v33] <= v30 )
        {
          v31 = (unsigned __int16 *)&v32[v33];
          memcpy(v32, opt, v33);
          *a1 = __ROL2__((_WORD)v31 - (_WORD)src, 8);
          return (char *)v31 - (char *)v34;
        }
      }
      return v57;
    }
    v34 = header;
    return (char *)v31 - (char *)v34;
  }
  v48 = udp_sz;
  v52 = v15;
  v35 = skip_questions(header, v10);
  if ( v35 )
  {
    v36 = v35;
    v50 = _bswap_16(header->ancount);
    v37 = v50 + _bswap_16(header->nscount);
    v38 = _bswap_16(header->arcount);
    v39 = skip_section(v36, v37 + v38, header, v10);
    if ( v39 )
    {
      v40 = v39;
      v41 = (char *)(v39 + 11);
      if ( v39 + 11 <= (unsigned int)limit )
      {
        *(_WORD *)v39 = 0;
        *(_BYTE *)(v39 + 2) = 41;
        *(_BYTE *)(v39 + 3) = HIBYTE(v48);
        *(_BYTE *)(v39 + 4) = v48;
        *(_BYTE *)(v39 + 5) = HIBYTE(v56);
        *(_BYTE *)(v39 + 6) = v56;
        *(_BYTE *)(v39 + 7) = HIBYTE(v52);
        *(_BYTE *)(v39 + 8) = v52;
        *(_BYTE *)(v39 + 9) = BYTE1(n);
        *(_BYTE *)(v39 + 10) = n;
        v42 = v39 + 11;
        if ( ptr )
        {
          if ( &v41[n] > (char *)limit )
          {
            free(ptr);
            return v57;
          }
          memcpy(v41, ptr, n);
          free(ptr);
          v42 = (int)&v41[n];
        }
        LOWORD(src) = (_WORD)v41;
        a1 = (_WORD *)(v40 + 9);
        v17 = (unsigned __int16 *)v42;
        v29 = optlen;
        if ( (int)&limit[-v42 - 4] >= optlen )
        {
          v46 = _bswap_16(header->arcount);
          header->arcount = _bswap_16(v46 + 1);
        }
        v30 = limit;
        goto LABEL_27;
      }
    }
  }
  return v57;
}
