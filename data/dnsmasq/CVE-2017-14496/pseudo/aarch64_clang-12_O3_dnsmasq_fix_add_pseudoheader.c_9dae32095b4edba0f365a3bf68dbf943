size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v15; // x19
  unsigned __int8 *pseudoheader; // x0
  char v19; // w28
  unsigned __int8 *v20; // x21
  _WORD *v21; // x26
  unsigned __int64 v22; // x22
  int v23; // w8
  unsigned __int64 v24; // x27
  int v25; // w23
  int v26; // w8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x8
  unsigned __int8 v29; // w26
  __int64 v30; // x0
  int v31; // w25
  __int64 v32; // x8
  void *v33; // x0
  int v34; // w9
  unsigned __int64 v35; // x10
  int v36; // w8
  __int64 v37; // x0
  unsigned __int8 *v38; // x0
  size_t n; // [xsp+0h] [xbp-50h]
  unsigned __int8 *src; // [xsp+8h] [xbp-48h]
  void *ptr; // [xsp+10h] [xbp-40h]
  unsigned __int8 v42; // [xsp+1Ch] [xbp-34h]
  unsigned __int8 *v43; // [xsp+20h] [xbp-30h]
  void *dest; // [xsp+28h] [xbp-28h]
  __int64 v45; // [xsp+30h] [xbp-20h]
  unsigned __int8 v46; // [xsp+38h] [xbp-18h]
  int is_last; // [xsp+40h] [xbp-10h] BYREF
  int is_sign; // [xsp+44h] [xbp-Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+48h] [xbp-8h] BYREF

  v15 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( set_do )
    v19 = 0x80;
  else
    v19 = 0;
  if ( !pseudoheader )
  {
    ptr = 0LL;
    LODWORD(v22) = 0;
    v29 = 0;
    v46 = 0;
    v45 = HIBYTE(udp_sz);
    v30 = skip_questions(header, v15);
    if ( !v30 )
      return v15;
    goto LABEL_36;
  }
  v43 = limit;
  v20 = udp_len;
  v19 = udp_len[4];
  if ( set_do )
  {
    v19 |= 0x80u;
    udp_len[4] = v19;
  }
  LOBYTE(udp_sz) = v20[1];
  v42 = v20[5];
  v21 = v20 + 6;
  if ( optno )
  {
    v46 = v20[2];
    v22 = bswap64((unsigned __int64)*((unsigned __int16 *)v20 + 3) << 48);
    LOBYTE(v45) = *v20;
    BYTE4(v45) = v20[3];
    dest = v20 + 8;
    if ( v20 + 8 - (unsigned __int8 *)header + v22 <= v15 )
    {
      n = optlen;
      src = opt;
      if ( (unsigned int)v22 < 5 )
      {
        v24 = (unsigned __int64)(v20 + 8);
LABEL_22:
        if ( is_last )
        {
          optlen = n;
          limit = v43;
          v31 = (int)dest;
          v32 = (int)n;
          goto LABEL_44;
        }
        optlen = n;
        limit = v43;
        if ( (_DWORD)v22 && (v33 = (void *)whine_malloc((int)v22)) != 0LL )
        {
          ptr = v33;
          memcpy(v33, dest, (int)v22);
        }
        else
        {
          ptr = 0LL;
        }
        opt = src;
      }
      else
      {
        v23 = replace;
        if ( replace )
        {
          v24 = (unsigned __int64)(v20 + 8);
          v25 = 0;
          v26 = 4;
          while ( 1 )
          {
            v27 = bswap64((unsigned __int64)*(unsigned __int16 *)(v24 + 2) << 48);
            if ( (int)v27 + v26 > (int)v22 )
              break;
            v28 = v24 + 4;
            if ( bswap32(*(unsigned __int16 *)v24 << 16) == optno )
            {
              LODWORD(v22) = v22 - v27 - 4;
              memcpy((void *)v24, (const void *)(v28 + v27), (int)v22 - v25);
              *((_WORD *)v20 + 3) = bswap32(v22) >> 16;
              v26 = v25 + 4;
              if ( v25 + 4 >= (int)v22 )
                goto LABEL_22;
            }
            else
            {
              v24 = v28 + (unsigned int)v27;
              v25 += v27 + 4;
              v26 = v25 + 4;
              if ( v25 + 4 >= (int)v22 )
                goto LABEL_22;
            }
          }
        }
        else
        {
          v24 = (unsigned __int64)(v20 + 8);
          v34 = 4;
          while ( 1 )
          {
            v35 = bswap64((unsigned __int64)*(unsigned __int16 *)(v24 + 2) << 48);
            if ( (int)v35 + v34 > (int)v22 )
              break;
            if ( bswap32(*(unsigned __int16 *)v24 << 16) == optno )
              return v15;
            v36 = v23 + v35;
            v24 += 4 + v35;
            v34 = v36 + 8;
            v23 = v36 + 4;
            if ( v34 >= (int)v22 )
              goto LABEL_22;
          }
        }
        optlen = n;
        opt = src;
        limit = v43;
        LODWORD(v22) = 0;
        ptr = 0LL;
        is_last = 0;
      }
      v29 = v42;
      v15 = rrfilter(header, v15, 0LL);
      v30 = skip_questions(header, v15);
      if ( !v30 )
        return v15;
LABEL_36:
      v37 = skip_section(
              v30,
              (bswap32(header->nscount) >> 0x10)
            + (bswap32(header->ancount) >> 0x10)
            + (bswap32(header->arcount) >> 0x10),
              header,
              v15);
      if ( !v37 || v37 + 0xB > (unsigned __int64)limit )
        return v15;
      *(_BYTE *)(v37 + 2) = 41;
      *(_BYTE *)(v37 + 3) = v45;
      *(_BYTE *)(v37 + 8) = v29;
      src = opt;
      *(_BYTE *)(v37 + 5) = v46;
      *(_WORD *)v37 = 0;
      *(_BYTE *)(v37 + 4) = udp_sz;
      *(_BYTE *)(v37 + 7) = v19;
      *(_BYTE *)(v37 + 6) = BYTE4(v45);
      *(_BYTE *)(v37 + 9) = BYTE1(v22);
      v21 = (_WORD *)(v37 + 9);
      v24 = v37 + 0xB;
      v31 = v37 + 0xB;
      *(_BYTE *)(v37 + 10) = v22;
      if ( ptr )
      {
        v24 = v37 + 0xB + (int)v22;
        if ( v24 > (unsigned __int64)limit )
        {
          free(ptr);
          return v15;
        }
        memcpy((void *)(v37 + 0xB), ptr, (int)v22);
        free(ptr);
      }
      v32 = (int)optlen;
      if ( (int)optlen <= (__int64)&limit[-v24 - 4] )
        header->arcount = bswap32((bswap32(header->arcount) >> 0x10) + 1) >> 16;
LABEL_44:
      v38 = (unsigned __int8 *)(v24 + 4);
      if ( v32 > (__int64)&limit[-v24 - 4] )
        return v15;
      if ( optno && replace != 2 )
      {
        if ( v38 > limit )
          return v15;
        *(_BYTE *)(v24 + 1) = optno;
        *(_BYTE *)(v24 + 3) = optlen;
        *(_BYTE *)v24 = BYTE1(optno);
        *(_BYTE *)(v24 + 2) = BYTE1(optlen);
        v24 = (unsigned __int64)&v38[optlen];
        if ( &v38[optlen] > limit )
          return v15;
        memcpy(v38, src, optlen);
        *v21 = bswap32(v24 - v31) >> 16;
      }
      return v24 - (_QWORD)header;
    }
  }
  return v15;
}
