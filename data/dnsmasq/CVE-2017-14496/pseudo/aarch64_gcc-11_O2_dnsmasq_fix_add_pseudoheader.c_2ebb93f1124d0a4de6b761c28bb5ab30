size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // x19
  unsigned int v14; // w25
  unsigned __int8 *pseudoheader; // x0
  int v17; // w24
  unsigned __int8 *v18; // x28
  unsigned __int16 *v19; // x5
  unsigned int v20; // w21
  unsigned __int16 *v21; // x25
  unsigned __int16 v22; // w0
  signed int v23; // w28
  unsigned __int64 v24; // x0
  bool v25; // cc
  unsigned __int16 *v26; // x2
  int v27; // w26
  int v28; // w3
  int v29; // w0
  size_t v30; // x3
  __int64 v32; // x0
  __int64 v33; // x0
  __int64 v34; // x26
  char *v35; // x7
  unsigned __int8 *v36; // x0
  _WORD *v37; // x28
  bool v38; // zf
  size_t v39; // x25
  unsigned __int8 *v40; // x0
  unsigned __int16 *rcode; // [xsp+60h] [xbp+60h]
  unsigned __int16 rcodea; // [xsp+60h] [xbp+60h]
  unsigned __int8 *p; // [xsp+70h] [xbp+70h]
  unsigned __int16 v45; // [xsp+78h] [xbp+78h]
  unsigned __int16 v46; // [xsp+7Ch] [xbp+7Ch]
  int is_sign; // [xsp+88h] [xbp+88h] BYREF
  int is_last; // [xsp+8Ch] [xbp+8Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF

  v10 = plen;
  v14 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v10;
  v18 = pseudoheader;
  if ( pseudoheader )
  {
    v19 = (unsigned __int16 *)udp_len;
    v46 = *(_WORD *)udp_len;
    v45 = *((_WORD *)udp_len + 1);
    v20 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
    if ( set_do )
    {
      v20 |= 0x8000u;
      *((_WORD *)udp_len + 2) = __rev16(v20);
    }
    v21 = v19 + 4;
    p = (unsigned __int8 *)(v19 + 4);
    v22 = __rev16(v19[3]);
    v23 = v22;
    v24 = (char *)(v19 + 4) - (char *)header + v22;
    if ( optno )
      v25 = v24 > v10;
    else
      v25 = 1;
    if ( !v25 )
    {
      if ( v23 > 4 )
      {
        v26 = v19 + 6;
        v27 = 0;
        v28 = (unsigned __int16)__rev16(v19[5]);
        v29 = (unsigned __int16)__rev16(v19[4]);
        if ( v23 >= v28 + 4 )
        {
          do
          {
            if ( v29 == optno )
            {
              rcode = v19;
              if ( !replace )
                return v10;
              v23 -= v28 + 4;
              memcpy(v21, (char *)v21 + (unsigned __int16)v28 + 4, v23 - v27);
              v19 = rcode;
              rcode[3] = __rev16(v23);
            }
            else
            {
              v21 = (unsigned __int16 *)((char *)v26 + (unsigned __int16)v28);
              v27 += v28 + 4;
            }
            if ( v27 + 4 >= v23 )
              goto LABEL_30;
            v26 = v21 + 2;
            v28 = (unsigned __int16)__rev16(v21[1]);
            v29 = (unsigned __int16)__rev16(*v21);
          }
          while ( v28 + v27 + 4 <= v23 );
        }
        v18 = 0LL;
        is_last = 0;
        goto LABEL_42;
      }
      v21 = v19 + 4;
LABEL_30:
      if ( !is_last )
      {
        if ( v23 )
        {
          v39 = v23;
          v17 = v23;
          v40 = (unsigned __int8 *)whine_malloc(v23);
          v18 = v40;
          if ( v40 )
            memcpy(v40, p, v39);
        }
        else
        {
          v17 = 0;
          v18 = 0LL;
        }
LABEL_42:
        v14 = (unsigned __int16)__rev16(v46);
        rcodea = __rev16(v45);
        v10 = rrfilter(header, v10, 0LL);
        goto LABEL_21;
      }
      v36 = (unsigned __int8 *)(v21 + 2);
      if ( limit - (unsigned __int8 *)(v21 + 2) >= (__int64)optlen )
      {
        v37 = v19 + 3;
        goto LABEL_33;
      }
    }
    return v10;
  }
  rcodea = 0;
  v20 = (set_do != 0) << 15;
LABEL_21:
  v32 = skip_questions(header, v10);
  v30 = v10;
  if ( !v32 )
    return v30;
  v33 = skip_section(
          v32,
          (unsigned __int16)__rev16(header->nscount)
        + (unsigned __int16)__rev16(header->ancount)
        + (unsigned int)(unsigned __int16)__rev16(header->arcount),
          header);
  v34 = v33;
  v30 = v10;
  if ( !v33 )
    return v30;
  v35 = (char *)(v33 + 0xB);
  if ( (unsigned __int64)limit < v33 + 0xB )
    return v30;
  *(_WORD *)v33 = 0;
  *(_BYTE *)(v33 + 2) = 41;
  *(_WORD *)(v33 + 3) = __rev16(v14);
  *(_WORD *)(v33 + 5) = __rev16(rcodea);
  *(_WORD *)(v33 + 7) = __rev16(v20);
  *(_WORD *)(v33 + 9) = __rev16(v17);
  LODWORD(p) = v33 + 0xB;
  if ( v18 )
  {
    v21 = (unsigned __int16 *)&v35[v17];
    if ( v21 > (unsigned __int16 *)limit )
    {
      free(v18);
      return v10;
    }
    memcpy(v35, v18, v17);
    free(v18);
  }
  else
  {
    v21 = (unsigned __int16 *)(v33 + 0xB);
  }
  v36 = (unsigned __int8 *)(v21 + 2);
  v30 = v10;
  if ( limit - (unsigned __int8 *)(v21 + 2) < (__int64)optlen )
    return v30;
  v37 = (_WORD *)(v34 + 9);
  header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_33:
  if ( optno )
    v38 = replace == 2;
  else
    v38 = 1;
  if ( v38 )
    return (char *)v21 - (char *)header;
  v30 = v10;
  if ( limit >= v36 )
  {
    *v21 = __rev16(optno);
    v21[1] = __rev16(optlen);
    v21 = (unsigned __int16 *)&v36[optlen];
    if ( &v36[optlen] <= limit )
    {
      memcpy(v36, opt, optlen);
      *v37 = __rev16((_DWORD)v21 - (_DWORD)p);
      return (char *)v21 - (char *)header;
    }
  }
  return v30;
}
