size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v11; // r12
  unsigned __int8 *pseudoheader; // rax
  int v13; // r8d
  unsigned __int8 *v14; // r14
  unsigned __int8 *v15; // rax
  __int16 v16; // bp
  __int16 v17; // dx
  const void *v18; // r15
  unsigned __int16 v19; // dx
  int v20; // r8d
  int v21; // edx
  unsigned __int64 v22; // rbx
  unsigned __int16 v23; // si
  unsigned __int16 v24; // di
  __int16 v25; // cx
  _WORD *v26; // rbp
  unsigned __int8 *v27; // rax
  __int64 v28; // rax
  __int16 v29; // bx
  u16 v30; // ax
  char v31; // t1
  unsigned __int8 *v32; // rax
  __int16 v33; // dx
  __int16 v34; // ax
  __int64 v35; // rdi
  unsigned __int16 v36; // dx
  unsigned __int16 v37; // ax
  __int64 v38; // rax
  unsigned __int8 *v39; // rdx
  __int16 v40; // bx
  char v41; // t2
  __int16 v42; // cx
  __int16 v46; // [rsp+14h] [rbp-74h]
  int v47; // [rsp+14h] [rbp-74h]
  unsigned __int64 v49; // [rsp+20h] [rbp-68h]
  int v50; // [rsp+20h] [rbp-68h]
  __int16 v51; // [rsp+2Ah] [rbp-5Eh]
  int rdlen; // [rsp+2Ch] [rbp-5Ch]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  v11 = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v13 = is_sign;
  if ( is_sign )
    return v11;
  v14 = pseudoheader;
  if ( pseudoheader )
  {
    v15 = udp_len[0];
    v51 = *(_WORD *)udp_len[0];
    v16 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
    v46 = *((_WORD *)udp_len[0] + 1);
    if ( set_do )
    {
      v16 |= 0x8000u;
      LOBYTE(v17) = HIBYTE(v16);
      HIBYTE(v17) = v16;
      *((_WORD *)udp_len[0] + 2) = v17;
    }
    v18 = v15 + 8;
    HIBYTE(v19) = *((_WORD *)v15 + 3);
    LOBYTE(v19) = HIBYTE(*((_WORD *)v15 + 3));
    v20 = v19;
    if ( v15 + 8 - (unsigned __int8 *)header + (unsigned __int64)v19 > plen || !optno )
      return v11;
    v21 = 0;
    v22 = (unsigned __int64)(v15 + 8);
    while ( v21 + 4 < v20 )
    {
      v23 = __ROL2__(*(_WORD *)(v22 + 2), 8);
      v24 = __ROL2__(*(_WORD *)v22, 8);
      if ( v23 + v21 + 4 > v20 )
      {
        is_last = 0;
        v20 = 0;
        v14 = 0LL;
        goto LABEL_20;
      }
      if ( v24 == optno )
      {
        if ( !replace )
          return v11;
        v20 -= v23 + 4;
        qmemcpy((void *)v22, (const void *)(v22 + v23 + 4), v20 - v21);
        LOBYTE(v25) = BYTE1(v20);
        HIBYTE(v25) = v20;
        *((_WORD *)v15 + 3) = v25;
      }
      else
      {
        v21 += v23 + 4;
        v22 += v23 + 4LL;
      }
    }
    if ( is_last )
    {
      v26 = v15 + 6;
      goto LABEL_24;
    }
    v14 = 0LL;
    if ( v20 )
    {
      rdlen = v20;
      v49 = v20;
      v27 = (unsigned __int8 *)whine_malloc(v20);
      v20 = rdlen;
      v14 = v27;
      if ( v27 )
        qmemcpy(v27, v18, v49);
    }
LABEL_20:
    v50 = v20;
    v28 = rrfilter(header, v11, 0LL);
    udp_sz = __ROL2__(v51, 8);
    v13 = v50;
    LOBYTE(v29) = HIBYTE(v46);
    HIBYTE(v29) = v46;
    v11 = v28;
  }
  else
  {
    v29 = 0;
    v16 = (set_do != 0) << 15;
  }
  v47 = v13;
  v35 = skip_questions(header, v11);
  if ( v35 )
  {
    HIBYTE(v36) = header->nscount;
    LOBYTE(v36) = HIBYTE(header->nscount);
    HIBYTE(v37) = header->arcount;
    LOBYTE(v37) = HIBYTE(header->arcount);
    v38 = skip_section(v35, v37 + v36 + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8), header, v11);
    if ( v38 )
    {
      v39 = (unsigned __int8 *)(v38 + 11);
      if ( (unsigned __int64)limit >= v38 + 11 )
      {
        v41 = HIBYTE(v29);
        HIBYTE(v40) = v29;
        LOBYTE(v40) = v41;
        *(_WORD *)(v38 + 3) = __ROL2__(udp_sz, 8);
        LOWORD(v18) = v38 + 11;
        *(_WORD *)(v38 + 7) = __ROL2__(v16, 8);
        v26 = (_WORD *)(v38 + 9);
        LOBYTE(v42) = BYTE1(v47);
        HIBYTE(v42) = v47;
        *(_WORD *)v38 = 0;
        *(_BYTE *)(v38 + 2) = 41;
        *(_WORD *)(v38 + 5) = v40;
        *(_WORD *)(v38 + 9) = v42;
        if ( v14 )
        {
          v22 = (unsigned __int64)&v39[v47];
          if ( v22 > (unsigned __int64)limit )
          {
            free(v14);
            return v11;
          }
          qmemcpy(v39, v14, v47);
          free(v14);
        }
        else
        {
          v22 = v38 + 11;
        }
        if ( (__int64)&limit[-v22 - 4] >= (__int64)optlen )
        {
          HIBYTE(v30) = header->arcount;
          LOBYTE(v30) = HIBYTE(header->arcount);
          ++v30;
          v31 = HIBYTE(v30);
          HIBYTE(v30) = v30;
          LOBYTE(v30) = v31;
          header->arcount = v30;
        }
LABEL_24:
        v32 = (unsigned __int8 *)(v22 + 4);
        if ( (__int64)&limit[-v22 - 4] >= (__int64)optlen )
        {
          if ( !optno || replace == 2 )
            return v22 - (_QWORD)header;
          if ( v32 <= limit )
          {
            LOBYTE(v33) = BYTE1(optlen);
            HIBYTE(v33) = optlen;
            *(_WORD *)v22 = __ROL2__(optno, 8);
            *(_WORD *)(v22 + 2) = v33;
            v22 = (unsigned __int64)&v32[optlen];
            if ( &v32[optlen] <= limit )
            {
              qmemcpy(v32, opt, optlen);
              HIBYTE(v34) = v22 - (_BYTE)v18;
              LOBYTE(v34) = (unsigned __int16)(v22 - (_WORD)v18) >> 8;
              *v26 = v34;
              return v22 - (_QWORD)header;
            }
          }
        }
      }
    }
  }
  return v11;
}
