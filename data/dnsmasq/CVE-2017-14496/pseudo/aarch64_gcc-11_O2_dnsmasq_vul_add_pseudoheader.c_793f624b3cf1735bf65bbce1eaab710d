size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v10; // x19
  unsigned int v15; // w25
  unsigned __int8 *pseudoheader; // x0
  int v17; // w27
  unsigned __int8 *v18; // x5
  unsigned __int16 *v19; // x5
  unsigned int v20; // w22
  unsigned __int16 *v21; // x25
  unsigned __int16 v22; // w0
  signed int v23; // w28
  unsigned __int64 v24; // x0
  unsigned __int16 *v26; // x2
  int v27; // w26
  signed int v28; // w3
  int v29; // w0
  size_t v30; // x6
  unsigned int v32; // w26
  int v33; // w22
  __int64 v34; // x0
  __int64 v35; // x0
  __int64 v36; // x28
  void *v37; // x0
  _WORD *v38; // x28
  unsigned __int8 *v39; // x0
  unsigned __int8 *v40; // x5
  bool v41; // zf
  size_t v42; // x25
  unsigned __int16 *ptr; // [xsp+68h] [xbp+68h]
  unsigned __int8 *ptra; // [xsp+68h] [xbp+68h]
  unsigned __int8 *ptrb; // [xsp+68h] [xbp+68h]
  unsigned __int8 *buff; // [xsp+78h] [xbp+78h]
  unsigned __int8 *buffa; // [xsp+78h] [xbp+78h]
  unsigned __int16 src; // [xsp+80h] [xbp+80h]
  unsigned __int8 *srca; // [xsp+80h] [xbp+80h]
  unsigned __int16 v51; // [xsp+8Ch] [xbp+8Ch]
  int is_sign; // [xsp+98h] [xbp+98h] BYREF
  int is_last; // [xsp+9Ch] [xbp+9Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+A0h] [xbp+A0h] BYREF

  v10 = plen;
  v15 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v10;
  v18 = pseudoheader;
  if ( !pseudoheader )
  {
    v41 = set_do == 0;
    v32 = 0;
    v33 = !v41;
    v20 = v33 << 15;
    goto LABEL_24;
  }
  v19 = (unsigned __int16 *)udp_len;
  src = *(_WORD *)udp_len;
  v51 = *((_WORD *)udp_len + 1);
  v20 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
  if ( set_do )
  {
    v20 |= 0x8000u;
    *((_WORD *)udp_len + 2) = __rev16(v20);
  }
  v21 = v19 + 4;
  buff = (unsigned __int8 *)(v19 + 4);
  v22 = __rev16(v19[3]);
  v23 = v22;
  v24 = (char *)(v19 + 4) - (char *)header + v22;
  if ( !optno || v24 > v10 )
    return v10;
  if ( v23 > 4 )
  {
    v26 = v19 + 6;
    v27 = 0;
    v28 = (unsigned __int16)__rev16(v19[5]);
    v29 = (unsigned __int16)__rev16(v19[4]);
    if ( v28 <= v23 )
    {
      do
      {
        if ( v29 == optno )
        {
          ptr = v19;
          if ( !replace )
            return v10;
          v23 -= v28 + 4;
          memcpy(v21, (char *)v21 + (unsigned __int16)v28 + 4, v23 - v27);
          v19 = ptr;
          ptr[3] = __rev16(v23);
        }
        else
        {
          v21 = (unsigned __int16 *)((char *)v26 + (unsigned __int16)v28);
          v27 += v28 + 4;
        }
        if ( v27 + 4 >= v23 )
          goto LABEL_31;
        v26 = v21 + 2;
        v28 = (unsigned __int16)__rev16(v21[1]);
        v29 = (unsigned __int16)__rev16(*v21);
      }
      while ( v28 + v27 <= v23 );
    }
    v40 = 0LL;
    is_last = 0;
    goto LABEL_44;
  }
  v21 = v19 + 4;
LABEL_31:
  if ( is_last )
  {
    v37 = v21 + 2;
    if ( limit - (unsigned __int8 *)(v21 + 2) >= (__int64)optlen )
    {
      v38 = v19 + 3;
      goto LABEL_37;
    }
    return v10;
  }
  if ( v23 )
  {
    v17 = v23;
    v39 = (unsigned __int8 *)whine_malloc(v23);
    v40 = v39;
    if ( v39 )
    {
      ptra = v39;
      memcpy(v39, buff, v23);
      v40 = ptra;
    }
  }
  else
  {
    v17 = 0;
    v40 = 0LL;
  }
LABEL_44:
  ptrb = v40;
  v15 = (unsigned __int16)__rev16(src);
  v32 = (unsigned __int16)__rev16(v51);
  v10 = rrfilter(header, v10, 0LL);
  v18 = ptrb;
LABEL_24:
  buffa = v18;
  v34 = skip_questions(header, v10);
  v30 = v10;
  if ( v34 )
  {
    srca = buffa;
    v35 = skip_section(
            v34,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v10);
    v36 = v35;
    v30 = v10;
    if ( v35 )
    {
      *(_WORD *)v35 = 0;
      *(_BYTE *)(v35 + 2) = 41;
      *(_WORD *)(v35 + 3) = __rev16(v15);
      v21 = (unsigned __int16 *)(v35 + 0xB);
      *(_WORD *)(v35 + 5) = __rev16(v32);
      *(_WORD *)(v35 + 7) = __rev16(v20);
      *(_WORD *)(v35 + 9) = __rev16(v17);
      LODWORD(buff) = v35 + 0xB;
      if ( srca )
      {
        v21 = (unsigned __int16 *)(v35 + 0xB + v17);
        memcpy((void *)(v35 + 0xB), srca, v17);
        free(srca);
      }
      v37 = v21 + 2;
      v30 = v10;
      if ( limit - (unsigned __int8 *)(v21 + 2) >= (__int64)optlen )
      {
        v38 = (_WORD *)(v36 + 9);
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
LABEL_37:
        if ( optno )
          v41 = replace == 2;
        else
          v41 = 1;
        if ( v41 )
        {
          return (char *)v21 - (char *)header;
        }
        else
        {
          *v21 = __rev16(optno);
          v21[1] = __rev16(optlen);
          v42 = (size_t)v37 + optlen;
          memcpy(v37, opt, optlen);
          v30 = v42 - (_QWORD)header;
          *v38 = __rev16(v42 - (_DWORD)buff);
        }
      }
    }
  }
  return v30;
}
