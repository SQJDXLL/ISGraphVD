size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v9; // r9
  unsigned int v11; // r4
  unsigned __int8 *pseudoheader; // r0
  int v13; // r10
  unsigned __int8 *v14; // r7
  unsigned __int8 *v15; // r11
  unsigned int v16; // r3
  unsigned int v17; // r5
  unsigned int v18; // r3
  unsigned __int8 *v19; // r9
  unsigned int v20; // r2
  signed int v21; // r3
  int v22; // r7
  unsigned int v23; // r1
  unsigned int v24; // r12
  signed int v25; // r2
  int v26; // r1
  unsigned __int8 *v27; // r12
  unsigned __int8 *v28; // r4
  int v29; // r11
  unsigned int v30; // r1
  unsigned int v31; // r0
  int v32; // r2
  int v33; // r7
  int v34; // r0
  unsigned int v35; // r1
  unsigned int v36; // r0
  int v38; // r5
  unsigned int v39; // r11
  int v40; // r0
  _BYTE *v41; // r0
  _BYTE *v42; // r3
  _BYTE *v43; // r1
  unsigned int v44; // r11
  unsigned int v45; // r5
  void *v46; // r0
  char *v47; // r5
  _BYTE *v48; // r11
  unsigned __int16 v49; // r3
  bool v50; // zf
  int v51; // r2
  unsigned __int8 *v52; // r0
  int v53; // r3
  void *v55; // [sp+10h] [bp-48h]
  unsigned int rdlen; // [sp+14h] [bp-44h]
  int rdlena; // [sp+14h] [bp-44h]
  unsigned int t_cp; // [sp+18h] [bp-40h]
  size_t n; // [sp+1Ch] [bp-3Ch]
  size_t na; // [sp+1Ch] [bp-3Ch]
  unsigned __int8 *udp_len; // [sp+20h] [bp-38h] BYREF
  int is_sign; // [sp+24h] [bp-34h] BYREF
  int is_last; // [sp+28h] [bp-30h] BYREF

  v9 = udp_sz;
  v11 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v13 = is_sign;
  if ( is_sign )
    return v11;
  v14 = pseudoheader;
  if ( pseudoheader )
  {
    v15 = udp_len;
    v16 = udp_len[4] | (udp_len[5] << 8);
    rdlen = *udp_len | (udp_len[1] << 8);
    v17 = (unsigned __int16)((v16 >> 8) | ((_WORD)v16 << 8));
    t_cp = udp_len[2] | (udp_len[3] << 8);
    if ( set_do )
    {
      v18 = ~(~(v17 << 17) >> 17) << 16;
      v17 = (unsigned __int16)~(~(v17 << 17) >> 17);
      udp_len[4] = HIBYTE(v18);
      v15[5] = v17;
    }
    v19 = v15 + 8;
    v20 = v15[6] | (v15[7] << 8);
    v21 = (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8));
    v22 = optno == 0;
    if ( v15 + 8 - (unsigned __int8 *)header + v21 > v11 )
      v22 = 1;
    v55 = v15 + 8;
    if ( v22 )
      return v11;
    if ( (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8)) > 4u )
    {
      v23 = v15[10] | (v15[11] << 8);
      v24 = v15[8] | (v15[9] << 8);
      v25 = (unsigned __int16)((v23 >> 8) | ((_WORD)v23 << 8));
      v26 = (unsigned __int16)((v24 >> 8) | ((_WORD)v24 << 8));
      v27 = v15 + 0xC;
      if ( v21 >= v25 )
      {
        if ( !replace )
        {
          v33 = 0;
          while ( v26 != optno )
          {
            v33 += v25 + 4;
            v19 = &v27[v25];
            if ( v33 + 4 >= v21 )
            {
              if ( !is_last )
                goto LABEL_48;
              goto LABEL_36;
            }
            v34 = v27[v25];
            v27 = v19 + 4;
            v35 = v19[2] | (v19[3] << 8);
            v36 = v34 | (v19[1] << 8);
            v25 = (unsigned __int16)((v35 >> 8) | ((_WORD)v35 << 8));
            v26 = (unsigned __int16)((v36 >> 8) | ((_WORD)v36 << 8));
            if ( v25 + v33 > v21 )
              goto LABEL_44;
          }
          return v11;
        }
        n = v11;
        v28 = v15;
        v29 = v21;
        do
        {
          if ( v26 == optno )
          {
            v32 = v25 + 4;
            v29 -= v32;
            memcpy(v19, &v19[v32], v29 - v22);
            v28[7] = v29;
            v28[6] = (unsigned int)(v29 << 16) >> 24;
          }
          else
          {
            v19 = &v27[v25];
            v22 += v25 + 4;
          }
          if ( v29 <= v22 + 4 )
          {
            v21 = v29;
            v15 = v28;
            v11 = n;
            goto LABEL_35;
          }
          v30 = v19[2] | (v19[3] << 8);
          v27 = v19 + 4;
          v31 = *v19 | (v19[1] << 8);
          v25 = (unsigned __int16)((v30 >> 8) | ((_WORD)v30 << 8));
          v26 = (unsigned __int16)((v31 >> 8) | ((_WORD)v31 << 8));
        }
        while ( v25 + v22 <= v29 );
        v11 = n;
      }
LABEL_44:
      is_last = 0;
      goto LABEL_45;
    }
LABEL_35:
    if ( !is_last )
    {
      if ( v21 )
      {
LABEL_48:
        na = v21;
        v52 = (unsigned __int8 *)whine_malloc(v21);
        v53 = na;
        v14 = v52;
        if ( v52 )
        {
          memcpy(v52, v55, na);
          v53 = na;
        }
        v13 = v53;
        goto LABEL_46;
      }
LABEL_45:
      v14 = 0;
LABEL_46:
      v9 = (unsigned __int16)((rdlen >> 8) | ((_WORD)rdlen << 8));
      v39 = (unsigned __int16)((t_cp >> 8) | ((_WORD)t_cp << 8));
      v11 = rrfilter(header, v11, 0);
      goto LABEL_26;
    }
LABEL_36:
    v47 = (char *)(v19 + 4);
    if ( limit - (v19 + 4) >= (int)optlen )
    {
      v48 = v15 + 6;
      goto LABEL_38;
    }
    return v11;
  }
  v38 = set_do;
  if ( set_do )
    v38 = 1;
  v17 = v38 << 15;
  v39 = 0;
LABEL_26:
  v40 = skip_questions(header, v11);
  if ( !v40 )
    return v11;
  v41 = (_BYTE *)skip_section(
                   v40,
                   (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                 + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                 + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                   header,
                   v11);
  v42 = v41;
  if ( !v41 )
    return v11;
  v41[9] = (unsigned int)(v13 << 16) >> 24;
  v43 = v41 + 0xB;
  v41[4] = v9;
  v41[6] = v39;
  v19 = (unsigned __int8 *)(v9 >> 8);
  v44 = v39 >> 8;
  v41[8] = v17;
  *v41 = 0;
  v45 = v17 >> 8;
  v41[1] = 0;
  v41[3] = (_BYTE)v19;
  v46 = v41 + 0xB;
  if ( !v14 )
    v19 = v42 + 0xB;
  v42[5] = v44;
  v42[7] = v45;
  v42[10] = v13;
  v42[2] = 41;
  v55 = v42 + 0xB;
  if ( v14 )
  {
    v19 = &v43[v13];
    rdlena = (int)v42;
    memcpy(v46, v14, v13);
    free(v14);
    v42 = (_BYTE *)rdlena;
  }
  v47 = (char *)(v19 + 4);
  if ( limit - (v19 + 4) < (int)optlen )
    return v11;
  v48 = v42 + 9;
  v49 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
  header->arcount = HIBYTE(v49) | (v49 << 8);
LABEL_38:
  v50 = optno == 0;
  if ( optno )
    v50 = replace == 2;
  if ( !v50 )
  {
    v19[1] = optno;
    v19[3] = optlen;
    v19[2] = optlen << 16 >> 24;
    *v19 = (unsigned int)(optno << 16) >> 24;
    memcpy(v47, opt, optlen);
    v19 = (unsigned __int8 *)&v47[optlen];
    v51 = &v47[optlen] - (_BYTE *)v55;
    *v48 = (unsigned int)(v51 << 16) >> 24;
    v48[1] = v51;
  }
  return v19 - (unsigned __int8 *)header;
}
