int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v16; // $s0
  int v17; // $s4
  unsigned __int8 *v18; // $fp
  unsigned __int8 *v19; // $fp
  unsigned __int16 v20; // $s6
  unsigned __int8 *v21; // $s7
  int v22; // $t0
  int v23; // $v0
  int v24; // $a1
  int v25; // $v1
  int v26; // $v0
  unsigned __int8 *v27; // $a0
  int v28; // $t3
  int v29; // $a2
  int result; // $v0
  int v31; // $a0
  int v32; // $v0
  char *v33; // $a3
  _WORD *v34; // $s1
  unsigned __int8 *v35; // $a0
  unsigned __int8 *v36; // $v0
  unsigned __int8 *v37; // $s7
  int rdlena; // [sp+20h] [-28h]
  int rdlen; // [sp+20h] [-28h]
  int i; // [sp+24h] [-24h]
  u16 t_s; // [sp+32h] [-16h]
  unsigned __int8 *p; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v16 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v16;
  v18 = pseudoheader;
  if ( pseudoheader )
  {
    v19 = udp_len;
    v20 = _byteswap_ushort(*((_WORD *)udp_len + 2));
    udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
    t_s = _byteswap_ushort(*((_WORD *)udp_len + 1));
    if ( set_do )
    {
      v20 |= 0x8000u;
      udp_len[4] = HIBYTE(v20);
      v19[5] = v20;
    }
    v21 = v19 + 8;
    v22 = v19[7] | (v19[6] << 8);
    p = v19 + 8;
    if ( v16 < v19 + 8 - (unsigned __int8 *)header + v22 || !optno )
      return v16;
    v23 = is_last;
    if ( v22 >= 5 )
    {
      v24 = v19[11] | (v19[10] << 8);
      v25 = v24 + 4;
      v26 = v19[9] | (v19[8] << 8);
      v27 = v19 + 0xC;
      if ( v22 < v24 + 4 )
      {
LABEL_39:
        is_last = 0;
        v18 = 0;
LABEL_40:
        v16 = rrfilter(header, v16, 0);
        goto LABEL_24;
      }
      v28 = 0;
      if ( !replace )
      {
        v29 = 0;
        while ( v26 != optno )
        {
          v29 += v24 + 4;
          v21 = &v27[v24];
          if ( v29 + 4 >= v22 )
          {
            v23 = is_last;
            goto LABEL_34;
          }
          v24 = v21[3] | (v21[2] << 8);
          v26 = v21[1] | (*v21 << 8);
          v27 = v21 + 4;
          if ( v22 < v24 + v29 + 4 )
            goto LABEL_39;
        }
        return v16;
      }
      while ( 1 )
      {
        if ( v26 == optno )
        {
          i = v28;
          rdlena = v22 - v25;
          memcpy(v21, &v21[v24 + 4], v22 - v25 - v28);
          v22 = rdlena;
          v28 = i;
          *((_WORD *)v19 + 3) = rdlena;
        }
        else
        {
          v21 = &v27[v24];
          v28 += v25;
        }
        v23 = is_last;
        if ( v28 + 4 >= v22 )
          break;
        v24 = v21[3] | (v21[2] << 8);
        v26 = v21[1] | (*v21 << 8);
        v27 = v21 + 4;
        if ( v22 < v24 + v28 + 4 )
          goto LABEL_39;
        v25 = v24 + 4;
      }
    }
LABEL_34:
    if ( v23 )
    {
      v35 = v21 + 4;
      result = v16;
      if ( limit - (v21 + 4) < (int)optlen )
        return result;
      v34 = v19 + 6;
      goto LABEL_43;
    }
    if ( v22 )
    {
      rdlen = v22;
      v36 = (unsigned __int8 *)whine_malloc(v22);
      v18 = v36;
      if ( v36 )
        memcpy(v36, p, rdlen);
      v17 = rdlen;
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
    goto LABEL_40;
  }
  t_s = 0;
  v20 = (set_do != 0) << 15;
LABEL_24:
  v31 = skip_questions(header, v16);
  if ( !v31 )
    return v16;
  v32 = skip_section(v31, header->ancount + header->nscount + header->arcount, header, v16);
  if ( !v32 )
    return v16;
  v33 = (char *)(v32 + 0xB);
  if ( (unsigned int)limit < v32 + 0xB )
    return v16;
  *(_BYTE *)(v32 + 4) = udp_sz;
  *(_BYTE *)v32 = 0;
  *(_WORD *)(v32 + 1) = 41;
  *(_BYTE *)(v32 + 3) = HIBYTE(udp_sz);
  *(_WORD *)(v32 + 5) = t_s;
  *(_WORD *)(v32 + 7) = v20;
  v34 = (_WORD *)(v32 + 9);
  *(_WORD *)(v32 + 9) = v17;
  LOWORD(p) = v32 + 0xB;
  if ( v18 )
  {
    v21 = (unsigned __int8 *)&v33[v17];
    if ( limit < (unsigned __int8 *)&v33[v17] )
    {
      free(v18);
      return v16;
    }
    memcpy(v33, v18, v17);
    free(v18);
  }
  else
  {
    v21 = (unsigned __int8 *)(v32 + 0xB);
  }
  v35 = v21 + 4;
  result = v16;
  if ( limit - (v21 + 4) < (int)optlen )
    return result;
  ++header->arcount;
  if ( !optno )
    return v21 - (unsigned __int8 *)header;
LABEL_43:
  result = v21 - (unsigned __int8 *)header;
  if ( replace != 2 )
  {
    if ( limit >= v35 )
    {
      v21[2] = BYTE2(optlen);
      *(_WORD *)v21 = optno;
      v21[3] = optlen;
      v37 = &v35[optlen];
      if ( limit >= &v35[optlen] )
      {
        memcpy(v35, opt, optlen);
        *v34 = (_WORD)v37 - (_WORD)p;
        return v37 - (unsigned __int8 *)header;
      }
    }
    return v16;
  }
  return result;
}
