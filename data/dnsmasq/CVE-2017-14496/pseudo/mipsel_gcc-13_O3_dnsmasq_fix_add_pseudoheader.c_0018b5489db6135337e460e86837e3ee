size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s7
  unsigned __int8 *v19; // $fp
  unsigned __int8 *v20; // $fp
  unsigned int v21; // $v0
  __int16 v22; // $s4
  unsigned int v23; // $v0
  unsigned __int8 *v24; // $s6
  int v25; // $t0
  int v26; // $v0
  unsigned int v27; // $v1
  unsigned int v28; // $v0
  int v29; // $a1
  unsigned int v30; // $a0
  int v31; // $v0
  int v32; // $v1
  unsigned __int8 *v33; // $a0
  int v34; // $t3
  unsigned int v35; // $a0
  unsigned int v36; // $v1
  int v37; // $a2
  unsigned int v38; // $v1
  unsigned int v39; // $v0
  size_t result; // $v0
  int v41; // $a0
  _BYTE *v42; // $v0
  _BYTE *v43; // $t0
  char *v44; // $a3
  unsigned __int8 *v45; // $a0
  _BYTE *v46; // $s4
  unsigned __int8 *v47; // $v0
  int v48; // $t0
  int t_sb; // [sp+20h] [-28h]
  __int16 t_s; // [sp+20h] [-28h]
  _BYTE *t_sc; // [sp+20h] [-28h]
  size_t t_sa; // [sp+20h] [-28h]
  int i; // [sp+24h] [-24h]
  unsigned __int8 *p; // [sp+2Ch] [-1Ch]
  unsigned int v55; // [sp+30h] [-18h]
  unsigned int v56; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    t_s = 0;
    v22 = (set_do != 0) << 15;
LABEL_24:
    v41 = skip_questions(header, v17);
    if ( v41 )
    {
      v42 = (_BYTE *)skip_section(
                       v41,
                       (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                     + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                     + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                       header,
                       v17);
      v43 = v42;
      if ( v42 )
      {
        v44 = v42 + 0xB;
        LOWORD(p) = (_WORD)v42 + 0xB;
        if ( limit >= v42 + 0xB )
        {
          *v42 = 0;
          v42[1] = 0;
          v42[2] = 41;
          v42[3] = HIBYTE(udp_sz);
          v42[4] = udp_sz;
          v42[5] = HIBYTE(t_s);
          v42[6] = t_s;
          v42[7] = HIBYTE(v22);
          v42[8] = v22;
          v42[9] = BYTE1(v18);
          v42[10] = v18;
          if ( !v19 )
          {
            v24 = v42 + 0xB;
            goto LABEL_30;
          }
          v24 = (unsigned __int8 *)&v44[v18];
          if ( limit >= (unsigned __int8 *)&v44[v18] )
          {
            t_sc = v42;
            memcpy(v44, v19, v18);
            free(v19);
            v43 = t_sc;
LABEL_30:
            v45 = v24 + 4;
            result = v17;
            if ( limit - (v24 + 4) < (int)optlen )
              return result;
            header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
            if ( !optno )
              return v24 - (unsigned __int8 *)header;
            v46 = v43 + 9;
            goto LABEL_37;
          }
          free(v19);
        }
      }
    }
    return v17;
  }
  v20 = udp_len;
  v21 = (udp_len[5] << 8) | udp_len[4];
  v55 = (udp_len[1] << 8) | *udp_len;
  v56 = (udp_len[3] << 8) | udp_len[2];
  v22 = ((_WORD)v21 << 8) | (v21 >> 8);
  if ( set_do )
  {
    v22 |= 0x8000u;
    udp_len[4] = HIBYTE(v22);
    v20[5] = v22;
  }
  v23 = (v20[7] << 8) | v20[6];
  v24 = v20 + 8;
  v25 = (unsigned __int16)(((_WORD)v23 << 8) | (v23 >> 8));
  p = v20 + 8;
  if ( v17 < v20 + 8 - (unsigned __int8 *)header + v25 || !optno )
    return v17;
  v26 = is_last;
  if ( v25 >= 5 )
  {
    v27 = (v20[11] << 8) | v20[10];
    v28 = (v20[9] << 8) | v20[8];
    v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
    v30 = v28 >> 8;
    LOWORD(v27) = (_WORD)v28 << 8;
    v31 = v29 + 4;
    v32 = (unsigned __int16)(v27 | v30);
    v33 = v20 + 0xC;
    if ( v25 < v29 + 4 )
    {
LABEL_42:
      is_last = 0;
      goto LABEL_43;
    }
    v34 = 0;
    if ( !replace )
    {
      v37 = 0;
      while ( v32 != optno )
      {
        v37 += v29 + 4;
        v24 = &v33[v29];
        if ( v37 + 4 >= v25 )
          goto LABEL_33;
        v38 = (v24[3] << 8) | v24[2];
        v39 = (v24[1] << 8) | *v24;
        v29 = (unsigned __int16)(((_WORD)v38 << 8) | (v38 >> 8));
        v32 = (unsigned __int16)(((_WORD)v39 << 8) | (v39 >> 8));
        v33 = v24 + 4;
        if ( v25 < v29 + v37 + 4 )
          goto LABEL_42;
      }
      return v17;
    }
    while ( 1 )
    {
      if ( v32 == optno )
      {
        i = v34;
        t_sb = v25 - v31;
        memcpy(v24, &v24[v29 + 4], v25 - v31 - v34);
        v25 = t_sb;
        v34 = i;
        v20[6] = BYTE1(t_sb);
        v20[7] = t_sb;
      }
      else
      {
        v24 = &v33[v29];
        v34 += v31;
      }
      if ( v34 + 4 >= v25 )
        break;
      v35 = (v24[3] << 8) | v24[2];
      v36 = (v24[1] << 8) | *v24;
      v29 = (unsigned __int16)(((_WORD)v35 << 8) | (v35 >> 8));
      v32 = (unsigned __int16)(((_WORD)v36 << 8) | (v36 >> 8));
      v33 = v24 + 4;
      if ( v25 < v34 + 4 + v29 )
        goto LABEL_42;
      v31 = v29 + 4;
    }
LABEL_33:
    v26 = is_last;
  }
  if ( !v26 )
  {
    if ( v25 )
    {
      t_sa = v25;
      v47 = (unsigned __int8 *)whine_malloc(v25);
      v19 = v47;
      v48 = t_sa;
      if ( v47 )
      {
        memcpy(v47, p, t_sa);
        v48 = t_sa;
      }
      v18 = v48;
      goto LABEL_44;
    }
LABEL_43:
    v19 = 0;
LABEL_44:
    t_s = ((_WORD)v56 << 8) | (v56 >> 8);
    udp_sz = ((_WORD)v55 << 8) | (v55 >> 8);
    v17 = rrfilter(header, v17, 0);
    goto LABEL_24;
  }
  v45 = v24 + 4;
  result = v17;
  if ( limit - (v24 + 4) < (int)optlen )
    return result;
  v46 = v20 + 6;
LABEL_37:
  result = v24 - (unsigned __int8 *)header;
  if ( replace != 2 )
  {
    if ( limit >= v45 )
    {
      v24[2] = BYTE1(optlen);
      *v24 = BYTE1(optno);
      v24[1] = optno;
      v24[3] = optlen;
      v24 = &v45[optlen];
      if ( limit >= &v45[optlen] )
      {
        memcpy(v45, opt, optlen);
        *v46 = (unsigned __int16)((_WORD)v24 - (_WORD)p) >> 8;
        v46[1] = (_BYTE)v24 - (_BYTE)p;
        return v24 - (unsigned __int8 *)header;
      }
    }
    return v17;
  }
  return result;
}
