size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // ebp
  u16 v11; // ax
  int v12; // edi
  signed int v13; // esi
  unsigned __int8 *v14; // ebx
  int v15; // ebp
  unsigned __int16 v16; // dx
  int v17; // eax
  int v18; // eax
  size_t v19; // edx
  __int16 v21; // di
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  char *v25; // ebx
  unsigned __int8 *v26; // eax
  _WORD *v27; // esi
  unsigned __int8 *v28; // eax
  unsigned __int8 *v29; // [esp+20h] [ebp-4Ch]
  int v30; // [esp+20h] [ebp-4Ch]
  size_t rdlen; // [esp+28h] [ebp-44h]
  unsigned __int8 *datap; // [esp+30h] [ebp-3Ch]
  u16 t_s; // [esp+36h] [ebp-36h]
  __int16 v34; // [esp+38h] [ebp-34h]
  __int16 v35; // [esp+3Ch] [ebp-30h]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  pseudoheader = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( pseudoheader )
  {
    v29 = t_cp;
    v35 = *(_WORD *)t_cp;
    v34 = *((_WORD *)t_cp + 1);
    v11 = __ROL2__(*((_WORD *)t_cp + 2), 8);
    t_s = v11;
    if ( set_do )
    {
      t_s = v11 | 0x8000;
      *((_WORD *)t_cp + 2) = __ROL2__(v11 | 0x8000, 8);
    }
    v12 = (int)(v29 + 8);
    datap = v29 + 8;
    v13 = (unsigned __int16)__ROL2__(*((_WORD *)v29 + 3), 8);
    if ( (unsigned int)(unsigned __int16)v13 + v29 + 8 - (unsigned __int8 *)header <= plen && optno )
    {
      if ( (unsigned __int16)v13 > 4u )
      {
        v14 = v29 + 12;
        v15 = 0;
        v16 = __ROL2__(*((_WORD *)v29 + 4), 8);
        v17 = (unsigned __int16)__ROL2__(*((_WORD *)v29 + 5), 8);
        if ( (unsigned __int16)v13 >= (unsigned __int16)v17 + 4 )
        {
          do
          {
            if ( v16 == optno )
            {
              if ( !replace )
                return plen;
              v18 = v17 + 4;
              v13 -= v18;
              memcpy((void *)v12, (const void *)(v12 + v18), v13 - v15);
              *((_WORD *)v29 + 3) = __ROL2__(v13, 8);
            }
            else
            {
              v12 = (int)&v14[v17];
              v15 += v17 + 4;
            }
            if ( v15 + 4 >= v13 )
              goto LABEL_28;
            v14 = (unsigned __int8 *)(v12 + 4);
            v16 = __ROL2__(*(_WORD *)v12, 8);
            v17 = (unsigned __int16)__ROL2__(*(_WORD *)(v12 + 2), 8);
          }
          while ( (unsigned __int16)v17 + v15 + 4 <= v13 );
        }
        is_last[0] = 0;
        pseudoheader = 0;
        goto LABEL_38;
      }
      v12 = (int)(v29 + 8);
LABEL_28:
      if ( !is_last[0] )
      {
        if ( v13 )
        {
          v28 = (unsigned __int8 *)whine_malloc(v13);
          pseudoheader = v28;
          rdlen = v13;
          if ( v28 )
            memcpy(v28, datap, v13);
        }
        else
        {
          rdlen = 0;
          pseudoheader = 0;
        }
LABEL_38:
        udp_sz = __ROL2__(v35, 8);
        v21 = __ROL2__(v34, 8);
        plen = rrfilter(header, plen, 0);
        goto LABEL_19;
      }
      v26 = (unsigned __int8 *)(v12 + 4);
      if ( (int)&limit[-v12 - 4] >= (int)optlen )
      {
        v27 = v29 + 6;
        goto LABEL_31;
      }
    }
    return plen;
  }
  v21 = 0;
  t_s = (set_do != 0) << 15;
LABEL_19:
  v22 = skip_questions(header, plen);
  v19 = plen;
  if ( !v22 )
    return v19;
  v23 = skip_section(
          v22,
          (unsigned __int16)__ROL2__(header->arcount, 8)
        + (unsigned __int16)__ROL2__(header->ancount, 8)
        + (unsigned __int16)__ROL2__(header->nscount, 8),
          header,
          plen);
  v19 = plen;
  v24 = v23;
  if ( !v23 )
    return v19;
  v25 = (char *)(v23 + 11);
  if ( (unsigned int)limit < v23 + 11 )
    return v19;
  *(_BYTE *)(v23 + 2) = 41;
  *(_WORD *)(v23 + 3) = __ROL2__(udp_sz, 8);
  *(_WORD *)(v23 + 5) = __ROL2__(v21, 8);
  *(_WORD *)v23 = 0;
  *(_WORD *)(v23 + 7) = __ROL2__(t_s, 8);
  LOWORD(datap) = v23 + 11;
  *(_WORD *)(v23 + 9) = __ROL2__(rdlen, 8);
  if ( pseudoheader )
  {
    v12 = (int)&v25[rdlen];
    if ( &v25[rdlen] > (char *)limit )
    {
      free(pseudoheader);
      return plen;
    }
    v30 = v23;
    memcpy(v25, pseudoheader, rdlen);
    free(pseudoheader);
    v24 = v30;
  }
  else
  {
    v12 = v23 + 11;
  }
  v26 = (unsigned __int8 *)(v12 + 4);
  v19 = plen;
  if ( (int)&limit[-v12 - 4] < (int)optlen )
    return v19;
  v27 = (_WORD *)(v24 + 9);
  header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_31:
  if ( !optno || replace == 2 )
    return v12 - (_DWORD)header;
  v19 = plen;
  if ( limit >= v26 )
  {
    *(_WORD *)v12 = __ROL2__(optno, 8);
    *(_WORD *)(v12 + 2) = __ROL2__(optlen, 8);
    v12 = (int)&v26[optlen];
    if ( &v26[optlen] <= limit )
    {
      memcpy(v26, opt, optlen);
      *v27 = __ROL2__(v12 - (_WORD)datap, 8);
      return v12 - (_DWORD)header;
    }
  }
  return v19;
}
