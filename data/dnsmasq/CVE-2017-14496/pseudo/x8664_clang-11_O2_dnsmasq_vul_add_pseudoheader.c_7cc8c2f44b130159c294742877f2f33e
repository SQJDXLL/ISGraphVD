size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v13; // r14
  unsigned __int8 *pseudoheader; // rax
  __int64 v16; // rdx
  __int16 v18; // si
  unsigned __int8 *v19; // rsi
  __int16 v20; // ax
  __int16 v21; // dx
  unsigned __int64 v22; // rdx
  unsigned __int8 *v23; // r13
  int v24; // ebp
  unsigned __int8 *v25; // rdi
  unsigned __int64 v26; // rax
  char *v27; // rsi
  unsigned __int64 v28; // r12
  unsigned __int8 *v29; // rsi
  _WORD *v30; // rbp
  __int16 v31; // dx
  size_t v32; // rbx
  void *v33; // rax
  __int64 v34; // rax
  __m128i v35; // xmm0
  __m128i v36; // xmm0
  __int64 v37; // rax
  int v38; // ecx
  __int64 v39; // rbp
  __int64 v40; // rbp
  __int64 v41; // rdi
  __int16 v42; // bx
  int v43; // [rsp+4h] [rbp-84h]
  __int16 v44; // [rsp+8h] [rbp-80h]
  __int16 v45; // [rsp+8h] [rbp-80h]
  __int64 v46; // [rsp+8h] [rbp-80h]
  __int16 v47; // [rsp+14h] [rbp-74h]
  unsigned __int8 *v48; // [rsp+18h] [rbp-70h]
  unsigned __int8 *v49; // [rsp+20h] [rbp-68h]
  void *ptr; // [rsp+28h] [rbp-60h]
  __int16 v51; // [rsp+30h] [rbp-58h]
  int is_last; // [rsp+34h] [rbp-54h] BYREF
  void *src; // [rsp+38h] [rbp-50h]
  unsigned __int64 v54; // [rsp+40h] [rbp-48h]
  int is_sign; // [rsp+4Ch] [rbp-3Ch] BYREF
  unsigned __int8 *v56; // [rsp+50h] [rbp-38h] BYREF

  v13 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v56, &is_sign, &is_last);
  if ( is_sign )
    return v13;
  v54 = 0LL;
  HIBYTE(v18) = 0;
  LOBYTE(v16) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v18) = set_do != 0;
    v51 = v18 << 15;
    ptr = 0LL;
    v45 = 0;
    goto LABEL_27;
  }
  v19 = v56;
  v20 = *(_WORD *)v56;
  v44 = *((_WORD *)v56 + 1);
  v21 = __ROL2__(*((_WORD *)v56 + 2), 8);
  if ( set_do )
  {
    v21 |= 0x8000u;
    v56[4] = HIBYTE(v21);
  }
  if ( optno )
  {
    v51 = v21;
    v47 = v20;
    v22 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v19 + 3) << 48);
    if ( v22 + v19 + 8 - (unsigned __int8 *)header <= v13 )
    {
      v48 = opt;
      v23 = v19;
      v49 = limit;
      v43 = optno;
      src = v19 + 8;
      if ( (unsigned int)v22 < 5 )
      {
        v25 = v19 + 8;
LABEL_18:
        if ( is_last )
        {
          v29 = v48;
          v30 = v23 + 6;
          limit = v49;
          v31 = (__int16)src;
LABEL_33:
          if ( limit - (v25 + 4) >= (__int64)optlen )
          {
            if ( v43 && replace != 2 )
            {
              *v25 = BYTE1(v43);
              v25[1] = v43;
              v25[2] = BYTE1(optlen);
              v25[3] = optlen;
              v42 = v31;
              memcpy(v25 + 4, v29, optlen);
              *v30 = __ROL2__(optlen + (_WORD)v25 + 4 - v42, 8);
              v25 += optlen + 4;
            }
            return v25 - (unsigned __int8 *)header;
          }
          return v13;
        }
        if ( (_DWORD)v22 )
        {
          v54 = v22;
          v32 = (int)v22;
          v33 = (void *)whine_malloc((int)v22);
          if ( v33 )
          {
            ptr = v33;
            memcpy(v33, src, v32);
LABEL_26:
            optno = v43;
            limit = v49;
            opt = v48;
            udp_sz = __ROL2__(v47, 8);
            v45 = __ROL2__(v44, 8);
            v13 = rrfilter(header, v13, 0LL);
LABEL_27:
            v34 = skip_questions(header, v13, v16);
            if ( !v34 )
              return v13;
            v35 = _mm_cvtsi32_si128(*(_DWORD *)&header->ancount);
            v36 = _mm_unpacklo_epi16(_mm_or_si128(_mm_slli_epi16(v35, 8u), _mm_srli_epi16(v35, 8u)), (__m128i)0LL);
            v37 = skip_section(
                    v34,
                    _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v36, 229), v36))
                  + (unsigned int)(unsigned __int16)__ROL2__(header->arcount, 8),
                    header,
                    v13);
            if ( !v37 )
              return v13;
            v43 = optno;
            *(_WORD *)v37 = 0;
            *(_BYTE *)(v37 + 2) = 41;
            *(_BYTE *)(v37 + 3) = HIBYTE(udp_sz);
            *(_BYTE *)(v37 + 4) = udp_sz;
            *(_BYTE *)(v37 + 5) = HIBYTE(v45);
            *(_BYTE *)(v37 + 6) = v45;
            *(_BYTE *)(v37 + 7) = HIBYTE(v51);
            *(_BYTE *)(v37 + 8) = v51;
            v38 = v54;
            *(_BYTE *)(v37 + 9) = BYTE1(v54);
            *(_BYTE *)(v37 + 10) = v38;
            v31 = v37 + 11;
            v25 = (unsigned __int8 *)(v37 + 11);
            v39 = v37;
            if ( ptr )
            {
              v46 = v37;
              v40 = v38;
              src = (void *)(v37 + 11);
              memcpy((void *)(v37 + 11), ptr, v38);
              free(ptr);
              v31 = (__int16)src;
              v41 = v40;
              v39 = v46;
              v25 = (unsigned __int8 *)src + v41;
            }
            v30 = (_WORD *)(v39 + 9);
            v29 = opt;
            if ( limit - v25 - 4 >= (__int64)optlen )
              header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
            goto LABEL_33;
          }
LABEL_25:
          ptr = 0LL;
          goto LABEL_26;
        }
      }
      else
      {
        v24 = 0;
        v25 = v19 + 8;
        while ( 1 )
        {
          v26 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v25 + 1) << 48);
          if ( (int)v26 + v24 > (int)v22 )
            break;
          v27 = (char *)(v25 + 4);
          if ( _byteswap_ulong(*(unsigned __int16 *)v25 << 16) == optno )
          {
            if ( !replace )
              return v13;
            v28 = (unsigned int)(v22 - v26 - 4);
            memcpy(v25, &v27[v26], (int)v28 - v24);
            v22 = v28;
            *((_WORD *)v23 + 3) = __ROL2__(v28, 8);
          }
          else
          {
            v24 += v26 + 4;
            v25 = (unsigned __int8 *)&v27[(unsigned int)v26];
          }
          if ( v24 + 4 >= (int)v22 )
            goto LABEL_18;
        }
        is_last = 0;
      }
      v54 = 0LL;
      goto LABEL_25;
    }
  }
  return v13;
}
