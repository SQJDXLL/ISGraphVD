size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v16; // $s0
  int v17; // $s4
  unsigned __int8 *v18; // $fp
  unsigned __int8 *v19; // $fp
  unsigned int v20; // $v0
  __int16 v21; // $s3
  unsigned int v22; // $v0
  unsigned __int8 *v23; // $s6
  signed int v24; // $s7
  int v25; // $v0
  unsigned int v26; // $v0
  unsigned int v27; // $a0
  signed int v28; // $v1
  int v29; // $v0
  unsigned __int8 *v30; // $a1
  int v31; // $t1
  unsigned int v32; // $a1
  unsigned int v33; // $a0
  int v34; // $v1
  int v35; // $a2
  unsigned int v36; // $v0
  unsigned int v37; // $a0
  size_t result; // $v0
  __int16 v39; // $s7
  int v40; // $a0
  _BYTE *v41; // $v0
  unsigned int v42; // $a2
  _BYTE *v43; // $s3
  void *v44; // $a0
  unsigned __int8 *v45; // $v0
  size_t v46; // $s6
  int i; // [sp+20h] [-28h]
  unsigned __int8 *p; // [sp+2Ch] [-1Ch]
  unsigned int v50; // [sp+30h] [-18h]
  unsigned int v51; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v16 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v16;
  v18 = pseudoheader;
  if ( pseudoheader )
  {
    v19 = udp_len;
    v20 = (udp_len[5] << 8) | udp_len[4];
    v51 = (udp_len[1] << 8) | *udp_len;
    v50 = (udp_len[3] << 8) | udp_len[2];
    v21 = ((_WORD)v20 << 8) | (v20 >> 8);
    if ( set_do )
    {
      v21 |= 0x8000u;
      udp_len[4] = HIBYTE(v21);
      v19[5] = v21;
    }
    v22 = (v19[7] << 8) | v19[6];
    v23 = v19 + 8;
    v24 = (unsigned __int16)(((_WORD)v22 << 8) | (v22 >> 8));
    p = v19 + 8;
    if ( v16 < v19 + 8 - (unsigned __int8 *)header + v24 || !optno )
      return v16;
    v25 = is_last;
    if ( v24 >= 5 )
    {
      v26 = (v19[11] << 8) | v19[10];
      v27 = (v19[9] << 8) | v19[8];
      v28 = (unsigned __int16)(((_WORD)v26 << 8) | (v26 >> 8));
      v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
      v30 = v19 + 0xC;
      if ( v24 < v28 )
      {
LABEL_36:
        is_last = 0;
        v18 = 0;
LABEL_37:
        udp_sz = (unsigned __int16)(((_WORD)v51 << 8) | (v51 >> 8));
        v39 = ((_WORD)v50 << 8) | (v50 >> 8);
        v16 = rrfilter(header, v16, 0);
        goto LABEL_23;
      }
      v31 = 0;
      if ( !replace )
      {
        v35 = 0;
        while ( v29 != optno )
        {
          v35 += v28 + 4;
          v23 = &v30[v28];
          if ( v35 + 4 >= v24 )
          {
            v25 = is_last;
            goto LABEL_31;
          }
          v36 = (v23[3] << 8) | v23[2];
          v37 = (v23[1] << 8) | *v23;
          v28 = (unsigned __int16)(((_WORD)v36 << 8) | (v36 >> 8));
          v29 = (unsigned __int16)(((_WORD)v37 << 8) | (v37 >> 8));
          v30 = v23 + 4;
          if ( v24 < v28 + v35 )
            goto LABEL_36;
        }
        return v16;
      }
      while ( 1 )
      {
        if ( v29 == optno )
        {
          v34 = v28 + 4;
          v24 -= v34;
          i = v31;
          memcpy(v23, &v23[v34], v24 - v31);
          v31 = i;
          v19[6] = BYTE1(v24);
          v19[7] = v24;
        }
        else
        {
          v23 = &v30[v28];
          v31 += v28 + 4;
        }
        v25 = is_last;
        if ( v31 + 4 >= v24 )
          break;
        v32 = (v23[3] << 8) | v23[2];
        v33 = (v23[1] << 8) | *v23;
        v28 = (unsigned __int16)(((_WORD)v32 << 8) | (v32 >> 8));
        v29 = (unsigned __int16)(((_WORD)v33 << 8) | (v33 >> 8));
        v30 = v23 + 4;
        if ( v24 < v28 + v31 )
          goto LABEL_36;
      }
    }
LABEL_31:
    if ( v25 )
    {
      v44 = v23 + 4;
      result = v16;
      if ( limit - (v23 + 4) < (int)optlen )
        return result;
      v43 = v19 + 6;
      goto LABEL_40;
    }
    if ( v24 )
    {
      v45 = (unsigned __int8 *)whine_malloc(v24);
      v18 = v45;
      if ( v45 )
        memcpy(v45, p, v24);
      v17 = v24;
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
    goto LABEL_37;
  }
  v39 = 0;
  v21 = (set_do != 0) << 15;
LABEL_23:
  v40 = skip_questions(header, v16);
  if ( !v40 )
    return v16;
  v41 = (_BYTE *)skip_section(
                   v40,
                   (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                 + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                 + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                   header,
                   v16);
  if ( !v41 )
    return v16;
  v42 = udp_sz >> 8;
  v41[4] = udp_sz;
  v23 = v41 + 0xB;
  v41[8] = v21;
  *v41 = 0;
  v41[1] = 0;
  v41[2] = 41;
  v41[3] = v42;
  v41[5] = HIBYTE(v39);
  v41[6] = v39;
  v41[7] = HIBYTE(v21);
  v43 = v41 + 9;
  v41[9] = BYTE1(v17);
  v41[10] = v17;
  LOWORD(p) = (_WORD)v41 + 0xB;
  if ( v18 )
  {
    memcpy(v41 + 0xB, v18, v17);
    v23 += v17;
    free(v18);
  }
  v44 = v23 + 4;
  result = v16;
  if ( limit - (v23 + 4) < (int)optlen )
    return result;
  header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
  if ( !optno )
    return v23 - (unsigned __int8 *)header;
LABEL_40:
  if ( replace == 2 )
    return v23 - (unsigned __int8 *)header;
  v23[2] = BYTE1(optlen);
  *v23 = BYTE1(optno);
  v23[1] = optno;
  v23[3] = optlen;
  v46 = (size_t)v44 + optlen;
  memcpy(v44, opt, optlen);
  *v43 = (unsigned __int16)(v46 - (_WORD)p) >> 8;
  v43[1] = v46 - (_BYTE)p;
  return v46 - (_DWORD)header;
}
