int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s0
  void *v17; // $fp
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $s3
  unsigned __int8 v21; // $a2
  char v22; // $s2
  unsigned __int8 v23; // $t0
  unsigned __int8 v24; // $a3
  unsigned __int8 v25; // $a1
  int v26; // $s5
  int v27; // $fp
  int v28; // $v0
  unsigned __int8 *v29; // $s7
  int v30; // $v1
  unsigned __int8 *v31; // $v0
  signed int v32; // $a2
  _WORD *v33; // $s2
  void *v34; // $v0
  void *v35; // $s3
  int v36; // $v0
  _BYTE *v37; // $v0
  char *v38; // $a0
  _BYTE *v39; // $s3
  __int16 v40; // $s2
  unsigned __int8 *v41; // $a0
  unsigned __int8 v42; // [sp+1Fh] [-29h]
  unsigned __int8 v43; // [sp+23h] [-25h]
  unsigned __int8 v44; // [sp+27h] [-21h]
  unsigned int v45; // [sp+28h] [-20h]
  void *src; // [sp+2Ch] [-1Ch]
  int n; // [sp+30h] [-18h]
  unsigned __int8 *v48; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v51; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v51, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( !pseudoheader )
  {
    n = optlen;
    v22 = 0x80;
    if ( !set_do )
      v22 = 0;
    v45 = udp_sz >> 8;
    v26 = 0;
    v44 = 0;
    v43 = 0;
    v42 = 0;
    goto LABEL_30;
  }
  v20 = v51;
  v21 = v51[5];
  v22 = v51[4];
  v23 = v51[3];
  v24 = v51[2];
  LOBYTE(udp_sz) = v51[1];
  v25 = *v51;
  if ( set_do )
  {
    v22 |= 0x80u;
    v51[4] = v22;
  }
  if ( optno )
  {
    n = optlen;
    src = v20 + 8;
    v26 = (v20[6] << 8) | v20[7];
    if ( v15 >= v20 + 8 - (unsigned __int8 *)header + v26 )
    {
      v48 = limit;
      LOBYTE(v45) = v25;
      v44 = v21;
      v43 = v24;
      v42 = v23;
      if ( (unsigned int)v26 < 5 )
      {
        v29 = v20 + 8;
LABEL_21:
        if ( is_last )
        {
          v32 = optlen;
          v33 = v20 + 6;
          goto LABEL_39;
        }
        v17 = 0;
        if ( v26 )
        {
          v34 = (void *)whine_malloc(v26);
          if ( v34 )
          {
            v35 = v34;
            memcpy(v34, src, v26);
            limit = v48;
            v17 = v35;
          }
          else
          {
            limit = v48;
          }
        }
        else
        {
          limit = v48;
          v26 = 0;
        }
      }
      else
      {
        v27 = 0;
        v28 = 4;
        v29 = v20 + 8;
        while ( 1 )
        {
          v30 = (v29[2] << 8) | v29[3];
          if ( v26 < v30 + v28 )
            break;
          v31 = v29 + 4;
          if ( ((*v29 << 8) | v29[1]) == optno )
          {
            if ( !replace )
              return v15;
            v26 = v26 - v30 - 4;
            memcpy(v29, &v31[v30], v26 - v27);
            *((_WORD *)v20 + 3) = v26;
          }
          else
          {
            v29 = &v31[v30];
            v27 += v30 + 4;
          }
          v28 = v27 + 4;
          if ( v27 + 4 >= v26 )
            goto LABEL_21;
        }
        is_last = 0;
        v26 = 0;
        limit = v48;
        v17 = 0;
      }
      v15 = rrfilter(header, v15, 0);
LABEL_30:
      v36 = skip_questions(header, v15);
      if ( !v36 )
        return v15;
      v37 = (_BYTE *)skip_section(
                       v36,
                       (_bswapw(header->nscount) >> 16)
                     + (_bswapw(header->ancount) >> 16)
                     + (_bswapw(header->arcount) >> 16),
                       header,
                       v15);
      if ( !v37 )
        return v15;
      v38 = v37 + 0xB;
      v39 = v37;
      if ( limit < v37 + 0xB )
        return v15;
      v48 = limit;
      v37[10] = v26;
      v37[8] = v44;
      v37[7] = v22;
      v37[6] = v42;
      v37[5] = v43;
      v37[4] = udp_sz;
      v37[3] = v45;
      v37[2] = 41;
      v37[1] = 0;
      *v37 = 0;
      v37[9] = BYTE2(v26);
      v29 = v37 + 0xB;
      if ( v17 )
      {
        v29 = (unsigned __int8 *)&v38[v26];
        if ( v48 < (unsigned __int8 *)&v38[v26] )
        {
          free(v17);
          return v15;
        }
        v40 = (_WORD)v37 + 0xB;
        memcpy(v38, v17, v26);
        free(v17);
        LOWORD(v38) = v40;
      }
      v33 = v39 + 9;
      v32 = n;
      LOWORD(src) = (_WORD)v38;
      if ( v48 - v29 - 4 >= n )
        header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
LABEL_39:
      v41 = v29 + 4;
      if ( v48 - (v29 + 4) < v32 )
        return v15;
      if ( optno && replace != 2 )
      {
        if ( v48 < v41 )
          return v15;
        v29[3] = v32;
        v29[1] = optno;
        v29[2] = BYTE2(v32);
        *v29 = BYTE2(optno);
        v29 = &v41[v32];
        if ( v48 < &v41[v32] )
          return v15;
        memcpy(v41, opt, v32);
        *v33 = (_WORD)v29 - (_WORD)src;
      }
      return v29 - (unsigned __int8 *)header;
    }
  }
  return v15;
}
