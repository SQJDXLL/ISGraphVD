size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v14; // $s4
  unsigned __int8 *pseudoheader; // $v0
  int v17; // $s7
  unsigned __int8 *v18; // $s2
  unsigned __int8 *v19; // $s2
  unsigned __int16 v20; // $v0
  int v21; // $s1
  char *v22; // $fp
  unsigned __int8 *v23; // $a2
  int v24; // $v0
  int v25; // $a1
  int v26; // $a0
  int v27; // $s3
  unsigned int v28; // $s0
  __int16 v29; // $s3
  int v30; // $a1
  unsigned int v31; // $a0
  _BYTE *v32; // $s2
  __int16 v33; // $fp
  unsigned __int8 *v34; // $v0
  int v35; // $a0
  _BYTE *v36; // $v0
  _BYTE *v37; // $s1
  __int16 t_s; // [sp+2Ch] [-24h]
  __int16 v41; // [sp+30h] [-20h]
  __int16 v42; // [sp+34h] [-1Ch]
  __int16 v43; // [sp+38h] [-18h]
  __int16 v44; // [sp+3Ch] [-14h]
  unsigned __int8 *udp_len; // [sp+40h] [-10h] BYREF
  int is_sign; // [sp+44h] [-Ch] BYREF
  int is_last; // [sp+48h] [-8h] BYREF

  v14 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v14;
  v18 = pseudoheader;
  if ( !pseudoheader )
  {
    t_s = (set_do != 0) << 15;
    v29 = 0;
LABEL_35:
    v35 = skip_questions(header, v14);
    if ( !v35 )
      return v14;
    v36 = (_BYTE *)skip_section(
                     v35,
                     (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                   + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                   + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                     header,
                     v14);
    v37 = v36;
    if ( !v36 )
      return v14;
    v22 = v36 + 0xB;
    if ( limit < v36 + 0xB )
      return v14;
    *v36 = 0;
    v36[1] = 0;
    v36[2] = 41;
    v36[3] = HIBYTE(udp_sz);
    v36[4] = udp_sz;
    v36[5] = HIBYTE(v29);
    v36[6] = v29;
    v36[7] = HIBYTE(t_s);
    v36[8] = t_s;
    v36[9] = BYTE1(v17);
    v36[10] = v17;
    if ( v18 )
    {
      v28 = (unsigned int)&v22[v17];
      if ( limit < (unsigned __int8 *)&v22[v17] )
      {
        free(v18);
        return v14;
      }
      memcpy(v22, v18, v17);
      free(v18);
    }
    else
    {
      v28 = (unsigned int)(v36 + 0xB);
    }
    v31 = v28 + 4;
    if ( (int)&limit[-v28 - 4] < (int)optlen )
      return v14;
    header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
    v32 = v37 + 9;
    if ( !optno )
      return v28 - (_DWORD)header;
    goto LABEL_22;
  }
  v19 = udp_len;
  v41 = *udp_len;
  v42 = udp_len[1];
  v43 = udp_len[2];
  v44 = udp_len[3];
  v20 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  if ( set_do )
  {
    t_s = v20 | 0x8000;
    udp_len[4] = (unsigned __int16)(v20 | 0x8000) >> 8;
    v19[5] = v20;
  }
  else
  {
    t_s = v20;
  }
  v21 = (v19[6] << 8) | v19[7];
  v22 = (char *)(v19 + 8);
  if ( v14 < v19 + 8 - (unsigned __int8 *)header + v21 || !optno )
    return v14;
  v23 = v19 + 0xC;
  if ( v21 >= 5 )
  {
    v24 = _byteswap_ushort(*((_WORD *)v19 + 4));
    v25 = _byteswap_ushort(*((_WORD *)v19 + 5));
    v26 = v25;
    if ( v21 < v25 + 4 )
    {
LABEL_11:
      is_last = 0;
      v18 = 0;
LABEL_12:
      udp_sz = (v41 << 8) | v42;
      v29 = (v43 << 8) | v44;
      v14 = rrfilter(header, v14, 0);
      goto LABEL_35;
    }
    v27 = 0;
    v28 = (unsigned int)(v19 + 8);
    while ( 1 )
    {
      if ( v24 == optno )
      {
        v30 = v25 + 4;
        if ( !replace )
          return v14;
        v21 -= v26 + 4;
        memcpy((void *)v28, (const void *)(v28 + v30), v21 - v27);
        v19[6] = BYTE1(v21);
        v19[7] = v21;
      }
      else
      {
        v28 = (unsigned int)&v23[v25];
        v27 += v26 + 4;
      }
      v23 = (unsigned __int8 *)(v28 + 4);
      if ( v27 + 4 >= v21 )
        break;
      v24 = _byteswap_ushort(*(_WORD *)v28);
      v25 = _byteswap_ushort(*(_WORD *)(v28 + 2));
      v26 = v25;
      if ( v21 < v25 + v27 + 4 )
        goto LABEL_11;
    }
    v31 = v28 + 4;
    if ( is_last )
      goto LABEL_20;
LABEL_26:
    if ( v21 )
    {
      v34 = (unsigned __int8 *)whine_malloc(v21);
      v18 = v34;
      if ( v34 )
        memcpy(v34, v22, v21);
      v17 = v21;
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
    goto LABEL_12;
  }
  v28 = (unsigned int)(v19 + 8);
  if ( !is_last )
    goto LABEL_26;
  v31 = (unsigned int)(v19 + 0xC);
LABEL_20:
  if ( (int)&limit[-v31] < (int)optlen )
    return v14;
  v32 = v19 + 6;
LABEL_22:
  if ( replace == 2 )
    return v28 - (_DWORD)header;
  if ( (unsigned int)limit >= v31 )
  {
    *(_BYTE *)v28 = BYTE1(optno);
    *(_BYTE *)(v28 + 1) = optno;
    *(_BYTE *)(v28 + 2) = BYTE1(optlen);
    *(_BYTE *)(v28 + 3) = optlen;
    v28 = v31 + optlen;
    if ( (unsigned int)limit >= v31 + optlen )
    {
      memcpy((void *)v31, opt, optlen);
      v33 = v28 - (_WORD)v22;
      *v32 = HIBYTE(v33);
      v32[1] = v33;
      return v28 - (_DWORD)header;
    }
  }
  return v14;
}
