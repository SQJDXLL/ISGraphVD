size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  int v9; // r10
  unsigned int v12; // r9
  unsigned __int8 *pseudoheader; // r0
  int v14; // r4
  unsigned __int8 *v15; // r6
  unsigned __int8 *v16; // r6
  unsigned int v17; // r3
  int v18; // r8
  unsigned int v19; // r3
  const void *v20; // r10
  unsigned int v21; // r3
  int v22; // r3
  unsigned __int8 *v23; // r5
  unsigned int v24; // r1
  int v25; // r2
  unsigned int v26; // r12
  int v27; // r1
  int v28; // r1
  _BYTE *v29; // r8
  unsigned __int8 *v30; // r0
  int v31; // r5
  int v32; // r0
  _BYTE *v33; // r0
  _BYTE *v34; // r3
  unsigned __int16 v35; // r3
  unsigned __int8 *v36; // r0
  bool v37; // zf
  int v38; // r10
  unsigned int v40; // [sp+8h] [bp-48h]
  unsigned int i; // [sp+Ch] [bp-44h]
  int v42; // [sp+14h] [bp-3Ch]
  unsigned __int8 *udp_len; // [sp+18h] [bp-38h] BYREF
  int is_sign; // [sp+1Ch] [bp-34h] BYREF
  int is_last; // [sp+20h] [bp-30h] BYREF

  LOWORD(v9) = udp_sz;
  v12 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v14 = is_sign;
  if ( is_sign )
    return v12;
  v15 = pseudoheader;
  if ( pseudoheader )
  {
    v16 = udp_len;
    i = *udp_len | (udp_len[1] << 8);
    v40 = udp_len[2] | (udp_len[3] << 8);
    v17 = udp_len[4] | (udp_len[5] << 8);
    v18 = (unsigned __int16)((v17 >> 8) | ((_WORD)v17 << 8));
    if ( set_do )
    {
      v19 = ~((unsigned int)~(v18 << 17) >> 17) << 16;
      LOWORD(v18) = ~((unsigned int)~(v18 << 17) >> 17);
      udp_len[4] = HIBYTE(v19);
      v16[5] = v18;
    }
    v20 = v16 + 8;
    v21 = v16[6] | (v16[7] << 8);
    v14 = (unsigned __int16)((v21 >> 8) | ((_WORD)v21 << 8));
    v22 = optno == 0;
    if ( v16 + 8 - (unsigned __int8 *)header + v14 > v12 )
      v22 = 1;
    if ( v22 )
      return v12;
    v23 = v16 + 8;
    while ( v22 + 4 < v14 )
    {
      v24 = *v23 | (v23[1] << 8);
      v25 = (v24 >> 8) | (v24 << 8);
      v26 = v23[2] | (v23[3] << 8);
      v27 = (unsigned __int16)((v26 >> 8) | ((_WORD)v26 << 8));
      if ( v27 + v22 + 4 > v14 )
      {
        v14 = 0;
        is_last = 0;
LABEL_12:
        v15 = (unsigned __int8 *)v14;
        goto LABEL_22;
      }
      if ( (unsigned __int16)v25 == optno )
      {
        if ( !replace )
          return v12;
        v28 = v27 + 4;
        v14 -= v28;
        v42 = v22;
        memcpy(v23, &v23[v28], v14 - v22);
        v22 = v42;
        v16[6] = (unsigned int)(v14 << 16) >> 24;
        v16[7] = v14;
      }
      else
      {
        v23 += v27 + 4;
        v22 += v27 + 4;
      }
    }
    if ( is_last )
    {
      v29 = v16 + 6;
      goto LABEL_33;
    }
    if ( !v14 )
      goto LABEL_12;
    v30 = (unsigned __int8 *)whine_malloc(v14);
    v15 = v30;
    if ( v30 )
      memcpy(v30, v20, v14);
LABEL_22:
    v9 = (i >> 8) | (i << 8);
    v31 = (v40 >> 8) | (v40 << 8);
    v12 = rrfilter(header, v12, 0);
  }
  else
  {
    LOWORD(v18) = (set_do != 0) << 15;
    LOWORD(v31) = 0;
  }
  v32 = skip_questions(header, v12);
  if ( v32 )
  {
    v33 = (_BYTE *)skip_section(
                     v32,
                     (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                   + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                   + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                     header,
                     v12);
    if ( v33 )
    {
      v34 = v33 + 0xB;
      if ( limit >= v33 + 0xB )
      {
        *v33 = 0;
        v33[1] = 0;
        v33[2] = 41;
        v33[3] = BYTE1(v9);
        v33[5] = BYTE1(v31);
        v33[7] = BYTE1(v18);
        v33[4] = v9;
        v33[8] = v18;
        v20 = v33 + 0xB;
        v29 = v33 + 9;
        v33[6] = v31;
        v33[9] = (unsigned int)(v14 << 16) >> 24;
        v33[10] = v14;
        if ( v15 )
        {
          v23 = &v34[v14];
          if ( &v34[v14] > limit )
          {
            free(v15);
            return v12;
          }
          memcpy(v33 + 0xB, v15, v14);
          free(v15);
        }
        else
        {
          v23 = v33 + 0xB;
        }
        if ( limit - (v23 + 4) >= (int)optlen )
        {
          v35 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
          header->arcount = HIBYTE(v35) | (v35 << 8);
        }
LABEL_33:
        v36 = v23 + 4;
        if ( limit - (v23 + 4) >= (int)optlen )
        {
          v37 = optno == 0;
          if ( optno )
            v37 = replace == 2;
          if ( v37 )
            return v23 - (unsigned __int8 *)header;
          if ( v36 <= limit )
          {
            *v23 = (unsigned int)(optno << 16) >> 24;
            v23[1] = optno;
            v23[2] = optlen << 16 >> 24;
            v23[3] = optlen;
            v23 = &v36[optlen];
            if ( &v36[optlen] <= limit )
            {
              v38 = v23 - (_BYTE *)v20;
              memcpy(v36, opt, optlen);
              *v29 = (unsigned int)(v38 << 16) >> 24;
              v29[1] = v38;
              return v23 - (unsigned __int8 *)header;
            }
          }
        }
      }
    }
  }
  return v12;
}
