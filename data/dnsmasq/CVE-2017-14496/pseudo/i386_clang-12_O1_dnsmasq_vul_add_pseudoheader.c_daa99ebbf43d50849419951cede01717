int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        signed int optlen,
        int set_do,
        int replace)
{
  size_t v9; // esi
  unsigned __int8 *pseudoheader; // eax
  unsigned __int8 *v11; // edx
  __int16 v13; // bx
  unsigned __int8 *v14; // edx
  __int16 v15; // bx
  signed int v16; // esi
  unsigned __int16 *v17; // ebp
  int v18; // edi
  unsigned __int32 v19; // eax
  unsigned __int16 *v20; // ebx
  unsigned __int8 *v21; // ebx
  char v22; // cl
  int v23; // eax
  signed int v24; // eax
  char *v25; // edi
  signed int v26; // ebx
  unsigned __int8 *v27; // esi
  unsigned __int16 *v28; // edi
  int v29; // eax
  int v30; // edi
  char *v31; // ebx
  __uint16_t v32; // ax
  int v33; // eax
  int v34; // edx
  int v35; // edi
  unsigned __int8 *v36; // edi
  void *v37; // ecx
  void *v38; // eax
  void *v39; // ebp
  unsigned __int8 *v40; // edi
  __uint16_t v41; // ax
  u16 v42; // ax
  _BYTE *v43; // [esp-Ch] [ebp-48h]
  size_t n; // [esp+8h] [ebp-34h]
  _BYTE v45[6]; // [esp+Eh] [ebp-2Eh]
  __int16 v46; // [esp+14h] [ebp-28h]
  __int16 v47; // [esp+14h] [ebp-28h]
  int v48; // [esp+14h] [ebp-28h]
  void *v49; // [esp+18h] [ebp-24h]
  void *v50; // [esp+18h] [ebp-24h]
  __int16 v51; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v54; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0, &v54, &is_sign, &is_last);
  if ( is_sign )
    return v9;
  HIBYTE(v13) = 0;
  LOBYTE(v11) = set_do != 0;
  if ( !pseudoheader )
  {
    *(_WORD *)v45 = udp_sz;
    LOBYTE(v13) = set_do != 0;
    v51 = v13 << 15;
    v47 = 0;
    n = 0;
    *(_DWORD *)&v45[2] = 0;
    v20 = 0;
    goto LABEL_23;
  }
  v14 = v54;
  v15 = __ROL2__(*((_WORD *)v54 + 2), 8);
  if ( set_do )
  {
    v15 |= 0x8000u;
    v54[4] = HIBYTE(v15);
  }
  v46 = *((_WORD *)v14 + 1);
  v16 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
  v17 = (unsigned __int16 *)(v14 + 8);
  *(_WORD *)&v45[4] = 0;
  v51 = v15;
  v49 = v14 + 8;
  *(_DWORD *)v45 = *(unsigned __int16 *)v14;
  if ( !optno || v16 + (char *)v17 - (char *)header > plen )
  {
    n = v16;
    v22 = 0;
    goto LABEL_20;
  }
  if ( (unsigned int)v16 < 5 )
  {
LABEL_19:
    n = v16;
    v22 = 1;
    if ( !is_last )
    {
      v36 = v14;
      v20 = 0;
      v37 = 0;
      if ( v16 )
      {
        v38 = (void *)whine_malloc(v16);
        v37 = 0;
        if ( v38 )
        {
          v39 = v38;
          memcpy(v38, v49, v16);
          v37 = v39;
        }
      }
      *(_DWORD *)&v45[2] = v37;
      v23 = rrfilter(header, plen, 0);
      v14 = v36;
      goto LABEL_22;
    }
LABEL_20:
    v20 = v17;
    goto LABEL_21;
  }
  v18 = 0;
  while ( 1 )
  {
    v19 = _byteswap_ulong(v17[1] << 16);
    v20 = v17 + 2;
    n = v16;
    if ( (int)(v19 + v18) > v16 )
    {
      is_last = 0;
      v17 += 2;
      v16 = 0;
      goto LABEL_19;
    }
    if ( _byteswap_ulong(*v17 << 16) == optno )
      break;
    v18 += v19 + 4;
    v17 = (unsigned __int16 *)((char *)v20 + v19);
LABEL_11:
    if ( v18 + 4 >= v16 )
      goto LABEL_19;
  }
  if ( replace )
  {
    v16 = v16 - v19 - 4;
    v43 = (char *)v20 + v19;
    v21 = v14;
    memcpy(v17, v43, n - v19 - 4 - v18);
    v14 = v21;
    *((_WORD *)v21 + 3) = __ROL2__(v16, 8);
    goto LABEL_11;
  }
  v22 = 0;
  *(_DWORD *)&v45[2] = 0;
LABEL_21:
  v9 = plen;
  v23 = plen;
  if ( v22 )
  {
LABEL_22:
    *(_WORD *)v45 = __ROL2__(*(_WORD *)v45, 8);
    v47 = __ROL2__(v46, 8);
    v11 = v14 + 6;
    v9 = v23;
LABEL_23:
    v24 = optlen;
    if ( v20 )
    {
LABEL_24:
      v25 = (char *)(v20 + 2);
      if ( limit - (unsigned __int8 *)(v20 + 2) >= v24 )
      {
        if ( optno && replace != 2 )
        {
          *(_BYTE *)v20 = BYTE1(optno);
          *((_BYTE *)v20 + 1) = optno;
          *((_BYTE *)v20 + 2) = BYTE1(v24);
          *((_BYTE *)v20 + 3) = v24;
          v26 = v24;
          v27 = v11;
          memcpy(v25, opt, v24);
          v28 = (unsigned __int16 *)&v25[v26];
          *(_WORD *)v27 = __ROL2__((_WORD)v28 - (_WORD)v49, 8);
          v20 = v28;
        }
        return (char *)v20 - (char *)header;
      }
    }
    else
    {
      v29 = skip_questions(header, v9);
      if ( v29 )
      {
        v30 = v29;
        v50 = (void *)_bswap_16(header->ancount);
        v31 = (char *)v50 + _bswap_16(header->nscount);
        v32 = _bswap_16(header->arcount);
        v33 = skip_section(v30, &v31[v32], header, v9);
        if ( v33 )
        {
          v34 = v33;
          *(_WORD *)v33 = 0;
          *(_BYTE *)(v33 + 2) = 41;
          *(_BYTE *)(v33 + 3) = v45[1];
          *(_BYTE *)(v33 + 4) = v45[0];
          *(_BYTE *)(v33 + 5) = HIBYTE(v47);
          *(_BYTE *)(v33 + 6) = v47;
          *(_BYTE *)(v33 + 7) = HIBYTE(v51);
          *(_BYTE *)(v33 + 8) = v51;
          *(_BYTE *)(v33 + 9) = BYTE1(n);
          *(_BYTE *)(v33 + 10) = n;
          v35 = v33 + 11;
          v20 = (unsigned __int16 *)(v33 + 11);
          if ( *(_DWORD *)&v45[2] )
          {
            v48 = v33;
            memcpy((void *)(v33 + 11), *(const void **)&v45[2], n);
            free(*(void **)&v45[2]);
            v34 = v48;
            v20 = (unsigned __int16 *)(v35 + n);
          }
          LOWORD(v49) = v35;
          v11 = (unsigned __int8 *)(v34 + 9);
          if ( limit - (unsigned __int8 *)v20 - 4 >= optlen )
          {
            v40 = v11;
            v41 = _bswap_16(header->arcount);
            v42 = _bswap_16(v41 + 1);
            v11 = v40;
            header->arcount = v42;
          }
          v24 = optlen;
          goto LABEL_24;
        }
      }
    }
  }
  return v9;
}
