size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  int v9; // r9
  unsigned int v11; // r4
  unsigned __int8 *pseudoheader; // r0
  int v13; // r10
  unsigned __int8 *v14; // r6
  unsigned __int8 *v15; // r3
  unsigned int v16; // r2
  int v17; // r5
  unsigned int v18; // r2
  unsigned __int8 *v19; // r9
  unsigned int v20; // r2
  signed int v21; // r11
  int v22; // r6
  unsigned int v23; // r1
  unsigned int v24; // r0
  int v25; // r2
  int v26; // r12
  int v27; // r1
  unsigned __int8 *v28; // r0
  unsigned __int8 *v29; // r10
  unsigned int v30; // r12
  unsigned int v31; // r0
  unsigned __int8 *v32; // r0
  _BYTE *v33; // r5
  bool v34; // zf
  __int16 v36; // r5
  int v37; // r11
  int v38; // r0
  _BYTE *v39; // r3
  _BYTE *v40; // r2
  unsigned __int16 v41; // r3
  unsigned __int8 *v42; // r0
  int v43; // r6
  int v44; // r12
  unsigned int v45; // lr
  unsigned int v46; // r12
  void *v48; // [sp+10h] [bp-48h]
  unsigned int v49; // [sp+14h] [bp-44h]
  _BYTE *v50; // [sp+14h] [bp-44h]
  unsigned int v51; // [sp+18h] [bp-40h]
  unsigned __int8 *udp_len; // [sp+20h] [bp-38h] BYREF
  int is_sign; // [sp+24h] [bp-34h] BYREF
  int is_last; // [sp+28h] [bp-30h] BYREF

  LOWORD(v9) = udp_sz;
  v11 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v13 = is_sign;
  if ( is_sign )
    return v11;
  v14 = pseudoheader;
  if ( !pseudoheader )
  {
    v36 = set_do;
    if ( set_do )
      v36 = 1;
    LOWORD(v17) = v36 << 15;
    LOWORD(v37) = 0;
LABEL_32:
    v38 = skip_questions(header, v11);
    if ( !v38 )
      return v11;
    v39 = (_BYTE *)skip_section(
                     v38,
                     (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                   + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                   + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                     header,
                     v11);
    if ( !v39 )
      return v11;
    v40 = v39 + 0xB;
    if ( limit < v39 + 0xB )
      return v11;
    v39[9] = (unsigned int)(v13 << 16) >> 24;
    v39[4] = v9;
    v39[6] = v37;
    v39[8] = v17;
    *v39 = 0;
    v39[1] = 0;
    v39[3] = BYTE1(v9);
    v39[5] = BYTE1(v37);
    v39[7] = BYTE1(v17);
    v39[10] = v13;
    v39[2] = 41;
    v48 = v39 + 0xB;
    if ( v14 )
    {
      v19 = &v40[v13];
      if ( &v40[v13] > limit )
      {
        free(v14);
        return v11;
      }
      v50 = v39;
      memcpy(v39 + 0xB, v14, v13);
      free(v14);
      v39 = v50;
    }
    else
    {
      v19 = v39 + 0xB;
    }
    v32 = v19 + 4;
    if ( limit - (v19 + 4) >= (int)optlen )
    {
      v33 = v39 + 9;
      v41 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
      header->arcount = HIBYTE(v41) | (v41 << 8);
      goto LABEL_23;
    }
    return v11;
  }
  v15 = udp_len;
  v16 = udp_len[4] | (udp_len[5] << 8);
  v51 = *udp_len | (udp_len[1] << 8);
  v17 = (unsigned __int16)((v16 >> 8) | ((_WORD)v16 << 8));
  v49 = udp_len[2] | (udp_len[3] << 8);
  if ( set_do )
  {
    v18 = ~((unsigned int)~(v17 << 17) >> 17) << 16;
    LOWORD(v17) = ~((unsigned int)~(v17 << 17) >> 17);
    udp_len[4] = HIBYTE(v18);
    v15[5] = v17;
  }
  v19 = v15 + 8;
  v20 = v15[6] | (v15[7] << 8);
  v21 = (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8));
  v22 = optno == 0;
  if ( v15 + 8 - (unsigned __int8 *)header + v21 > v11 )
    v22 = 1;
  v48 = v15 + 8;
  if ( v22 )
    return v11;
  if ( (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8)) > 4u )
  {
    v23 = v15[10] | (v15[11] << 8);
    v24 = v15[8] | (v15[9] << 8);
    v25 = (unsigned __int16)((v23 >> 8) | ((_WORD)v23 << 8));
    v26 = v25 + 4;
    v27 = (unsigned __int16)((v24 >> 8) | ((_WORD)v24 << 8));
    v28 = v15 + 0xC;
    if ( v21 < v25 + 4 )
    {
LABEL_42:
      v14 = 0;
      is_last = 0;
LABEL_43:
      v9 = (v51 >> 8) | (v51 << 8);
      v37 = (v49 >> 8) | (v49 << 8);
      v11 = rrfilter(header, v11, 0);
      goto LABEL_32;
    }
    if ( !replace )
    {
      v43 = 0;
      while ( v27 != optno )
      {
        v43 += v25 + 4;
        v19 = &v28[v25];
        if ( v43 + 4 >= v21 )
          goto LABEL_20;
        v44 = v28[v25];
        v28 = v19 + 4;
        v45 = v19[2] | (v19[3] << 8);
        v46 = v44 | (v19[1] << 8);
        v25 = (unsigned __int16)((v45 >> 8) | ((_WORD)v45 << 8));
        v27 = (unsigned __int16)((v46 >> 8) | ((_WORD)v46 << 8));
        if ( v25 + v43 + 4 > v21 )
          goto LABEL_42;
      }
      return v11;
    }
    v29 = v15;
    while ( 1 )
    {
      if ( v27 == optno )
      {
        v21 -= v26;
        memcpy(v19, &v19[v25 + 4], v21 - v22);
        v29[7] = v21;
        v29[6] = (unsigned int)(v21 << 16) >> 24;
      }
      else
      {
        v19 = &v28[v25];
        v22 += v26;
      }
      if ( v22 + 4 >= v21 )
        break;
      v30 = v19[2] | (v19[3] << 8);
      v31 = *v19 | (v19[1] << 8);
      v25 = (unsigned __int16)((v30 >> 8) | ((_WORD)v30 << 8));
      v27 = (unsigned __int16)((v31 >> 8) | ((_WORD)v31 << 8));
      v28 = v19 + 4;
      if ( v25 + v22 + 4 > v21 )
      {
        v13 = 0;
        goto LABEL_42;
      }
      v26 = v25 + 4;
    }
    v15 = v29;
  }
LABEL_20:
  if ( !is_last )
  {
    if ( v21 )
    {
      v42 = (unsigned __int8 *)whine_malloc(v21);
      v14 = v42;
      if ( v42 )
        memcpy(v42, v48, v21);
      v13 = v21;
    }
    else
    {
      v13 = 0;
      v14 = 0;
    }
    goto LABEL_43;
  }
  v32 = v19 + 4;
  if ( limit - (v19 + 4) < (int)optlen )
    return v11;
  v33 = v15 + 6;
LABEL_23:
  v34 = optno == 0;
  if ( optno )
    v34 = replace == 2;
  if ( !v34 )
  {
    if ( limit < v32 )
      return v11;
    v19[1] = optno;
    v19[3] = optlen;
    v19[2] = optlen << 16 >> 24;
    *v19 = (unsigned int)(optno << 16) >> 24;
    v19 = &v32[optlen];
    if ( &v32[optlen] > limit )
      return v11;
    memcpy(v32, opt, optlen);
    *v33 = (unsigned int)((v19 - (_BYTE *)v48) << 16) >> 24;
    v33[1] = (_BYTE)v19 - (_BYTE)v48;
  }
  return v19 - (unsigned __int8 *)header;
}
