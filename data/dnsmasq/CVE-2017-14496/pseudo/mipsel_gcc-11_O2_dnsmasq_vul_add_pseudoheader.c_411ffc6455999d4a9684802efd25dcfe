size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v16; // $s0
  int v17; // $s4
  unsigned __int8 *v18; // $fp
  unsigned __int8 *v19; // $fp
  unsigned int v20; // $v0
  __int16 v21; // $s3
  unsigned int v22; // $v0
  signed int v23; // $s7
  size_t result; // $v0
  unsigned __int8 *v25; // $s6
  unsigned int v26; // $v0
  unsigned int v27; // $a0
  signed int v28; // $v1
  int v29; // $v0
  unsigned __int8 *v30; // $a1
  int v31; // $t1
  int v32; // $v0
  unsigned int v33; // $a1
  unsigned int v34; // $a0
  int v35; // $v1
  __int16 v36; // $s7
  int v37; // $a0
  unsigned __int8 *v38; // $v0
  _BYTE *v39; // $v0
  unsigned int v40; // $a2
  _BYTE *v41; // $s6
  _BYTE *v42; // $s3
  void *v43; // $a0
  size_t v44; // $s6
  int i; // [sp+20h] [-28h]
  unsigned __int8 *t_cp; // [sp+2Ch] [-1Ch]
  unsigned int v48; // [sp+30h] [-18h]
  unsigned int v49; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v16 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v16;
  v18 = pseudoheader;
  if ( !pseudoheader )
  {
    v36 = 0;
    v21 = (set_do != 0) << 15;
LABEL_17:
    v37 = skip_questions(header, v16);
    if ( v37 )
    {
      v39 = (_BYTE *)skip_section(
                       v37,
                       (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                     + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                     + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                       header,
                       v16);
      if ( v39 )
      {
        v40 = udp_sz >> 8;
        v39[4] = udp_sz;
        v41 = v39 + 0xB;
        v39[8] = v21;
        *v39 = 0;
        v39[1] = 0;
        v39[2] = 41;
        v39[3] = v40;
        v39[5] = HIBYTE(v36);
        v39[6] = v36;
        v39[7] = HIBYTE(v21);
        v42 = v39 + 9;
        v39[9] = BYTE1(v17);
        v39[10] = v17;
        LOWORD(t_cp) = (_WORD)v39 + 0xB;
        if ( v18 )
        {
          memcpy(v39 + 0xB, v18, v17);
          v25 = &v41[v17];
          free(v18);
        }
        else
        {
          v25 = v39 + 0xB;
        }
        v43 = v25 + 4;
        result = v16;
        if ( limit - (v25 + 4) < (int)optlen )
          return result;
        header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
        if ( !optno )
          return v25 - (unsigned __int8 *)header;
        goto LABEL_36;
      }
    }
    return v16;
  }
  v19 = udp_len;
  v20 = (udp_len[5] << 8) | udp_len[4];
  v49 = (udp_len[1] << 8) | *udp_len;
  v48 = (udp_len[3] << 8) | udp_len[2];
  v21 = ((_WORD)v20 << 8) | (v20 >> 8);
  if ( set_do )
  {
    v21 |= 0x8000u;
    udp_len[4] = HIBYTE(v21);
    v19[5] = v21;
  }
  v22 = (v19[7] << 8) | v19[6];
  t_cp = v19 + 8;
  v23 = (unsigned __int16)(((_WORD)v22 << 8) | (v22 >> 8));
  result = v16;
  if ( v16 < v19 + 8 - (unsigned __int8 *)header + v23 )
    return result;
  if ( !optno )
    return v16;
  v25 = v19 + 8;
  if ( v23 >= 5 )
  {
    v26 = (v19[11] << 8) | v19[10];
    v27 = (v19[9] << 8) | v19[8];
    v28 = (unsigned __int16)(((_WORD)v26 << 8) | (v26 >> 8));
    v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
    v30 = v19 + 0xC;
    if ( v23 >= v28 )
    {
      v25 = v19 + 8;
      v31 = 0;
      do
      {
        if ( v29 == optno )
        {
          v35 = v28 + 4;
          if ( !replace )
            return v16;
          v23 -= v35;
          i = v31;
          memcpy(v25, &v25[v35], v23 - v31);
          v31 = i;
          v19[6] = BYTE1(v23);
          v19[7] = v23;
        }
        else
        {
          v25 = &v30[v28];
          v31 += v28 + 4;
        }
        v32 = is_last;
        if ( v31 + 4 >= v23 )
          goto LABEL_21;
        v33 = (v25[3] << 8) | v25[2];
        v34 = (v25[1] << 8) | *v25;
        v28 = (unsigned __int16)(((_WORD)v33 << 8) | (v33 >> 8));
        v29 = (unsigned __int16)(((_WORD)v34 << 8) | (v34 >> 8));
        v30 = v25 + 4;
      }
      while ( v23 >= v28 + v31 );
    }
    is_last = 0;
    v18 = 0;
    goto LABEL_27;
  }
  v32 = is_last;
LABEL_21:
  if ( !v32 )
  {
    if ( v23 )
    {
      v38 = (unsigned __int8 *)whine_malloc(v23);
      v18 = v38;
      if ( v38 )
        memcpy(v38, t_cp, v23);
      v17 = v23;
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
LABEL_27:
    udp_sz = (unsigned __int16)(((_WORD)v49 << 8) | (v49 >> 8));
    v36 = ((_WORD)v48 << 8) | (v48 >> 8);
    v16 = rrfilter(header, v16, 0);
    goto LABEL_17;
  }
  v43 = v25 + 4;
  result = v16;
  if ( limit - (v25 + 4) < (int)optlen )
    return result;
  v42 = v19 + 6;
LABEL_36:
  if ( replace == 2 )
    return v25 - (unsigned __int8 *)header;
  v25[2] = BYTE1(optlen);
  *v25 = BYTE1(optno);
  v25[1] = optno;
  v25[3] = optlen;
  v44 = (size_t)v43 + optlen;
  memcpy(v43, opt, optlen);
  *v42 = (unsigned __int16)(v44 - (_WORD)t_cp) >> 8;
  v42[1] = v44 - (_BYTE)t_cp;
  return v44 - (_DWORD)header;
}
