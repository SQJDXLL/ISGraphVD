size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v15; // x20
  unsigned __int8 *pseudoheader; // x0
  char v19; // w27
  unsigned __int8 *v20; // x22
  unsigned __int8 v21; // w14
  unsigned __int8 v22; // w12
  unsigned __int8 v23; // w11
  unsigned __int8 v24; // w13
  unsigned __int64 v25; // x21
  int v26; // w23
  int v27; // w8
  unsigned __int16 *v28; // x28
  unsigned __int64 v29; // x26
  unsigned __int64 v30; // x9
  int v31; // w8
  unsigned __int8 v32; // w11
  unsigned __int8 v33; // w12
  unsigned __int8 v34; // w13
  void *v35; // x15
  unsigned __int8 v36; // w14
  __int64 v37; // x0
  void *v38; // x0
  unsigned __int8 *v39; // x0
  __int64 v40; // x0
  __int64 v41; // x26
  __uint16_t v42; // w28
  int v43; // w22
  __uint16_t v44; // w0
  __int64 v45; // x0
  int v46; // w25
  _WORD *v47; // x11
  size_t v48; // x2
  __int64 v49; // x21
  __uint16_t v50; // w0
  void *ptr; // [xsp+8h] [xbp-58h]
  void *ptra; // [xsp+8h] [xbp-58h]
  size_t v53; // [xsp+10h] [xbp-50h]
  _WORD *v54; // [xsp+18h] [xbp-48h]
  void *src; // [xsp+20h] [xbp-40h]
  unsigned __int8 *v56; // [xsp+28h] [xbp-38h]
  unsigned __int8 *v57; // [xsp+28h] [xbp-38h]
  unsigned __int8 v58; // [xsp+30h] [xbp-30h]
  unsigned __int8 v59; // [xsp+30h] [xbp-30h]
  unsigned __int8 v60; // [xsp+34h] [xbp-2Ch]
  unsigned __int8 v61; // [xsp+34h] [xbp-2Ch]
  unsigned __int8 v62; // [xsp+38h] [xbp-28h]
  unsigned __int8 v63; // [xsp+38h] [xbp-28h]
  unsigned __int8 v64; // [xsp+3Ch] [xbp-24h]
  unsigned __int8 v65; // [xsp+3Ch] [xbp-24h]
  unsigned __int8 *limita; // [xsp+40h] [xbp-20h]
  unsigned __int8 *limitb; // [xsp+40h] [xbp-20h]
  int is_last; // [xsp+50h] [xbp-10h] BYREF
  int is_sign; // [xsp+54h] [xbp-Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+58h] [xbp-8h] BYREF

  v15 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( set_do )
    v19 = 0x80;
  else
    v19 = 0;
  if ( !pseudoheader )
  {
    v32 = 0;
    v33 = 0;
    v34 = 0;
    LODWORD(v25) = 0;
    v35 = 0LL;
    v36 = HIBYTE(udp_sz);
LABEL_40:
    ptra = v35;
    v59 = v36;
    v61 = v34;
    v63 = v33;
    v65 = v32;
    v40 = skip_questions(header, v15);
    if ( !v40 )
      return v15;
    v41 = v40;
    limitb = limit;
    v57 = opt;
    v42 = _bswap_16(header->ancount);
    v43 = _bswap_16(header->nscount) + v42;
    v44 = _bswap_16(header->arcount);
    v45 = skip_section(v41, v43 + (unsigned int)v44, header, v15);
    if ( !v45 )
      return v15;
    limit = limitb;
    if ( v45 + 0xB > (unsigned __int64)limitb )
      return v15;
    *(_BYTE *)(v45 + 7) = v19;
    opt = v57;
    *(_BYTE *)(v45 + 3) = v59;
    *(_WORD *)v45 = 0;
    *(_BYTE *)(v45 + 5) = v63;
    *(_BYTE *)(v45 + 4) = udp_sz;
    *(_BYTE *)(v45 + 2) = 41;
    v46 = v45 + 0xB;
    *(_BYTE *)(v45 + 6) = v65;
    v29 = v45 + 0xB;
    *(_BYTE *)(v45 + 8) = v61;
    *(_BYTE *)(v45 + 9) = BYTE1(v25);
    v47 = (_WORD *)(v45 + 9);
    *(_BYTE *)(v45 + 10) = v25;
    if ( ptra )
    {
      v48 = (int)v25;
      v29 = v45 + 0xB + (int)v25;
      if ( v29 > (unsigned __int64)limitb )
      {
        free(ptra);
        return v15;
      }
      v49 = v45 + 9;
      memcpy((void *)(v45 + 0xB), ptra, v48);
      free(ptra);
      v47 = (_WORD *)v49;
    }
    v54 = v47;
    LODWORD(src) = v46;
    if ( (__int64)&limitb[-v29 - 4] >= (int)optlen )
    {
      v50 = _bswap_16(header->arcount);
      header->arcount = _bswap_16(v50 + 1);
    }
LABEL_33:
    v39 = (unsigned __int8 *)(v29 + 4);
    if ( (__int64)&limit[-v29 - 4] < (int)optlen )
      return v15;
    if ( optno && replace != 2 )
    {
      if ( v39 > limit )
        return v15;
      *(_BYTE *)(v29 + 1) = optno;
      *(_BYTE *)(v29 + 3) = optlen;
      *(_BYTE *)v29 = BYTE1(optno);
      *(_BYTE *)(v29 + 2) = BYTE1(optlen);
      v29 = (unsigned __int64)&v39[optlen];
      if ( &v39[optlen] > limit )
        return v15;
      memcpy(v39, opt, optlen);
      *v54 = bswap32(v29 - (_DWORD)src) >> 16;
    }
    return v29 - (_QWORD)header;
  }
  limita = limit;
  v20 = udp_len;
  v21 = *udp_len;
  LOBYTE(udp_sz) = udp_len[1];
  v22 = udp_len[2];
  v23 = udp_len[3];
  v19 = udp_len[4];
  v24 = udp_len[5];
  if ( set_do )
  {
    v19 |= 0x80u;
    udp_len[4] = v19;
  }
  v25 = bswap64((unsigned __int64)*((unsigned __int16 *)v20 + 3) << 48);
  v54 = v20 + 6;
  src = v20 + 8;
  if ( !optno || v20 + 8 - (unsigned __int8 *)header + v25 > v15 )
    return v15;
  v53 = optlen;
  v56 = opt;
  v62 = v22;
  v64 = v23;
  v60 = v24;
  v58 = v21;
  if ( (unsigned int)v25 < 5 )
  {
    v28 = (unsigned __int16 *)(v20 + 8);
LABEL_22:
    if ( is_last )
    {
      v35 = 0LL;
      v31 = 1;
      v29 = (unsigned __int64)v28;
      goto LABEL_24;
    }
LABEL_27:
    if ( (_DWORD)v25 && (v38 = (void *)whine_malloc((int)v25)) != 0LL )
    {
      ptr = v38;
      memcpy(v38, src, (int)v25);
    }
    else
    {
      ptr = 0LL;
    }
    optlen = v53;
    opt = v56;
    limit = limita;
    v37 = rrfilter(header, v15, 0LL);
    v33 = v62;
    v32 = v64;
    v34 = v60;
    v36 = v58;
    v35 = ptr;
    v29 = 0LL;
LABEL_32:
    v15 = v37;
    if ( v29 )
      goto LABEL_33;
    goto LABEL_40;
  }
  v26 = 0;
  v27 = 4;
  v28 = (unsigned __int16 *)(v20 + 8);
  while ( 1 )
  {
    v29 = (unsigned __int64)(v28 + 2);
    v30 = bswap64((unsigned __int64)v28[1] << 48);
    if ( (int)v30 + v27 > (int)v25 )
    {
      LODWORD(v25) = 0;
      is_last = 0;
      goto LABEL_27;
    }
    if ( bswap32(*v28 << 16) == optno )
      break;
    v28 = (unsigned __int16 *)(v29 + v30);
    v26 += v30 + 4;
LABEL_14:
    v27 = v26 + 4;
    if ( v26 + 4 >= (int)v25 )
      goto LABEL_22;
  }
  v31 = replace;
  if ( replace )
  {
    LODWORD(v25) = v25 - v30 - 4;
    memcpy(v28, (const void *)(v29 + v30), (int)v25 - v26);
    *((_WORD *)v20 + 3) = bswap32(v25) >> 16;
    goto LABEL_14;
  }
  v35 = 0LL;
LABEL_24:
  optlen = v53;
  opt = v56;
  limit = limita;
  v33 = v62;
  v32 = v64;
  v34 = v60;
  v36 = v58;
  v37 = v15;
  if ( v31 )
    goto LABEL_32;
  return v15;
}
