size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int16 *ptr; // esi
  unsigned __int8 *v10; // ebp
  __int16 v11; // si
  unsigned __int8 v12; // bl
  __int16 v13; // cx
  unsigned __int8 v14; // dl
  unsigned __int16 v15; // ax
  int v16; // edi
  unsigned __int16 v17; // dx
  unsigned __int16 v18; // ax
  int v19; // ecx
  int v20; // ebp
  int v21; // edi
  _BYTE *v22; // ebp
  unsigned __int8 *v24; // eax
  char *v25; // esi
  int v26; // ebx
  _BYTE *v27; // eax
  _BYTE *v28; // ebp
  unsigned __int8 *v29; // [esp+18h] [ebp-54h]
  size_t rdlen; // [esp+28h] [ebp-44h]
  unsigned __int8 *v32; // [esp+34h] [ebp-38h]
  unsigned __int8 *p; // [esp+38h] [ebp-34h]
  unsigned __int16 flags; // [esp+3Ch] [ebp-30h]
  unsigned __int16 rcode; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  ptr = (unsigned __int16 *)find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !ptr )
  {
    flags = (set_do != 0) << 15;
    rcode = 0;
    goto LABEL_34;
  }
  v10 = t_cp;
  v11 = *t_cp;
  v12 = t_cp[1];
  v13 = t_cp[2];
  v14 = t_cp[3];
  v15 = _byteswap_ushort(*((_WORD *)t_cp + 2));
  flags = v15;
  if ( set_do )
  {
    flags = v15 | 0x8000;
    t_cp[4] = (unsigned __int16)(v15 | 0x8000) >> 8;
    v10[5] = v15;
  }
  v16 = (v10[6] << 8) | v10[7];
  p = v10 + 8;
  if ( v16 + v10 + 8 - (unsigned __int8 *)header <= plen && optno )
  {
    udp_sz = v12 | (unsigned __int16)(v11 << 8);
    rcode = v14 | (unsigned __int16)(v13 << 8);
    if ( v16 <= 4 )
    {
      if ( is_last[0] )
      {
        ptr = (unsigned __int16 *)(v10 + 8);
        goto LABEL_20;
      }
    }
    else
    {
      v17 = _byteswap_ushort(*((_WORD *)v10 + 4));
      v18 = _byteswap_ushort(*((_WORD *)v10 + 5));
      v29 = v10 + 12;
      v19 = v18;
      if ( v16 < v18 )
      {
LABEL_10:
        is_last[0] = 0;
        ptr = 0;
LABEL_11:
        plen = rrfilter(header, plen, 0);
        goto LABEL_34;
      }
      ptr = (unsigned __int16 *)(v10 + 8);
      v32 = v10;
      v20 = (v10[6] << 8) | v10[7];
      v21 = 0;
      while ( 1 )
      {
        if ( v17 == optno )
        {
          if ( !replace )
            return plen;
          v20 -= v19 + 4;
          memcpy(ptr, (char *)ptr + v18 + 4, v20 - v21);
          v32[6] = BYTE1(v20);
          v32[7] = v20;
        }
        else
        {
          ptr = (unsigned __int16 *)&v29[v18];
          v21 += v19 + 4;
        }
        if ( v21 + 4 >= v20 )
          break;
        v17 = _byteswap_ushort(*ptr);
        v18 = _byteswap_ushort(ptr[1]);
        v29 = (unsigned __int8 *)(ptr + 2);
        v19 = v18;
        if ( v18 + v21 > v20 )
          goto LABEL_10;
      }
      v16 = v20;
      v10 = v32;
      if ( is_last[0] )
      {
        if ( ptr )
        {
LABEL_20:
          if ( limit - (unsigned __int8 *)(ptr + 2) < (int)optlen )
            return plen;
          v22 = v10 + 6;
LABEL_22:
          if ( optno && replace != 2 )
          {
            *(_BYTE *)ptr = BYTE1(optno);
            *((_BYTE *)ptr + 1) = optno;
            *((_BYTE *)ptr + 2) = BYTE1(optlen);
            *((_BYTE *)ptr + 3) = optlen;
            v25 = (char *)(ptr + 2);
            memcpy(v25, opt, optlen);
            ptr = (unsigned __int16 *)&v25[optlen];
            *v22 = (unsigned __int16)((_WORD)ptr - (_WORD)p) >> 8;
            v22[1] = (_BYTE)ptr - (_BYTE)p;
          }
          return (char *)ptr - (char *)header;
        }
        rdlen = v16;
LABEL_34:
        v26 = skip_questions(header, plen);
        if ( !v26 )
          return plen;
        v27 = (_BYTE *)skip_section(
                         v26,
                         (unsigned __int16)__ROL2__(header->arcount, 8)
                       + (unsigned __int16)__ROL2__(header->ancount, 8)
                       + (unsigned __int16)__ROL2__(header->nscount, 8),
                         header,
                         plen);
        v28 = v27;
        if ( !v27 )
          return plen;
        *v27 = 0;
        v27[1] = 0;
        v27[2] = 41;
        v27[3] = HIBYTE(udp_sz);
        v27[4] = udp_sz;
        v27[5] = HIBYTE(rcode);
        v27[6] = rcode;
        v27[7] = HIBYTE(flags);
        v27[8] = flags;
        v27[9] = BYTE1(rdlen);
        v27[10] = rdlen;
        LOWORD(p) = (_WORD)v27 + 11;
        if ( ptr )
        {
          LOWORD(p) = (_WORD)v27 + 11;
          memcpy(v27 + 11, ptr, rdlen);
          free(ptr);
          ptr = (unsigned __int16 *)&v28[rdlen + 11];
        }
        else
        {
          ptr = (unsigned __int16 *)(v27 + 11);
        }
        if ( limit - (unsigned __int8 *)(ptr + 2) < (int)optlen )
          return plen;
        v22 = v28 + 9;
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
        goto LABEL_22;
      }
    }
    if ( v16 )
    {
      v24 = (unsigned __int8 *)whine_malloc(v16);
      ptr = (unsigned __int16 *)v24;
      rdlen = v16;
      if ( v24 )
      {
        memcpy(v24, p, v16);
        rdlen = v16;
      }
    }
    else
    {
      rdlen = 0;
      ptr = 0;
    }
    goto LABEL_11;
  }
  return plen;
}
