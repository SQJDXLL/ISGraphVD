size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // rax
  int v13; // r8d
  unsigned __int8 *v14; // rbp
  unsigned __int8 *v15; // rax
  __int16 v16; // r15
  __int16 v17; // r12
  __int16 v18; // dx
  char *v19; // r14
  int v20; // r8d
  int v21; // r9d
  unsigned __int8 *v22; // rdx
  unsigned __int16 v23; // di
  unsigned __int8 *v24; // rsi
  unsigned __int64 v25; // rcx
  int v26; // r8d
  unsigned __int8 *v27; // rax
  __int64 v28; // rax
  __int16 v29; // r14
  _WORD *v30; // rax
  __int64 v31; // rdi
  unsigned __int16 v32; // dx
  unsigned __int16 v33; // ax
  __int64 v34; // rax
  int v35; // r8d
  __int16 v36; // dx
  unsigned __int8 *v37; // r12
  u16 v38; // cx
  char v39; // t2
  __int16 v40; // cx
  size_t plena; // [rsp+0h] [rbp-88h]
  __int16 v44; // [rsp+10h] [rbp-78h]
  int v45; // [rsp+10h] [rbp-78h]
  __int64 v46; // [rsp+10h] [rbp-78h]
  unsigned __int64 v48; // [rsp+20h] [rbp-68h]
  int v49; // [rsp+20h] [rbp-68h]
  int rdlen; // [rsp+2Ch] [rbp-5Ch]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *t_cp[9]; // [rsp+40h] [rbp-48h] BYREF

  plena = plen;
  t_cp[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, t_cp, &is_sign, &is_last);
  v13 = is_sign;
  if ( is_sign )
    return plena;
  v14 = pseudoheader;
  if ( pseudoheader )
  {
    v15 = t_cp[0];
    v16 = *(_WORD *)t_cp[0];
    v44 = *((_WORD *)t_cp[0] + 1);
    v17 = __ROL2__(*((_WORD *)t_cp[0] + 2), 8);
    if ( set_do )
    {
      v17 |= 0x8000u;
      LOBYTE(v18) = HIBYTE(v17);
      HIBYTE(v18) = v17;
      *((_WORD *)t_cp[0] + 2) = v18;
    }
    v19 = (char *)(v15 + 8);
    LOWORD(v20) = __ROL2__(*((_WORD *)v15 + 3), 8);
    if ( plen >= (unsigned __int64)(unsigned __int16)v20 + v15 + 8 - (unsigned __int8 *)header && optno )
    {
      v20 = (unsigned __int16)v20;
      v21 = 0;
      v22 = v15 + 8;
      while ( v21 + 4 < v20 )
      {
        LOWORD(plen) = __ROL2__(*((_WORD *)v22 + 1), 8);
        v23 = __ROL2__(*(_WORD *)v22, 8);
        if ( (unsigned __int16)plen + v21 > v20 )
        {
          is_last = 0;
          goto LABEL_17;
        }
        if ( v23 == optno )
        {
          if ( !replace )
            return plena;
          v20 -= (unsigned __int16)plen + 4;
          v24 = &v22[(unsigned __int16)plen + 4];
          v25 = v20 - v21;
          qmemcpy(v22, v24, v25);
          plen = (size_t)&v24[v25];
          LOBYTE(v25) = BYTE1(v20);
          BYTE1(v25) = v20;
          *((_WORD *)v15 + 3) = v25;
        }
        else
        {
          plen = (unsigned __int16)plen;
          v21 += (unsigned __int16)plen + 4;
          v22 += (unsigned __int16)plen + 4;
        }
      }
      if ( !is_last )
      {
        if ( v20 )
        {
          rdlen = v20;
          v48 = v20;
          v27 = (unsigned __int8 *)whine_malloc(v20, plen, v22);
          v26 = rdlen;
          v14 = v27;
          if ( v27 )
            qmemcpy(v27, v19, v48);
        }
        else
        {
LABEL_17:
          v26 = 0;
          v14 = 0LL;
        }
        v49 = v26;
        udp_sz = __ROL2__(v16, 8);
        v28 = rrfilter(header, plena, 0LL);
        v29 = __ROL2__(v44, 8);
        v13 = v49;
        plena = v28;
        goto LABEL_23;
      }
      v30 = v15 + 6;
      goto LABEL_30;
    }
  }
  else
  {
    v29 = 0;
    v17 = (set_do != 0) << 15;
LABEL_23:
    v45 = v13;
    v31 = skip_questions(header, plena);
    if ( v31 )
    {
      HIBYTE(v32) = header->nscount;
      LOBYTE(v32) = HIBYTE(header->nscount);
      HIBYTE(v33) = header->arcount;
      LOBYTE(v33) = HIBYTE(header->arcount);
      v34 = skip_section(v31, v33 + v32 + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8), header, plena);
      if ( v34 )
      {
        v35 = v45;
        *(_WORD *)v34 = 0;
        *(_WORD *)(v34 + 5) = __ROL2__(v29, 8);
        v19 = (char *)(v34 + 11);
        *(_BYTE *)(v34 + 2) = 41;
        LOBYTE(v36) = BYTE1(v45);
        HIBYTE(v36) = v45;
        *(_WORD *)(v34 + 3) = __ROL2__(udp_sz, 8);
        *(_WORD *)(v34 + 7) = __ROL2__(v17, 8);
        *(_WORD *)(v34 + 9) = v36;
        v22 = (unsigned __int8 *)(v34 + 11);
        if ( v14 )
        {
          v46 = v34;
          qmemcpy(v19, v14, v35);
          v37 = (unsigned __int8 *)&v19[v35];
          free(v14);
          v34 = v46;
          v22 = v37;
        }
        if ( limit - (v22 + 4) >= (__int64)optlen )
        {
          HIBYTE(v38) = header->arcount;
          LOBYTE(v38) = HIBYTE(header->arcount);
          ++v38;
          v39 = HIBYTE(v38);
          HIBYTE(v38) = v38;
          LOBYTE(v38) = v39;
          header->arcount = v38;
        }
        v30 = (_WORD *)(v34 + 9);
LABEL_30:
        if ( limit - (v22 + 4) >= (__int64)optlen )
        {
          if ( optno && replace != 2 )
          {
            *(_WORD *)v22 = __ROL2__(optno, 8);
            LOBYTE(v40) = BYTE1(optlen);
            HIBYTE(v40) = optlen;
            *((_WORD *)v22 + 1) = v40;
            qmemcpy(v22 + 4, opt, optlen);
            v22 += optlen + 4;
            HIBYTE(v40) = (_BYTE)v22 - (_BYTE)v19;
            LOBYTE(v40) = (unsigned __int16)((_WORD)v22 - (_WORD)v19) >> 8;
            *v30 = v40;
          }
          return v22 - (unsigned __int8 *)header;
        }
      }
    }
  }
  return plena;
}
