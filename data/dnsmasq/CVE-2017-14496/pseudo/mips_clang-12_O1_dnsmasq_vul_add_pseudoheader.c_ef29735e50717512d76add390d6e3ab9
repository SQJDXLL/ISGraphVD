int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  _WORD *v13; // $fp
  size_t v16; // $s1
  unsigned __int8 v18; // $s2
  unsigned __int8 *pseudoheader; // $v0
  int v21; // $a2
  unsigned __int8 *v22; // $fp
  unsigned __int8 v23; // $v0
  char v24; // $at
  unsigned int v25; // $v1
  unsigned __int8 v26; // $a0
  unsigned __int8 v27; // $a1
  int v28; // $s5
  unsigned __int8 *v29; // $s4
  int v30; // $v0
  int v31; // $s6
  unsigned __int8 *v32; // $s7
  int v33; // $v0
  unsigned __int8 *v34; // $s4
  unsigned __int8 *v35; // $a1
  int v36; // $s4
  void *v37; // $v0
  void *v38; // $s7
  _BYTE *v39; // $s3
  int v40; // $v0
  int v41; // $s4
  int v42; // $fp
  int v43; // $v0
  int v44; // $s6
  _BYTE *v45; // $v0
  _BYTE *v46; // $fp
  __uint16_t v47; // $v0
  int v48; // [sp+18h] [-30h]
  int v49; // [sp+18h] [-30h]
  void *src; // [sp+1Ch] [-2Ch]
  unsigned __int8 v51; // [sp+23h] [-25h]
  unsigned __int8 v52; // [sp+23h] [-25h]
  unsigned __int8 v53; // [sp+27h] [-21h]
  unsigned __int8 v54; // [sp+27h] [-21h]
  unsigned __int8 v55; // [sp+2Bh] [-1Dh]
  char v56; // [sp+2Bh] [-1Dh]
  unsigned __int8 v57; // [sp+2Fh] [-19h]
  void *v58; // [sp+30h] [-18h]
  unsigned __int8 *v59; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v62; // [sp+44h] [-4h] BYREF

  v16 = plen;
  v18 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v62, &is_sign, &is_last);
  if ( is_sign )
    return v16;
  v21 = optno;
  v59 = limit;
  if ( pseudoheader )
  {
    v22 = v62;
    v23 = v62[4];
    if ( set_do )
    {
      v57 = v23 | 0x80;
      v62[4] = v23 | 0x80;
    }
    else
    {
      v57 = v62[4];
    }
    v18 = v22[3];
    LOBYTE(udp_sz) = v22[1];
    v28 = (v22[6] << 8) | v22[7];
    src = v22 + 8;
    if ( !optno || v16 < v22 + 8 - (unsigned __int8 *)header + v28 )
      return v16;
    v58 = 0;
    v51 = v22[5];
    v53 = v22[2];
    v55 = *v22;
    if ( (unsigned int)v28 < 5 )
    {
      v32 = v22 + 8;
    }
    else
    {
      v31 = 0;
      v32 = v22 + 8;
      while ( 1 )
      {
        v33 = (v32[2] << 8) | v32[3];
        v34 = v32 + 4;
        if ( v28 < v33 + v31 )
          break;
        if ( ((*v32 << 8) | v32[1]) == v21 )
        {
          if ( !replace )
            return v16;
          v35 = &v34[v33];
          v28 = v28 - v33 - 4;
          v36 = v21;
          memcpy(v32, v35, v28 - v31);
          v21 = v36;
          *((_WORD *)v22 + 3) = v28;
        }
        else
        {
          v32 = &v34[v33];
          v31 += v33 + 4;
        }
        if ( v31 + 4 >= v28 )
          goto LABEL_24;
      }
      is_last = 0;
      v28 = 0;
      v32 += 4;
    }
LABEL_24:
    if ( is_last )
    {
      v29 = v32;
      v30 = v16;
      LOBYTE(v25) = v55;
      v26 = v53;
      v27 = v51;
      v13 = v22 + 6;
    }
    else
    {
      v48 = v21;
      v29 = 0;
      v37 = 0;
      if ( v28 )
      {
        v38 = (void *)whine_malloc(v28);
        v37 = 0;
        if ( v38 )
        {
          memcpy(v38, src, v28);
          v37 = v38;
        }
      }
      v58 = v37;
      v30 = rrfilter(header, v16, 0);
      v21 = v48;
      LOBYTE(v25) = v55;
      v26 = v53;
      v27 = v51;
      v13 = v22 + 6;
    }
  }
  else
  {
    v24 = 0x80;
    if ( !set_do )
      v24 = 0;
    v57 = v24;
    v25 = udp_sz >> 8;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v58 = 0;
    v29 = 0;
    v30 = v16;
  }
  v16 = v30;
  if ( !v29 )
  {
    v52 = v27;
    v54 = v26;
    v56 = v25;
    v49 = v21;
    v40 = skip_questions(header, v30);
    if ( !v40 )
      return v16;
    v41 = v40;
    v42 = _bswap_16(header->ancount);
    v44 = _bswap_16(header->nscount) + v42;
    v43 = _bswap_16(header->arcount);
    v45 = (_BYTE *)skip_section(v41, v44 + v43, header, v16);
    if ( !v45 )
      return v16;
    v46 = v45;
    v45[10] = v28;
    v45[8] = v52;
    v45[7] = v57;
    v45[6] = v18;
    v45[5] = v54;
    v45[4] = udp_sz;
    v45[3] = v56;
    v45[2] = 41;
    v45[1] = 0;
    *v45 = 0;
    v45[9] = BYTE2(v28);
    v29 = v45 + 0xB;
    if ( v58 )
    {
      memcpy(v45 + 0xB, v58, v28);
      free(v58);
      v29 = &v46[v28 + 0xB];
    }
    LOWORD(src) = (_WORD)v46 + 0xB;
    v13 = v46 + 9;
    if ( v59 - v29 - 4 >= (int)optlen )
    {
      v47 = _bswap_16(header->arcount);
      header->arcount = _bswap_16(v47 + 1);
    }
    v21 = v49;
  }
  v39 = v29 + 4;
  if ( v59 - (v29 + 4) >= (int)optlen )
  {
    if ( v21 && replace != 2 )
    {
      v29[3] = optlen;
      v29[1] = v21;
      v29[2] = BYTE2(optlen);
      *v29 = BYTE2(v21);
      memcpy(v29 + 4, opt, optlen);
      v29 = &v39[optlen];
      *v13 = (_WORD)v39 + optlen - (_WORD)src;
    }
    return v29 - (unsigned __int8 *)header;
  }
  return v16;
}
