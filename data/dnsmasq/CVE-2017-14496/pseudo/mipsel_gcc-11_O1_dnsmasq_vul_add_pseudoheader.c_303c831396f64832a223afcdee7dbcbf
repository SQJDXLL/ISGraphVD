size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int t_sa,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v14; // $s4
  unsigned __int8 *pseudoheader; // $v0
  int v16; // $fp
  unsigned __int8 *v17; // $s0
  unsigned __int8 *v18; // $s2
  __int16 v19; // $a0
  __int16 v20; // $a2
  __int16 v21; // $v1
  unsigned __int16 v22; // $s7
  __int16 v23; // $a1
  int v24; // $s1
  __int16 v25; // $a0
  unsigned __int8 *v26; // $a2
  int v27; // $v0
  int v28; // $a1
  int v29; // $v1
  int v30; // $s3
  int v31; // $v1
  unsigned __int8 *v32; // $v0
  _BYTE *v33; // $s2
  char *v34; // $s0
  unsigned __int8 *v35; // $v0
  int v36; // $a0
  _BYTE *v37; // $v0
  _BYTE *v38; // $s2
  _BYTE *v39; // $s1
  unsigned __int8 *p; // [sp+28h] [-18h]
  __int16 t_s_0; // [sp+2Ch] [-14h]
  unsigned __int8 *udp_len; // [sp+30h] [-10h] BYREF
  int is_sign; // [sp+34h] [-Ch] BYREF
  int is_last; // [sp+38h] [-8h] BYREF

  v14 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v14;
  v17 = pseudoheader;
  if ( !pseudoheader )
  {
    v22 = (set_do != 0) << 15;
    t_s_0 = 0;
    goto LABEL_33;
  }
  v18 = udp_len;
  v19 = *udp_len;
  v20 = udp_len[1];
  v21 = udp_len[2];
  v22 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  v23 = udp_len[3];
  if ( set_do )
  {
    v22 |= 0x8000u;
    udp_len[4] = HIBYTE(v22);
    v18[5] = v22;
  }
  v24 = (v18[6] << 8) | v18[7];
  v17 = v18 + 8;
  p = v18 + 8;
  if ( v14 < v18 + 8 - (unsigned __int8 *)header + v24 )
    return v14;
  v25 = v19 << 8;
  if ( !optno )
    return v14;
  udp_sz = v25 | v20;
  t_s_0 = (v21 << 8) | v23;
  v26 = v18 + 0xC;
  if ( v24 < 5 )
  {
    v17 = v18 + 8;
    if ( is_last )
    {
      v32 = v18 + 0xC;
      goto LABEL_21;
    }
    goto LABEL_25;
  }
  v27 = (v18[8] << 8) | v18[9];
  v28 = (v18[10] << 8) | v18[11];
  v29 = v28;
  if ( v24 < v28 )
  {
LABEL_10:
    is_last = 0;
    v17 = 0;
LABEL_11:
    v14 = rrfilter(header, v14, 0);
LABEL_33:
    v36 = skip_questions(header, v14);
    if ( !v36 )
      return v14;
    v37 = (_BYTE *)skip_section(
                     v36,
                     (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                   + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                   + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                     header,
                     v14);
    v38 = v37;
    if ( !v37 )
      return v14;
    *v37 = 0;
    v37[1] = 0;
    v37[2] = 41;
    v37[3] = HIBYTE(udp_sz);
    v37[4] = udp_sz;
    v37[5] = HIBYTE(t_s_0);
    v37[6] = t_s_0;
    v37[7] = HIBYTE(v22);
    v37[8] = v22;
    v37[9] = BYTE1(v16);
    v37[10] = v16;
    v39 = v37 + 0xB;
    LOWORD(p) = (_WORD)v37 + 0xB;
    if ( v17 )
    {
      memcpy(v37 + 0xB, v17, v16);
      free(v17);
      v17 = &v39[v16];
    }
    else
    {
      v17 = v37 + 0xB;
    }
    if ( limit - (v17 + 4) < (int)optlen )
      return v14;
    v33 = v38 + 9;
    header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
    if ( !optno )
      return v17 - (unsigned __int8 *)header;
    goto LABEL_23;
  }
  v30 = 0;
  while ( 1 )
  {
    if ( v27 == optno )
    {
      v31 = v29 + 4;
      if ( !replace )
        return v14;
      v24 -= v31;
      memcpy(v17, &v17[v28 + 4], v24 - v30);
      v18[6] = BYTE1(v24);
      v18[7] = v24;
    }
    else
    {
      v17 = &v26[v28];
      v30 += v29 + 4;
    }
    v26 = v17 + 4;
    if ( v30 + 4 >= v24 )
      break;
    v27 = (*v17 << 8) | v17[1];
    v28 = (v17[2] << 8) | v17[3];
    v29 = v28;
    if ( v24 < v28 + v30 )
      goto LABEL_10;
  }
  if ( !is_last )
  {
LABEL_25:
    if ( v24 )
    {
      v35 = (unsigned __int8 *)whine_malloc(v24);
      v17 = v35;
      if ( v35 )
        memcpy(v35, p, v24);
      v16 = v24;
    }
    else
    {
      v16 = 0;
      v17 = 0;
    }
    goto LABEL_11;
  }
  v16 = v24;
  if ( !v17 )
    goto LABEL_33;
  v32 = v17 + 4;
LABEL_21:
  if ( limit - v32 < (int)optlen )
    return v14;
  v33 = v18 + 6;
LABEL_23:
  v14 = v17 - (unsigned __int8 *)header;
  if ( replace != 2 )
  {
    *v17 = BYTE1(optno);
    v17[1] = optno;
    v17[2] = BYTE1(optlen);
    v17[3] = optlen;
    v34 = (char *)(v17 + 4);
    memcpy(v34, opt, optlen);
    v17 = (unsigned __int8 *)&v34[optlen];
    *v33 = (unsigned __int16)((_WORD)v17 - (_WORD)p) >> 8;
    v33[1] = (_BYTE)v17 - (_BYTE)p;
    return v17 - (unsigned __int8 *)header;
  }
  return v14;
}
