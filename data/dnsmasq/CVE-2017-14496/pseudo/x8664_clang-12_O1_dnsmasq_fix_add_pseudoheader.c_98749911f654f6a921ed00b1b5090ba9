size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v11; // ebx
  size_t v13; // r13
  dns_header *v14; // r12
  unsigned __int8 *pseudoheader; // rax
  int v17; // esi
  unsigned __int16 *v18; // rsi
  __int16 v19; // ax
  __int64 v20; // rdx
  __int64 v21; // rcx
  unsigned __int16 *v22; // rbx
  void *v23; // r8
  char v24; // r13
  unsigned int v25; // r15d
  int v26; // r13d
  int v27; // ecx
  int v28; // r12d
  unsigned __int64 v29; // rax
  unsigned __int16 *v30; // rbp
  _BYTE *v31; // rbp
  size_t v32; // rdx
  unsigned __int16 *v33; // rax
  const void *v34; // rsi
  unsigned __int16 *v35; // rbp
  unsigned __int64 v36; // rsi
  __int64 v37; // r9
  __int64 v38; // rax
  unsigned int v39; // ebp
  void *v40; // rax
  void *v41; // r15
  bool v42; // zf
  __int64 v43; // rdx
  unsigned __int8 *v44; // rdi
  __int64 v45; // rax
  size_t v46; // rbx
  __int64 v47; // r13
  int v48; // r15d
  int v49; // ebp
  __uint16_t v50; // ax
  __int64 v51; // rax
  __int64 v52; // rsi
  char *v53; // r13
  __int64 v54; // rcx
  void *v55; // rbp
  unsigned __int16 *v56; // r14
  __uint16_t v57; // ax
  unsigned int v58; // [rsp+4h] [rbp-84h]
  size_t v59; // [rsp+8h] [rbp-80h]
  unsigned __int16 v60; // [rsp+14h] [rbp-74h]
  __int16 v61; // [rsp+14h] [rbp-74h]
  void *src; // [rsp+20h] [rbp-68h]
  __int16 srca; // [rsp+20h] [rbp-68h]
  unsigned __int8 *v64; // [rsp+28h] [rbp-60h]
  unsigned __int8 *v65; // [rsp+28h] [rbp-60h]
  __int16 v66; // [rsp+30h] [rbp-58h]
  int is_last; // [rsp+34h] [rbp-54h] BYREF
  void *ptr; // [rsp+38h] [rbp-50h]
  int is_sign; // [rsp+44h] [rbp-44h] BYREF
  void *v70; // [rsp+48h] [rbp-40h]
  unsigned __int8 *v71; // [rsp+50h] [rbp-38h] BYREF

  v11 = udp_sz;
  v13 = plen;
  v14 = header;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v71, &is_sign, &is_last);
  if ( is_sign )
    return v13;
  v70 = opt;
  LODWORD(opt) = 0;
  v58 = optno;
  v17 = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v17) = set_do != 0;
    v36 = (unsigned int)(v17 << 15);
    v66 = v36;
    v61 = 0;
    v23 = 0LL;
    v30 = 0LL;
    v37 = v58;
    v21 = v11;
    goto LABEL_30;
  }
  v18 = (unsigned __int16 *)v71;
  v19 = __ROL2__(*((_WORD *)v71 + 2), 8);
  v64 = limit;
  v59 = v13;
  if ( set_do )
  {
    v19 |= 0x8000u;
    v71[4] = HIBYTE(v19);
  }
  v20 = (unsigned int)optno;
  v21 = *v18;
  v60 = v18[1];
  opt = (unsigned __int8 *)_byteswap_uint64((unsigned __int64)v18[3] << 48);
  v22 = v18 + 4;
  v23 = 0LL;
  v24 = 0;
  src = v18 + 4;
  v66 = v19;
  if ( !optno || (unsigned __int64)&opt[(char *)v22 - (char *)header] > v59 )
  {
    v30 = v18 + 4;
    v38 = v59;
    goto LABEL_28;
  }
  v25 = *v18;
  if ( (unsigned int)opt >= 5 )
  {
    v26 = 0;
    v27 = 4;
    v28 = (int)opt;
    while ( 1 )
    {
      v29 = _byteswap_uint64((unsigned __int64)v22[1] << 48);
      v30 = v22 + 2;
      if ( (int)v29 + v27 > v28 )
      {
        is_last = 0;
        v28 = 0;
        v22 += 2;
        goto LABEL_20;
      }
      LODWORD(opt) = v28;
      if ( _byteswap_ulong(*v22 << 16) == (_DWORD)v20 )
      {
        if ( !replace )
        {
          v24 = 0;
          v23 = 0LL;
          v38 = v59;
          v14 = header;
          v21 = v25;
          goto LABEL_28;
        }
        v28 = v28 - v29 - 4;
        v31 = (char *)v30 + v29;
        v32 = (int)opt - (int)v29 - 4 - v26;
        v33 = v18;
        v34 = v31;
        v35 = v33;
        memcpy(v22, v34, v32);
        v18 = v35;
        v20 = v58;
        v35[3] = __ROL2__(v28, 8);
      }
      else
      {
        v26 += v29 + 4;
        v22 = (unsigned __int16 *)((char *)v30 + (unsigned int)v29);
      }
      v27 = v26 + 4;
      if ( v26 + 4 >= v28 )
        goto LABEL_20;
    }
  }
  v28 = (int)opt;
LABEL_20:
  LODWORD(opt) = v28;
  v24 = 1;
  v21 = v25;
  if ( is_last )
  {
    v23 = 0LL;
    v30 = v22;
    v38 = v59;
    v14 = header;
  }
  else
  {
    ptr = v18;
    v39 = v25;
    if ( v28 && (v40 = (void *)whine_malloc(v28, v18, v20, v25, v23)) != 0LL )
    {
      v41 = v40;
      memcpy(v40, src, v28);
    }
    else
    {
      v41 = 0LL;
    }
    v14 = header;
    v38 = rrfilter(header, v59, 0LL);
    LODWORD(v20) = v58;
    v18 = (unsigned __int16 *)ptr;
    v21 = v39;
    v30 = 0LL;
    v23 = v41;
  }
LABEL_28:
  v42 = v24 == 0;
  v13 = v59;
  if ( !v42 )
  {
    v37 = (unsigned int)v20;
    LOWORD(v21) = __ROL2__(v21, 8);
    v61 = __ROL2__(v60, 8);
    v36 = (unsigned __int64)(v18 + 3);
    v13 = v38;
    limit = v64;
LABEL_30:
    v43 = optlen;
    if ( !v30 )
    {
      ptr = v23;
      srca = v21;
      v45 = skip_questions(v14, v13, optlen, v21, v23, v37);
      v46 = v13;
      if ( !v45 )
        return v13;
      v47 = v45;
      v65 = limit;
      v48 = _bswap_16(v14->ancount);
      v49 = v48 + _bswap_16(v14->nscount);
      v50 = _bswap_16(v14->arcount);
      v51 = skip_section(v47, v49 + (unsigned int)v50, v14, v46);
      v13 = v46;
      if ( !v51 )
        return v13;
      v52 = v51;
      v53 = (char *)(v51 + 11);
      limit = v65;
      if ( v51 + 11 > (unsigned __int64)v65 )
        return v46;
      *(_WORD *)v51 = 0;
      *(_BYTE *)(v51 + 2) = 41;
      *(_BYTE *)(v51 + 3) = HIBYTE(srca);
      *(_BYTE *)(v51 + 4) = srca;
      *(_BYTE *)(v51 + 5) = HIBYTE(v61);
      *(_BYTE *)(v51 + 6) = v61;
      *(_BYTE *)(v51 + 7) = HIBYTE(v66);
      *(_BYTE *)(v51 + 8) = v66;
      *(_BYTE *)(v51 + 9) = BYTE1(opt);
      *(_BYTE *)(v51 + 10) = (_BYTE)opt;
      v54 = v51 + 11;
      v55 = ptr;
      if ( ptr )
      {
        if ( &v53[(int)opt] > (char *)v65 )
        {
          free(ptr);
          return v46;
        }
        memcpy(v53, ptr, (int)opt);
        free(v55);
        limit = v65;
        v54 = (__int64)&v53[(int)opt];
      }
      LOWORD(src) = (_WORD)v53;
      v36 = v52 + 9;
      v56 = (unsigned __int16 *)v54;
      if ( (__int64)&limit[-v54 - 4] >= (__int64)optlen )
      {
        v57 = _bswap_16(v14->arcount);
        limit = v65;
        v14->arcount = _bswap_16(v57 + 1);
      }
      LODWORD(v37) = v58;
      v13 = v46;
      v30 = v56;
      v43 = optlen;
    }
    v44 = (unsigned __int8 *)(v30 + 2);
    if ( limit - (unsigned __int8 *)(v30 + 2) < v43 )
      return v13;
    if ( (_DWORD)v37 && replace != 2 )
    {
      if ( v44 > limit )
        return v13;
      *(_BYTE *)v30 = BYTE1(v37);
      *((_BYTE *)v30 + 1) = v37;
      *((_BYTE *)v30 + 2) = BYTE1(v43);
      *((_BYTE *)v30 + 3) = v43;
      v30 = (unsigned __int16 *)&v44[v43];
      if ( &v44[v43] > limit )
        return v13;
      memcpy(v44, v70, v43);
      *(_WORD *)v36 = __ROL2__((_WORD)v30 - (_WORD)src, 8);
    }
    return (char *)v30 - (char *)v14;
  }
  return v13;
}
