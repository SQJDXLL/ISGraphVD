size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int16 *ptr; // esi
  __int16 v10; // si
  unsigned __int8 v11; // bl
  __int16 v12; // cx
  unsigned __int16 v13; // ax
  int v14; // ebp
  unsigned __int16 v15; // dx
  unsigned __int16 v16; // ax
  int v17; // ecx
  int v18; // edi
  char *v19; // edi
  _BYTE *v20; // ebp
  unsigned __int8 *v22; // eax
  __int16 v23; // ax
  int v24; // ebx
  _BYTE *v25; // eax
  _BYTE *v26; // ebp
  unsigned __int8 v27; // [esp+18h] [ebp-54h]
  unsigned __int8 *v28; // [esp+18h] [ebp-54h]
  unsigned __int8 *v29; // [esp+1Ch] [ebp-50h]
  size_t rdlen; // [esp+2Ch] [ebp-40h]
  unsigned __int8 *p; // [esp+38h] [ebp-34h]
  unsigned __int16 flags; // [esp+3Ch] [ebp-30h]
  unsigned __int16 rcode; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  ptr = (unsigned __int16 *)find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !ptr )
  {
    flags = (set_do != 0) << 15;
    rcode = 0;
    goto LABEL_35;
  }
  v29 = t_cp;
  v10 = *t_cp;
  v11 = t_cp[1];
  v12 = t_cp[2];
  v27 = t_cp[3];
  v13 = _byteswap_ushort(*((_WORD *)t_cp + 2));
  if ( set_do )
  {
    flags = v13 | 0x8000;
    t_cp[4] = (unsigned __int16)(v13 | 0x8000) >> 8;
    v29[5] = v13;
  }
  else
  {
    flags = v13;
  }
  v14 = v29[7] | (v29[6] << 8);
  p = v29 + 8;
  if ( plen < v14 + v29 + 8 - (unsigned __int8 *)header || !optno )
    return plen;
  udp_sz = v11 | (unsigned __int16)(v10 << 8);
  rcode = v27 | (unsigned __int16)(v12 << 8);
  if ( v14 <= 4 )
  {
    if ( is_last[0] )
    {
      ptr = (unsigned __int16 *)(v29 + 8);
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  v15 = _byteswap_ushort(*((_WORD *)v29 + 4));
  v16 = _byteswap_ushort(*((_WORD *)v29 + 5));
  v28 = v29 + 12;
  v17 = v16;
  if ( v14 < v16 )
  {
LABEL_11:
    is_last[0] = 0;
    ptr = 0;
LABEL_12:
    plen = rrfilter(header, plen, 0);
LABEL_35:
    v24 = skip_questions(header, plen);
    if ( !v24 )
      return plen;
    v25 = (_BYTE *)skip_section(
                     v24,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->ancount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8),
                     header,
                     plen);
    v26 = v25;
    if ( !v25 )
      return plen;
    *v25 = 0;
    v25[1] = 0;
    v25[2] = 41;
    v25[3] = HIBYTE(udp_sz);
    v25[4] = udp_sz;
    v25[5] = HIBYTE(rcode);
    v25[6] = rcode;
    v25[7] = HIBYTE(flags);
    v25[8] = flags;
    v25[9] = BYTE1(rdlen);
    v25[10] = rdlen;
    LOWORD(p) = (_WORD)v25 + 11;
    if ( ptr )
    {
      LOWORD(p) = (_WORD)v25 + 11;
      memcpy(v25 + 11, ptr, rdlen);
      free(ptr);
      ptr = (unsigned __int16 *)&v26[rdlen + 11];
    }
    else
    {
      ptr = (unsigned __int16 *)(v25 + 11);
    }
    v19 = (char *)(ptr + 2);
    if ( limit - (unsigned __int8 *)(ptr + 2) < (int)optlen )
      return plen;
    v20 = v26 + 9;
    header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    goto LABEL_23;
  }
  v18 = 0;
  ptr = (unsigned __int16 *)(v29 + 8);
  while ( 1 )
  {
    if ( v15 == optno )
    {
      if ( !replace )
        return plen;
      v14 -= v17 + 4;
      memcpy(ptr, (char *)ptr + v16 + 4, v14 - v18);
      v29[6] = BYTE1(v14);
      v29[7] = v14;
    }
    else
    {
      ptr = (unsigned __int16 *)&v28[v16];
      v18 += v17 + 4;
    }
    if ( v18 + 4 >= v14 )
      break;
    v15 = _byteswap_ushort(*ptr);
    v16 = _byteswap_ushort(ptr[1]);
    v28 = (unsigned __int8 *)(ptr + 2);
    v17 = v16;
    if ( v16 + v18 > v14 )
      goto LABEL_11;
  }
  if ( !is_last[0] )
  {
LABEL_28:
    if ( v14 )
    {
      v22 = (unsigned __int8 *)whine_malloc(v14);
      ptr = (unsigned __int16 *)v22;
      rdlen = v14;
      if ( v22 )
      {
        memcpy(v22, p, v14);
        rdlen = v14;
      }
    }
    else
    {
      rdlen = 0;
      ptr = 0;
    }
    goto LABEL_12;
  }
  if ( !ptr )
  {
    rdlen = v14;
    goto LABEL_35;
  }
LABEL_21:
  v19 = (char *)(ptr + 2);
  if ( limit - (unsigned __int8 *)(ptr + 2) < (int)optlen )
    return plen;
  v20 = v29 + 6;
LABEL_23:
  if ( optno && replace != 2 )
  {
    *(_BYTE *)ptr = BYTE1(optno);
    *((_BYTE *)ptr + 1) = optno;
    *((_BYTE *)ptr + 2) = BYTE1(optlen);
    *((_BYTE *)ptr + 3) = optlen;
    memcpy(v19, opt, optlen);
    ptr = (unsigned __int16 *)&v19[optlen];
    v23 = optlen + (_WORD)v19 - (_WORD)p;
    *v20 = HIBYTE(v23);
    v20[1] = v23;
  }
  return (char *)ptr - (char *)header;
}
