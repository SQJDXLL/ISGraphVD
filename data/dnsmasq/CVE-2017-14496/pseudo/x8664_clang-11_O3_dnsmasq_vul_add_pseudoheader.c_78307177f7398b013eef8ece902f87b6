size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v13; // r14
  unsigned __int8 *pseudoheader; // rax
  __int64 v15; // rdx
  int v17; // ebx
  __int16 v18; // si
  unsigned __int8 *v19; // rsi
  __int16 v20; // ax
  __int16 v21; // dx
  __int16 v22; // bx
  unsigned __int64 v23; // rdx
  int v24; // ebp
  __int64 v25; // rbx
  unsigned __int64 v26; // rax
  __int64 v27; // rsi
  int v28; // r13d
  __int16 v29; // r13
  void *v30; // rsi
  int v31; // ebp
  _WORD *v32; // rdx
  void *v33; // r13
  size_t v34; // rbp
  void *v35; // rax
  int v36; // eax
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // rsi
  int v39; // edx
  bool v40; // cc
  __int64 v41; // rax
  __m128i v42; // xmm0
  __m128i v43; // xmm0
  __int64 v44; // rax
  int v45; // ecx
  char *v46; // rbp
  __int64 v47; // rdx
  __int64 v48; // rbx
  _WORD *v49; // rbx
  __int64 v50; // r13
  __int16 v51; // [rsp+4h] [rbp-74h]
  __int16 v52; // [rsp+8h] [rbp-70h]
  int v53; // [rsp+Ch] [rbp-6Ch]
  void *ptr; // [rsp+10h] [rbp-68h]
  __int16 v55; // [rsp+18h] [rbp-60h]
  int is_last; // [rsp+1Ch] [rbp-5Ch] BYREF
  __int64 v57; // [rsp+20h] [rbp-58h]
  void *src; // [rsp+28h] [rbp-50h]
  int is_sign; // [rsp+34h] [rbp-44h] BYREF
  void *v60; // [rsp+38h] [rbp-40h]
  unsigned __int8 *v61; // [rsp+40h] [rbp-38h] BYREF

  v13 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v61, &is_sign, &is_last);
  if ( is_sign )
    return v13;
  v60 = opt;
  v17 = 0;
  HIBYTE(v18) = 0;
  LOBYTE(v15) = set_do != 0;
  v53 = optno;
  if ( !pseudoheader )
  {
    LOBYTE(v18) = set_do != 0;
    v55 = v18 << 15;
    ptr = 0LL;
    v29 = 0;
    goto LABEL_33;
  }
  v19 = v61;
  v20 = *(_WORD *)v61;
  v21 = *((_WORD *)v61 + 1);
  v22 = __ROL2__(*((_WORD *)v61 + 2), 8);
  if ( set_do )
  {
    v22 |= 0x8000u;
    v61[4] = HIBYTE(v22);
  }
  if ( !optno )
    return v13;
  v51 = v21;
  v52 = v20;
  v23 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v19 + 3) << 48);
  if ( v23 + v19 + 8 - (unsigned __int8 *)header > v13 )
    return v13;
  v55 = v22;
  v57 = (__int64)v19;
  src = v19 + 8;
  if ( (unsigned int)v23 >= 5 )
  {
    if ( replace )
    {
      v24 = 0;
      v25 = (__int64)(v19 + 8);
      while ( 1 )
      {
        v26 = _byteswap_uint64((unsigned __int64)*(unsigned __int16 *)(v25 + 2) << 48);
        if ( (int)v26 + v24 > (int)v23 )
          break;
        v27 = v25 + 4;
        if ( _byteswap_ulong(*(unsigned __int16 *)v25 << 16) == v53 )
        {
          v28 = v23 - v26 - 4;
          memcpy((void *)v25, (const void *)(v26 + v27), v28 - v24);
          LODWORD(v23) = v28;
          *(_WORD *)(v57 + 6) = __ROL2__(v28, 8);
          if ( v24 + 4 >= v28 )
            goto LABEL_18;
        }
        else
        {
          v24 += v26 + 4;
          v25 = (unsigned int)v26 + v27;
          if ( v24 + 4 >= (int)v23 )
            goto LABEL_18;
        }
      }
    }
    else
    {
      v36 = 0;
      v25 = (__int64)(v19 + 8);
      while ( 1 )
      {
        v37 = _byteswap_uint64((unsigned __int64)*(unsigned __int16 *)(v25 + 2) << 48);
        v38 = v23;
        if ( (int)v37 + v36 > (int)v23 )
          break;
        if ( _byteswap_ulong(*(unsigned __int16 *)v25 << 16) == optno )
          return v13;
        v25 += v37 + 4;
        v39 = v36 + v37 + 8;
        v36 += v37 + 4;
        v40 = v39 < (int)v38;
        v23 = v38;
        if ( !v40 )
          goto LABEL_18;
      }
    }
    is_last = 0;
LABEL_30:
    v17 = 0;
    goto LABEL_31;
  }
  v25 = (__int64)(v19 + 8);
LABEL_18:
  if ( is_last )
  {
    v30 = v60;
    v31 = replace;
    v32 = (_WORD *)(v57 + 6);
    v33 = (void *)(v25 + 4);
    if ( (__int64)&limit[-v25 - 4] < (__int64)optlen )
      return v13;
    goto LABEL_40;
  }
  if ( !(_DWORD)v23 )
    goto LABEL_30;
  v17 = v23;
  v34 = (int)v23;
  v35 = (void *)whine_malloc((int)v23);
  if ( !v35 )
  {
LABEL_31:
    ptr = 0LL;
    goto LABEL_32;
  }
  ptr = v35;
  memcpy(v35, src, v34);
LABEL_32:
  udp_sz = __ROL2__(v52, 8);
  v29 = __ROL2__(v51, 8);
  v13 = rrfilter(header, v13, 0LL);
LABEL_33:
  v41 = skip_questions(header, v13, v15);
  if ( v41 )
  {
    v42 = _mm_cvtsi32_si128(*(_DWORD *)&header->ancount);
    v43 = _mm_unpacklo_epi16(_mm_or_si128(_mm_slli_epi16(v42, 8u), _mm_srli_epi16(v42, 8u)), (__m128i)0LL);
    v44 = skip_section(
            v41,
            _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v43, 229), v43))
          + (unsigned int)(unsigned __int16)__ROL2__(header->arcount, 8),
            header,
            v13);
    if ( v44 )
    {
      *(_WORD *)v44 = 0;
      *(_BYTE *)(v44 + 2) = 41;
      *(_BYTE *)(v44 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v44 + 4) = udp_sz;
      *(_BYTE *)(v44 + 5) = HIBYTE(v29);
      *(_BYTE *)(v44 + 6) = v29;
      *(_BYTE *)(v44 + 7) = HIBYTE(v55);
      *(_BYTE *)(v44 + 8) = v55;
      v45 = v17;
      *(_BYTE *)(v44 + 9) = BYTE1(v17);
      *(_BYTE *)(v44 + 10) = v17;
      v46 = (char *)(v44 + 11);
      v25 = v44 + 11;
      v47 = v44;
      if ( ptr )
      {
        v48 = v45;
        v57 = v44;
        memcpy((void *)(v44 + 11), ptr, v45);
        free(ptr);
        v47 = v57;
        v25 = (__int64)&v46[v48];
      }
      src = v46;
      v32 = (_WORD *)(v47 + 9);
      v30 = v60;
      if ( (__int64)&limit[-v25 - 4] >= (__int64)optlen )
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
      v31 = replace;
      v33 = (void *)(v25 + 4);
      if ( (__int64)&limit[-v25 - 4] >= (__int64)optlen )
      {
LABEL_40:
        if ( v53 && v31 != 2 )
        {
          *(_BYTE *)v25 = BYTE1(v53);
          *(_BYTE *)(v25 + 1) = v53;
          *(_BYTE *)(v25 + 2) = BYTE1(optlen);
          *(_BYTE *)(v25 + 3) = optlen;
          v49 = v32;
          memcpy(v33, v30, optlen);
          v50 = (__int64)v33 + optlen;
          *v49 = __ROL2__(v50 - (_WORD)src, 8);
          v25 = v50;
        }
        return v25 - (_QWORD)header;
      }
    }
  }
  return v13;
}
