size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  __int16 v9; // w0
  int v11; // w19
  int v12; // w19
  uint16_t v13; // w0
  unsigned __int8 *v14; // x0
  uint16_t v15; // w0
  unsigned __int64 plena; // [xsp+50h] [xbp+50h]
  unsigned __int16 flags; // [xsp+64h] [xbp+64h]
  unsigned __int16 rcode; // [xsp+66h] [xbp+66h]
  unsigned __int16 code; // [xsp+6Ah] [xbp+6Ah]
  unsigned __int16 len; // [xsp+6Ch] [xbp+6Ch]
  unsigned __int8 t_s_0; // [xsp+6Eh] [xbp+6Eh]
  unsigned __int8 t_s_5; // [xsp+78h] [xbp+78h]
  unsigned __int8 t_s_8; // [xsp+7Eh] [xbp+7Eh]
  int is_sign; // [xsp+80h] [xbp+80h] BYREF
  int is_last; // [xsp+84h] [xbp+84h] BYREF
  int rdlen; // [xsp+88h] [xbp+88h]
  int i; // [xsp+8Ch] [xbp+8Ch]
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF
  unsigned __int8 *lenp; // [xsp+98h] [xbp+98h]
  unsigned __int8 *datap; // [xsp+A0h] [xbp+A0h]
  unsigned __int8 *p; // [xsp+A8h] [xbp+A8h]
  unsigned __int8 *buff; // [xsp+B0h] [xbp+B0h]
  unsigned __int8 *t_cp; // [xsp+B8h] [xbp+B8h]
  unsigned __int8 *t_cp_0; // [xsp+C0h] [xbp+C0h]
  unsigned __int8 *t_cp_1; // [xsp+C8h] [xbp+C8h]
  unsigned __int8 *t_cp_2; // [xsp+D0h] [xbp+D0h]
  unsigned __int8 *t_cp_3; // [xsp+D8h] [xbp+D8h]
  unsigned __int8 *t_cp_4; // [xsp+E0h] [xbp+E0h]
  unsigned __int8 *t_cp_5; // [xsp+E8h] [xbp+E8h]
  unsigned __int8 *t_cp_6; // [xsp+F0h] [xbp+F0h]
  unsigned __int8 *t_cp_7; // [xsp+F8h] [xbp+F8h]
  unsigned __int8 *t_cp_8; // [xsp+100h] [xbp+100h]
  unsigned __int8 *t_cp_9; // [xsp+108h] [xbp+108h]
  unsigned __int8 *t_cp_10; // [xsp+110h] [xbp+110h]
  unsigned __int8 *t_cp_11; // [xsp+118h] [xbp+118h]
  unsigned __int8 *t_cp_12; // [xsp+120h] [xbp+120h]
  unsigned __int8 *t_cp_13; // [xsp+128h] [xbp+128h]
  unsigned __int8 *t_cp_14; // [xsp+130h] [xbp+130h]

  plena = plen;
  buff = 0LL;
  rdlen = 0;
  if ( set_do )
    v9 = 0x8000;
  else
    v9 = 0;
  flags = v9;
  rcode = 0;
  p = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return plena;
  if ( p )
  {
    p = udp_len;
    t_cp = udp_len;
    udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
    p = udp_len + 2;
    t_cp_0 = udp_len + 2;
    rcode = _byteswap_ushort(*((_WORD *)udp_len + 1));
    p = udp_len + 4;
    t_cp_1 = udp_len + 4;
    flags = _byteswap_ushort(*((_WORD *)udp_len + 2));
    p = udp_len + 6;
    if ( set_do )
    {
      p += -0x2;
      flags |= 0x8000u;
      t_cp_2 = p + 1;
      *p = HIBYTE(flags);
      *t_cp_2 = flags;
      p += 2;
    }
    lenp = p;
    t_cp_3 = p;
    rdlen = (*p << 8) | p[1];
    p += 2;
    if ( plena < p - (unsigned __int8 *)header + rdlen )
      return plena;
    datap = p;
    if ( !optno )
      return plena;
    i = 0;
    while ( rdlen > i + 4 )
    {
      t_cp_4 = p;
      code = _byteswap_ushort(*(_WORD *)p);
      p += 2;
      t_cp_5 = p;
      len = _byteswap_ushort(*(_WORD *)p);
      p += 2;
      if ( rdlen < len + i )
      {
        rdlen = 0;
        is_last = 0;
        break;
      }
      if ( optno == code )
      {
        if ( !replace )
          return plena;
        p += -0x4;
        rdlen -= len + 4;
        memcpy(p, &p[len + 4], rdlen - i);
        t_s_0 = rdlen;
        t_cp_6 = lenp + 1;
        *lenp = BYTE1(rdlen);
        *t_cp_6 = t_s_0;
        lenp += 2;
        lenp += -0x2;
      }
      else
      {
        p += len;
        i += len + 4;
      }
    }
    if ( !is_last )
    {
      if ( rdlen )
      {
        buff = (unsigned __int8 *)whine_malloc(rdlen);
        if ( buff )
          memcpy(buff, datap, rdlen);
      }
      plena = rrfilter(header, plena, 0LL);
      p = 0LL;
    }
  }
  if ( !p )
  {
    p = (unsigned __int8 *)skip_questions(header, plena);
    if ( !p )
      return plena;
    v11 = ntohs(header->ancount);
    v12 = v11 + ntohs(header->nscount);
    v13 = ntohs(header->arcount);
    p = (unsigned __int8 *)skip_section(p, v12 + (unsigned int)v13, header, plena);
    if ( !p )
      return plena;
    v14 = p++;
    *v14 = 0;
    t_cp_7 = p + 1;
    *p = 0;
    *t_cp_7 = 41;
    p += 2;
    t_cp_8 = p + 1;
    *p = HIBYTE(udp_sz);
    *t_cp_8 = udp_sz;
    p += 2;
    t_cp_9 = p + 1;
    *p = HIBYTE(rcode);
    *t_cp_9 = rcode;
    p += 2;
    t_cp_10 = p + 1;
    *p = HIBYTE(flags);
    *t_cp_10 = flags;
    p += 2;
    lenp = p;
    t_s_5 = rdlen;
    t_cp_11 = p + 1;
    *p = BYTE1(rdlen);
    *t_cp_11 = t_s_5;
    p += 2;
    datap = p;
    if ( buff )
    {
      memcpy(p, buff, rdlen);
      free(buff);
      p += rdlen;
    }
    if ( limit - (p + 4) >= (__int64)optlen )
    {
      v15 = ntohs(header->arcount);
      header->arcount = htons(v15 + 1);
    }
  }
  if ( limit - (p + 4) < (__int64)optlen )
    return plena;
  if ( optno )
  {
    if ( replace != 2 )
    {
      t_cp_12 = p + 1;
      *p = BYTE1(optno);
      *t_cp_12 = optno;
      p += 2;
      t_cp_13 = p + 1;
      *p = BYTE1(optlen);
      *t_cp_13 = optlen;
      p += 2;
      memcpy(p, opt, optlen);
      p += optlen;
      t_s_8 = (_BYTE)p - (_BYTE)datap;
      t_cp_14 = lenp + 1;
      *lenp = (unsigned __int16)((_WORD)p - (_WORD)datap) >> 8;
      *t_cp_14 = t_s_8;
      lenp += 2;
    }
  }
  return p - (unsigned __int8 *)header;
}
