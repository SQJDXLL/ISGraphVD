size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v11; // r6
  dns_header *v12; // r7
  unsigned __int8 *pseudoheader; // r0
  int v15; // r4
  char v16; // r2
  unsigned __int8 *v17; // r8
  unsigned __int8 v18; // r2
  unsigned int v19; // lr
  unsigned __int8 v20; // r12
  int v21; // r5
  unsigned __int8 *v22; // r10
  int v23; // r9
  unsigned __int8 *v24; // r7
  int v25; // r0
  void *v26; // r1
  int v27; // r8
  int v28; // r0
  void *v29; // r1
  void *v30; // r0
  void *v31; // r7
  void *v32; // r4
  int v33; // r8
  unsigned __int8 *v34; // r5
  bool v35; // zf
  __int16 v36; // r0
  char v37; // r10
  int v38; // r0
  __uint16_t *p_id; // r4
  int v40; // r7
  int v41; // r8
  int v42; // r8
  int v43; // r0
  _BYTE *v44; // r0
  _BYTE *v45; // r2
  _BYTE *v46; // r4
  _BYTE *v47; // r8
  __uint16_t v48; // r0
  unsigned __int8 v49; // [sp+8h] [bp-50h]
  dns_header *v50; // [sp+Ch] [bp-4Ch]
  unsigned __int8 *v51; // [sp+10h] [bp-48h]
  _BYTE *v52; // [sp+14h] [bp-44h]
  void *src; // [sp+18h] [bp-40h]
  void *srca; // [sp+18h] [bp-40h]
  unsigned __int8 v55; // [sp+20h] [bp-38h]
  unsigned __int8 v56; // [sp+24h] [bp-34h]
  unsigned __int8 v57; // [sp+28h] [bp-30h]
  unsigned __int8 v58; // [sp+2Ch] [bp-2Ch]
  int is_last; // [sp+30h] [bp-28h] BYREF
  int is_sign; // [sp+34h] [bp-24h] BYREF
  unsigned __int8 *udp_len; // [sp+38h] [bp-20h] BYREF

  v11 = plen;
  v12 = header;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return v11;
  v15 = optno;
  v16 = set_do;
  if ( set_do )
    v16 = 0x80;
  if ( pseudoheader )
  {
    v17 = udp_len;
    v18 = udp_len[4];
    LOBYTE(v19) = *udp_len;
    v20 = udp_len[3];
    v58 = udp_len[1];
    v56 = udp_len[2];
    v55 = udp_len[5];
    if ( set_do )
    {
      v18 |= 0x80u;
      udp_len[4] = v18;
    }
    v21 = v17[7] | (v17[6] << 8);
    v52 = v17 + 6;
    v22 = v17 + 8;
    v57 = v20;
    src = v17 + 8;
    if ( !optno || v22 - (unsigned __int8 *)v12 + v21 > v11 )
      return v11;
    v49 = v18;
    v50 = v12;
    v51 = limit;
    if ( (unsigned int)v21 >= 5 )
    {
      v23 = 0;
      v24 = v17 + 8;
      while ( 1 )
      {
        v25 = v24[3] | (v24[2] << 8);
        v22 = v24 + 4;
        if ( v25 + v23 > v21 )
        {
          v21 = 0;
          is_last = 0;
          break;
        }
        if ( (v24[1] | (*v24 << 8)) == v15 )
        {
          if ( !replace )
          {
            v27 = 0;
            v26 = 0;
            v28 = v11;
            limit = v51;
            v12 = v50;
            goto LABEL_29;
          }
          v21 = v21 - v25 - 4;
          memcpy(v24, &v22[v25], v21 - v23);
          v15 = optno;
          v17[7] = v21;
          v17[6] = BYTE1(v21);
        }
        else
        {
          v24 = &v22[v25];
          v23 += v25 + 4;
        }
        if ( v23 + 4 >= v21 )
          goto LABEL_22;
      }
    }
    v24 = v22;
LABEL_22:
    v27 = 1;
    if ( is_last )
    {
      v22 = v24;
      v28 = v11;
      v16 = v49;
      v12 = v50;
      limit = v51;
      v26 = 0;
    }
    else
    {
      v22 = 0;
      v29 = 0;
      limit = v51;
      if ( v21 )
      {
        v30 = (void *)whine_malloc(v21, 0);
        v29 = 0;
        if ( v30 )
        {
          v31 = v30;
          memcpy(v30, src, v21);
          v29 = v31;
        }
      }
      v12 = v50;
      v32 = v29;
      v28 = rrfilter(v50, v11, 0);
      v26 = v32;
      v15 = optno;
LABEL_29:
      v16 = v49;
      if ( !v27 )
        return v11;
    }
    v11 = v28;
  }
  else
  {
    v57 = 0;
    v58 = udp_sz;
    v19 = udp_sz >> 8;
    v56 = 0;
    v55 = 0;
    v21 = 0;
    v26 = 0;
    v22 = 0;
  }
  v33 = optlen;
  if ( !v22 )
  {
    srca = v26;
    v37 = v16;
    v38 = skip_questions(v12, v11);
    if ( !v38 )
      return v11;
    p_id = &v12->id;
    v40 = v38;
    v41 = _bswap_16(p_id[3]);
    v42 = _bswap_16(p_id[4]) + v41;
    v43 = _bswap_16(p_id[5]);
    v44 = (_BYTE *)skip_section(v40, v42 + v43, p_id, v11);
    if ( !v44 )
      return v11;
    v12 = (dns_header *)p_id;
    v44[10] = v21;
    v44[8] = v55;
    v44[7] = v37;
    v44[6] = v57;
    v44[5] = v56;
    v44[4] = v58;
    v44[3] = v19;
    v44[2] = 41;
    v44[1] = 0;
    *v44 = 0;
    v44[9] = BYTE1(v21);
    v45 = v44 + 9;
    v46 = v44 + 0xB;
    v22 = v44 + 0xB;
    if ( srca )
    {
      v47 = v44 + 9;
      memcpy(v44 + 0xB, srca, v21);
      free(srca);
      v45 = v47;
      v22 = &v46[v21];
    }
    LOWORD(src) = (_WORD)v46;
    v33 = optlen;
    v52 = v45;
    if ( limit - v22 - 4 >= (int)optlen )
    {
      v48 = _bswap_16(v12->arcount);
      v12->arcount = _bswap_16(v48 + 1);
    }
    v15 = optno;
  }
  v34 = v22 + 4;
  if ( limit - (v22 + 4) >= v33 )
  {
    v35 = v15 == 0;
    if ( v15 )
      v35 = replace == 2;
    if ( !v35 )
    {
      v22[3] = v33;
      v22[1] = v15;
      v22[2] = BYTE1(v33);
      *v22 = BYTE1(v15);
      memcpy(v22 + 4, opt, v33);
      v22 = &v34[v33];
      v36 = (_WORD)v34 + v33 - (_WORD)src;
      v52[1] = v36;
      *v52 = HIBYTE(v36);
    }
    return v22 - (unsigned __int8 *)v12;
  }
  return v11;
}
