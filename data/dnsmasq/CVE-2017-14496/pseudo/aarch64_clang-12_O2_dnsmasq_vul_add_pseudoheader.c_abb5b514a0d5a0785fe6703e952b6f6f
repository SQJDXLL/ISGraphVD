size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v15; // x22
  unsigned __int8 *pseudoheader; // x0
  char v19; // w28
  unsigned __int8 *v20; // x20
  _WORD *v21; // x24
  _BYTE *v22; // x27
  int v23; // w26
  unsigned __int64 v24; // x8
  _BYTE *v25; // x9
  unsigned __int8 v26; // w24
  unsigned __int8 v27; // w26
  unsigned __int8 *v28; // x10
  __int64 v29; // x26
  signed __int64 v30; // x8
  void *v31; // x0
  __int64 v32; // x0
  __int64 v33; // x0
  _BYTE *v34; // x25
  unsigned __int8 v35; // [xsp+0h] [xbp-50h]
  unsigned __int8 v36; // [xsp+4h] [xbp-4Ch]
  void *src; // [xsp+8h] [xbp-48h]
  void *v38; // [xsp+10h] [xbp-40h]
  unsigned __int8 *v39; // [xsp+18h] [xbp-38h]
  unsigned __int8 v40; // [xsp+20h] [xbp-30h]
  unsigned __int8 v41; // [xsp+24h] [xbp-2Ch]
  size_t n; // [xsp+28h] [xbp-28h]
  unsigned __int8 *limita; // [xsp+30h] [xbp-20h]
  int is_last; // [xsp+40h] [xbp-10h] BYREF
  int is_sign; // [xsp+44h] [xbp-Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+48h] [xbp-8h] BYREF

  v15 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  if ( set_do )
    v19 = 0x80;
  else
    v19 = 0;
  if ( !pseudoheader )
  {
    limita = limit;
    v38 = 0LL;
    LODWORD(limit) = 0;
    v26 = 0;
    v27 = 0;
    v40 = HIBYTE(udp_sz);
    v41 = 0;
    goto LABEL_28;
  }
  n = optlen;
  v20 = udp_len;
  v19 = udp_len[4];
  if ( set_do )
  {
    v19 |= 0x80u;
    udp_len[4] = v19;
  }
  LOBYTE(udp_sz) = v20[1];
  v21 = v20 + 6;
  if ( optno )
  {
    limita = limit;
    limit = (unsigned __int8 *)bswap64((unsigned __int64)*((unsigned __int16 *)v20 + 3) << 48);
    if ( (unsigned __int64)&limit[v20 + 8 - (unsigned __int8 *)header] <= v15 )
    {
      v39 = opt;
      v22 = v20 + 8;
      v40 = *v20;
      v41 = v20[3];
      v35 = v20[2];
      v36 = v20[5];
      src = v20 + 8;
      if ( (unsigned int)limit < 5 )
      {
LABEL_20:
        if ( is_last )
        {
          optlen = n;
          v28 = limita;
          LODWORD(v29) = (_DWORD)src;
          v30 = (int)n;
LABEL_34:
          v34 = v22 + 4;
          if ( v30 <= v28 - (v22 + 4) )
          {
            if ( optno && replace != 2 )
            {
              v22[1] = optno;
              *v22 = BYTE1(optno);
              v22[2] = BYTE1(optlen);
              v22[3] = optlen;
              memcpy(v22 + 4, v39, optlen);
              v22 = &v34[optlen];
              *v21 = bswap32((_DWORD)v34 + optlen - v29) >> 16;
            }
            return v22 - (_BYTE *)header;
          }
          return v15;
        }
        if ( (_DWORD)limit && (v31 = (void *)whine_malloc((int)limit)) != 0LL )
        {
          v38 = v31;
          memcpy(v31, src, (int)limit);
        }
        else
        {
          v38 = 0LL;
        }
      }
      else
      {
        v23 = 0;
        while ( 1 )
        {
          v24 = bswap64((unsigned __int64)*((unsigned __int16 *)v22 + 1) << 48);
          if ( (int)v24 + v23 > (int)limit )
            break;
          v25 = v22 + 4;
          if ( bswap32(*(unsigned __int16 *)v22 << 16) == optno )
          {
            if ( !replace )
              return v15;
            LODWORD(limit) = (_DWORD)limit - v24 - 4;
            memcpy(v22, &v25[v24], (int)limit - v23);
            *((_WORD *)v20 + 3) = bswap32((unsigned int)limit) >> 16;
          }
          else
          {
            v22 = &v25[(unsigned int)v24];
            v23 += v24 + 4;
          }
          if ( v23 + 4 >= (int)limit )
            goto LABEL_20;
        }
        LODWORD(limit) = 0;
        v38 = 0LL;
        is_last = 0;
      }
      optlen = n;
      opt = v39;
      v27 = v35;
      v26 = v36;
      v15 = rrfilter(header, v15, 0LL);
LABEL_28:
      v32 = skip_questions(header, v15);
      if ( !v32 )
        return v15;
      v33 = skip_section(
              v32,
              (bswap32(header->nscount) >> 0x10)
            + (bswap32(header->ancount) >> 0x10)
            + (bswap32(header->arcount) >> 0x10),
              header,
              v15);
      if ( !v33 )
        return v15;
      *(_BYTE *)(v33 + 7) = v19;
      *(_BYTE *)(v33 + 3) = v40;
      *(_BYTE *)(v33 + 5) = v27;
      *(_BYTE *)(v33 + 8) = v26;
      *(_BYTE *)(v33 + 6) = v41;
      v29 = v33 + 0xB;
      v39 = opt;
      *(_WORD *)v33 = 0;
      *(_BYTE *)(v33 + 4) = udp_sz;
      *(_BYTE *)(v33 + 2) = 41;
      *(_BYTE *)(v33 + 9) = BYTE1(limit);
      v21 = (_WORD *)(v33 + 9);
      v22 = (_BYTE *)(v33 + 0xB);
      *(_BYTE *)(v33 + 10) = (_BYTE)limit;
      if ( v38 )
      {
        memcpy((void *)(v33 + 0xB), v38, (int)limit);
        free(v38);
        v22 = (_BYTE *)(v29 + (int)limit);
      }
      v28 = limita;
      v30 = (int)optlen;
      if ( (int)optlen <= limita - v22 - 4 )
        header->arcount = bswap32((bswap32(header->arcount) >> 0x10) + 1) >> 16;
      goto LABEL_34;
    }
  }
  return v15;
}
