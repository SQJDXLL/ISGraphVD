size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v16; // $s2
  int v17; // $v1
  unsigned __int8 *v18; // $s0
  unsigned __int8 *v19; // $s0
  unsigned __int16 v20; // $s4
  char *v21; // $s5
  int v22; // $s7
  int v23; // $a3
  unsigned __int8 *v24; // $fp
  _WORD *v25; // $s0
  unsigned __int8 *v26; // $v0
  int v27; // $a0
  int v28; // $v0
  int v29; // $a3
  int v30; // $a1
  int v31; // $a1
  int v32; // $a1
  unsigned __int8 *v33; // $a0
  int v35; // [sp+20h] [-20h]
  u16 t_s_0; // [sp+22h] [-1Eh]
  size_t t_s_1; // [sp+2Ch] [-14h]
  int t_s_1a; // [sp+2Ch] [-14h]
  unsigned __int8 *udp_len; // [sp+30h] [-10h] BYREF
  int is_sign; // [sp+34h] [-Ch] BYREF
  int is_last; // [sp+38h] [-8h] BYREF

  v16 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v17 = is_sign;
  if ( is_sign )
    return v16;
  v18 = pseudoheader;
  if ( pseudoheader )
  {
    v19 = udp_len;
    udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
    t_s_0 = _byteswap_ushort(*((_WORD *)udp_len + 1));
    v20 = _byteswap_ushort(*((_WORD *)udp_len + 2));
    if ( set_do )
    {
      v20 |= 0x8000u;
      udp_len[4] = HIBYTE(v20);
      v19[5] = v20;
    }
    v21 = (char *)(v19 + 8);
    v22 = v19[7] | (v19[6] << 8);
    if ( v16 < v19 + 8 - (unsigned __int8 *)header + v22 )
      return v16;
    v23 = 0;
    if ( !optno )
      return v16;
    v24 = v19 + 8;
    while ( v23 + 4 < v22 )
    {
      v30 = v24[3] | (v24[2] << 8);
      if ( v22 < v30 + v23 + 4 )
      {
        is_last = 0;
LABEL_23:
        v22 = 0;
        v18 = 0;
        goto LABEL_13;
      }
      if ( (v24[1] | (*v24 << 8)) == optno )
      {
        v31 = v30 + 4;
        if ( !replace )
          return v16;
        v22 -= v31;
        t_s_1a = v23;
        memcpy(v24, &v24[v31], v22 - v23);
        v23 = t_s_1a;
        *((_WORD *)v19 + 3) = v22;
      }
      else
      {
        v32 = v30 + 4;
        v24 += v32;
        v23 += v32;
      }
    }
    v25 = v19 + 6;
    if ( is_last )
      goto LABEL_31;
    if ( !v22 )
      goto LABEL_23;
    v26 = (unsigned __int8 *)whine_malloc(v22);
    v18 = v26;
    if ( v26 )
      memcpy(v26, v21, v22);
LABEL_13:
    v16 = rrfilter(header, v16, 0);
    v17 = v22;
  }
  else
  {
    t_s_0 = 0;
    v20 = (set_do != 0) << 15;
  }
  t_s_1 = v17;
  v27 = skip_questions(header, v16);
  if ( v27 )
  {
    v28 = skip_section(v27, header->ancount + header->nscount + header->arcount, header, v16);
    v29 = v28;
    if ( v28 )
    {
      v21 = (char *)(v28 + 0xB);
      if ( (unsigned int)limit >= v28 + 0xB )
      {
        *(_BYTE *)v28 = 0;
        *(_WORD *)(v28 + 1) = 41;
        *(_BYTE *)(v28 + 3) = HIBYTE(udp_sz);
        *(_BYTE *)(v28 + 8) = v20;
        *(_BYTE *)(v28 + 4) = udp_sz;
        *(_BYTE *)(v28 + 10) = t_s_1;
        *(_WORD *)(v28 + 5) = t_s_0;
        *(_BYTE *)(v28 + 7) = HIBYTE(v20);
        *(_BYTE *)(v28 + 9) = BYTE2(t_s_1);
        if ( v18 )
        {
          v24 = (unsigned __int8 *)&v21[t_s_1];
          if ( limit < (unsigned __int8 *)&v21[t_s_1] )
          {
            free(v18);
            return v16;
          }
          v35 = v28;
          memcpy(v21, v18, t_s_1);
          free(v18);
          v29 = v35;
        }
        else
        {
          v24 = (unsigned __int8 *)(v28 + 0xB);
        }
        v25 = (_WORD *)(v29 + 9);
        if ( limit - (v24 + 4) >= (int)optlen )
          ++header->arcount;
LABEL_31:
        v33 = v24 + 4;
        if ( limit - (v24 + 4) >= (int)optlen )
        {
          if ( !optno || replace == 2 )
            return v24 - (unsigned __int8 *)header;
          if ( limit >= v33 )
          {
            v24[3] = optlen;
            *(_WORD *)v24 = optno;
            v24[2] = BYTE2(optlen);
            v24 = &v33[optlen];
            if ( limit >= &v33[optlen] )
            {
              memcpy(v33, opt, optlen);
              *v25 = (_WORD)v24 - (_WORD)v21;
              return v24 - (unsigned __int8 *)header;
            }
          }
        }
      }
    }
  }
  return v16;
}
