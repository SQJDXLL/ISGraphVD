size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v9; // r8
  unsigned __int8 *pseudoheader; // r0
  int v11; // r11
  unsigned __int8 *v12; // r6
  unsigned __int8 *v13; // r6
  __int16 v14; // lr
  __int16 v15; // r12
  __int16 v16; // r0
  __int16 v17; // r1
  int v18; // r10
  unsigned int v19; // r3
  int v20; // r5
  unsigned __int8 *v21; // r4
  _BOOL4 v22; // r3
  int v24; // r0
  int v25; // r1
  unsigned __int8 *v26; // r12
  int v27; // r3
  int v28; // r7
  unsigned int v29; // r3
  _BYTE *v30; // r6
  bool v31; // zf
  void *v32; // r0
  unsigned __int8 *v33; // r0
  __int16 v34; // r3
  int v35; // r0
  _BYTE *v36; // r0
  _BYTE *v37; // r5
  _BYTE *v38; // r3
  unsigned __int16 v39; // r2
  void *src; // [sp+18h] [bp-40h]
  __int16 v44; // [sp+1Ch] [bp-3Ch]
  unsigned __int8 *udp_len; // [sp+20h] [bp-38h] BYREF
  int is_sign; // [sp+24h] [bp-34h] BYREF
  int is_last; // [sp+28h] [bp-30h] BYREF

  v9 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v11 = is_sign;
  if ( is_sign )
    return v9;
  v12 = pseudoheader;
  if ( !pseudoheader )
  {
    v34 = set_do;
    if ( set_do )
      v34 = 1;
    LOWORD(v18) = v34 << 15;
    v44 = 0;
    goto LABEL_42;
  }
  v13 = udp_len;
  v14 = *udp_len;
  v15 = udp_len[1];
  v16 = udp_len[2];
  v17 = udp_len[3];
  v18 = udp_len[5] | (udp_len[4] << 8);
  if ( set_do )
  {
    v19 = ~((unsigned int)~(v18 << 17) >> 17) << 16;
    LOWORD(v18) = ~((unsigned int)~(v18 << 17) >> 17);
    udp_len[4] = HIBYTE(v19);
    v13[5] = v18;
  }
  v20 = v13[7] | (v13[6] << 8);
  v21 = v13 + 8;
  src = v13 + 8;
  v22 = optno == 0;
  if ( v13 + 8 - (unsigned __int8 *)header + v20 > v9 )
    v22 = 1;
  if ( !v22 )
  {
    udp_sz = v15 | (v14 << 8);
    v44 = v17 | (v16 << 8);
    if ( v20 <= 4 )
    {
      v27 = is_last;
      if ( is_last )
      {
        v21 = v13 + 8;
        goto LABEL_22;
      }
    }
    else
    {
      v24 = v13[9] | (v13[8] << 8);
      v25 = v13[11] | (v13[10] << 8);
      v26 = v13 + 0xC;
      v27 = v25;
      if ( v20 < v25 + 4 )
      {
LABEL_12:
        v12 = 0;
        is_last = 0;
LABEL_13:
        v9 = rrfilter(header, v9, 0, v27);
        goto LABEL_42;
      }
      v28 = 0;
      while ( 1 )
      {
        if ( v24 == optno )
        {
          if ( !replace )
            return v9;
          v20 -= v27 + 4;
          memcpy(v21, &v21[v25 + 4], v20 - v28);
          v13[6] = (unsigned int)(v20 << 16) >> 24;
          v13[7] = v20;
        }
        else
        {
          v21 = &v26[v25];
          v28 += v27 + 4;
        }
        if ( v28 + 4 >= v20 )
          break;
        v24 = v21[1] | (*v21 << 8);
        v25 = v21[3] | (v21[2] << 8);
        v26 = v21 + 4;
        v27 = v25;
        if ( v25 + v28 + 4 > v20 )
          goto LABEL_12;
      }
      v27 = is_last;
      if ( is_last )
      {
        if ( v21 )
        {
LABEL_22:
          v29 = (unsigned int)(v21 + 4);
          if ( limit - (v21 + 4) < (int)optlen )
            return v9;
          v30 = v13 + 6;
          goto LABEL_24;
        }
        v11 = v20;
        v12 = 0;
LABEL_42:
        v35 = skip_questions(header, v9);
        if ( !v35 )
          return v9;
        v36 = (_BYTE *)skip_section(
                         v35,
                         (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                       + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                       + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                         header,
                         v9);
        v37 = v36;
        if ( !v36 || limit < v36 + 0xB )
          return v9;
        *v36 = 0;
        v36[1] = 0;
        v36[2] = 41;
        v36[3] = HIBYTE(udp_sz);
        v36[4] = udp_sz;
        v36[5] = HIBYTE(v44);
        v36[6] = v44;
        v36[7] = BYTE1(v18);
        v36[8] = v18;
        v36[9] = (unsigned int)(v11 << 16) >> 24;
        v36[10] = v11;
        v38 = v36 + 0xB;
        src = v36 + 0xB;
        if ( v12 )
        {
          v21 = &v38[v11];
          if ( &v38[v11] > limit )
          {
            free(v12);
            return v9;
          }
          memcpy(src, v12, v11);
          free(v12);
        }
        else
        {
          v21 = v36 + 0xB;
        }
        v29 = (unsigned int)(v21 + 4);
        if ( limit - (v21 + 4) < (int)optlen )
          return v9;
        v30 = v37 + 9;
        v39 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
        header->arcount = HIBYTE(v39) | (v39 << 8);
LABEL_24:
        v31 = optno == 0;
        if ( optno )
          v31 = replace == 2;
        if ( !v31 )
        {
          if ( (unsigned int)limit < v29 )
            return v9;
          *v21 = (unsigned int)(optno << 16) >> 24;
          v21[1] = optno;
          v21[2] = optlen << 16 >> 24;
          v21[3] = optlen;
          v32 = v21 + 4;
          v21 += optlen + 4;
          if ( v21 > limit )
            return v9;
          memcpy(v32, opt, optlen);
          *v30 = (unsigned int)((v21 - (_BYTE *)src) << 16) >> 24;
          v30[1] = (_BYTE)v21 - (_BYTE)src;
        }
        return v21 - (unsigned __int8 *)header;
      }
    }
    if ( v20 )
    {
      v33 = (unsigned __int8 *)whine_malloc(v20);
      v12 = v33;
      if ( v33 )
        memcpy(v33, src, v20);
      v11 = v20;
    }
    else
    {
      v11 = 0;
      v12 = 0;
    }
    goto LABEL_13;
  }
  return v9;
}
