int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s3
  unsigned __int8 *v19; // $fp
  unsigned __int8 *v20; // $fp
  unsigned __int16 v21; // $s6
  unsigned __int8 *v22; // $s7
  int v23; // $a3
  int v24; // $v0
  int v25; // $a1
  int v26; // $v0
  int v27; // $a0
  unsigned __int8 *v28; // $a2
  int v29; // $t2
  int j; // $v0
  int result; // $v0
  int v32; // $a0
  int v33; // $v0
  int v34; // $a3
  char *v35; // $t0
  unsigned __int8 *v36; // $a0
  _WORD *v37; // $s1
  unsigned __int8 *v38; // $s7
  unsigned __int8 *v39; // $v0
  int v40; // $a3
  int t_sa; // [sp+24h] [-24h]
  int t_sb; // [sp+24h] [-24h]
  size_t t_s; // [sp+24h] [-24h]
  int i; // [sp+28h] [-20h]
  unsigned __int16 v45; // [sp+32h] [-16h]
  unsigned __int8 *p; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( pseudoheader )
  {
    v20 = udp_len;
    v21 = _byteswap_ushort(*((_WORD *)udp_len + 2));
    udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
    v45 = _byteswap_ushort(*((_WORD *)udp_len + 1));
    if ( set_do )
    {
      v21 |= 0x8000u;
      udp_len[4] = HIBYTE(v21);
      v20[5] = v21;
    }
    v22 = v20 + 8;
    v23 = v20[7] | (v20[6] << 8);
    p = v20 + 8;
    if ( v17 < v20 + 8 - (unsigned __int8 *)header + v23 || !optno )
      return v17;
    v24 = is_last;
    if ( v23 >= 5 )
    {
      v25 = v20[11] | (v20[10] << 8);
      v26 = v25 + 4;
      v27 = v20[9] | (v20[8] << 8);
      v28 = v20 + 0xC;
      if ( v23 < v25 + 4 )
      {
LABEL_41:
        is_last = 0;
        goto LABEL_42;
      }
      v29 = 0;
      if ( !replace )
      {
        for ( j = optno; v27 != j; j = optno )
        {
          v29 += v25 + 4;
          v22 = &v28[v25];
          if ( v29 + 4 >= v23 )
            goto LABEL_33;
          v25 = v22[3] | (v22[2] << 8);
          v27 = v22[1] | (*v22 << 8);
          v28 = v22 + 4;
          if ( v23 < v25 + v29 + 4 )
            goto LABEL_41;
        }
        return v17;
      }
      while ( 1 )
      {
        if ( v27 == optno )
        {
          i = v29;
          t_sa = v23 - v26;
          memcpy(v22, &v22[v25 + 4], v23 - v26 - v29);
          v23 = t_sa;
          v29 = i;
          *((_WORD *)v20 + 3) = t_sa;
        }
        else
        {
          v22 = &v28[v25];
          v29 += v26;
        }
        if ( v29 + 4 >= v23 )
          break;
        v25 = v22[3] | (v22[2] << 8);
        v27 = v22[1] | (*v22 << 8);
        v28 = v22 + 4;
        if ( v23 < v29 + 4 + v25 )
          goto LABEL_41;
        v26 = v25 + 4;
      }
LABEL_33:
      v24 = is_last;
    }
    if ( v24 )
    {
      v36 = v22 + 4;
      result = v17;
      if ( limit - (v22 + 4) < (int)optlen )
        return result;
      v37 = v20 + 6;
      goto LABEL_37;
    }
    if ( v23 )
    {
      t_s = v23;
      v39 = (unsigned __int8 *)whine_malloc(v23);
      v19 = v39;
      v40 = t_s;
      if ( v39 )
      {
        memcpy(v39, p, t_s);
        v40 = t_s;
      }
      v18 = v40;
      goto LABEL_43;
    }
LABEL_42:
    v19 = 0;
LABEL_43:
    v17 = rrfilter(header, v17, 0);
    goto LABEL_24;
  }
  v45 = 0;
  v21 = (set_do != 0) << 15;
LABEL_24:
  v32 = skip_questions(header, v17);
  if ( !v32 )
    return v17;
  v33 = skip_section(v32, header->ancount + header->nscount + header->arcount, header, v17);
  v34 = v33;
  if ( !v33 )
    return v17;
  v35 = (char *)(v33 + 0xB);
  LOWORD(p) = v33 + 0xB;
  if ( (unsigned int)limit < v33 + 0xB )
    return v17;
  *(_BYTE *)v33 = 0;
  *(_WORD *)(v33 + 1) = 41;
  *(_WORD *)(v33 + 3) = udp_sz;
  *(_WORD *)(v33 + 5) = v45;
  *(_WORD *)(v33 + 7) = v21;
  *(_WORD *)(v33 + 9) = v18;
  if ( v19 )
  {
    v22 = (unsigned __int8 *)&v35[v18];
    if ( limit >= (unsigned __int8 *)&v35[v18] )
    {
      t_sb = v33;
      memcpy(v35, v19, v18);
      free(v19);
      v34 = t_sb;
      goto LABEL_30;
    }
    free(v19);
    return v17;
  }
  v22 = (unsigned __int8 *)(v33 + 0xB);
LABEL_30:
  v36 = v22 + 4;
  result = v17;
  if ( limit - (v22 + 4) < (int)optlen )
    return result;
  ++header->arcount;
  result = v22 - (unsigned __int8 *)header;
  if ( !optno )
    return result;
  v37 = (_WORD *)(v34 + 9);
LABEL_37:
  result = v22 - (unsigned __int8 *)header;
  if ( replace != 2 )
  {
    if ( limit >= v36 )
    {
      v22[2] = BYTE2(optlen);
      *(_WORD *)v22 = optno;
      v22[3] = optlen;
      v38 = &v36[optlen];
      if ( limit >= &v36[optlen] )
      {
        memcpy(v36, opt, optlen);
        *v37 = (_WORD)v38 - (_WORD)p;
        return v38 - (unsigned __int8 *)header;
      }
    }
    return v17;
  }
  return result;
}
