int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned int udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v15; // $s1
  void *v17; // $s7
  unsigned __int8 *pseudoheader; // $v0
  unsigned __int8 *v20; // $s2
  unsigned __int8 v21; // $a2
  char v22; // $s6
  unsigned __int8 v23; // $t0
  unsigned __int8 v24; // $a3
  unsigned __int8 v25; // $a1
  unsigned __int8 *v26; // $fp
  int v27; // $s5
  int v28; // $s7
  int v29; // $v0
  unsigned __int8 *v30; // $a0
  signed int v31; // $s5
  unsigned __int8 *v32; // $v0
  _WORD *v33; // $s4
  unsigned int v34; // $fp
  void *v35; // $v0
  void *v36; // $s2
  int v37; // $v0
  _BYTE *v38; // $v0
  _BYTE *v39; // $s2
  _BYTE *v40; // $s4
  unsigned __int8 *v41; // $s2
  unsigned __int8 v42; // [sp+1Fh] [-29h]
  void *src; // [sp+20h] [-28h]
  unsigned __int8 v44; // [sp+27h] [-21h]
  unsigned __int8 v45; // [sp+2Bh] [-1Dh]
  unsigned __int8 v46; // [sp+2Fh] [-19h]
  signed int v47; // [sp+30h] [-18h]
  unsigned __int8 *v48; // [sp+34h] [-14h]
  int is_last; // [sp+3Ch] [-Ch] BYREF
  int is_sign; // [sp+40h] [-8h] BYREF
  unsigned __int8 *v51; // [sp+44h] [-4h] BYREF

  v15 = plen;
  v17 = 0;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v51, &is_sign, &is_last);
  if ( is_sign )
    return v15;
  v48 = limit;
  if ( !pseudoheader )
  {
    v47 = optlen;
    v22 = 0x80;
    if ( !set_do )
      v22 = 0;
    v34 = udp_sz >> 8;
    v27 = 0;
    v46 = 0;
    v45 = 0;
    v44 = 0;
    goto LABEL_28;
  }
  v20 = v51;
  v21 = v51[5];
  v22 = v51[4];
  v23 = v51[3];
  v24 = v51[2];
  LOBYTE(udp_sz) = v51[1];
  v25 = *v51;
  if ( set_do )
  {
    v22 |= 0x80u;
    v51[4] = v22;
  }
  if ( optno )
  {
    v47 = optlen;
    v26 = v20 + 8;
    v27 = (v20[6] << 8) | v20[7];
    if ( v15 >= v20 + 8 - (unsigned __int8 *)header + v27 )
    {
      v44 = v23;
      v45 = v24;
      v46 = v21;
      v42 = v25;
      src = v20 + 8;
      if ( (unsigned int)v27 < 5 )
      {
LABEL_16:
        if ( is_last )
        {
          v31 = optlen;
          v32 = v48;
          v33 = v20 + 6;
LABEL_34:
          v41 = v26 + 4;
          if ( v32 - (v26 + 4) >= v31 )
          {
            if ( optno && replace != 2 )
            {
              v26[3] = v31;
              v26[1] = optno;
              v26[2] = BYTE2(v31);
              *v26 = BYTE2(optno);
              memcpy(v26 + 4, opt, v31);
              v26 = &v41[v31];
              *v33 = (_WORD)v41 + v31 - (_WORD)src;
            }
            return v26 - (unsigned __int8 *)header;
          }
          return v15;
        }
        v17 = 0;
        if ( v27 )
        {
          v35 = (void *)whine_malloc(v27);
          if ( v35 )
          {
            v36 = v35;
            memcpy(v35, src, v27);
            LOBYTE(v34) = v42;
            v17 = v36;
          }
          else
          {
            LOBYTE(v34) = v42;
          }
        }
        else
        {
          LOBYTE(v34) = v42;
          v27 = 0;
        }
      }
      else
      {
        v28 = 0;
        while ( 1 )
        {
          v29 = (v26[2] << 8) | v26[3];
          if ( v27 < v29 + v28 )
            break;
          v30 = v26 + 4;
          if ( ((*v26 << 8) | v26[1]) == optno )
          {
            if ( !replace )
              return v15;
            v27 = v27 - v29 - 4;
            memcpy(v26, &v30[v29], v27 - v28);
            *((_WORD *)v20 + 3) = v27;
          }
          else
          {
            v26 = &v30[v29];
            v28 += v29 + 4;
          }
          if ( v28 + 4 >= v27 )
            goto LABEL_16;
        }
        is_last = 0;
        v27 = 0;
        LOBYTE(v34) = v42;
        v17 = 0;
      }
      v15 = rrfilter(header, v15, 0);
LABEL_28:
      v37 = skip_questions(header, v15);
      if ( !v37 )
        return v15;
      v38 = (_BYTE *)skip_section(
                       v37,
                       (_bswapw(header->nscount) >> 16)
                     + (_bswapw(header->ancount) >> 16)
                     + (_bswapw(header->arcount) >> 16),
                       header,
                       v15);
      if ( !v38 )
        return v15;
      v39 = v38;
      v38[10] = v27;
      v38[8] = v46;
      v38[7] = v22;
      v38[6] = v44;
      v38[5] = v45;
      v38[4] = udp_sz;
      v38[3] = v34;
      v38[2] = 41;
      v38[1] = 0;
      *v38 = 0;
      v38[9] = BYTE2(v27);
      v40 = v38 + 0xB;
      v26 = v38 + 0xB;
      if ( v17 )
      {
        memcpy(v38 + 0xB, v17, v27);
        free(v17);
        v26 = &v40[v27];
      }
      LOWORD(src) = (_WORD)v39 + 0xB;
      v32 = v48;
      v31 = v47;
      v33 = v39 + 9;
      if ( v48 - v26 - 4 >= v47 )
        header->arcount = _bswapw((_bswapw(header->arcount) >> 16) + 1) >> 16;
      goto LABEL_34;
    }
  }
  return v15;
}
