int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        signed int optlen,
        int set_do,
        int replace)
{
  int v9; // ebp
  dns_header *v10; // esi
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // bx
  unsigned __int8 *v14; // edi
  __int16 v15; // ax
  signed int v16; // ebx
  int v17; // ebp
  int v18; // esi
  int v19; // ecx
  unsigned __int32 v20; // eax
  int v21; // ecx
  _WORD *v22; // edi
  signed int v23; // edx
  unsigned __int8 *v24; // ebx
  size_t v25; // esi
  void *v26; // eax
  void *v27; // edi
  int v28; // eax
  __m128i v29; // xmm0
  __m128i v30; // xmm0
  int v31; // eax
  int v32; // edi
  char *v33; // ecx
  unsigned __int8 *v34; // eax
  size_t v35; // [esp-Ch] [ebp-48h]
  __int16 v36; // [esp+Eh] [ebp-2Eh]
  __int16 v38; // [esp+10h] [ebp-2Ch]
  __int16 v39; // [esp+10h] [ebp-2Ch]
  void *ptr; // [esp+14h] [ebp-28h]
  void *src; // [esp+18h] [ebp-24h]
  __int16 v42; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v45; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v45, &is_sign, &is_last);
  if ( is_sign )
    return v9;
  HIBYTE(v13) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    v42 = v13 << 15;
    ptr = 0;
    v16 = 0;
    v39 = 0;
    goto LABEL_27;
  }
  v14 = v45;
  v15 = __ROL2__(*((_WORD *)v45 + 2), 8);
  if ( set_do )
  {
    v15 |= 0x8000u;
    v45[4] = HIBYTE(v15);
  }
  if ( optno )
  {
    v42 = v15;
    v16 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
    if ( v16 + v14 + 8 - (unsigned __int8 *)header <= plen )
    {
      v38 = *((_WORD *)v14 + 1);
      src = v14 + 8;
      v36 = *(_WORD *)v14;
      if ( (unsigned int)v16 >= 5 )
      {
        v17 = 0;
        v18 = (int)(v14 + 8);
        v19 = 4;
        while ( 1 )
        {
          v20 = _byteswap_ulong(*(unsigned __int16 *)(v18 + 2) << 16);
          if ( (int)(v20 + v19) > v16 )
          {
            is_last = 0;
            v16 = 0;
            ptr = 0;
            v25 = plen;
            goto LABEL_26;
          }
          v21 = v18 + 4;
          if ( _byteswap_ulong(*(unsigned __int16 *)v18 << 16) == optno )
          {
            if ( !replace )
              return plen;
            v16 = v16 - v20 - 4;
            memcpy((void *)v18, (const void *)(v20 + v21), v16 - v17);
            *((_WORD *)v14 + 3) = __ROL2__(v16, 8);
          }
          else
          {
            v17 += v20 + 4;
            v18 = v20 + v21;
          }
          v19 = v17 + 4;
          if ( v17 + 4 >= v16 )
            goto LABEL_18;
        }
      }
      v18 = (int)(v14 + 8);
LABEL_18:
      if ( is_last )
      {
        v22 = v14 + 6;
        v9 = plen;
        v23 = optlen;
        v24 = limit;
        goto LABEL_36;
      }
      v25 = plen;
      if ( v16 )
      {
        ptr = 0;
        v26 = (void *)whine_malloc(v16);
        if ( v26 )
        {
          v27 = v26;
          memcpy(v26, src, v16);
          ptr = v27;
        }
      }
      else
      {
        ptr = 0;
        v16 = 0;
      }
LABEL_26:
      udp_sz = __ROL2__(v36, 8);
      v39 = __ROL2__(v38, 8);
      v35 = v25;
      v10 = header;
      v9 = rrfilter(header, v35, 0);
LABEL_27:
      v28 = skip_questions(v10, v9);
      if ( !v28 )
        return v9;
      v29 = _mm_cvtsi32_si128(*(_DWORD *)&v10->ancount);
      v30 = _mm_or_si128(_mm_slli_epi16(v29, 8u), _mm_srli_epi16(v29, 8u));
      v31 = skip_section(
              v28,
              _mm_cvtsi128_si32(_mm_add_epi32(_mm_srli_epi32(v30, 0x10u), _mm_unpacklo_epi16(v30, (__m128i)0LL)))
            + (unsigned __int16)__ROL2__(v10->arcount, 8),
              v10,
              v9);
      if ( !v31 )
        return v9;
      v32 = v31;
      v33 = (char *)(v31 + 11);
      if ( v31 + 11 > (unsigned int)limit )
        return v9;
      *(_WORD *)v31 = 0;
      *(_BYTE *)(v31 + 2) = 41;
      *(_BYTE *)(v31 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v31 + 4) = udp_sz;
      *(_BYTE *)(v31 + 5) = HIBYTE(v39);
      *(_BYTE *)(v31 + 6) = v39;
      *(_BYTE *)(v31 + 7) = HIBYTE(v42);
      *(_BYTE *)(v31 + 8) = v42;
      *(_BYTE *)(v31 + 9) = BYTE1(v16);
      *(_BYTE *)(v31 + 10) = v16;
      v18 = v31 + 11;
      LOWORD(src) = v31 + 11;
      if ( ptr )
      {
        v18 = (int)&v33[v16];
        if ( &v33[v16] > (char *)limit )
        {
          free(ptr);
          return v9;
        }
        memcpy(v33, ptr, v16);
        free(ptr);
      }
      v22 = (_WORD *)(v32 + 9);
      v24 = limit;
      v23 = optlen;
      if ( (int)&limit[-v18 - 4] >= optlen )
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_36:
      v34 = (unsigned __int8 *)(v18 + 4);
      if ( (int)&v24[-v18 - 4] < v23 )
        return v9;
      if ( optno && replace != 2 )
      {
        if ( v34 > v24 )
          return v9;
        *(_BYTE *)v18 = BYTE1(optno);
        *(_BYTE *)(v18 + 1) = optno;
        *(_BYTE *)(v18 + 2) = BYTE1(v23);
        *(_BYTE *)(v18 + 3) = v23;
        v18 = (int)&v34[v23];
        if ( &v34[v23] > v24 )
          return v9;
        memcpy(v34, opt, v23);
        *v22 = __ROL2__(v18 - (_WORD)src, 8);
      }
      return v18 - (_DWORD)header;
    }
  }
  return v9;
}
