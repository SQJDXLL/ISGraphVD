size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  __int16 v9; // r0
  dns_header *v10; // r0
  size_t v11; // r1
  int v12; // r0
  unsigned __int8 *v13; // r1
  uint16_t v14; // r0
  int *v16; // [sp+0h] [bp-C0h]
  int *v17; // [sp+4h] [bp-BCh]
  int v18; // [sp+8h] [bp-B8h]
  int v19; // [sp+Ch] [bp-B4h]
  unsigned __int8 *v20; // [sp+10h] [bp-B0h]
  unsigned __int8 *v21; // [sp+18h] [bp-A8h]
  unsigned __int8 v22; // [sp+1Eh] [bp-A2h]
  unsigned __int8 *v23; // [sp+20h] [bp-A0h]
  unsigned __int8 *v24; // [sp+28h] [bp-98h]
  unsigned __int8 *v25; // [sp+30h] [bp-90h]
  unsigned __int8 v26; // [sp+36h] [bp-8Ah]
  unsigned __int8 *v27; // [sp+38h] [bp-88h]
  unsigned __int8 *v28; // [sp+40h] [bp-80h]
  unsigned __int8 *v29; // [sp+48h] [bp-78h]
  unsigned __int8 v30; // [sp+4Eh] [bp-72h]
  unsigned __int8 *v31; // [sp+50h] [bp-70h]
  unsigned __int8 *v32; // [sp+58h] [bp-68h]
  unsigned __int8 v33; // [sp+5Eh] [bp-62h]
  unsigned __int8 *t_cp_2; // [sp+6Ch] [bp-54h]
  unsigned __int16 len; // [sp+80h] [bp-40h]
  unsigned __int16 code; // [sp+82h] [bp-3Eh]
  int i; // [sp+84h] [bp-3Ch]
  unsigned __int16 rcode; // [sp+88h] [bp-38h]
  unsigned __int16 flags; // [sp+8Ah] [bp-36h]
  int is_last; // [sp+8Ch] [bp-34h] BYREF
  int is_sign; // [sp+90h] [bp-30h] BYREF
  int rdlen; // [sp+94h] [bp-2Ch]
  unsigned __int8 *buff; // [sp+98h] [bp-28h]
  unsigned __int8 *udp_len; // [sp+9Ch] [bp-24h] BYREF
  unsigned __int8 *p; // [sp+A0h] [bp-20h]
  unsigned __int8 *datap; // [sp+A4h] [bp-1Ch]
  unsigned __int8 *lenp; // [sp+A8h] [bp-18h]
  unsigned __int16 udp_sza; // [sp+AEh] [bp-12h]
  unsigned __int8 *limita; // [sp+B0h] [bp-10h]
  size_t plena; // [sp+B4h] [bp-Ch]
  dns_header *headera; // [sp+B8h] [bp-8h]

  headera = header;
  plena = plen;
  limita = limit;
  udp_sza = udp_sz;
  buff = 0;
  rdlen = 0;
  v9 = set_do;
  if ( set_do )
    v9 = 1;
  flags = v9 << 15;
  rcode = 0;
  v10 = headera;
  v11 = plena;
  *(_DWORD *)(optno + 4) = &is_last;
  *(_DWORD *)optno = &is_sign;
  p = find_pseudoheader(v10, v11, 0u, &udp_len, v16, v17);
  if ( is_sign )
    return plena;
  if ( p )
  {
    p = udp_len;
    udp_sza = _byteswap_ushort(*(_WORD *)udp_len);
    p = udp_len + 2;
    rcode = _byteswap_ushort(*((_WORD *)udp_len + 1));
    p = udp_len + 4;
    flags = _byteswap_ushort(*((_WORD *)udp_len + 2));
    p = udp_len + 6;
    if ( set_do )
    {
      p += -0x2;
      flags |= 0x8000u;
      t_cp_2 = p + 1;
      *p = HIBYTE(flags);
      *t_cp_2 = flags;
      p += 2;
    }
    lenp = p;
    rdlen = p[1] | (*p << 8);
    p += 2;
    if ( p - (unsigned __int8 *)headera + rdlen > plena )
      return plena;
    datap = p;
    if ( !optno )
      return plena;
    i = 0;
    while ( i + 4 < rdlen )
    {
      code = _byteswap_ushort(*(_WORD *)p);
      p += 2;
      len = _byteswap_ushort(*(_WORD *)p);
      p += 2;
      if ( i + len > rdlen )
      {
        rdlen = 0;
        is_last = 0;
        break;
      }
      if ( code == optno )
      {
        if ( !replace )
          return plena;
        p += -0x4;
        rdlen = rdlen - len - 4;
        memcpy(p, &p[len + 4], rdlen - i);
        v33 = rdlen;
        v32 = lenp + 1;
        *lenp = BYTE1(rdlen);
        *v32 = v33;
        lenp += 2;
        lenp += -0x2;
      }
      else
      {
        p += len;
        i += len + 4;
      }
    }
    if ( !is_last )
    {
      if ( rdlen )
      {
        buff = (unsigned __int8 *)whine_malloc(rdlen);
        if ( buff )
          memcpy(buff, datap, rdlen);
      }
      plena = rrfilter(headera, plena);
      p = 0;
    }
  }
  if ( !p )
  {
    p = (unsigned __int8 *)skip_questions(headera, plena);
    if ( !p )
      return plena;
    v20 = p;
    v18 = ntohs(headera->ancount);
    v19 = v18 + ntohs(headera->nscount);
    v12 = ntohs(headera->arcount);
    p = (unsigned __int8 *)skip_section(v20, v19 + v12, headera, plena);
    if ( !p )
      return plena;
    v13 = p++;
    *v13 = 0;
    v31 = p + 1;
    *p = 0;
    *v31 = 41;
    p += 2;
    v30 = udp_sza;
    v29 = p + 1;
    *p = HIBYTE(udp_sza);
    *v29 = v30;
    p += 2;
    v28 = p + 1;
    *p = HIBYTE(rcode);
    *v28 = rcode;
    p += 2;
    v27 = p + 1;
    *p = HIBYTE(flags);
    *v27 = flags;
    p += 2;
    lenp = p;
    v26 = rdlen;
    v25 = p + 1;
    *p = BYTE1(rdlen);
    *v25 = v26;
    p += 2;
    datap = p;
    if ( buff )
    {
      memcpy(p, buff, rdlen);
      free(buff);
      p += rdlen;
    }
    if ( (int)optlen <= limita - p - 4 )
    {
      v14 = ntohs(headera->arcount);
      headera->arcount = htons(v14 + 1);
    }
  }
  if ( (int)optlen > limita - p - 4 )
    return plena;
  if ( optno && replace != 2 )
  {
    v24 = p + 1;
    *p = BYTE1(optno);
    *v24 = optno;
    p += 2;
    v23 = p + 1;
    *p = BYTE1(optlen);
    *v23 = optlen;
    p += 2;
    memcpy(p, opt, optlen);
    p += optlen;
    v22 = (_BYTE)p - (_BYTE)datap;
    v21 = lenp + 1;
    *lenp = (unsigned __int16)((_WORD)p - (_WORD)datap) >> 8;
    *v21 = v22;
    lenp += 2;
  }
  return p - (unsigned __int8 *)headera;
}
