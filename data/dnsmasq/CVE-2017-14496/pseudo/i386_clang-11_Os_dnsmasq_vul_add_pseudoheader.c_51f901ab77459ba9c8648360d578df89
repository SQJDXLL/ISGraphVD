int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        int optlen,
        int set_do,
        int replace)
{
  int v9; // edi
  dns_header *v10; // ebp
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // bx
  unsigned __int8 *v14; // edi
  __int16 v15; // dx
  int v16; // esi
  __int16 v17; // ax
  int v18; // ebx
  char *v19; // esi
  signed int v20; // ebx
  int v21; // ebp
  unsigned __int32 v22; // eax
  unsigned __int8 *v23; // ecx
  _WORD *v24; // edi
  __int16 v25; // si
  void *v26; // eax
  void *v27; // edi
  int v28; // eax
  __m128i v29; // xmm1
  __m128i v30; // xmm0
  int v31; // eax
  _BYTE *v32; // edi
  __int16 v33; // ax
  char *v34; // ebx
  __int16 v35; // [esp+Ah] [ebp-32h]
  void *ptr; // [esp+Ch] [ebp-30h]
  char *src; // [esp+10h] [ebp-2Ch]
  size_t v39; // [esp+14h] [ebp-28h]
  __int16 v40; // [esp+18h] [ebp-24h]
  int is_last; // [esp+1Ch] [ebp-20h] BYREF
  int v42; // [esp+20h] [ebp-1Ch]
  unsigned __int8 *v43; // [esp+24h] [ebp-18h] BYREF
  int is_sign[5]; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v43, is_sign, &is_last);
  if ( is_sign[0] )
    return plen;
  HIBYTE(v13) = 0;
  if ( !pseudoheader )
  {
    LOBYTE(v13) = set_do != 0;
    ptr = 0;
    v25 = 0;
    v40 = v13 << 15;
    v20 = 0;
    goto LABEL_26;
  }
  v39 = plen;
  v14 = v43;
  v15 = *(_WORD *)v43;
  v16 = *((unsigned __int16 *)v43 + 1);
  v17 = __ROL2__(*((_WORD *)v43 + 2), 8);
  if ( set_do )
  {
    v17 |= 0x8000u;
    v43[4] = HIBYTE(v17);
  }
  if ( optno )
  {
    v18 = *((unsigned __int16 *)v14 + 3);
    v42 = v16;
    v19 = (char *)(v14 + 8);
    v40 = v17;
    v35 = v15;
    v20 = _byteswap_ulong(v18 << 16);
    if ( v20 + v14 + 8 - (unsigned __int8 *)header <= plen )
    {
      src = (char *)(v14 + 8);
      if ( (unsigned int)v20 < 5 )
      {
LABEL_17:
        v10 = header;
        if ( is_last )
        {
          v24 = v14 + 6;
LABEL_32:
          v34 = v19 + 4;
          if ( limit - (unsigned __int8 *)(v19 + 4) >= optlen )
          {
            if ( optno && replace != 2 )
            {
              *v19 = BYTE1(optno);
              v19[1] = optno;
              v19[2] = BYTE1(optlen);
              v19[3] = optlen;
              memcpy(v34, opt, optlen);
              v19 = &v34[optlen];
              *v24 = __ROL2__(optlen + (_WORD)v34 - (_WORD)src, 8);
            }
            return v19 - (char *)v10;
          }
          return v39;
        }
        if ( v20 )
        {
          ptr = 0;
          v26 = (void *)whine_malloc(v20);
          if ( v26 )
          {
            v27 = v26;
            memcpy(v26, src, v20);
            ptr = v27;
          }
        }
        else
        {
          ptr = 0;
          v20 = 0;
        }
      }
      else
      {
        v21 = 0;
        while ( 1 )
        {
          v22 = _byteswap_ulong(*((unsigned __int16 *)v19 + 1) << 16);
          if ( (int)(v22 + v21) > v20 )
            break;
          v23 = (unsigned __int8 *)(v19 + 4);
          if ( _byteswap_ulong(*(unsigned __int16 *)v19 << 16) == optno )
          {
            if ( !replace )
              return v39;
            v20 = v20 - v22 - 4;
            memcpy(v19, &v23[v22], v20 - v21);
            *((_WORD *)v14 + 3) = __ROL2__(v20, 8);
          }
          else
          {
            v21 += v22 + 4;
            v19 = (char *)&v23[v22];
          }
          if ( v21 + 4 >= v20 )
            goto LABEL_17;
        }
        v10 = header;
        is_last = 0;
        v20 = 0;
        ptr = 0;
      }
      udp_sz = __ROL2__(v35, 8);
      v25 = __ROL2__(v42, 8);
      v9 = rrfilter(v10, plen, 0);
LABEL_26:
      v28 = skip_questions(v10, v9);
      v39 = v9;
      if ( !v28 )
        return v39;
      v29 = _mm_cvtsi32_si128(*(_DWORD *)&v10->ancount);
      v30 = _mm_unpacklo_epi16(_mm_or_si128(_mm_slli_epi16(v29, 8u), _mm_srli_epi16(v29, 8u)), (__m128i)0LL);
      v31 = skip_section(
              v28,
              _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v30, 229), v30))
            + (unsigned __int16)__ROL2__(v10->arcount, 8),
              v10,
              v9);
      if ( !v31 )
        return v39;
      v32 = (_BYTE *)v31;
      *(_WORD *)v31 = 0;
      *(_BYTE *)(v31 + 2) = 41;
      src = (char *)(v31 + 11);
      *(_BYTE *)(v31 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v31 + 4) = udp_sz;
      v33 = v25;
      v19 = v32 + 11;
      v32[5] = HIBYTE(v33);
      v32[6] = v33;
      v32[7] = HIBYTE(v40);
      v32[8] = v40;
      v32[9] = BYTE1(v20);
      v32[10] = v20;
      if ( ptr )
      {
        memcpy(v32 + 11, ptr, v20);
        free(ptr);
        v19 = &src[v20];
      }
      v24 = v32 + 9;
      if ( limit - (unsigned __int8 *)v19 - 4 >= optlen )
        v10->arcount = __ROL2__(__ROL2__(v10->arcount, 8) + 1, 8);
      goto LABEL_32;
    }
  }
  return v39;
}
