size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  int v9; // r9
  unsigned int v11; // r4
  unsigned __int8 *pseudoheader; // r0
  int v13; // r10
  unsigned __int8 *v14; // r7
  unsigned __int8 *v15; // r11
  unsigned int v16; // r3
  unsigned __int8 *v17; // r5
  unsigned int v18; // r3
  int v19; // r7
  unsigned int v20; // r2
  signed int v21; // r3
  unsigned int v22; // r1
  unsigned int v23; // r12
  signed int v24; // r2
  int v25; // r1
  unsigned __int8 *v26; // r12
  char *v27; // r9
  int v28; // r11
  unsigned int v29; // r1
  unsigned int v30; // r0
  int v31; // r2
  __int16 v32; // r5
  int v33; // r11
  int v34; // r0
  unsigned __int8 *v36; // r0
  int v37; // r3
  char *v38; // r5
  _BYTE *v39; // r11
  bool v40; // zf
  int v41; // r2
  _BYTE *v42; // r0
  _BYTE *v43; // r3
  void *v44; // r0
  unsigned __int16 v45; // r3
  void *src; // [sp+10h] [bp-48h]
  unsigned int v48; // [sp+14h] [bp-44h]
  _BYTE *v49; // [sp+14h] [bp-44h]
  unsigned int t_cp; // [sp+18h] [bp-40h]
  __int16 n; // [sp+1Ch] [bp-3Ch]
  size_t na; // [sp+1Ch] [bp-3Ch]
  unsigned __int8 *udp_len; // [sp+20h] [bp-38h] BYREF
  int is_sign; // [sp+24h] [bp-34h] BYREF
  int is_last; // [sp+28h] [bp-30h] BYREF

  LOWORD(v9) = udp_sz;
  v11 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v13 = is_sign;
  if ( is_sign )
    return v11;
  v14 = pseudoheader;
  if ( !pseudoheader )
  {
    v32 = set_do;
    if ( set_do )
      v32 = 1;
    LOWORD(v17) = v32 << 15;
    LOWORD(v33) = 0;
LABEL_20:
    v34 = skip_questions(header, v11);
    if ( v34 )
    {
      v42 = (_BYTE *)skip_section(
                       v34,
                       (unsigned __int16)(HIBYTE(header->ancount) | (header->ancount << 8))
                     + (unsigned __int16)(HIBYTE(header->nscount) | (header->nscount << 8))
                     + (unsigned __int16)(HIBYTE(header->arcount) | (header->arcount << 8)),
                       header,
                       v11);
      v43 = v42;
      if ( v42 )
      {
        v42[9] = (unsigned int)(v13 << 16) >> 24;
        v42[4] = v9;
        v42[6] = v33;
        v42[8] = (_BYTE)v17;
        *v42 = 0;
        v42[1] = 0;
        v44 = v42 + 0xB;
        v43[3] = BYTE1(v9);
        v43[5] = BYTE1(v33);
        v43[7] = BYTE1(v17);
        v43[10] = v13;
        v43[2] = 41;
        src = v43 + 0xB;
        if ( v14 )
        {
          v27 = &v43[v13 + 0xB];
          v49 = v43;
          memcpy(v44, v14, v13);
          free(v14);
          v43 = v49;
        }
        else
        {
          v27 = v43 + 0xB;
        }
        v38 = v27 + 4;
        if ( limit - (unsigned __int8 *)(v27 + 4) >= (int)optlen )
        {
          v39 = v43 + 9;
          v45 = (HIBYTE(header->arcount) | (header->arcount << 8)) + 1;
          header->arcount = HIBYTE(v45) | (v45 << 8);
          goto LABEL_35;
        }
      }
    }
    return v11;
  }
  v15 = udp_len;
  v16 = udp_len[4] | (udp_len[5] << 8);
  v48 = *udp_len | (udp_len[1] << 8);
  v17 = (unsigned __int8 *)(unsigned __int16)((v16 >> 8) | ((_WORD)v16 << 8));
  t_cp = udp_len[2] | (udp_len[3] << 8);
  if ( set_do )
  {
    v18 = ~((unsigned int)~((_DWORD)v17 << 17) >> 17) << 16;
    LOWORD(v17) = ~((unsigned int)~((_DWORD)v17 << 17) >> 17);
    udp_len[4] = HIBYTE(v18);
    v15[5] = (unsigned __int8)v17;
  }
  v19 = optno == 0;
  v20 = v15[6] | (v15[7] << 8);
  v21 = (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8));
  src = v15 + 8;
  if ( v15 + 8 - (unsigned __int8 *)header + v21 > v11 )
    v19 = 1;
  if ( v19 )
    return v11;
  if ( (unsigned __int16)((v20 >> 8) | ((_WORD)v20 << 8)) <= 4u )
  {
    if ( !is_last )
      goto LABEL_27;
    v27 = (char *)(v15 + 8);
  }
  else
  {
    v22 = v15[10] | (v15[11] << 8);
    v23 = v15[8] | (v15[9] << 8);
    v24 = (unsigned __int16)((v22 >> 8) | ((_WORD)v22 << 8));
    v25 = (unsigned __int16)((v23 >> 8) | ((_WORD)v23 << 8));
    v26 = v15 + 0xC;
    if ( v21 < v24 )
    {
LABEL_23:
      is_last = 0;
      goto LABEL_24;
    }
    n = (__int16)v17;
    v27 = (char *)(v15 + 8);
    v17 = v15;
    v28 = v21;
    while ( 1 )
    {
      if ( v25 == optno )
      {
        if ( !replace )
          return v11;
        v31 = v24 + 4;
        v28 -= v31;
        memcpy(v27, &v27[v31], v28 - v19);
        v17[7] = v28;
        v17[6] = (unsigned int)(v28 << 16) >> 24;
      }
      else
      {
        v27 = (char *)&v26[v24];
        v19 += v24 + 4;
      }
      if ( v19 + 4 >= v28 )
        break;
      v29 = (unsigned __int8)v27[2] | ((unsigned __int8)v27[3] << 8);
      v26 = (unsigned __int8 *)(v27 + 4);
      v30 = (unsigned __int8)*v27 | ((unsigned __int8)v27[1] << 8);
      v24 = (unsigned __int16)((v29 >> 8) | ((_WORD)v29 << 8));
      v25 = (unsigned __int16)((v30 >> 8) | ((_WORD)v30 << 8));
      if ( v24 + v19 > v28 )
      {
        LOWORD(v17) = n;
        goto LABEL_23;
      }
    }
    v21 = v28;
    v15 = v17;
    LOWORD(v17) = n;
    if ( !is_last )
    {
LABEL_27:
      if ( v21 )
      {
        na = v21;
        v36 = (unsigned __int8 *)whine_malloc(v21);
        v37 = na;
        v14 = v36;
        if ( v36 )
        {
          memcpy(v36, src, na);
          v37 = na;
        }
        v13 = v37;
        goto LABEL_25;
      }
LABEL_24:
      v14 = 0;
LABEL_25:
      v9 = (v48 >> 8) | (v48 << 8);
      v33 = (t_cp >> 8) | (t_cp << 8);
      v11 = rrfilter(header, v11, 0);
      goto LABEL_20;
    }
  }
  v38 = v27 + 4;
  if ( limit - (unsigned __int8 *)(v27 + 4) < (int)optlen )
    return v11;
  v39 = v15 + 6;
LABEL_35:
  v40 = optno == 0;
  if ( optno )
    v40 = replace == 2;
  if ( !v40 )
  {
    v27[1] = optno;
    v27[3] = optlen;
    v27[2] = optlen << 16 >> 24;
    *v27 = (unsigned int)(optno << 16) >> 24;
    memcpy(v38, opt, optlen);
    v27 = &v38[optlen];
    v41 = &v38[optlen] - (_BYTE *)src;
    *v39 = (unsigned int)(v41 << 16) >> 24;
    v39[1] = v41;
  }
  return v27 - (char *)header;
}
