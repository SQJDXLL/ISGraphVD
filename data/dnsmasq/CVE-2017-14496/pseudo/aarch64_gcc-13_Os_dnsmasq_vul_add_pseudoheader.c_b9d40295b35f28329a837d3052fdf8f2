size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int64 v11; // x21
  unsigned int v12; // w24
  unsigned __int8 *pseudoheader; // x0
  int v16; // w28
  int v17; // w7
  unsigned __int8 *v18; // x22
  unsigned __int8 *v19; // x22
  unsigned int v20; // w24
  unsigned int v21; // w19
  char *v22; // x23
  unsigned __int16 v23; // w0
  unsigned __int8 *v24; // x4
  int v25; // w6
  _WORD *v26; // x22
  bool v27; // zf
  char *v28; // x0
  __int64 v29; // x1
  int v30; // w2
  __int64 v31; // x1
  unsigned __int16 *v32; // x0
  unsigned __int8 *v33; // x0
  unsigned int v34; // w23
  __int64 v35; // x0
  __int64 v36; // x0
  __int64 v37; // x3
  unsigned __int16 set_dob; // [xsp+68h] [xbp+68h]
  __int64 set_doc; // [xsp+68h] [xbp+68h]
  int i; // [xsp+78h] [xbp+78h]
  int is_sign; // [xsp+88h] [xbp+88h] BYREF
  int is_last; // [xsp+8Ch] [xbp+8Ch] BYREF
  unsigned __int8 *udp_len; // [xsp+90h] [xbp+90h] BYREF

  v11 = plen;
  v12 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0uLL, &udp_len, &is_sign, &is_last);
  v16 = is_sign;
  if ( is_sign )
    return v11;
  v17 = set_do;
  v18 = pseudoheader;
  if ( pseudoheader )
  {
    v19 = udp_len;
    set_dob = *((_WORD *)udp_len + 1);
    v20 = *(unsigned __int16 *)udp_len;
    v21 = (unsigned __int16)__rev16(*((unsigned __int16 *)udp_len + 2));
    if ( v17 )
    {
      v21 |= 0x8000u;
      *((_WORD *)udp_len + 2) = __rev16(v21);
    }
    v22 = (char *)(v19 + 8);
    v23 = __rev16(*((unsigned __int16 *)v19 + 3));
    if ( v19 + 8 - (unsigned __int8 *)header + (unsigned __int64)v23 > v11 || !optno )
      return v11;
    v16 = v23;
    v24 = v19 + 8;
    v25 = 0;
    while ( v25 + 4 < v16 )
    {
      v29 = (unsigned __int16)__rev16(*((unsigned __int16 *)v24 + 1));
      v30 = (unsigned __int16)__rev16(*(unsigned __int16 *)v24);
      if ( v25 + (int)v29 > v16 )
      {
        is_last = 0;
LABEL_21:
        v16 = 0;
        v18 = 0LL;
        goto LABEL_29;
      }
      if ( v30 == optno )
      {
        if ( !replace )
          return v11;
        v31 = v29 + 4;
        v16 -= v31;
        i = v25;
        v32 = (unsigned __int16 *)memcpy(v24, &v24[v31], v16 - v25);
        v25 = i;
        v24 = (unsigned __int8 *)v32;
        *((_WORD *)v19 + 3) = __rev16(v16);
      }
      else
      {
        v25 += v29 + 4;
        v24 += (unsigned int)v29 + 4;
      }
    }
    if ( is_last )
    {
      v26 = v19 + 6;
      goto LABEL_11;
    }
    if ( !v16 )
      goto LABEL_21;
    v33 = (unsigned __int8 *)whine_malloc(v16);
    v18 = v33;
    if ( v33 )
      memcpy(v33, v22, v16);
LABEL_29:
    v12 = (unsigned __int16)__rev16(v20);
    v34 = (unsigned __int16)__rev16(set_dob);
    v11 = rrfilter(header, v11, 0LL);
  }
  else
  {
    v34 = 0;
    v21 = (set_do != 0) << 15;
  }
  v35 = skip_questions(header, v11);
  if ( v35 )
  {
    v36 = skip_section(
            v35,
            (unsigned __int16)__rev16(header->nscount)
          + (unsigned __int16)__rev16(header->ancount)
          + (unsigned int)(unsigned __int16)__rev16(header->arcount),
            header,
            v11);
    v37 = v36;
    if ( v36 )
    {
      *(_WORD *)v36 = 0;
      *(_BYTE *)(v36 + 2) = 41;
      *(_WORD *)(v36 + 3) = __rev16(v12);
      *(_WORD *)(v36 + 5) = __rev16(v34);
      v22 = (char *)(v36 + 0xB);
      *(_WORD *)(v36 + 7) = __rev16(v21);
      *(_WORD *)(v36 + 9) = __rev16(v16);
      if ( v18 )
      {
        set_doc = v36;
        memcpy((void *)(v36 + 0xB), v18, v16);
        free(v18);
        v37 = set_doc;
        v24 = (unsigned __int8 *)&v22[v16];
      }
      else
      {
        v24 = (unsigned __int8 *)(v36 + 0xB);
      }
      if ( limit - (v24 + 4) >= (__int64)optlen )
        header->arcount = __rev16((unsigned __int16)__rev16(header->arcount) + 1);
      v26 = (_WORD *)(v37 + 9);
LABEL_11:
      if ( limit - (v24 + 4) >= (__int64)optlen )
      {
        if ( optno )
          v27 = replace == 2;
        else
          v27 = 1;
        if ( !v27 )
        {
          *(_WORD *)v24 = __rev16(optno);
          *((_WORD *)v24 + 1) = __rev16(optlen);
          v28 = (char *)memcpy(v24 + 4, opt, optlen);
          v24 = (unsigned __int8 *)&v28[optlen];
          *v26 = __rev16((_DWORD)v28 + optlen - (_DWORD)v22);
        }
        return v24 - (unsigned __int8 *)header;
      }
    }
  }
  return v11;
}
