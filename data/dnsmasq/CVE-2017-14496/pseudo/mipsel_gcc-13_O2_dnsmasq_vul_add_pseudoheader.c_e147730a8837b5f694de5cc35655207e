size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $fp
  unsigned __int8 *v19; // $t0
  unsigned __int8 *v20; // $s7
  unsigned int v21; // $v0
  __int16 v22; // $s4
  unsigned int v23; // $v0
  signed int v24; // $s6
  size_t result; // $v0
  unsigned __int8 *v26; // $a0
  unsigned int v27; // $v0
  unsigned int v28; // $a0
  signed int v29; // $v1
  int v30; // $v0
  unsigned __int8 *v31; // $a2
  int v32; // $t2
  int v33; // $v0
  unsigned int v34; // $a2
  unsigned int v35; // $a1
  int v36; // $v1
  __int16 v37; // $s7
  int v38; // $a0
  void *v39; // $a3
  _BYTE *v40; // $s0
  char *v41; // $a3
  void *v42; // $t0
  int v43; // $v0
  _BYTE *v44; // $v0
  _BYTE *v45; // $v1
  _BYTE *v46; // $s4
  void *v47; // $v0
  int ia; // [sp+24h] [-24h]
  unsigned __int8 *i; // [sp+24h] [-24h]
  int ib; // [sp+24h] [-24h]
  unsigned __int8 *t_cp; // [sp+2Ch] [-1Ch]
  unsigned int v52; // [sp+30h] [-18h]
  _BYTE *v53; // [sp+30h] [-18h]
  unsigned int v54; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    v37 = 0;
    v22 = (set_do != 0) << 15;
LABEL_17:
    i = v19;
    v38 = skip_questions(header, v17);
    if ( v38 )
    {
      v44 = (_BYTE *)skip_section(
                       v38,
                       (unsigned __int16)((header->ancount << 8) | HIBYTE(header->ancount))
                     + (unsigned __int16)((header->nscount << 8) | HIBYTE(header->nscount))
                     + (unsigned __int16)((header->arcount << 8) | HIBYTE(header->arcount)),
                       header,
                       v17);
      v45 = v44;
      if ( v44 )
      {
        v44[9] = BYTE1(v18);
        v44[8] = v22;
        *v44 = 0;
        v44[1] = 0;
        v44[2] = 41;
        v44[3] = HIBYTE(udp_sz);
        v44[4] = udp_sz;
        v44[5] = HIBYTE(v37);
        v44[6] = v37;
        v44[7] = HIBYTE(v22);
        v44[10] = v18;
        v46 = v44 + 0xB;
        LOWORD(t_cp) = (_WORD)v44 + 0xB;
        if ( i )
        {
          v53 = v44;
          memcpy(v44 + 0xB, i, v18);
          free(i);
          v45 = v53;
          v26 = &v46[v18];
        }
        else
        {
          v26 = v44 + 0xB;
        }
        v39 = v26 + 4;
        result = v17;
        if ( limit - (v26 + 4) >= (int)optlen )
        {
          header->arcount = ((((unsigned __int16)(header->arcount << 8) | HIBYTE(header->arcount)) + 1) << 8) | ((unsigned __int16)(((header->arcount << 8) | HIBYTE(header->arcount)) + 1) >> 8);
          if ( !optno )
            return v26 - (unsigned __int8 *)header;
          v40 = v45 + 9;
LABEL_24:
          if ( replace != 2 )
          {
            v26[2] = BYTE1(optlen);
            *v26 = BYTE1(optno);
            v26[1] = optno;
            v26[3] = optlen;
            v41 = (char *)memcpy(v39, opt, optlen);
            v26 = (unsigned __int8 *)&v41[optlen];
            *v40 = (unsigned __int16)((_WORD)v41 + optlen - (_WORD)t_cp) >> 8;
            v40[1] = (_BYTE)v41 + optlen - (_BYTE)t_cp;
          }
          return v26 - (unsigned __int8 *)header;
        }
        return result;
      }
    }
    return v17;
  }
  v20 = udp_len;
  v21 = (udp_len[5] << 8) | udp_len[4];
  v54 = (udp_len[1] << 8) | *udp_len;
  v52 = (udp_len[3] << 8) | udp_len[2];
  v22 = ((_WORD)v21 << 8) | (v21 >> 8);
  if ( set_do )
  {
    v22 |= 0x8000u;
    udp_len[4] = HIBYTE(v22);
    v20[5] = v22;
  }
  v23 = (v20[7] << 8) | v20[6];
  t_cp = v20 + 8;
  v24 = (unsigned __int16)(((_WORD)v23 << 8) | (v23 >> 8));
  result = v17;
  if ( v17 < v20 + 8 - (unsigned __int8 *)header + v24 )
    return result;
  if ( !optno )
    return v17;
  v26 = v20 + 8;
  if ( v24 >= 5 )
  {
    v27 = (v20[11] << 8) | v20[10];
    v28 = (v20[9] << 8) | v20[8];
    v29 = (unsigned __int16)(((_WORD)v27 << 8) | (v27 >> 8));
    v30 = (unsigned __int16)(((_WORD)v28 << 8) | (v28 >> 8));
    v31 = v20 + 0xC;
    if ( v24 >= v29 )
    {
      v26 = v20 + 8;
      v32 = 0;
      do
      {
        if ( v30 == optno )
        {
          v36 = v29 + 4;
          if ( !replace )
            return v17;
          v24 -= v36;
          ia = v32;
          v26 = (unsigned __int8 *)memcpy(v26, &v26[v36], v24 - v32);
          v32 = ia;
          v20[6] = BYTE1(v24);
          v20[7] = v24;
        }
        else
        {
          v26 = &v31[v29];
          v32 += v29 + 4;
        }
        v33 = is_last;
        if ( v32 + 4 >= v24 )
          goto LABEL_21;
        v34 = (v26[3] << 8) | v26[2];
        v35 = (v26[1] << 8) | *v26;
        v29 = (unsigned __int16)(((_WORD)v34 << 8) | (v34 >> 8));
        v30 = (unsigned __int16)(((_WORD)v35 << 8) | (v35 >> 8));
        v31 = v26 + 4;
      }
      while ( v24 >= v29 + v32 );
    }
    is_last = 0;
    goto LABEL_28;
  }
  v33 = is_last;
LABEL_21:
  if ( !v33 )
  {
    if ( v24 )
    {
      v47 = (void *)whine_malloc(v24);
      v42 = v47;
      if ( v47 )
        v42 = memcpy(v47, t_cp, v24);
      v18 = v24;
      goto LABEL_29;
    }
LABEL_28:
    v42 = 0;
LABEL_29:
    ib = (int)v42;
    v43 = rrfilter(header, v17, 0);
    udp_sz = ((_WORD)v54 << 8) | (v54 >> 8);
    v19 = (unsigned __int8 *)ib;
    v37 = ((_WORD)v52 << 8) | (v52 >> 8);
    v17 = v43;
    goto LABEL_17;
  }
  v39 = v26 + 4;
  result = v17;
  if ( limit - (v26 + 4) >= (int)optlen )
  {
    v40 = v20 + 6;
    goto LABEL_24;
  }
  return result;
}
