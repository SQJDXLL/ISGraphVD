int __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        int optlen,
        int set_do,
        int replace)
{
  int v9; // esi
  dns_header *v10; // ebp
  unsigned __int8 *pseudoheader; // eax
  __int16 v13; // bx
  unsigned __int8 *v14; // edi
  __int16 v15; // dx
  __int16 v16; // bx
  __int16 v17; // ax
  signed int v18; // ebx
  int v19; // ebp
  char *v20; // esi
  unsigned __int32 v21; // eax
  unsigned __int16 *v22; // ecx
  __int16 v23; // cx
  _WORD *v24; // edi
  void *v25; // eax
  size_t v26; // esi
  void *v27; // edi
  int v28; // eax
  unsigned __int32 v29; // ecx
  int v30; // edx
  int v31; // eax
  __m128i v32; // xmm1
  __m128i v33; // xmm0
  int v34; // eax
  int v35; // edi
  char *v36; // ebx
  __int16 v37; // [esp+Ah] [ebp-32h]
  void *src; // [esp+Ch] [ebp-30h]
  __int16 srca; // [esp+Ch] [ebp-30h]
  void *ptr; // [esp+10h] [ebp-2Ch]
  __int16 v42; // [esp+14h] [ebp-28h]
  __int16 v43; // [esp+14h] [ebp-28h]
  size_t v44; // [esp+18h] [ebp-24h]
  __int16 v45; // [esp+1Ch] [ebp-20h]
  int is_last; // [esp+20h] [ebp-1Ch] BYREF
  int is_sign; // [esp+24h] [ebp-18h] BYREF
  unsigned __int8 *v48; // [esp+28h] [ebp-14h] BYREF

  v9 = plen;
  v10 = header;
  pseudoheader = find_pseudoheader(header, plen, 0, &v48, &is_sign, &is_last);
  if ( is_sign )
    return v9;
  HIBYTE(v13) = 0;
  if ( pseudoheader )
  {
    v14 = v48;
    v15 = *(_WORD *)v48;
    v16 = *((_WORD *)v48 + 1);
    v17 = __ROL2__(*((_WORD *)v48 + 2), 8);
    if ( set_do )
    {
      v17 |= 0x8000u;
      v48[4] = HIBYTE(v17);
    }
    v44 = plen;
    if ( !optno )
      return v44;
    v42 = v16;
    v45 = v17;
    v18 = _byteswap_ulong(*((unsigned __int16 *)v14 + 3) << 16);
    if ( v18 + v14 + 8 - (unsigned __int8 *)header > plen )
      return v44;
    v37 = v15;
    src = v14 + 8;
    if ( (unsigned int)v18 < 5 )
    {
      v20 = (char *)(v14 + 8);
LABEL_19:
      v10 = header;
      if ( is_last )
      {
        v23 = (_WORD)v14 + 8;
        v24 = v14 + 6;
LABEL_38:
        v36 = v20 + 4;
        if ( limit - (unsigned __int8 *)(v20 + 4) < optlen )
          return v44;
        if ( optno && replace != 2 )
        {
          srca = v23;
          *v20 = BYTE1(optno);
          v20[1] = optno;
          v20[2] = BYTE1(optlen);
          v20[3] = optlen;
          memcpy(v36, opt, optlen);
          v20 = &v36[optlen];
          *v24 = __ROL2__(optlen + (_WORD)v36 - srca, 8);
        }
        return v20 - (char *)v10;
      }
      ptr = 0;
      if ( v18 )
      {
        v25 = (void *)whine_malloc(v18);
        v26 = plen;
        if ( v25 )
        {
          v27 = v25;
          memcpy(v25, src, v18);
          ptr = v27;
        }
      }
      else
      {
        v26 = plen;
        v18 = 0;
      }
    }
    else
    {
      if ( replace )
      {
        v19 = 0;
        v20 = (char *)(v14 + 8);
        while ( 1 )
        {
          v21 = _byteswap_ulong(*((unsigned __int16 *)v20 + 1) << 16);
          if ( (int)(v21 + v19) > v18 )
            break;
          v22 = (unsigned __int16 *)(v20 + 4);
          if ( _byteswap_ulong(*(unsigned __int16 *)v20 << 16) == optno )
          {
            v18 = v18 - v21 - 4;
            memcpy(v20, (char *)v22 + v21, v18 - v19);
            *((_WORD *)v14 + 3) = __ROL2__(v18, 8);
            if ( v19 + 4 >= v18 )
              goto LABEL_19;
          }
          else
          {
            v19 += v21 + 4;
            v20 = (char *)v22 + v21;
            if ( v19 + 4 >= v18 )
              goto LABEL_19;
          }
        }
      }
      else
      {
        v28 = 0;
        v20 = (char *)(v14 + 8);
        while ( 1 )
        {
          v29 = _byteswap_ulong(*((unsigned __int16 *)v20 + 1) << 16);
          if ( (int)(v29 + v28) > v18 )
            break;
          if ( _byteswap_ulong(*(unsigned __int16 *)v20 << 16) == optno )
            return v44;
          v30 = v28 + v29 + 8;
          v28 += v29 + 4;
          v20 += v29 + 4;
          if ( v30 >= v18 )
            goto LABEL_19;
        }
      }
      v10 = header;
      v26 = plen;
      is_last = 0;
      v18 = 0;
      ptr = 0;
    }
    udp_sz = __ROL2__(v37, 8);
    v43 = __ROL2__(v42, 8);
    v9 = rrfilter(v10, v26, 0);
  }
  else
  {
    LOBYTE(v13) = set_do != 0;
    ptr = 0;
    v43 = 0;
    v45 = v13 << 15;
    v18 = 0;
  }
  v31 = skip_questions(v10, v9);
  v44 = v9;
  if ( v31 )
  {
    v32 = _mm_cvtsi32_si128(*(_DWORD *)&v10->ancount);
    v33 = _mm_unpacklo_epi16(_mm_or_si128(_mm_slli_epi16(v32, 8u), _mm_srli_epi16(v32, 8u)), (__m128i)0LL);
    v34 = skip_section(
            v31,
            _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v33, 229), v33))
          + (unsigned __int16)__ROL2__(v10->arcount, 8),
            v10,
            v9);
    if ( v34 )
    {
      v35 = v34;
      *(_WORD *)v34 = 0;
      *(_BYTE *)(v34 + 2) = 41;
      v23 = v34 + 11;
      v20 = (char *)(v34 + 11);
      *(_BYTE *)(v34 + 3) = HIBYTE(udp_sz);
      *(_BYTE *)(v34 + 4) = udp_sz;
      *(_BYTE *)(v34 + 5) = HIBYTE(v43);
      *(_BYTE *)(v34 + 6) = v43;
      *(_BYTE *)(v34 + 7) = HIBYTE(v45);
      *(_BYTE *)(v34 + 8) = v45;
      *(_BYTE *)(v34 + 9) = BYTE1(v18);
      *(_BYTE *)(v34 + 10) = v18;
      if ( ptr )
      {
        memcpy((void *)(v34 + 11), ptr, v18);
        free(ptr);
        v23 = v35 + 11;
        v20 = (char *)(v35 + 11 + v18);
      }
      v24 = (_WORD *)(v35 + 9);
      if ( limit - (unsigned __int8 *)v20 - 4 >= optlen )
        v10->arcount = __ROL2__(__ROL2__(v10->arcount, 8) + 1, 8);
      goto LABEL_38;
    }
  }
  return v44;
}
