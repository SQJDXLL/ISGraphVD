size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v10; // r12
  unsigned __int8 *pseudoheader; // rax
  int v14; // r14d
  unsigned __int8 *v15; // r9
  unsigned __int8 *v16; // rcx
  __int16 v17; // ax
  __int64 v18; // rdx
  __int64 v19; // r15
  unsigned __int8 *v20; // r11
  unsigned __int16 v21; // ax
  int v22; // edi
  int v23; // ebx
  unsigned __int8 *v24; // r14
  unsigned __int8 *v25; // r9
  int v26; // r13d
  int v27; // r15d
  size_t v28; // r11
  __int16 v30; // r15
  __int64 v31; // rax
  __int64 v32; // rax
  char *v33; // rcx
  unsigned __int8 *v34; // rax
  unsigned __int8 *v35; // r9
  unsigned __int64 v36; // r13
  unsigned __int8 *v37; // rdi
  _WORD *v38; // r14
  unsigned __int8 *v39; // r9
  __int64 v40; // rax
  unsigned __int8 *v41; // rax
  __int16 t_s; // [rsp+10h] [rbp-78h]
  unsigned __int8 *t_sa; // [rsp+10h] [rbp-78h]
  unsigned __int8 *buff; // [rsp+18h] [rbp-70h]
  unsigned __int8 *buffa; // [rsp+18h] [rbp-70h]
  __int16 src; // [rsp+20h] [rbp-68h]
  unsigned __int8 *srca; // [rsp+20h] [rbp-68h]
  char *srcb; // [rsp+20h] [rbp-68h]
  __int16 v51; // [rsp+2Ah] [rbp-5Eh]
  int v52; // [rsp+2Ch] [rbp-5Ch]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  v10 = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v14 = is_sign;
  if ( is_sign )
    return v10;
  v15 = pseudoheader;
  if ( pseudoheader )
  {
    v16 = udp_len[0];
    v51 = *(_WORD *)udp_len[0];
    src = *((_WORD *)udp_len[0] + 1);
    v17 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
    t_s = v17;
    if ( set_do )
    {
      t_s = v17 | 0x8000;
      *((_WORD *)udp_len[0] + 2) = __ROL2__(v17 | 0x8000, 8);
    }
    buff = v16 + 8;
    v18 = v16 + 8 - (unsigned __int8 *)header;
    v19 = (unsigned __int16)__ROL2__(*((_WORD *)v16 + 3), 8);
    if ( v18 + v19 > plen || !optno )
      return v10;
    if ( (int)v19 <= 4 )
    {
      v36 = (unsigned __int64)(v16 + 8);
    }
    else
    {
      v20 = v16 + 12;
      v21 = __ROL2__(*((_WORD *)v16 + 5), 8);
      LOWORD(v18) = __ROL2__(*((_WORD *)v16 + 4), 8);
      v22 = v21;
      if ( (int)v19 < v21 + 4 )
      {
LABEL_28:
        is_last = 0;
        v39 = 0LL;
LABEL_29:
        buffa = v39;
        v40 = rrfilter(header, v10, 0LL);
        udp_sz = __ROL2__(v51, 8);
        v15 = buffa;
        v30 = __ROL2__(src, 8);
        v10 = v40;
        goto LABEL_19;
      }
      plen = (unsigned int)optno;
      v52 = v14;
      v23 = 0;
      v24 = v16;
      v25 = v16 + 8;
      v26 = v19;
      v27 = plen;
      while ( 1 )
      {
        v18 = (unsigned __int16)v18;
        if ( (unsigned __int16)v18 == v27 )
        {
          if ( !replace )
            return v10;
          v26 -= v22 + 4;
          plen = (size_t)&v25[v21 + 4];
          v25 = (unsigned __int8 *)memcpy(v25, (const void *)plen, v26 - v23);
          *((_WORD *)v24 + 3) = __ROL2__(v26, 8);
        }
        else
        {
          v23 += v22 + 4;
          v25 = &v20[v21];
        }
        if ( v23 + 4 >= v26 )
          break;
        v20 = v25 + 4;
        v21 = __ROL2__(*((_WORD *)v25 + 1), 8);
        LOWORD(v18) = __ROL2__(*(_WORD *)v25, 8);
        v22 = v21;
        if ( v21 + v23 + 4 > v26 )
        {
          v14 = v52;
          optno = v27;
          goto LABEL_28;
        }
      }
      optno = v27;
      v16 = v24;
      LODWORD(v19) = v26;
      v36 = (unsigned __int64)v25;
    }
    if ( is_last )
    {
      v37 = (unsigned __int8 *)(v36 + 4);
      if ( (__int64)&limit[-v36 - 4] >= (__int64)optlen )
      {
        v38 = v16 + 6;
        goto LABEL_34;
      }
      return v10;
    }
    if ( (_DWORD)v19 )
    {
      v14 = v19;
      v41 = (unsigned __int8 *)whine_malloc((int)v19, plen, v18, v16);
      v39 = v41;
      if ( v41 )
        v39 = (unsigned __int8 *)memcpy(v41, buff, (int)v19);
    }
    else
    {
      v14 = 0;
      v39 = 0LL;
    }
    goto LABEL_29;
  }
  v30 = 0;
  t_s = (set_do != 0) << 15;
LABEL_19:
  buff = v15;
  v31 = skip_questions(header, v10);
  v28 = v10;
  if ( !v31 )
    return v28;
  srca = buff;
  v32 = skip_section(
          v31,
          (unsigned __int16)__ROL2__(header->arcount, 8)
        + (unsigned __int16)__ROL2__(header->nscount, 8)
        + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8),
          header,
          v10);
  v28 = v10;
  v33 = (char *)v32;
  if ( !v32 )
    return v28;
  v34 = (unsigned __int8 *)(v32 + 11);
  if ( limit < v34 )
    return v28;
  v35 = buff;
  v33[2] = 41;
  *(_WORD *)v33 = 0;
  *(_WORD *)(v33 + 3) = __ROL2__(udp_sz, 8);
  *(_WORD *)(v33 + 7) = __ROL2__(t_s, 8);
  *(_WORD *)(v33 + 5) = __ROL2__(v30, 8);
  *(_WORD *)(v33 + 9) = __ROL2__(v14, 8);
  LOWORD(buff) = (_WORD)v34;
  if ( srca )
  {
    v36 = (unsigned __int64)&v34[v14];
    if ( v36 > (unsigned __int64)limit )
    {
      free(srca);
      return v10;
    }
    srcb = v33;
    t_sa = v35;
    memcpy(v34, v35, v14);
    free(t_sa);
    v33 = srcb;
  }
  else
  {
    v36 = (unsigned __int64)v34;
  }
  v37 = (unsigned __int8 *)(v36 + 4);
  v28 = v10;
  if ( (__int64)&limit[-v36 - 4] < (__int64)optlen )
    return v28;
  v38 = v33 + 9;
  header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
LABEL_34:
  if ( !optno || replace == 2 )
    return v36 - (_QWORD)header;
  v28 = v10;
  if ( limit >= v37 )
  {
    *(_WORD *)v36 = __ROL2__(optno, 8);
    *(_WORD *)(v36 + 2) = __ROL2__(optlen, 8);
    v36 = (unsigned __int64)&v37[optlen];
    if ( &v37[optlen] <= limit )
    {
      memcpy(v37, opt, optlen);
      *v38 = __ROL2__(v36 - (_WORD)buff, 8);
      return v36 - (_QWORD)header;
    }
  }
  return v28;
}
