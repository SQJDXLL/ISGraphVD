size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // rax
  int v12; // r14d
  unsigned __int8 *v13; // r12
  unsigned __int8 *v14; // r12
  unsigned __int16 v15; // ax
  int v16; // ebp
  unsigned __int64 v17; // rbx
  unsigned __int16 v18; // dx
  unsigned __int16 v19; // ax
  unsigned __int8 *v20; // rdi
  int v21; // ecx
  int v22; // r15d
  __int16 v23; // r15
  __int64 v24; // rax
  unsigned __int8 *v25; // rdi
  _BYTE *v26; // r12
  unsigned __int8 *v28; // rax
  _BYTE *v29; // rax
  _BYTE *v30; // rbp
  __int64 plena; // [rsp+0h] [rbp-88h]
  unsigned __int8 *p; // [rsp+20h] [rbp-68h]
  unsigned __int16 flags; // [rsp+28h] [rbp-60h]
  __int16 v37; // [rsp+2Ah] [rbp-5Eh]
  __int16 v38; // [rsp+2Ch] [rbp-5Ch]
  unsigned __int8 v39; // [rsp+2Eh] [rbp-5Ah]
  unsigned __int8 v40; // [rsp+2Fh] [rbp-59h]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  plena = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v12 = is_sign;
  if ( is_sign )
    return plena;
  v13 = pseudoheader;
  if ( !pseudoheader )
  {
    flags = (set_do != 0) << 15;
    v23 = 0;
    v24 = skip_questions(header, plen);
LABEL_36:
    if ( !v24 )
      return plena;
    v29 = (_BYTE *)skip_section(
                     v24,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8)
                   + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8),
                     header,
                     plena);
    v30 = v29;
    if ( !v29 )
      return plena;
    p = v29 + 11;
    if ( limit < v29 + 11 )
      return plena;
    *v29 = 0;
    v29[1] = 0;
    v29[2] = 41;
    v29[3] = HIBYTE(udp_sz);
    v29[4] = udp_sz;
    v29[5] = HIBYTE(v23);
    v29[6] = v23;
    v29[7] = HIBYTE(flags);
    v29[8] = flags;
    v29[9] = BYTE1(v12);
    v29[10] = v12;
    if ( v13 )
    {
      v17 = (unsigned __int64)&v29[v12 + 11];
      if ( (unsigned __int64)limit < v17 )
      {
        free(v13);
        return plena;
      }
      memcpy(p, v13, v12);
      free(v13);
    }
    else
    {
      v17 = (unsigned __int64)(v29 + 11);
    }
    v25 = (unsigned __int8 *)(v17 + 4);
    if ( (__int64)&limit[-v17 - 4] < (__int64)optlen )
      return plena;
    v26 = v30 + 9;
    header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    goto LABEL_22;
  }
  v14 = udp_len[0];
  LOBYTE(v37) = *udp_len[0];
  v39 = udp_len[0][1];
  LOBYTE(v38) = udp_len[0][2];
  v40 = udp_len[0][3];
  v15 = _byteswap_ushort(*((_WORD *)udp_len[0] + 2));
  if ( set_do )
  {
    flags = v15 | 0x8000;
    udp_len[0][4] = (unsigned __int16)(v15 | 0x8000) >> 8;
    v14[5] = v15;
  }
  else
  {
    flags = v15;
  }
  v16 = v14[7] | (v14[6] << 8);
  v17 = (unsigned __int64)(v14 + 8);
  p = v14 + 8;
  if ( plen < v16 + v14 + 8 - (unsigned __int8 *)header || !optno )
    return plena;
  if ( v16 > 4 )
  {
    v18 = _byteswap_ushort(*((_WORD *)v14 + 4));
    v19 = _byteswap_ushort(*((_WORD *)v14 + 5));
    v20 = v14 + 12;
    v21 = v19;
    if ( v16 < v19 + 4 )
    {
LABEL_11:
      is_last = 0;
      v13 = 0LL;
LABEL_12:
      udp_sz = v39 | (unsigned __int16)(v37 << 8);
      v23 = v40 | (unsigned __int16)(v38 << 8);
      plena = rrfilter(header, plen, 0LL);
      v24 = skip_questions(header, plena);
      goto LABEL_36;
    }
    v22 = v12;
    while ( 1 )
    {
      if ( v18 == optno )
      {
        if ( !replace )
          return plena;
        v16 -= v21 + 4;
        memcpy((void *)v17, (const void *)(v17 + v19 + 4), v16 - v22);
        v14[6] = BYTE1(v16);
        v14[7] = v16;
      }
      else
      {
        v17 = (unsigned __int64)&v20[v19];
        v22 += v21 + 4;
      }
      if ( v22 + 4 >= v16 )
        break;
      v18 = _byteswap_ushort(*(_WORD *)v17);
      v19 = _byteswap_ushort(*(_WORD *)(v17 + 2));
      v20 = (unsigned __int8 *)(v17 + 4);
      v21 = v19;
      if ( v19 + v22 + 4 > v16 )
        goto LABEL_11;
    }
    if ( is_last )
      goto LABEL_20;
LABEL_29:
    if ( v16 )
    {
      v28 = (unsigned __int8 *)whine_malloc(v16);
      v13 = v28;
      v12 = v16;
      if ( v28 )
        memcpy(v28, p, v16);
    }
    else
    {
      v12 = 0;
      v13 = 0LL;
    }
    goto LABEL_12;
  }
  if ( !is_last )
    goto LABEL_29;
  v17 = (unsigned __int64)(v14 + 8);
LABEL_20:
  v25 = (unsigned __int8 *)(v17 + 4);
  if ( (__int64)&limit[-v17 - 4] < (__int64)optlen )
    return plena;
  v26 = v14 + 6;
LABEL_22:
  if ( !optno || replace == 2 )
    return v17 - (_QWORD)header;
  if ( limit >= v25 )
  {
    *(_BYTE *)v17 = BYTE1(optno);
    *(_BYTE *)(v17 + 1) = optno;
    *(_BYTE *)(v17 + 2) = BYTE1(optlen);
    *(_BYTE *)(v17 + 3) = optlen;
    v17 = (unsigned __int64)&v25[optlen];
    if ( limit >= &v25[optlen] )
    {
      memcpy(v25, opt, optlen);
      *v26 = (unsigned __int16)(v17 - (_WORD)p) >> 8;
      v26[1] = v17 - (_BYTE)p;
      return v17 - (_QWORD)header;
    }
  }
  return plena;
}
