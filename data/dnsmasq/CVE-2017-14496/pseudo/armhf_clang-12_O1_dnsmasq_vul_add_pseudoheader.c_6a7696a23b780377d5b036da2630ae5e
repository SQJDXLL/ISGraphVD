size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v9; // r7
  unsigned int v11; // r8
  unsigned __int8 *pseudoheader; // r0
  int v15; // r12
  char v16; // r6
  unsigned __int8 *v17; // r11
  unsigned int v18; // lr
  int v19; // r5
  unsigned __int8 *v20; // r9
  int v21; // r10
  int v22; // r0
  void *v23; // r1
  int v24; // r11
  int v25; // r0
  void *v26; // r1
  void *v27; // r0
  void *v28; // r7
  void *v29; // r4
  int v30; // r11
  unsigned __int8 *v31; // r5
  bool v32; // zf
  __int16 v33; // r0
  int v34; // r0
  int v35; // r7
  int v36; // r11
  int v37; // r9
  int v38; // r0
  _BYTE *v39; // r0
  _BYTE *v40; // r4
  _BYTE *v41; // r6
  __uint16_t v42; // r0
  unsigned __int8 *v43; // [sp+Ch] [bp-54h]
  _BYTE *v44; // [sp+10h] [bp-50h]
  void *src; // [sp+14h] [bp-4Ch]
  void *srca; // [sp+14h] [bp-4Ch]
  unsigned __int8 v47; // [sp+1Ch] [bp-44h]
  char v48; // [sp+1Ch] [bp-44h]
  unsigned __int8 v49; // [sp+20h] [bp-40h]
  unsigned __int8 v50; // [sp+24h] [bp-3Ch]
  unsigned __int8 v51; // [sp+28h] [bp-38h]
  dns_header *v52; // [sp+2Ch] [bp-34h]
  int v53; // [sp+30h] [bp-30h] BYREF
  int v54; // [sp+34h] [bp-2Ch] BYREF
  unsigned __int8 *v55; // [sp+38h] [bp-28h] BYREF

  v9 = udp_sz;
  v11 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v55, &v54, &v53);
  if ( v54 )
    return v11;
  v15 = optno;
  v16 = set_do;
  if ( set_do )
    v16 = 0x80;
  v52 = header;
  if ( pseudoheader )
  {
    v17 = v55;
    v16 = v55[4];
    if ( set_do )
    {
      v16 |= 0x80u;
      v55[4] = v16;
    }
    v49 = v17[5];
    LOBYTE(v18) = *v17;
    v50 = v17[2];
    v19 = v17[7] | (v17[6] << 8);
    v44 = v17 + 6;
    v20 = v17 + 8;
    v51 = v17[3];
    src = v17 + 8;
    if ( !optno || v20 - (unsigned __int8 *)header + v19 > v11 )
      return v11;
    v47 = v17[1];
    v43 = limit;
    if ( (unsigned int)v19 >= 5 )
    {
      v21 = 0;
      v9 = (unsigned int)(v17 + 8);
      while ( 1 )
      {
        v22 = *(unsigned __int8 *)(v9 + 3) | (*(unsigned __int8 *)(v9 + 2) << 8);
        v20 = (unsigned __int8 *)(v9 + 4);
        if ( v22 + v21 > v19 )
        {
          v19 = 0;
          v53 = 0;
          break;
        }
        if ( (*(unsigned __int8 *)(v9 + 1) | (*(unsigned __int8 *)v9 << 8)) == v15 )
        {
          if ( !replace )
          {
            v24 = 0;
            v23 = 0;
            v25 = v11;
            limit = v43;
            goto LABEL_29;
          }
          v19 = v19 - v22 - 4;
          memcpy((void *)v9, &v20[v22], v19 - v21);
          v15 = optno;
          v17[7] = v19;
          v17[6] = BYTE1(v19);
        }
        else
        {
          v9 = (unsigned int)&v20[v22];
          v21 += v22 + 4;
        }
        if ( v21 + 4 >= v19 )
          goto LABEL_22;
      }
    }
    v9 = (unsigned int)v20;
LABEL_22:
    v24 = 1;
    if ( v53 )
    {
      v20 = (unsigned __int8 *)v9;
      v25 = v11;
      limit = v43;
      LOBYTE(v9) = v47;
      v23 = 0;
    }
    else
    {
      v20 = 0;
      v26 = 0;
      limit = v43;
      if ( v19 )
      {
        v27 = (void *)whine_malloc(v19, 0);
        v26 = 0;
        if ( v27 )
        {
          v28 = v27;
          memcpy(v27, src, v19);
          v26 = v28;
        }
      }
      v29 = v26;
      v25 = rrfilter(v52, v11, 0);
      v23 = v29;
      v15 = optno;
LABEL_29:
      LOBYTE(v9) = v47;
      if ( !v24 )
        return v11;
    }
    v11 = v25;
  }
  else
  {
    v51 = 0;
    v18 = v9 >> 8;
    v50 = 0;
    v49 = 0;
    v19 = 0;
    v23 = 0;
    v20 = 0;
  }
  v30 = optlen;
  if ( !v20 )
  {
    srca = v23;
    v48 = v9;
    v34 = skip_questions(v52, v11);
    if ( !v34 )
      return v11;
    v35 = v34;
    v36 = _bswap_16(v52->ancount);
    v37 = _bswap_16(v52->nscount) + v36;
    v38 = _bswap_16(v52->arcount);
    v39 = (_BYTE *)skip_section(v35, v37 + v38, v52, v11);
    if ( !v39 )
      return v11;
    v39[10] = v19;
    v39[8] = v49;
    v39[7] = v16;
    v39[6] = v51;
    v39[5] = v50;
    v39[4] = v48;
    v39[3] = v18;
    v39[2] = 41;
    v39[1] = 0;
    *v39 = 0;
    v39[9] = BYTE1(v19);
    v40 = v39 + 9;
    v41 = v39 + 0xB;
    v20 = v39 + 0xB;
    if ( srca )
    {
      memcpy(v39 + 0xB, srca, v19);
      free(srca);
      v20 = &v41[v19];
    }
    LOWORD(src) = (_WORD)v41;
    v30 = optlen;
    v44 = v40;
    if ( limit - v20 - 4 >= (int)optlen )
    {
      v42 = _bswap_16(v52->arcount);
      v52->arcount = _bswap_16(v42 + 1);
    }
    v15 = optno;
  }
  v31 = v20 + 4;
  if ( limit - (v20 + 4) >= v30 )
  {
    v32 = v15 == 0;
    if ( v15 )
      v32 = replace == 2;
    if ( !v32 )
    {
      v20[3] = v30;
      v20[1] = v15;
      v20[2] = BYTE1(v30);
      *v20 = BYTE1(v15);
      memcpy(v20 + 4, opt, v30);
      v20 = &v31[v30];
      v33 = (_WORD)v31 + v30 - (_WORD)src;
      v44[1] = v33;
      *v44 = HIBYTE(v33);
    }
    return v20 - (unsigned __int8 *)v52;
  }
  return v11;
}
