size_t __cdecl add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *ptr; // ebp
  unsigned __int8 *v10; // ebp
  __int16 v11; // si
  unsigned __int8 v12; // bl
  __int16 v13; // cx
  unsigned __int8 v14; // dl
  unsigned __int16 v15; // ax
  int v16; // edi
  unsigned __int16 v17; // dx
  unsigned __int16 v18; // ax
  int v19; // ebx
  unsigned int v20; // esi
  int v21; // ebp
  unsigned int v22; // eax
  _BYTE *v23; // ebp
  void *v24; // eax
  unsigned __int8 *v26; // eax
  int v27; // ebx
  _BYTE *v28; // eax
  _BYTE *v29; // edi
  _BYTE *v30; // ecx
  unsigned __int8 *v31; // [esp+18h] [ebp-54h]
  size_t rdlen; // [esp+28h] [ebp-44h]
  unsigned __int8 *v34; // [esp+34h] [ebp-38h]
  unsigned __int8 *p; // [esp+38h] [ebp-34h]
  unsigned __int16 flags; // [esp+3Ch] [ebp-30h]
  unsigned __int16 rcode; // [esp+3Eh] [ebp-2Eh]
  unsigned __int8 *t_cp; // [esp+40h] [ebp-2Ch] BYREF
  int is_sign; // [esp+44h] [ebp-28h] BYREF
  int is_last[9]; // [esp+48h] [ebp-24h] BYREF

  is_last[1] = __readgsdword(0x14u);
  ptr = find_pseudoheader(header, plen, 0, &t_cp, &is_sign, is_last);
  rdlen = is_sign;
  if ( is_sign )
    return plen;
  if ( !ptr )
  {
    flags = (set_do != 0) << 15;
    rcode = 0;
LABEL_37:
    v27 = skip_questions(header, plen);
    if ( !v27 )
      return plen;
    v28 = (_BYTE *)skip_section(
                     v27,
                     (unsigned __int16)__ROL2__(header->arcount, 8)
                   + (unsigned __int16)__ROL2__(header->ancount, 8)
                   + (unsigned __int16)__ROL2__(header->nscount, 8),
                     header,
                     plen);
    v29 = v28;
    if ( !v28 || limit < v28 + 11 )
      return plen;
    *v28 = 0;
    v28[1] = 0;
    v28[2] = 41;
    v28[3] = HIBYTE(udp_sz);
    v28[4] = udp_sz;
    v28[5] = HIBYTE(rcode);
    v28[6] = rcode;
    v28[7] = HIBYTE(flags);
    v28[8] = flags;
    v28[9] = BYTE1(rdlen);
    v28[10] = rdlen;
    v30 = v28 + 11;
    p = v28 + 11;
    if ( ptr )
    {
      v20 = (unsigned int)&v30[rdlen];
      if ( &v30[rdlen] > limit )
      {
        free(ptr);
        return plen;
      }
      memcpy(p, ptr, rdlen);
      free(ptr);
    }
    else
    {
      v20 = (unsigned int)(v28 + 11);
    }
    v22 = v20 + 4;
    if ( (int)&limit[-v20 - 4] < (int)optlen )
      return plen;
    v23 = v29 + 9;
    header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
    goto LABEL_22;
  }
  v10 = t_cp;
  v11 = *t_cp;
  v12 = t_cp[1];
  v13 = t_cp[2];
  v14 = t_cp[3];
  v15 = _byteswap_ushort(*((_WORD *)t_cp + 2));
  flags = v15;
  if ( set_do )
  {
    flags = v15 | 0x8000;
    t_cp[4] = (unsigned __int16)(v15 | 0x8000) >> 8;
    v10[5] = v15;
  }
  v16 = (v10[6] << 8) | v10[7];
  p = v10 + 8;
  if ( v16 + v10 + 8 - (unsigned __int8 *)header > plen || !optno )
    return plen;
  udp_sz = v12 | (unsigned __int16)(v11 << 8);
  rcode = v14 | (unsigned __int16)(v13 << 8);
  if ( v16 <= 4 )
  {
    if ( is_last[0] )
    {
      v20 = (unsigned int)(v10 + 8);
      goto LABEL_20;
    }
    goto LABEL_29;
  }
  v17 = _byteswap_ushort(*((_WORD *)v10 + 4));
  v18 = _byteswap_ushort(*((_WORD *)v10 + 5));
  v31 = v10 + 12;
  v19 = v18;
  if ( v16 < v18 + 4 )
  {
LABEL_10:
    is_last[0] = 0;
    ptr = 0;
LABEL_11:
    plen = rrfilter(header, plen, 0);
    goto LABEL_37;
  }
  v20 = (unsigned int)(v10 + 8);
  v34 = v10;
  v21 = 0;
  while ( 1 )
  {
    if ( v17 == optno )
    {
      if ( !replace )
        return plen;
      v16 -= v19 + 4;
      memcpy((void *)v20, (const void *)(v20 + v18 + 4), v16 - v21);
      v34[6] = BYTE1(v16);
      v34[7] = v16;
    }
    else
    {
      v20 = (unsigned int)&v31[v18];
      v21 += v19 + 4;
    }
    if ( v21 + 4 >= v16 )
      break;
    v17 = _byteswap_ushort(*(_WORD *)v20);
    v18 = _byteswap_ushort(*(_WORD *)(v20 + 2));
    v31 = (unsigned __int8 *)(v20 + 4);
    v19 = v18;
    if ( v18 + v21 + 4 > v16 )
      goto LABEL_10;
  }
  v10 = v34;
  if ( !is_last[0] )
  {
LABEL_29:
    if ( v16 )
    {
      v26 = (unsigned __int8 *)whine_malloc(v16);
      ptr = v26;
      rdlen = v16;
      if ( v26 )
      {
        memcpy(v26, p, v16);
        rdlen = v16;
      }
    }
    else
    {
      rdlen = 0;
      ptr = 0;
    }
    goto LABEL_11;
  }
  if ( !v20 )
  {
    rdlen = v16;
    ptr = 0;
    goto LABEL_37;
  }
LABEL_20:
  v22 = v20 + 4;
  if ( (int)&limit[-v20 - 4] < (int)optlen )
    return plen;
  v23 = v10 + 6;
LABEL_22:
  if ( !optno || replace == 2 )
    return v20 - (_DWORD)header;
  if ( (unsigned int)limit >= v22 )
  {
    *(_BYTE *)v20 = BYTE1(optno);
    *(_BYTE *)(v20 + 1) = optno;
    *(_BYTE *)(v20 + 2) = BYTE1(optlen);
    *(_BYTE *)(v20 + 3) = optlen;
    v24 = (void *)(v20 + 4);
    v20 += optlen + 4;
    if ( v20 <= (unsigned int)limit )
    {
      memcpy(v24, opt, optlen);
      *v23 = (unsigned __int16)(v20 - (_WORD)p) >> 8;
      v23[1] = v20 - (_BYTE)p;
      return v20 - (_DWORD)header;
    }
  }
  return plen;
}
