size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned int v9; // r9
  unsigned int v11; // r10
  unsigned __int8 *pseudoheader; // r0
  int v15; // r11
  int v16; // r5
  char v17; // r6
  unsigned __int8 *v18; // r6
  unsigned __int8 v19; // r3
  unsigned __int8 v20; // r12
  unsigned __int8 v21; // lr
  unsigned __int8 v22; // r10
  unsigned __int8 v23; // r2
  int v24; // r7
  unsigned __int8 *v25; // r10
  int v26; // r11
  int v27; // r0
  unsigned __int8 *v28; // r2
  unsigned __int8 *v29; // r3
  unsigned int v30; // r5
  void *v31; // r0
  void *v32; // r10
  int v33; // r0
  _BYTE *v34; // r0
  _BYTE *v35; // r4
  unsigned int v36; // r0
  unsigned __int8 *v37; // r6
  bool v38; // zf
  __int16 v39; // r0
  unsigned __int8 v40; // [sp+8h] [bp-58h]
  _BYTE *v41; // [sp+10h] [bp-50h]
  void *src; // [sp+14h] [bp-4Ch]
  void *v43; // [sp+18h] [bp-48h]
  unsigned __int8 v44; // [sp+1Ch] [bp-44h]
  unsigned __int8 v45; // [sp+20h] [bp-40h]
  unsigned __int8 v46; // [sp+24h] [bp-3Ch]
  unsigned __int8 v47; // [sp+28h] [bp-38h]
  unsigned __int8 *v48; // [sp+2Ch] [bp-34h]
  int v49; // [sp+30h] [bp-30h] BYREF
  int v50; // [sp+34h] [bp-2Ch] BYREF
  unsigned __int8 *v51; // [sp+38h] [bp-28h] BYREF

  v9 = plen;
  v11 = udp_sz;
  pseudoheader = find_pseudoheader(header, plen, 0u, &v51, &v50, &v49);
  if ( v50 )
    return v9;
  v15 = optlen;
  v16 = optno;
  v17 = set_do;
  if ( set_do )
    v17 = 0x80;
  if ( !pseudoheader )
  {
    v48 = limit;
    v30 = v11 >> 8;
    v24 = 0;
    v43 = 0;
    v47 = 0;
    v46 = 0;
    v45 = 0;
    goto LABEL_27;
  }
  v18 = v51;
  v19 = v51[4];
  v20 = v51[5];
  v21 = v51[1];
  v22 = v51[2];
  v23 = v51[3];
  v44 = *v51;
  if ( set_do )
  {
    v19 |= 0x80u;
    v51[4] = v19;
  }
  if ( optno )
  {
    v48 = limit;
    v24 = v18[7] | (v18[6] << 8);
    if ( v18 + 8 - (unsigned __int8 *)header + v24 <= v9 )
    {
      v41 = v18 + 6;
      v40 = v19;
      src = v18 + 8;
      v45 = v23;
      v46 = v22;
      v47 = v20;
      v25 = v18 + 8;
      if ( (unsigned int)v24 < 5 )
      {
LABEL_18:
        if ( v49 )
        {
          v15 = optlen;
          v29 = limit;
LABEL_34:
          v37 = v25 + 4;
          if ( v29 - (v25 + 4) >= v15 )
          {
            v38 = v16 == 0;
            if ( v16 )
              v38 = replace == 2;
            if ( !v38 )
            {
              v25[3] = v15;
              v25[1] = v16;
              v25[2] = BYTE1(v15);
              *v25 = BYTE1(v16);
              memcpy(v25 + 4, opt, v15);
              v25 = &v37[v15];
              v39 = (_WORD)v37 + v15 - (_WORD)src;
              v41[1] = v39;
              *v41 = HIBYTE(v39);
            }
            return v25 - (unsigned __int8 *)header;
          }
          return v9;
        }
        v43 = 0;
        if ( v24 )
        {
          v31 = (void *)whine_malloc(v24);
          if ( v31 )
          {
            v32 = v31;
            memcpy(v31, src, v24);
            v43 = v32;
          }
        }
        else
        {
          v24 = 0;
        }
      }
      else
      {
        v26 = 0;
        while ( 1 )
        {
          v27 = v25[3] | (v25[2] << 8);
          if ( v27 + v26 > v24 )
            break;
          v28 = v25 + 4;
          if ( (v25[1] | (*v25 << 8)) == v16 )
          {
            if ( !replace )
              return v9;
            v24 = v24 - v27 - 4;
            memcpy(v25, &v28[v27], v24 - v26);
            v16 = optno;
            v18[7] = v24;
            v18[6] = BYTE1(v24);
          }
          else
          {
            v25 = &v28[v27];
            v26 += v27 + 4;
          }
          if ( v26 + 4 >= v24 )
            goto LABEL_18;
        }
        v24 = 0;
        v49 = 0;
        v43 = 0;
      }
      v15 = optlen;
      LOBYTE(v11) = v21;
      v17 = v40;
      LOBYTE(v30) = v44;
      v9 = rrfilter(header, v9, 0);
LABEL_27:
      v33 = skip_questions(header, v9);
      if ( !v33 )
        return v9;
      v34 = (_BYTE *)skip_section(
                       v33,
                       ((unsigned int)((header->nscount << 8) & 0xFF0000 | (header->nscount << 24)) >> 16)
                     + ((unsigned int)((header->ancount << 8) & 0xFF0000 | (header->ancount << 24)) >> 0x10)
                     + ((unsigned int)((header->arcount << 8) & 0xFF0000 | (header->arcount << 24)) >> 0x10),
                       header,
                       v9);
      if ( !v34 )
        return v9;
      v34[3] = v30;
      v35 = v34 + 0xB;
      v34[4] = v11;
      v34[10] = v24;
      v34[7] = v17;
      v25 = v34 + 0xB;
      v34[8] = v47;
      v34[6] = v45;
      v34[5] = v46;
      v34[2] = 41;
      v34[1] = 0;
      *v34 = 0;
      v34[9] = BYTE1(v24);
      v41 = v34 + 9;
      if ( v43 )
      {
        memcpy(v34 + 0xB, v43, v24);
        free(v43);
        v25 = &v35[v24];
      }
      v29 = v48;
      LOWORD(src) = (_WORD)v35;
      if ( v48 - v25 - 4 >= v15 )
      {
        v36 = ((unsigned int)((header->arcount << 8) & 0xFF0000 | (header->arcount << 24)) >> 0x10) + 1;
        header->arcount = ((v36 << 8) & 0xFF0000 | (v36 << 24)) >> 16;
      }
      v16 = optno;
      goto LABEL_34;
    }
  }
  return v9;
}
