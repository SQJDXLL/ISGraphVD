int __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int a5,
        int a6,
        int a7,
        int a8,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // $v0
  size_t v17; // $s0
  int v18; // $s3
  unsigned __int8 *v19; // $s7
  unsigned __int8 *v20; // $s7
  unsigned __int16 v21; // $s6
  unsigned __int8 *v22; // $fp
  int v23; // $t0
  int v24; // $v0
  int v25; // $v1
  int v26; // $v0
  int v27; // $a0
  unsigned __int8 *v28; // $a1
  int v29; // $t3
  int j; // $a2
  int v31; // $a2
  int result; // $v0
  int v33; // $a0
  int v34; // $v0
  int v35; // $v1
  char *v36; // $t0
  unsigned __int8 *v37; // $a0
  _WORD *v38; // $s1
  signed int v39; // $v1
  unsigned __int8 *v40; // $fp
  unsigned __int8 *v41; // $v0
  int v42; // $t0
  int rdlena; // [sp+24h] [-24h]
  int rdlenb; // [sp+24h] [-24h]
  int rdlen; // [sp+24h] [-24h]
  int i; // [sp+28h] [-20h]
  u16 t_s; // [sp+32h] [-16h]
  unsigned __int8 *p; // [sp+34h] [-14h]
  unsigned __int8 *udp_len; // [sp+38h] [-10h] BYREF
  int is_sign; // [sp+3Ch] [-Ch] BYREF
  int is_last; // [sp+40h] [-8h] BYREF

  v17 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0u, &udp_len, &is_sign, &is_last);
  v18 = is_sign;
  if ( is_sign )
    return v17;
  v19 = pseudoheader;
  if ( !pseudoheader )
  {
    t_s = 0;
    v21 = (set_do != 0) << 15;
LABEL_24:
    v33 = skip_questions(header, v17);
    if ( v33 )
    {
      v34 = skip_section(v33, header->ancount + header->nscount + header->arcount, header, v17);
      v35 = v34;
      if ( v34 )
      {
        v36 = (char *)(v34 + 0xB);
        LOWORD(p) = v34 + 0xB;
        if ( (unsigned int)limit >= v34 + 0xB )
        {
          *(_BYTE *)v34 = 0;
          *(_WORD *)(v34 + 1) = 41;
          *(_WORD *)(v34 + 3) = udp_sz;
          *(_WORD *)(v34 + 5) = t_s;
          *(_WORD *)(v34 + 7) = v21;
          *(_WORD *)(v34 + 9) = v18;
          if ( !v19 )
          {
            v22 = (unsigned __int8 *)(v34 + 0xB);
            goto LABEL_30;
          }
          v22 = (unsigned __int8 *)&v36[v18];
          if ( limit >= (unsigned __int8 *)&v36[v18] )
          {
            rdlenb = v34;
            memcpy(v36, v19, v18);
            free(v19);
            v35 = rdlenb;
LABEL_30:
            v37 = v22 + 4;
            result = v17;
            if ( limit - (v22 + 4) < (int)optlen )
              return result;
            ++header->arcount;
            v38 = (_WORD *)(v35 + 9);
            if ( !optno )
              return v22 - (unsigned __int8 *)header;
            goto LABEL_37;
          }
          free(v19);
        }
      }
    }
    return v17;
  }
  v20 = udp_len;
  v21 = _byteswap_ushort(*((_WORD *)udp_len + 2));
  udp_sz = _byteswap_ushort(*(_WORD *)udp_len);
  t_s = _byteswap_ushort(*((_WORD *)udp_len + 1));
  if ( set_do )
  {
    v21 |= 0x8000u;
    udp_len[4] = HIBYTE(v21);
    v20[5] = v21;
  }
  v22 = v20 + 8;
  v23 = v20[7] | (v20[6] << 8);
  p = v20 + 8;
  if ( v17 < v20 + 8 - (unsigned __int8 *)header + v23 || !optno )
    return v17;
  v24 = is_last;
  if ( v23 >= 5 )
  {
    v25 = v20[11] | (v20[10] << 8);
    v26 = v25 + 4;
    v27 = v20[9] | (v20[8] << 8);
    v28 = v20 + 0xC;
    if ( v23 < v25 + 4 )
    {
LABEL_41:
      is_last = 0;
      v19 = 0;
LABEL_42:
      v17 = rrfilter(header, v17, 0);
      goto LABEL_24;
    }
    v29 = 0;
    if ( !replace )
    {
      v31 = 0;
      while ( v27 != optno )
      {
        v31 += v25 + 4;
        v22 = &v28[v25];
        if ( v31 + 4 >= v23 )
        {
          if ( !is_last )
            goto LABEL_44;
          v39 = optlen;
          goto LABEL_35;
        }
        v25 = v22[3] | (v22[2] << 8);
        v27 = v22[1] | (*v22 << 8);
        v28 = v22 + 4;
        if ( v23 < v25 + v31 + 4 )
          goto LABEL_41;
      }
      return v17;
    }
    for ( j = optno; ; j = optno )
    {
      if ( v27 == j )
      {
        i = v29;
        rdlena = v23 - v26;
        memcpy(v22, &v22[(unsigned __int16)(v25 + 4)], v23 - v26 - v29);
        v23 = rdlena;
        v29 = i;
        *((_WORD *)v20 + 3) = rdlena;
      }
      else
      {
        v22 = &v28[v25];
        v29 += v26;
      }
      if ( v29 + 4 >= v23 )
        break;
      v25 = v22[3] | (v22[2] << 8);
      v27 = v22[1] | (*v22 << 8);
      v28 = v22 + 4;
      if ( v23 < v25 + v29 + 4 )
        goto LABEL_41;
      v26 = v25 + 4;
    }
    v24 = is_last;
  }
  v39 = optlen;
  if ( !v24 )
  {
    v19 = 0;
    if ( v23 )
    {
LABEL_44:
      rdlen = v23;
      v41 = (unsigned __int8 *)whine_malloc(v23);
      v19 = v41;
      v42 = rdlen;
      if ( v41 )
      {
        memcpy(v41, p, rdlen);
        v42 = rdlen;
      }
      v18 = v42;
    }
    goto LABEL_42;
  }
LABEL_35:
  v37 = v22 + 4;
  result = v17;
  if ( limit - (v22 + 4) < v39 )
    return result;
  v38 = v20 + 6;
LABEL_37:
  result = v22 - (unsigned __int8 *)header;
  if ( replace != 2 )
  {
    if ( limit >= v37 )
    {
      *v22 = BYTE2(optno);
      v22[2] = BYTE2(optlen);
      v22[1] = optno;
      v22[3] = optlen;
      v40 = &v37[optlen];
      if ( limit >= &v37[optlen] )
      {
        memcpy(v37, opt, optlen);
        *v38 = (_WORD)v40 - (_WORD)p;
        return v40 - (unsigned __int8 *)header;
      }
    }
    return v17;
  }
  return result;
}
