size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  unsigned __int8 *pseudoheader; // rax
  __int64 v14; // rdx
  size_t v15; // r15
  __int16 v17; // si
  unsigned __int8 *v18; // rbp
  __int16 v19; // r12
  __int16 v20; // ax
  __int16 v21; // bx
  __int64 v22; // r8
  dns_header *v23; // rcx
  unsigned __int64 v24; // rdx
  _BYTE *v25; // rsi
  char *v26; // rbx
  int v27; // r13d
  char *v28; // r12
  unsigned __int64 v29; // rax
  _BYTE *v30; // rsi
  unsigned __int64 v31; // r14
  __int16 v32; // r13
  unsigned __int16 v33; // bx
  dns_header *v34; // r14
  _WORD *v35; // rbp
  signed __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  size_t v38; // rbx
  void *v39; // rax
  __int16 v40; // bx
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // rbp
  int v44; // eax
  char *v45; // rdi
  unsigned int v46; // [rsp+4h] [rbp-84h]
  __int16 v47; // [rsp+8h] [rbp-80h]
  __int16 v48; // [rsp+Ch] [rbp-7Ch]
  void *ptr; // [rsp+10h] [rbp-78h]
  __int16 v50; // [rsp+18h] [rbp-70h]
  int is_last; // [rsp+1Ch] [rbp-6Ch] BYREF
  unsigned __int64 v52; // [rsp+20h] [rbp-68h]
  unsigned __int8 *v53; // [rsp+28h] [rbp-60h]
  unsigned __int64 v54; // [rsp+30h] [rbp-58h]
  dns_header *v55; // [rsp+38h] [rbp-50h]
  void *src; // [rsp+40h] [rbp-48h]
  unsigned __int8 *v57; // [rsp+48h] [rbp-40h] BYREF
  int is_sign[13]; // [rsp+54h] [rbp-34h] BYREF

  v54 = plen;
  pseudoheader = find_pseudoheader(header, plen, 0LL, &v57, is_sign, &is_last);
  if ( is_sign[0] )
    return v54;
  v52 = 0LL;
  src = opt;
  v53 = limit;
  v46 = optno;
  HIBYTE(v17) = 0;
  LOBYTE(v14) = set_do != 0;
  if ( !pseudoheader )
  {
    LOBYTE(v17) = set_do != 0;
    v50 = v17 << 15;
    ptr = 0LL;
    v32 = 0;
    v33 = udp_sz;
    v34 = header;
    v15 = v54;
    goto LABEL_30;
  }
  v18 = v57;
  v19 = *(_WORD *)v57;
  v20 = *((_WORD *)v57 + 1);
  v21 = __ROL2__(*((_WORD *)v57 + 2), 8);
  if ( set_do )
  {
    v21 |= 0x8000u;
    v57[4] = HIBYTE(v21);
  }
  v22 = v46;
  v23 = header;
  v15 = v54;
  if ( !v46 )
    return v15;
  v48 = v20;
  v24 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v18 + 3) << 48);
  v25 = v18 + 8;
  if ( v24 + v18 + 8 - (unsigned __int8 *)header > v54 )
    return v15;
  v55 = header;
  v50 = v21;
  v47 = v19;
  if ( (unsigned int)v24 >= 5 )
  {
    v26 = (char *)(v18 + 8);
    v27 = 0;
    LODWORD(v23) = 4;
    v28 = (char *)(v18 + 8);
    while ( 1 )
    {
      v29 = _byteswap_uint64((unsigned __int64)*((unsigned __int16 *)v26 + 1) << 48);
      if ( (int)v29 + (int)v23 > (int)v24 )
        break;
      v30 = v26 + 4;
      if ( _byteswap_ulong(*(unsigned __int16 *)v26 << 16) == (_DWORD)v22 )
      {
        if ( !replace )
          return v15;
        v25 = &v30[v29];
        v31 = (unsigned int)(v24 - v29 - 4);
        memcpy(v26, v25, (int)v31 - v27);
        v24 = v31;
        v22 = v46;
        *((_WORD *)v18 + 3) = __ROL2__(v31, 8);
      }
      else
      {
        v25 = &v30[(unsigned int)v29];
        v27 += v29 + 4;
        v26 = v25;
      }
      v23 = (dns_header *)(unsigned int)(v27 + 4);
      if ( (int)v23 >= (int)v24 )
        goto LABEL_20;
    }
    is_last = 0;
    v52 = 0LL;
    ptr = 0LL;
    v40 = v47;
    v34 = v55;
    goto LABEL_29;
  }
  v28 = (char *)(v18 + 8);
  v26 = (char *)(v18 + 8);
LABEL_20:
  v34 = v55;
  if ( !is_last )
  {
    if ( (_DWORD)v24 )
    {
      v52 = v24;
      v38 = (int)v24;
      v39 = (void *)whine_malloc((int)v24, v25, v24, v23, v22);
      if ( v39 )
      {
        ptr = v39;
        memcpy(v39, v28, v38);
LABEL_28:
        v40 = v47;
LABEL_29:
        v33 = __ROL2__(v40, 8);
        v32 = __ROL2__(v48, 8);
        v15 = rrfilter(v34, v15, 0LL);
LABEL_30:
        v41 = skip_questions(v34, v15, v14);
        if ( !v41 )
          return v15;
        v42 = skip_section(
                v41,
                (unsigned __int16)__ROL2__(v34->ancount, 8)
              + (unsigned __int16)__ROL2__(v34->nscount, 8)
              + (unsigned int)(unsigned __int16)__ROL2__(v34->arcount, 8),
                v34,
                v15);
        if ( !v42 )
          return v15;
        v43 = v42;
        v28 = (char *)(v42 + 11);
        v37 = (unsigned __int64)v53;
        if ( v42 + 11 > (unsigned __int64)v53 )
          return v15;
        *(_WORD *)v42 = 0;
        *(_BYTE *)(v42 + 2) = 41;
        *(_BYTE *)(v42 + 3) = HIBYTE(v33);
        *(_BYTE *)(v42 + 4) = v33;
        *(_BYTE *)(v42 + 5) = HIBYTE(v32);
        *(_BYTE *)(v42 + 6) = v32;
        *(_BYTE *)(v42 + 7) = HIBYTE(v50);
        *(_BYTE *)(v42 + 8) = v50;
        v44 = v52;
        *(_BYTE *)(v43 + 9) = BYTE1(v52);
        *(_BYTE *)(v43 + 10) = v44;
        v26 = v28;
        if ( ptr )
        {
          v26 = &v28[v44];
          if ( (unsigned __int64)v26 > v37 )
          {
            free(ptr);
            return v15;
          }
          memcpy(v28, ptr, v44);
          free(ptr);
          v37 = (unsigned __int64)v53;
        }
        v35 = (_WORD *)(v43 + 9);
        v36 = optlen;
        if ( (__int64)(v37 - (_QWORD)v26 - 4) >= (__int64)optlen )
          v34->arcount = __ROL2__(__ROL2__(v34->arcount, 8) + 1, 8);
        LODWORD(v22) = v46;
        goto LABEL_40;
      }
    }
    else
    {
      v52 = 0LL;
    }
    ptr = 0LL;
    goto LABEL_28;
  }
  v35 = v18 + 6;
  v36 = optlen;
  v37 = (unsigned __int64)v53;
LABEL_40:
  v45 = v26 + 4;
  if ( (__int64)(v37 - (_QWORD)(v26 + 4)) < v36 )
    return v15;
  if ( !(_DWORD)v22 || replace == 2 )
    return v26 - (char *)v34;
  if ( (unsigned __int64)v45 <= v37 )
  {
    *v26 = BYTE1(v22);
    v26[1] = v22;
    v26[2] = BYTE1(v36);
    v26[3] = v36;
    v26 = &v45[v36];
    if ( (unsigned __int64)&v45[v36] <= v37 )
    {
      memcpy(v45, src, v36);
      *v35 = __ROL2__((_WORD)v26 - (_WORD)v28, 8);
      return v26 - (char *)v34;
    }
  }
  return v15;
}
