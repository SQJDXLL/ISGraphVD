size_t __fastcall add_pseudoheader(
        dns_header *header,
        size_t plen,
        unsigned __int8 *limit,
        unsigned __int16 udp_sz,
        int optno,
        unsigned __int8 *opt,
        size_t optlen,
        int set_do,
        int replace)
{
  size_t v11; // rbp
  unsigned __int8 *pseudoheader; // rax
  size_t v14; // r13
  unsigned __int8 *v15; // r8
  unsigned __int8 *v16; // r14
  __int16 v17; // ax
  char *v18; // rdi
  __int64 v19; // r15
  unsigned __int8 *v20; // r11
  unsigned __int16 v21; // ax
  unsigned __int16 v22; // dx
  int v23; // esi
  int v24; // r13d
  int v25; // ebx
  int v26; // r15d
  size_t v27; // r10
  __int16 v29; // r15
  __int64 v30; // rax
  __int64 v31; // rax
  char *v32; // rcx
  unsigned __int8 *v33; // r8
  __int64 v34; // r14
  void *v35; // r8
  _WORD *v36; // rbp
  unsigned __int8 *v37; // r8
  __int64 v38; // rax
  char *v39; // rax
  unsigned __int8 *v40; // rax
  __int16 t_s; // [rsp+10h] [rbp-78h]
  unsigned __int8 *t_sa; // [rsp+10h] [rbp-78h]
  unsigned __int8 *buff; // [rsp+18h] [rbp-70h]
  unsigned __int8 *buffa; // [rsp+18h] [rbp-70h]
  __int16 src; // [rsp+20h] [rbp-68h]
  unsigned __int8 *srca; // [rsp+20h] [rbp-68h]
  char *srcb; // [rsp+20h] [rbp-68h]
  __int16 v50; // [rsp+2Ah] [rbp-5Eh]
  int v51; // [rsp+2Ch] [rbp-5Ch]
  int is_sign; // [rsp+38h] [rbp-50h] BYREF
  int is_last; // [rsp+3Ch] [rbp-4Ch] BYREF
  unsigned __int8 *udp_len[9]; // [rsp+40h] [rbp-48h] BYREF

  v11 = plen;
  udp_len[1] = (unsigned __int8 *)__readfsqword(0x28u);
  pseudoheader = find_pseudoheader(header, plen, 0LL, udp_len, &is_sign, &is_last);
  v14 = is_sign;
  if ( is_sign )
    return v11;
  v15 = pseudoheader;
  if ( !pseudoheader )
  {
    v29 = 0;
    t_s = (set_do != 0) << 15;
    goto LABEL_19;
  }
  v16 = udp_len[0];
  src = *(_WORD *)udp_len[0];
  v50 = *((_WORD *)udp_len[0] + 1);
  v17 = __ROL2__(*((_WORD *)udp_len[0] + 2), 8);
  t_s = v17;
  if ( set_do )
  {
    t_s = v17 | 0x8000;
    *((_WORD *)udp_len[0] + 2) = __ROL2__(v17 | 0x8000, 8);
  }
  v18 = (char *)(v16 + 8);
  buff = v16 + 8;
  v19 = (unsigned __int16)__ROL2__(*((_WORD *)v16 + 3), 8);
  if ( v16 + 8 - (unsigned __int8 *)header + v19 > plen || !optno )
    return v11;
  if ( (int)v19 <= 4 )
  {
    v18 = (char *)(v16 + 8);
LABEL_29:
    if ( is_last )
    {
      v35 = v18 + 4;
      if ( limit - (unsigned __int8 *)(v18 + 4) >= (__int64)optlen )
      {
        v36 = v16 + 6;
LABEL_32:
        if ( optno && replace != 2 )
        {
          *(_WORD *)v18 = __ROL2__(optno, 8);
          *((_WORD *)v18 + 1) = __ROL2__(optlen, 8);
          v39 = (char *)memcpy(v35, opt, optlen);
          v18 = &v39[optlen];
          *v36 = __ROL2__((_WORD)v39 + optlen - (_WORD)buff, 8);
        }
        return v18 - (char *)header;
      }
      return v11;
    }
    if ( (_DWORD)v19 )
    {
      v14 = (int)v19;
      v40 = (unsigned __int8 *)whine_malloc((int)v19);
      v37 = v40;
      if ( v40 )
        v37 = (unsigned __int8 *)memcpy(v40, buff, (int)v19);
    }
    else
    {
      v14 = 0LL;
      v37 = 0LL;
    }
    goto LABEL_27;
  }
  v20 = v16 + 12;
  v21 = __ROL2__(*((_WORD *)v16 + 5), 8);
  v22 = __ROL2__(*((_WORD *)v16 + 4), 8);
  v23 = v21;
  if ( v21 <= (int)v19 )
  {
    v51 = v14;
    v24 = optno;
    v25 = v19;
    v26 = 0;
    while ( 1 )
    {
      if ( v22 == v24 )
      {
        if ( !replace )
          return v11;
        v25 -= v23 + 4;
        v18 = (char *)memcpy(v18, &v18[v21 + 4], v25 - v26);
        *((_WORD *)v16 + 3) = __ROL2__(v25, 8);
      }
      else
      {
        v26 += v23 + 4;
        v18 = (char *)&v20[v21];
      }
      if ( v26 + 4 >= v25 )
        break;
      v20 = (unsigned __int8 *)(v18 + 4);
      v21 = __ROL2__(*((_WORD *)v18 + 1), 8);
      v22 = __ROL2__(*(_WORD *)v18, 8);
      v23 = v21;
      if ( v21 + v26 > v25 )
      {
        optno = v24;
        v14 = v51;
        goto LABEL_26;
      }
    }
    LODWORD(v19) = v25;
    optno = v24;
    goto LABEL_29;
  }
LABEL_26:
  is_last = 0;
  v37 = 0LL;
LABEL_27:
  buffa = v37;
  v38 = rrfilter(header, v11, 0LL);
  udp_sz = __ROL2__(src, 8);
  v15 = buffa;
  v29 = __ROL2__(v50, 8);
  v11 = v38;
LABEL_19:
  buff = v15;
  v30 = skip_questions(header, v11);
  v27 = v11;
  if ( v30 )
  {
    srca = buff;
    v31 = skip_section(
            v30,
            (unsigned __int16)__ROL2__(header->arcount, 8)
          + (unsigned __int16)__ROL2__(header->nscount, 8)
          + (unsigned int)(unsigned __int16)__ROL2__(header->ancount, 8),
            header,
            v11);
    v27 = v11;
    v32 = (char *)v31;
    if ( v31 )
    {
      *(_BYTE *)(v31 + 2) = 41;
      *(_WORD *)(v31 + 3) = __ROL2__(udp_sz, 8);
      v33 = buff;
      *(_WORD *)v31 = 0;
      *(_WORD *)(v31 + 5) = __ROL2__(v29, 8);
      *(_WORD *)(v31 + 7) = __ROL2__(t_s, 8);
      *(_WORD *)(v31 + 9) = __ROL2__(v14, 8);
      LOWORD(buff) = v31 + 11;
      v34 = v31 + 11;
      v18 = (char *)(v31 + 11);
      if ( srca )
      {
        srcb = (char *)v31;
        t_sa = v33;
        memcpy(v18, v33, v14);
        free(t_sa);
        v32 = srcb;
        v18 = (char *)(v34 + v14);
      }
      v35 = v18 + 4;
      v27 = v11;
      if ( limit - (unsigned __int8 *)(v18 + 4) >= (__int64)optlen )
      {
        v36 = v32 + 9;
        header->arcount = __ROL2__(__ROL2__(header->arcount, 8) + 1, 8);
        goto LABEL_32;
      }
    }
  }
  return v27;
}
