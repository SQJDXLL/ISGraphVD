int __fastcall set_dns_listeners(time_t now)
{
  unsigned int v2; // $v0
  int v3; // $s4
  tftp_transfer *i; // $s1
  int j; // $s1
  randfd_list *k; // $s1
  listener *m; // $s1
  randfd *v9; // $v0
  int tcpfd; // $a0
  dnsmasq_daemon *tcp_pids; // $v0
  auth_zone *auth_zones; // $a1
  dnsmasq_daemon *v13; // $v0
  int tftpfd; // $a0
  int n; // $s1
  int v16; // $a0
  int wait; // [sp+18h] [-8h] BYREF

  v2 = dnsmasq_daemon_0->options[1] & 0x10000000;
  wait = 0;
  v3 = 0;
  if ( !v2 )
  {
    for ( i = dnsmasq_daemon_0->tftp_trans; i; i = i->next )
    {
      poll_listen(i->sockfd, 1);
      ++v3;
    }
  }
  if ( dnsmasq_daemon_0->port )
    get_new_frec(now, &wait, 0);
  for ( j = (int)dnsmasq_daemon_0->sfds; j; j = *(_DWORD *)(j + 64) )
    poll_listen(*(_DWORD *)j, 1);
  while ( j < dnsmasq_daemon_0->numrrand )
  {
    v9 = &dnsmasq_daemon_0->randomsocks[j];
    if ( v9->refcount )
      poll_listen(v9->fd, 1);
    ++j;
  }
  for ( k = dnsmasq_daemon_0->rfl_poll; k; k = k->next )
    poll_listen(k->rfd->fd, 1);
  for ( m = dnsmasq_daemon_0->listeners; m; m = m->next )
  {
    if ( m->fd != -1 && !wait )
      poll_listen(m->fd, 1);
    tcpfd = m->tcpfd;
    if ( tcpfd == -1 )
    {
LABEL_29:
      v13 = dnsmasq_daemon_0;
    }
    else
    {
      tcp_pids = (dnsmasq_daemon *)dnsmasq_daemon_0->tcp_pids;
      do
      {
        if ( tcp_pids->options[0] )
        {
          tcp_pids = (dnsmasq_daemon *)((char *)tcp_pids + 4);
        }
        else
        {
          auth_zones = tcp_pids->auth_zones;
          tcp_pids = (dnsmasq_daemon *)((char *)tcp_pids + 4);
          if ( auth_zones == (auth_zone *)-1 )
          {
            poll_listen(tcpfd, 1);
            goto LABEL_29;
          }
        }
      }
      while ( dnsmasq_daemon_0->tcp_pipes != (int *)tcp_pids );
      v13 = dnsmasq_daemon_0;
    }
    if ( v13->tftp_max >= v3 )
    {
      tftpfd = m->tftpfd;
      if ( tftpfd != -1 )
        poll_listen(tftpfd, 1);
    }
  }
  if ( (dnsmasq_daemon_0->options[0] & 0x40) == 0 )
  {
    for ( n = 0; n != 20; ++n )
    {
      v16 = dnsmasq_daemon_0->tcp_pipes[n];
      if ( v16 != -1 )
        poll_listen(v16, 1);
    }
  }
  return wait;
}
