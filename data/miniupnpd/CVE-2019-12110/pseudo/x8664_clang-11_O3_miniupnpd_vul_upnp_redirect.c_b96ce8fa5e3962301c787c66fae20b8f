int __fastcall upnp_redirect(
        const char *rhost,
        unsigned __int16 eport,
        const char *iaddr,
        unsigned __int16 iport,
        const char *protocol,
        const char *desc,
        unsigned int leaseduration)
{
  unsigned int v9; // r12d
  int v11; // eax
  int v12; // ecx
  unsigned int v13; // ebx
  unsigned int v14; // eax
  int v15; // ebx
  const char *v16; // rbp
  unsigned int v18; // r14d
  __int64 v19; // r8
  unsigned int v20; // r12d
  char v21; // r13
  int v22; // eax
  unsigned int v23; // r13d
  __int64 v24; // [rsp+0h] [rbp-D8h]
  unsigned __int16 v25; // [rsp+3Ah] [rbp-9Eh] BYREF
  unsigned int v26; // [rsp+3Ch] [rbp-9Ch]
  unsigned int v27; // [rsp+40h] [rbp-98h]
  unsigned int v28; // [rsp+44h] [rbp-94h] BYREF
  char *s1; // [rsp+48h] [rbp-90h]
  const char *v30; // [rsp+50h] [rbp-88h]
  struct in_addr inp; // [rsp+58h] [rbp-80h] BYREF
  char v32[32]; // [rsp+60h] [rbp-78h] BYREF
  char s2[88]; // [rsp+80h] [rbp-58h] BYREF

  v9 = iport;
  if ( !strcasecmp(protocol, "UDP") )
  {
    v27 = 17;
  }
  else
  {
    v11 = strcasecmp(protocol, "UDPLITE");
    v12 = 6;
    if ( !v11 )
      v12 = 136;
    v27 = v12;
  }
  if ( inet_aton(iaddr, &inp) <= 0 )
  {
    syslog(3, "inet_aton(%s) FAILED", iaddr);
    return -1;
  }
  else
  {
    s1 = (char *)rhost;
    v30 = desc;
    if ( (unsigned int)check_upnp_rule_against_permissions(
                         upnppermlist,
                         num_upnpperm,
                         eport,
                         inp.s_addr,
                         (unsigned __int16)v9) )
    {
      v26 = v9;
      v32[0] = 0;
      v13 = v27;
      if ( (unsigned int)get_redirect_rule(ext_if_name, eport, v27, s2, 32LL, &v25, 0LL, 0, v32, 32, &v28, 0LL, 0LL) )
      {
        if ( leaseduration )
          v14 = leaseduration + upnp_time();
        else
          v14 = 0;
        v28 = v14;
        v16 = v30;
        syslog(
          6,
          "redirecting port %hu to %s:%hu protocol %s for: %s",
          eport,
          iaddr,
          (unsigned __int16)v9,
          protocol,
          v30);
        v15 = -1;
        if ( !disable_port_forwarding )
        {
          v18 = (unsigned __int16)v9;
          v26 = v28;
          v19 = (unsigned __int16)v9;
          v20 = v27;
          if ( (int)add_redirect_rule2(ext_if_name, s1, eport, iaddr, v19, v27, v16, v28) >= 0
            && (int)add_filter_rule2(ext_if_name, s1, iaddr, eport, v18, v20, v16) >= 0 )
          {
            if ( v26 && nextruletoclean_timestamp - 1 >= v26 )
              nextruletoclean_timestamp = v26;
            upnp_event_var_change_notify(2LL);
            return 0;
          }
        }
      }
      else if ( strcmp(iaddr, s2)
             || ((v21 = v32[0], s1) || v32[0]) && (!s1 || ((v22 = strcmp(s1, "*"), v21) || v22) && strcmp(s1, v32)) )
      {
        LODWORD(v24) = v25;
        syslog(6, "port %hu %s (rhost '%s') already redirected to %s:%hu", eport, protocol, v32, s2, v24);
        return -2;
      }
      else
      {
        LODWORD(v24) = v25;
        v23 = 0;
        syslog(6, "updating existing port mapping %hu %s (rhost '%s') => %s:%hu", eport, protocol, v32, s2, v24);
        if ( leaseduration )
          v23 = leaseduration + upnp_time();
        v28 = v23;
        if ( v25 == (_WORD)v26 )
          return update_portmapping_desc_timestamp(ext_if_name, eport, v13, v30, v23);
        else
          return update_portmapping(ext_if_name, eport, v13, (unsigned __int16)v9, v30, v23);
      }
    }
    else
    {
      syslog(6, "redirection permission check failed for %hu->%s:%hu %s", eport, iaddr, (unsigned __int16)v9, protocol);
      return -3;
    }
  }
  return v15;
}
