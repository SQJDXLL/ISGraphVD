int __fastcall upnp_redirect(
        const char *rhost,
        unsigned __int16 eport,
        const char *iaddr,
        unsigned __int16 iport,
        const char *protocol,
        const char *desc,
        unsigned int leaseduration)
{
  int v10; // ebx
  const char *v11; // rbp
  unsigned int v12; // eax
  int v13; // ebp
  unsigned int v14; // ebx
  const char *v15; // r14
  __int64 v17; // r8
  char *v18; // rbx
  unsigned int v19; // r12d
  char v20; // r15
  int v21; // eax
  unsigned int v22; // r15d
  __int64 v23; // [rsp+0h] [rbp-E8h]
  unsigned __int16 v24; // [rsp+46h] [rbp-A2h] BYREF
  unsigned int v25; // [rsp+48h] [rbp-A0h]
  unsigned int v26; // [rsp+4Ch] [rbp-9Ch]
  unsigned int v27; // [rsp+50h] [rbp-98h]
  unsigned int v28; // [rsp+54h] [rbp-94h] BYREF
  char *s1; // [rsp+58h] [rbp-90h]
  struct in_addr inp; // [rsp+60h] [rbp-88h] BYREF
  const char *v31; // [rsp+68h] [rbp-80h]
  char v32[32]; // [rsp+70h] [rbp-78h] BYREF
  char s2[88]; // [rsp+90h] [rbp-58h] BYREF

  v26 = iport;
  if ( !strcasecmp(protocol, "UDP") )
  {
    v10 = 17;
  }
  else
  {
    v10 = 6;
    if ( !strcasecmp(protocol, "UDPLITE") )
      v10 = 136;
  }
  if ( inet_aton(iaddr, &inp) <= 0 )
  {
    syslog(3, "inet_aton(%s) FAILED", iaddr);
    return -1;
  }
  else
  {
    v25 = v10;
    s1 = (char *)rhost;
    if ( (unsigned int)check_upnp_rule_against_permissions(
                         upnppermlist,
                         num_upnpperm,
                         eport,
                         inp.s_addr,
                         (unsigned __int16)v26) )
    {
      v27 = (unsigned __int16)v26;
      v11 = (const char *)&unk_BDC;
      if ( desc )
        v11 = desc;
      v32[0] = 0;
      if ( (unsigned int)get_redirect_rule(ext_if_name, eport, v25, s2, 32LL, &v24, 0LL, 0, v32, 32, &v28, 0LL, 0LL) )
      {
        if ( leaseduration )
          v12 = leaseduration + upnp_time();
        else
          v12 = 0;
        v28 = v12;
        v14 = v27;
        syslog(6, "redirecting port %hu to %s:%hu protocol %s for: %s", eport, iaddr, v27, protocol, v11);
        v15 = v11;
        v13 = -1;
        if ( !disable_port_forwarding )
        {
          v17 = v14;
          v26 = v28;
          v18 = s1;
          v19 = v25;
          if ( (int)add_redirect_rule2(ext_if_name, s1, eport, iaddr, v17, v25, v15, v28) >= 0
            && (int)add_filter_rule2(ext_if_name, v18, iaddr, eport, v27, v19, v15) >= 0 )
          {
            if ( v26 && nextruletoclean_timestamp - 1 >= v26 )
              nextruletoclean_timestamp = v26;
            upnp_event_var_change_notify(2LL);
            return 0;
          }
        }
      }
      else
      {
        v31 = v11;
        if ( strcmp(iaddr, s2)
          || ((v20 = v32[0], s1) || v32[0]) && (!s1 || ((v21 = strcmp(s1, "*"), v20) || v21) && strcmp(s1, v32)) )
        {
          LODWORD(v23) = v24;
          syslog(6, "port %hu %s (rhost '%s') already redirected to %s:%hu", eport, protocol, v32, s2, v23);
          return -2;
        }
        else
        {
          LODWORD(v23) = v24;
          v22 = 0;
          syslog(6, "updating existing port mapping %hu %s (rhost '%s') => %s:%hu", eport, protocol, v32, s2, v23);
          if ( leaseduration )
            v22 = leaseduration + upnp_time();
          v28 = v22;
          if ( v24 == (_WORD)v26 )
            return update_portmapping_desc_timestamp(ext_if_name, eport, v25, v31, v22);
          else
            return update_portmapping(ext_if_name, eport, v25, v27, v31, v22);
        }
      }
    }
    else
    {
      syslog(6, "redirection permission check failed for %hu->%s:%hu %s", eport, iaddr, (unsigned __int16)v26, protocol);
      return -3;
    }
  }
  return v13;
}
