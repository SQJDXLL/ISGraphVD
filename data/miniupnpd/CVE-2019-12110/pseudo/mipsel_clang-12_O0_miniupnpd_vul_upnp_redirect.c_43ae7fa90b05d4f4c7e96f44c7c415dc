int __fastcall upnp_redirect(
        const char *rhost,
        unsigned __int16 eport,
        const char *iaddr,
        unsigned __int16 iport,
        int a5,
        int a6,
        int a7,
        int a8,
        const char *protocol,
        const char *desc,
        unsigned int leaseduration)
{
  int v12; // [sp+0h] [+0h] BYREF
  int v13; // [sp+10h] [+10h]
  unsigned __int16 *v14; // [sp+14h] [+14h]
  int v15; // [sp+18h] [+18h]
  int v16; // [sp+1Ch] [+1Ch]
  char *v17; // [sp+20h] [+20h]
  int v18; // [sp+24h] [+24h]
  unsigned int *v19; // [sp+28h] [+28h]
  int v20; // [sp+2Ch] [+2Ch]
  int v21; // [sp+30h] [+30h]
  unsigned int v22; // [sp+38h] [+38h]
  unsigned int v23; // [sp+3Ch] [+3Ch]
  int *v24; // [sp+40h] [+40h]
  unsigned __int16 *v25; // [sp+44h] [+44h] BYREF
  struct in_addr v26; // [sp+48h] [+48h] BYREF
  unsigned __int16 v27; // [sp+50h] [+50h] BYREF
  char v28[32]; // [sp+54h] [+54h] BYREF
  char v29[32]; // [sp+74h] [+74h] BYREF
  int v31; // [sp+98h] [+98h]
  unsigned __int16 v32; // [sp+9Ch] [+9Ch]
  char *cp; // [sp+A0h] [+A0h]
  unsigned __int16 v34; // [sp+A4h] [+A4h]
  char *rhosta; // [sp+A8h] [+A8h]

  rhosta = (char *)rhost;
  v34 = eport;
  cp = (char *)iaddr;
  v32 = iport;
  v31 = proto_atoi(protocol);
  if ( inet_aton(cp, &v26) > 0 )
  {
    v13 = v32;
    if ( check_upnp_rule_against_permissions(upnppermlist, num_upnpperm, v34, v26.s_addr) )
    {
      v28[0] = 0;
      v24 = &v12;
      v19 = (unsigned int *)&v25;
      v18 = 32;
      v17 = v28;
      v14 = &v27;
      v13 = 32;
      v21 = 0;
      v20 = 0;
      v16 = 0;
      v15 = 0;
      if ( get_redirect_rule(ext_if_name, v34, v31, v29) )
      {
        if ( leaseduration )
          v22 = upnp_time() + leaseduration;
        else
          v22 = 0;
        v25 = (unsigned __int16 *)v22;
        syslog(6, "redirecting port %hu to %s:%hu protocol %s for: %s", v34, cp, v32, protocol, desc);
        return upnp_redirect_internal(rhosta, v34, cp, v32, v31, desc, (unsigned int)v25);
      }
      else if ( !strcmp(cp, v29)
             && (!rhosta && !v28[0] || rhosta && !strcmp(rhosta, "*") && !v28[0] || rhosta && !strcmp(rhosta, v28)) )
      {
        syslog(6, "updating existing port mapping %hu %s (rhost '%s') => %s:%hu", v34, protocol, v28, v29, v27);
        if ( leaseduration )
          v23 = upnp_time() + leaseduration;
        else
          v23 = 0;
        v25 = (unsigned __int16 *)v23;
        if ( v32 == v27 )
        {
          v13 = (int)v25;
          return update_portmapping_desc_timestamp(ext_if_name, v34, v31, desc);
        }
        else
        {
          v14 = v25;
          v13 = (int)desc;
          return update_portmapping(ext_if_name, v34, v31, v32);
        }
      }
      else
      {
        syslog(6, "port %hu %s (rhost '%s') already redirected to %s:%hu", v34, protocol, v28, v29, v27);
        return -2;
      }
    }
    else
    {
      syslog(6, "redirection permission check failed for %hu->%s:%hu %s", v34, cp, v32, protocol);
      return -3;
    }
  }
  else
  {
    syslog(3, "inet_aton(%s) FAILED", cp);
    return -1;
  }
}
