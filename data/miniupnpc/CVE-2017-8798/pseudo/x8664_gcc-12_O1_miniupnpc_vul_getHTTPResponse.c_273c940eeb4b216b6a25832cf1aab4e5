void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  void *v3; // r15
  unsigned int v4; // r14d
  int v5; // r15d
  int v6; // eax
  int v7; // eax
  int v8; // ebp
  char v9; // dl
  int v10; // edx
  int v11; // edi
  int v12; // edx
  int v13; // ebx
  int v14; // ebp
  char *v15; // rdx
  int v16; // eax
  char v17; // al
  char v18; // al
  char *v19; // rax
  const char *v20; // rbp
  size_t v21; // r13
  const char *v22; // rbp
  bool v23; // zf
  int v24; // eax
  int v25; // r13d
  int v26; // ebx
  const unsigned __int16 *v27; // rdi
  char *v28; // rdx
  unsigned int v29; // esi
  char *v30; // rax
  int v31; // r12d
  char *v32; // rcx
  char *v33; // r14
  int v34; // edx
  char v35; // al
  unsigned int v36; // ebp
  unsigned int v37; // eax
  char *v38; // rax
  char *v39; // rbx
  char *v40; // r15
  int *v41; // r12
  int v43; // ebp
  int v44; // r12d
  char *v45; // rax
  char *content_buf; // [rsp+10h] [rbp-8B8h]
  unsigned int content_buf_used; // [rsp+18h] [rbp-8B0h]
  unsigned int content_buf_len; // [rsp+1Ch] [rbp-8ACh]
  int endofheaders; // [rsp+20h] [rbp-8A8h]
  int content_length; // [rsp+24h] [rbp-8A4h]
  char *header_buf; // [rsp+28h] [rbp-8A0h]
  unsigned int valuestart; // [rsp+30h] [rbp-898h]
  int valuestarta; // [rsp+30h] [rbp-898h]
  unsigned int header_buf_len; // [rsp+38h] [rbp-890h]
  int chunked; // [rsp+3Ch] [rbp-88Ch]
  int v57; // [rsp+44h] [rbp-884h]
  char chunksize_buf[32]; // [rsp+60h] [rbp-868h] BYREF
  char buf[2048]; // [rsp+80h] [rbp-848h] BYREF
  unsigned __int64 v62; // [rsp+888h] [rbp-40h]

  v62 = __readfsqword(0x28u);
  if ( status_code )
    *status_code = -1;
  v3 = malloc(0x800uLL);
  if ( !v3 )
  {
    *size = -1;
    return 0LL;
  }
  content_buf = (char *)malloc(0x800uLL);
  if ( !content_buf )
  {
    free(v3);
    *size = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  v4 = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  header_buf = (char *)v3;
  v5 = 0;
  v6 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
  while ( 2 )
  {
    v25 = v6;
    if ( v6 <= 0 )
    {
      v40 = header_buf;
      v41 = size;
      goto end_of_stream;
    }
    if ( endofheaders )
    {
      if ( !chunked )
      {
LABEL_133:
        if ( content_length > 0 )
        {
          v43 = v25 + content_buf_used;
          if ( (int)(v25 + content_buf_used) <= content_length )
          {
            v39 = content_buf;
            if ( content_buf_len >= v43 )
              goto LABEL_139;
            goto LABEL_131;
          }
          v25 = content_length - content_buf_used;
        }
        v43 = v25 + content_buf_used;
        if ( content_buf_len >= v25 + content_buf_used )
        {
          v39 = content_buf;
          goto LABEL_139;
        }
        content_buf_len = v25 + content_buf_used;
        if ( v43 > content_length )
        {
LABEL_138:
          v39 = (char *)realloc(content_buf, content_buf_len);
          if ( !v39 )
          {
LABEL_108:
            free(content_buf);
            free(header_buf);
            *size = -1;
            return 0LL;
          }
LABEL_139:
          memcpy(&v39[content_buf_used], buf, v25);
          content_buf_used = v43;
          content_buf = v39;
          goto LABEL_140;
        }
LABEL_131:
        content_buf_len = content_length;
        goto LABEL_138;
      }
LABEL_75:
      v26 = 0;
      while ( 1 )
      {
        if ( v5 )
          goto LABEL_112;
        if ( !v4 )
        {
          if ( buf[v26] == 13 )
            ++v26;
          if ( v25 <= v26 )
            goto LABEL_140;
          if ( buf[v26] != 10 )
            goto LABEL_83;
          ++v26;
        }
        if ( v25 <= v26 )
          goto LABEL_140;
LABEL_83:
        v27 = *_ctype_b_loc();
        v28 = &buf[v26];
        v29 = v25 + v4 - v26;
        while ( (v27[*v28] & 0x1000) != 0 && v4 <= 0x1E )
        {
          chunksize_buf[v4] = *v28;
          chunksize_buf[v4 + 1] = 0;
          ++v26;
          ++v28;
          if ( v4 + 1 == v29 )
          {
            v4 = v29;
            break;
          }
          ++v4;
        }
        if ( v25 <= v26 )
          goto LABEL_140;
        v30 = &buf[v26];
        while ( *v30 != 10 && *v30 != 13 )
        {
          ++v26;
          ++v30;
          if ( v25 == v26 )
            goto LABEL_140;
        }
        if ( v25 <= v26 )
          goto LABEL_140;
        if ( buf[v26] == 13 && v25 <= ++v26 )
          goto LABEL_140;
        if ( buf[v26] != 10 )
        {
          v31 = content_buf_used;
          goto LABEL_110;
        }
        if ( !v4 )
        {
          v40 = header_buf;
          v41 = size;
          goto end_of_stream;
        }
        v32 = chunksize_buf;
        v33 = &chunksize_buf[v4];
        v34 = 0;
        do
        {
          v35 = *v32;
          if ( (unsigned __int8)(*v32 - 48) > 9u )
            v34 = 16 * v34 + (v35 | 0x20) - 87;
          else
            v34 = 16 * v34 + v35 - 48;
          ++v32;
        }
        while ( v32 != v33 );
        chunksize_buf[0] = 0;
        ++v26;
        if ( !v34 )
        {
          v40 = header_buf;
          v41 = size;
          goto end_of_stream;
        }
        v4 = 0;
        v5 = v34;
LABEL_112:
        v36 = v25 - v26;
        if ( v25 - v26 > v5 )
          v36 = v5;
        v31 = v36 + content_buf_used;
        if ( content_buf_len < v36 + content_buf_used )
        {
          v37 = content_length;
          if ( content_length < v31 )
            v37 = v36 + content_buf_used;
          content_buf_len = v37;
          v38 = (char *)realloc(content_buf, v37);
          if ( !v38 )
            goto LABEL_108;
          content_buf = v38;
        }
        memcpy(&content_buf[content_buf_used], &buf[v26], v36);
        v26 += v36;
        v5 -= v36;
        if ( v25 <= v26 )
        {
          content_buf_used += v36;
          goto LABEL_140;
        }
LABEL_110:
        content_buf_used = v31;
      }
    }
    v44 = v6 + valuestart;
    if ( header_buf_len < v6 + valuestart )
    {
      v45 = (char *)realloc(header_buf, (unsigned int)v44);
      if ( !v45 )
      {
        free(header_buf);
        free(content_buf);
        *size = -1;
        return 0LL;
      }
      header_buf_len = v25 + valuestart;
      header_buf = v45;
    }
    memcpy(&header_buf[valuestart], buf, v25);
    if ( v44 <= 1 )
    {
      valuestart += v25;
      goto LABEL_142;
    }
    v7 = 0;
    do
    {
      v9 = header_buf[v7];
      if ( v9 == 13 )
      {
        if ( header_buf[v7 + 1] == 10 )
        {
          if ( v7 + 2 >= v44 )
          {
            v7 += 2;
            v8 = 0;
          }
          else if ( header_buf[v7 + 2] == 13 )
          {
            v10 = v7 + 3;
            if ( v7 + 3 >= v44 )
            {
              v7 += 3;
              v8 = 0;
            }
            else
            {
              v8 = v7 + 4;
              v7 += 3;
              if ( header_buf[v10] != 10 )
                v8 = 0;
            }
          }
          else
          {
            v7 += 2;
            v8 = 0;
          }
        }
        else
        {
          ++v7;
          v8 = endofheaders;
        }
      }
      else
      {
        v8 = endofheaders;
        if ( v9 == 10 )
        {
          v8 = v7 + 2;
          if ( header_buf[++v7] != 10 )
            v8 = endofheaders;
        }
      }
      ++v7;
    }
    while ( v7 < v44 - 1 && !v8 );
    if ( !v8 )
    {
      valuestart += v25;
      endofheaders = 0;
      goto LABEL_142;
    }
    v11 = v8 - 1;
    if ( v8 - 1 <= 0 )
      goto LABEL_72;
    valuestarta = 0;
    v12 = 0;
    v13 = 0;
    v57 = v8;
    v14 = 0;
    do
    {
      if ( v14 <= 0 || v14 < v12 )
      {
        v17 = header_buf[v13];
        if ( v17 != 13 && v17 != 10 )
          goto LABEL_39;
        if ( v14 || !status_code )
        {
          if ( v14 < v12 && v12 < valuestarta )
          {
            v21 = v12 - v14;
            v22 = &header_buf[v14];
            if ( !strncasecmp(v22, "content-length", v21) )
            {
              content_length = strtol(&header_buf[valuestarta], 0LL, 10);
            }
            else if ( !strncasecmp(v22, "transfer-encoding", v21) )
            {
              v23 = strncasecmp(&header_buf[valuestarta], "chunked", 7uLL) == 0;
              v24 = 1;
              if ( !v23 )
                v24 = chunked;
              chunked = v24;
            }
          }
        }
        else if ( v13 > 0 )
        {
          v20 = header_buf + 1;
          while ( 1 )
          {
            if ( *(v20 - 1) == 32 )
            {
              if ( *status_code >= 0 )
                goto LABEL_45;
              *status_code = strtol(v20, 0LL, 10);
            }
            if ( ++v20 == &header_buf[v13 + 1] )
              goto LABEL_45;
          }
        }
        goto LABEL_45;
      }
      v18 = header_buf[v13];
      if ( v18 != 58 )
      {
        if ( v18 != 13 && v18 != 10 )
          goto LABEL_39;
LABEL_45:
        if ( v44 <= v13 )
        {
          valuestarta = 0;
          v12 = v13;
          v14 = v13;
        }
        else
        {
          v19 = &header_buf[v13];
          do
          {
            if ( *v19 != 13 && *v19 != 10 )
            {
              valuestarta = endofheaders;
              v12 = v13;
              v14 = v13;
              goto LABEL_39;
            }
            ++v13;
            ++v19;
          }
          while ( v13 != v44 );
          valuestarta = endofheaders;
          v12 = v44;
          v14 = v44;
          v13 = v44;
        }
        goto LABEL_39;
      }
      if ( v11 <= v13 )
      {
        v16 = v13;
      }
      else
      {
        v15 = &header_buf[v13 + 1];
        v16 = v13;
        while ( *v15 == 32 || *v15 == 9 )
        {
          ++v16;
          ++v15;
          if ( v16 == v57 - 1 )
          {
            v16 = v57 - 1;
            break;
          }
        }
      }
      valuestarta = v16 + 1;
      v12 = v13;
      v13 = v16;
LABEL_39:
      ++v13;
    }
    while ( v13 < v11 );
    v8 = v57;
LABEL_72:
    v25 = v44 - v8;
    memcpy(buf, &header_buf[v8], v44 - v8);
    valuestart = v44;
    endofheaders = v8;
    if ( !chunked )
      goto LABEL_133;
    if ( v25 > 0 )
      goto LABEL_75;
    valuestart = v44;
    endofheaders = v8;
LABEL_140:
    if ( content_length <= 0 || (int)content_buf_used < content_length )
    {
LABEL_142:
      v6 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
      continue;
    }
    break;
  }
  v40 = header_buf;
  v41 = size;
end_of_stream:
  free(v40);
  *v41 = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0LL;
  }
  return content_buf;
}
