void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x22
  int v4; // w19
  int v5; // w24
  unsigned int v6; // w25
  int v7; // w28
  int v8; // w27
  int v9; // w26
  char *v10; // x0
  int v11; // w3
  int v12; // w0
  int v13; // w8
  _BOOL4 v14; // w1
  int v16; // w1
  int v17; // w2
  int v18; // w10
  int v19; // w11
  int v20; // w2
  int v21; // w1
  int v22; // w3
  int v23; // w0
  __int64 v24; // x27
  bool v25; // cc
  int v26; // w23
  bool v27; // zf
  int v28; // w3
  int v29; // w26
  unsigned int v30; // w23
  int v31; // w1
  size_t v32; // x1
  char *v33; // x0
  int v34; // w2
  char *v35; // x1
  int v38; // w3
  unsigned int v39; // w2
  int v40; // w26
  size_t v43; // x2
  int v44; // w0
  int v45; // w0
  int v46; // w0
  const unsigned __int16 *v48; // x8
  unsigned int v49; // w7
  __int64 j; // x2
  char *v52; // x2
  int v53; // w1
  int v55; // w0
  char *v56; // x3
  int v57; // t1
  int v58; // w19
  int v59; // w0
  int v60; // w0
  bool v62; // zf
  const char *v63; // x4
  __int64 v64; // x11
  int v65; // w0
  char *v66; // x0
  int v67; // w0
  __int64 v68; // x0
  int v69; // w2
  char *v71; // x0
  char *content_buf; // [xsp+68h] [xbp+68h]
  unsigned int content_buf_len; // [xsp+70h] [xbp+70h]
  int content_buf_lena; // [xsp+70h] [xbp+70h]
  int chunked; // [xsp+74h] [xbp+74h]
  int chunkeda; // [xsp+74h] [xbp+74h]
  unsigned int header_buf_used; // [xsp+78h] [xbp+78h]
  size_t header_buf_useda; // [xsp+78h] [xbp+78h]
  __int64 header_buf_usedb; // [xsp+78h] [xbp+78h]
  int endofheaders; // [xsp+80h] [xbp+80h]
  const char *endofheadersa; // [xsp+80h] [xbp+80h]
  const char *endofheadersb; // [xsp+80h] [xbp+80h]
  int v85; // [xsp+94h] [xbp+94h]
  int v86; // [xsp+94h] [xbp+94h]
  int v87; // [xsp+94h] [xbp+94h]
  int v88; // [xsp+98h] [xbp+98h]
  int v89; // [xsp+98h] [xbp+98h]
  int i; // [xsp+9Ch] [xbp+9Ch]
  int ia; // [xsp+9Ch] [xbp+9Ch]
  unsigned int header_buf_len; // [xsp+A0h] [xbp+A0h]
  int valuestart; // [xsp+A4h] [xbp+A4h]
  char chunksize_buf[32]; // [xsp+B8h] [xbp+B8h] BYREF
  char buf[2048]; // [xsp+D8h] [xbp+D8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
    goto LABEL_177;
  content_buf = (char *)malloc(0x800uLL);
  if ( !content_buf )
  {
    free(v3);
LABEL_177:
    content_buf = 0LL;
    *size = -1;
    return content_buf;
  }
  v4 = 0;
  v5 = -1;
  v6 = 0;
  v7 = 0;
  content_buf_len = 2048;
  chunked = 0;
  header_buf_used = 0;
  endofheaders = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
LABEL_6:
    v8 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v8 <= 0 )
    {
LABEL_171:
      free(v3);
      *size = v7;
      if ( v7 )
        return content_buf;
      goto LABEL_172;
    }
    if ( endofheaders )
      break;
    v9 = v8 + header_buf_used;
    if ( v8 + header_buf_used > header_buf_len )
    {
      v10 = (char *)realloc(v3, (unsigned int)v9);
      if ( !v10 )
      {
        free(v3);
        v71 = content_buf;
        goto LABEL_175;
      }
      v3 = v10;
      header_buf_len = v8 + header_buf_used;
    }
    memcpy(&v3[header_buf_used], buf, v8);
    v11 = v9 - 1;
    if ( v9 <= 1 )
    {
      header_buf_used += v8;
    }
    else
    {
      v12 = 0;
      do
      {
        while ( 1 )
        {
          v16 = (unsigned __int8)v3[v12];
          v17 = v12 + 1;
          if ( v16 != 13 )
            break;
          if ( v3[v17] == 10 )
          {
            if ( v12 + 2 < v9 && v3[v12 + 2] == 13 )
            {
              if ( v12 + 3 < v9 && v3[v12 + 3] == 10 )
              {
                v12 += 4;
                v14 = v12 == 0;
                v13 = v12;
              }
              else
              {
                v12 += 4;
                v13 = 0;
                v14 = 1;
              }
            }
            else
            {
              v12 += 3;
              v13 = 0;
              v14 = 1;
            }
            goto LABEL_15;
          }
LABEL_21:
          v12 += 2;
          v13 = 0;
          if ( v11 <= v12 )
            goto LABEL_22;
        }
        if ( v16 == 10 )
        {
          if ( v3[v17] != 10 )
            goto LABEL_21;
          v12 += 2;
          v14 = v12 == 0;
          v13 = v12;
        }
        else
        {
          ++v12;
          v13 = 0;
          v14 = 1;
        }
LABEL_15:
        ;
      }
      while ( v14 && v11 > v12 );
LABEL_22:
      if ( v13 )
      {
        v18 = v13 - 1;
        if ( v13 - 1 > 0 )
        {
          v19 = 0;
          v20 = 0;
          v21 = 0;
          v22 = 0;
          do
          {
            v23 = (unsigned __int8)v3[v22];
            v24 = v22;
            v25 = v21 <= 0 || v21 < v20;
            v26 = v22 + 1;
            if ( v25 )
            {
              if ( v23 == 13 || v23 == 10 )
              {
                if ( v21 )
                  v62 = 1;
                else
                  v62 = status_code == 0LL;
                if ( !v62 )
                {
                  if ( v22 > 0 )
                  {
                    v63 = v3 + 1;
                    v64 = (__int64)&v3[v22 + 1];
                    while ( 1 )
                    {
                      if ( *(v63 - 1) == 32 )
                      {
                        header_buf_usedb = v64;
                        if ( (*status_code & 0x80000000) == 0 )
                          goto LABEL_91;
                        endofheadersb = v63;
                        v87 = v13;
                        v89 = v18;
                        ia = v22;
                        v65 = strtol(v63, 0uLL, 10);
                        v64 = header_buf_usedb;
                        v63 = endofheadersb;
                        v13 = v87;
                        v18 = v89;
                        *status_code = v65;
                        v22 = ia;
                      }
                      if ( (const char *)v64 == ++v63 )
                        goto LABEL_91;
                    }
                  }
                  do
                  {
LABEL_94:
                    v46 = (unsigned __int8)v3[v24];
                    v21 = v24;
                    v22 = v24 + 1;
                    if ( v46 != 13 && v46 != 10 )
                    {
                      v20 = v24;
                      v19 = 0;
                      goto LABEL_35;
                    }
                    ++v24;
                  }
                  while ( v9 > (int)v24 );
                  v67 = v21 + 2;
                  v20 = v22;
                  v21 = v22;
                  v19 = 0;
                  v22 = v67;
                  continue;
                }
                valuestart = v19;
                if ( v21 < v20 && v20 < v19 )
                {
                  v43 = v20 - v21;
                  header_buf_useda = (int)v43;
                  endofheadersa = &v3[v21];
                  v86 = v13;
                  v88 = v18;
                  i = v22;
                  if ( strncasecmp(endofheadersa, "content-length", v43) )
                  {
                    v44 = strncasecmp(endofheadersa, "transfer-encoding", header_buf_useda);
                    v13 = v86;
                    v18 = v88;
                    v22 = i;
                    if ( !v44 )
                    {
                      v27 = strncasecmp(&v3[valuestart], "chunked", 7uLL) == 0;
                      v18 = v88;
                      v45 = chunked;
                      v13 = v86;
                      v22 = i;
                      if ( v27 )
                        v45 = 1;
                      chunked = v45;
                    }
                    goto LABEL_91;
                  }
                  v5 = strtol(&v3[valuestart], 0uLL, 10);
                  v22 = i;
                  v13 = v86;
                  v18 = v88;
                  if ( v9 > i )
                    goto LABEL_94;
                }
                else
                {
LABEL_91:
                  if ( v9 > v22 )
                    goto LABEL_94;
                }
                v20 = v22;
                v21 = v22;
                v19 = 0;
                v22 = v26;
                continue;
              }
            }
            else
            {
              if ( v23 == 58 )
              {
                v68 = v26;
                while ( 1 )
                {
                  v19 = v68;
                  if ( (int)v68 - 1 >= v18 )
                    break;
                  v69 = (unsigned __int8)v3[v68++];
                  if ( v69 != 32 && v69 != 9 )
                  {
                    v20 = v22;
                    v22 = v19;
                    goto LABEL_35;
                  }
                }
                v20 = v22;
                v22 = v68;
                continue;
              }
              v27 = v23 == 10 || v23 == 13;
              if ( v27 )
                goto LABEL_91;
            }
            ++v22;
LABEL_35:
            ;
          }
          while ( v18 > v22 );
        }
        v8 = v9 - v13;
        endofheaders = v13;
        memcpy(buf, &v3[v13], v9 - v13);
        header_buf_used = v9;
        if ( !chunked )
        {
LABEL_67:
          v38 = v8 + v7;
          v39 = v8 + v7;
          if ( v5 <= 0 )
          {
            if ( content_buf_len < v38 )
            {
              v40 = v8 + v7;
              if ( v5 < v38 )
                goto LABEL_150;
              goto LABEL_154;
            }
          }
          else
          {
            if ( v5 < v38 )
            {
              v38 = v5;
              v40 = v5;
              v8 = v5 - v7;
              if ( v5 <= content_buf_len )
              {
LABEL_70:
                v85 = v38;
                memcpy(&content_buf[v7], buf, v8);
                v28 = v85;
                v7 = v40;
                chunked = 0;
                goto LABEL_71;
              }
              v40 = v5;
              v39 = v5;
LABEL_150:
              content_buf_len = v39;
              v66 = (char *)realloc(content_buf, v39);
              if ( !v66 )
                goto LABEL_174;
              v38 = v40;
              content_buf = v66;
              goto LABEL_70;
            }
            if ( content_buf_len < v38 )
            {
LABEL_154:
              v40 = v8 + v7;
              v39 = v5;
              goto LABEL_150;
            }
          }
          v40 = v8 + v7;
          goto LABEL_70;
        }
        v28 = v7;
        if ( v8 > 0 )
          goto LABEL_38;
LABEL_71:
        if ( v5 > 0 && v5 <= v28 )
        {
end_of_stream:
          content_buf_lena = v28;
          free(v3);
          *size = content_buf_lena;
          if ( v7 )
            return content_buf;
LABEL_172:
          free(content_buf);
          return 0LL;
        }
      }
      else
      {
        header_buf_used += v8;
        endofheaders = 0;
      }
    }
  }
  if ( !chunked )
    goto LABEL_67;
LABEL_38:
  v29 = 0;
  while ( 2 )
  {
    v34 = v7;
    if ( v4 )
      goto LABEL_39;
    while ( 2 )
    {
      if ( v6 )
      {
LABEL_101:
        if ( v29 >= v8 )
          goto LABEL_57;
      }
      else
      {
        if ( buf[v29] == 13 )
          ++v29;
        if ( v29 >= v8 )
          goto LABEL_57;
        if ( buf[v29] == 10 )
        {
          ++v29;
          goto LABEL_101;
        }
      }
      v48 = *_ctype_b_loc();
      v49 = v8 + v6 - v29;
      for ( j = v29 + 1; ; ++j )
      {
        if ( (v48[(unsigned __int8)buf[j - 1]] & 0x1000) == 0 || v6 > 0x1E )
        {
          v29 = j - 1;
          goto LABEL_111;
        }
        chunksize_buf[v6] = buf[j - 1];
        chunksize_buf[v6 + 1] = 0;
        if ( v6 + 1 == v49 )
          break;
        ++v6;
      }
      v29 = j;
      v6 = v49;
LABEL_111:
      if ( v29 >= v8 )
        goto LABEL_57;
      v52 = &buf[v29];
      while ( 1 )
      {
        v53 = (unsigned __int8)*v52;
        if ( v53 == 13 || v53 == 10 )
          break;
        ++v29;
        ++v52;
        if ( v29 == v8 )
          goto LABEL_57;
      }
      if ( v29 >= v8 )
        goto LABEL_57;
      v55 = (unsigned __int8)buf[v29];
      if ( v55 == 13 )
      {
        if ( ++v29 >= v8 )
          goto LABEL_57;
        v55 = (unsigned __int8)buf[v29];
      }
      if ( v55 != 10 )
        continue;
      break;
    }
    if ( !v6 )
      goto LABEL_171;
    v56 = chunksize_buf;
    v4 = 0;
    do
    {
      v57 = (unsigned __int8)*v56++;
      v58 = 16 * v4;
      v59 = v58 - 0x57;
      v4 = v58 - 0x30 + v57;
      v60 = v59 + (v57 | 0x20);
      if ( (unsigned __int8)(v57 - 0x30) > 9u )
        v4 = v60;
    }
    while ( v56 != &chunksize_buf[v6] );
    chunksize_buf[0] = 0;
    ++v29;
    if ( !v4 )
      goto LABEL_171;
    v34 = v7;
    v6 = 0;
LABEL_39:
    if ( v8 - v29 > v4 )
      v30 = v4;
    else
      v30 = v8 - v29;
    v7 += v30;
    if ( v7 <= content_buf_len )
    {
LABEL_51:
      v35 = &buf[v29];
      v29 += v30;
      v4 -= v30;
      memcpy(&content_buf[v34], v35, v30);
      if ( v29 < v8 )
        continue;
LABEL_57:
      chunked = 1;
      v28 = v7;
      if ( v5 > 0 && v5 <= v7 )
        goto end_of_stream;
      goto LABEL_6;
    }
    break;
  }
  if ( v7 <= v5 )
    v31 = v5;
  else
    v31 = v7;
  content_buf_len = v31;
  chunkeda = v34;
  if ( v7 <= v5 )
    v32 = (unsigned int)v5;
  else
    v32 = (unsigned int)v7;
  v33 = (char *)realloc(content_buf, v32);
  v34 = chunkeda;
  if ( v33 )
  {
    content_buf = v33;
    goto LABEL_51;
  }
LABEL_174:
  free(content_buf);
  v71 = v3;
LABEL_175:
  free(v71);
  content_buf = 0LL;
  *size = -1;
  return content_buf;
}
