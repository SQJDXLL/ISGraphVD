void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int v3; // r0
  unsigned int v4; // r1
  size_t v6; // [sp+4h] [bp-8B4h]
  bool v7; // [sp+8h] [bp-8B0h]
  bool v8; // [sp+Ch] [bp-8ACh]
  bool v9; // [sp+10h] [bp-8A8h]
  bool v10; // [sp+14h] [bp-8A4h]
  bool v11; // [sp+18h] [bp-8A0h]
  bool v12; // [sp+1Ch] [bp-89Ch]
  bool v13; // [sp+20h] [bp-898h]
  void *v14; // [sp+24h] [bp-894h]
  void *v15; // [sp+28h] [bp-890h]
  unsigned int m; // [sp+2Ch] [bp-88Ch]
  signed int v17; // [sp+30h] [bp-888h]
  int k; // [sp+34h] [bp-884h]
  void *v19; // [sp+38h] [bp-880h]
  int v20; // [sp+3Ch] [bp-87Ch]
  int v21; // [sp+40h] [bp-878h]
  int v22; // [sp+44h] [bp-874h]
  int i; // [sp+48h] [bp-870h]
  int j; // [sp+48h] [bp-870h]
  unsigned int v25; // [sp+4Ch] [bp-86Ch]
  char v26[32]; // [sp+50h] [bp-868h]
  int v27; // [sp+70h] [bp-848h]
  size_t v28; // [sp+74h] [bp-844h]
  void *v29; // [sp+78h] [bp-840h]
  int v30; // [sp+7Ch] [bp-83Ch]
  size_t v31; // [sp+80h] [bp-838h]
  void *ptr; // [sp+84h] [bp-834h]
  size_t v33; // [sp+88h] [bp-830h]
  int v34; // [sp+8Ch] [bp-82Ch]
  int v35; // [sp+90h] [bp-828h]
  int v36; // [sp+94h] [bp-824h]
  int v37; // [sp+98h] [bp-820h]
  size_t n; // [sp+9Ch] [bp-81Ch]
  char src[2048]; // [sp+A0h] [bp-818h] BYREF
  int *status_codea; // [sp+8A0h] [bp-18h]
  int *sizea; // [sp+8A4h] [bp-14h]
  int sa; // [sp+8A8h] [bp-10h]

  sa = s;
  sizea = size;
  status_codea = status_code;
  v37 = 0;
  v36 = 0;
  v35 = -1;
  v34 = 0;
  v33 = 0;
  v31 = 2048;
  v30 = 0;
  v28 = 2048;
  v27 = 0;
  if ( status_code )
    *status_codea = -1;
  ptr = malloc(v31);
  if ( !ptr )
  {
    *sizea = -1;
    return 0;
  }
  v29 = malloc(v28);
  if ( !v29 )
  {
    free(ptr);
    *sizea = -1;
    return 0;
  }
  v26[0] = 0;
  v25 = 0;
  while ( 1 )
  {
    n = receivedata(sa, src, 2048, 5000, 0);
    if ( (int)n < 1 )
      break;
    if ( v37 )
      goto LABEL_72;
    v22 = 0;
    v21 = 0;
    v20 = 0;
    if ( v30 + n > v31 )
    {
      v19 = realloc(ptr, v30 + n);
      if ( !v19 )
      {
        free(ptr);
        free(v29);
        *sizea = -1;
        return 0;
      }
      ptr = v19;
      v31 = v30 + n;
    }
    memcpy((char *)ptr + v30, src, n);
    v30 += n;
    for ( i = 0; ; ++i )
    {
      v13 = 0;
      if ( i < v30 - 1 )
        v13 = v37 == 0;
      if ( !v13 )
        break;
      if ( *((_BYTE *)ptr + i) == 13 )
      {
        ++i;
        if ( *((_BYTE *)ptr + i) == 10
          && ++i < v30
          && *((_BYTE *)ptr + i) == 13
          && ++i < v30
          && *((_BYTE *)ptr + i) == 10 )
        {
          v37 = i + 1;
        }
      }
      else if ( *((_BYTE *)ptr + i) == 10 )
      {
        ++i;
        if ( *((_BYTE *)ptr + i) == 10 )
          v37 = i + 1;
      }
    }
    if ( v37 )
    {
      for ( j = 0; j < v37 - 1; ++j )
      {
        if ( v22 >= 1 && v21 <= v22 && *((_BYTE *)ptr + j) == 58 )
        {
          v21 = j;
          while ( 1 )
          {
            v12 = 0;
            if ( j < v37 - 1 )
            {
              v11 = 1;
              if ( *((_BYTE *)ptr + j + 1) != 32 )
                v11 = *((_BYTE *)ptr + j + 1) == 9;
              v12 = v11;
            }
            if ( !v12 )
              break;
            ++j;
          }
          v20 = j + 1;
        }
        else if ( *((_BYTE *)ptr + j) == 13 || *((_BYTE *)ptr + j) == 10 )
        {
          if ( v22 || !status_codea )
          {
            if ( v21 > v22 && v20 > v21 )
            {
              if ( !strncasecmp((const char *)ptr + v22, "content-length", v21 - v22) )
              {
                v35 = atoi((const char *)ptr + v20);
              }
              else if ( !strncasecmp((const char *)ptr + v22, "transfer-encoding", v21 - v22)
                     && !strncasecmp((const char *)ptr + v20, "chunked", 7u) )
              {
                v36 = 1;
              }
            }
          }
          else
          {
            for ( k = 0; k < j; ++k )
            {
              if ( *((_BYTE *)ptr + k) == 32 )
              {
                if ( *status_codea > -1 )
                  goto LABEL_63;
                v3 = atoi((const char *)ptr + k + 1);
                *status_codea = v3;
              }
            }
          }
          while ( 1 )
          {
LABEL_63:
            v10 = 0;
            if ( j < v30 )
            {
              v9 = 1;
              if ( *((_BYTE *)ptr + j) != 13 )
                v9 = *((_BYTE *)ptr + j) == 0xA;
              v10 = v9;
            }
            if ( !v10 )
              break;
            ++j;
          }
          v22 = j;
          v21 = j;
          v20 = 0;
        }
      }
      n = v30 - v37;
      memcpy(src, (char *)ptr + v37, v30 - v37);
LABEL_72:
      if ( v37 )
      {
        if ( v36 )
        {
          v17 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( v17 >= (int)n )
                goto LABEL_131;
              if ( !v34 )
                break;
LABEL_109:
              if ( v34 >= (int)(n - v17) )
                v6 = n - v17;
              else
                v6 = v34;
              v33 = v6;
              if ( v27 + v6 > v28 )
              {
                if ( v35 < (int)(v27 + v33) )
                  v28 = v27 + v33;
                else
                  v28 = v35;
                v15 = realloc(v29, v28);
                if ( !v15 )
                  goto LABEL_117;
                v29 = v15;
              }
              memcpy((char *)v29 + v27, &src[v17], v33);
              v27 += v33;
              v17 += v33;
              v34 -= v33;
            }
            if ( !v25 )
            {
              if ( v17 < (int)n && src[v17] == 13 )
                ++v17;
              if ( v17 < (int)n && src[v17] == 10 )
                ++v17;
            }
            while ( 1 )
            {
              v8 = 0;
              if ( v17 < (int)n )
              {
                v8 = 0;
                if ( ((*_ctype_b_loc())[(unsigned __int8)src[v17]] & 0x1000) != 0 )
                  v8 = v25 < 0x1F;
              }
              if ( !v8 )
                break;
              v4 = v25++;
              v26[v4] = src[v17];
              v26[v25] = 0;
              ++v17;
            }
            while ( 1 )
            {
              v7 = 0;
              if ( v17 < (int)n )
              {
                v7 = 0;
                if ( src[v17] != 13 )
                  v7 = src[v17] != 0xA;
              }
              if ( !v7 )
                break;
              ++v17;
            }
            if ( v17 < (int)n && src[v17] == 13 )
              ++v17;
            if ( v17 < (int)n && src[v17] == 10 )
            {
              for ( m = 0; m < v25; ++m )
              {
                if ( (unsigned __int8)v26[m] < 0x30u || (unsigned __int8)v26[m] > 0x39u )
                  v34 = ((unsigned __int8)v26[m] | 0x20) + 16 * v34 - 0x57;
                else
                  v34 = (unsigned __int8)v26[m] + 16 * v34 - 0x30;
              }
              v26[0] = 0;
              v25 = 0;
              ++v17;
              if ( !v34 )
                goto end_of_stream;
              goto LABEL_109;
            }
          }
        }
        if ( v35 >= 1 && (int)(v27 + n) > v35 )
          n = v35 - v27;
        if ( v27 + n > v28 )
        {
          if ( v35 < (int)(v27 + n) )
            v28 = v27 + n;
          else
            v28 = v35;
          v14 = realloc(v29, v28);
          if ( !v14 )
          {
LABEL_117:
            free(v29);
            free(ptr);
            *sizea = -1;
            return 0;
          }
          v29 = v14;
        }
        memcpy((char *)v29 + v27, src, n);
        v27 += n;
      }
LABEL_131:
      if ( v35 >= 1 && v27 >= v35 )
        break;
    }
  }
end_of_stream:
  free(ptr);
  ptr = 0;
  *sizea = v27;
  if ( !v27 )
  {
    free(v29);
    return 0;
  }
  return v29;
}
