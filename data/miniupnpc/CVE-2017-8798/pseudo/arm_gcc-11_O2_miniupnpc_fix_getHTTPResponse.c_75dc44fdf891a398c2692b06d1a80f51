void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // r0
  void *v4; // r4
  unsigned int v5; // r8
  unsigned int v6; // r11
  unsigned int v7; // r10
  char *v8; // r9
  int v9; // r0
  signed int v10; // r5
  unsigned int v11; // r3
  void *v12; // r0
  signed int v13; // r0
  signed int v14; // r6
  int v15; // r2
  signed int v16; // r1
  signed int v17; // r2
  size_t v18; // r4
  unsigned int v19; // r5
  bool v20; // cf
  unsigned int v21; // r3
  char *v22; // r0
  _BOOL4 v23; // r3
  int v25; // r4
  unsigned int v26; // r11
  int *v27; // r10
  int v28; // r2
  int v29; // r1
  int v30; // r5
  int v31; // r8
  int v32; // r9
  int v33; // r4
  bool v34; // zf
  bool v35; // cc
  int v36; // r0
  const char *v37; // r7
  int v38; // r6
  bool v39; // zf
  _BOOL4 v40; // r0
  const char *v41; // r4
  int v42; // t1
  unsigned int v43; // r2
  int v44; // r4
  int v45; // t1
  bool v46; // zf
  unsigned int v47; // r6
  size_t v48; // r2
  signed int v49; // r4
  size_t v50; // r2
  unsigned int v51; // r7
  unsigned int v52; // r3
  char *v53; // r0
  const void *v54; // r1
  int v55; // r3
  const unsigned __int16 *v56; // lr
  int v57; // r0
  _BYTE *v58; // r1
  int v59; // r3
  int v60; // t1
  int v61; // r2
  int v62; // t1
  bool v63; // zf
  unsigned __int8 *v64; // r3
  unsigned __int8 *v65; // r8
  int v66; // r2
  int v67; // t1
  int v68; // r10
  int v69; // r10
  int v70; // r3
  int v71; // t1
  int v72; // r2
  bool v73; // zf
  _BOOL4 v74; // r0
  const char *v75; // r7
  int v76; // r0
  char *v77; // r3
  int v78; // [sp+0h] [bp-8A8h] BYREF
  unsigned int bytestocopy; // [sp+Ch] [bp-89Ch]
  int content_length; // [sp+10h] [bp-898h]
  char *header_buf; // [sp+14h] [bp-894h]
  unsigned int v82; // [sp+18h] [bp-890h]
  unsigned int content_buf_used; // [sp+1Ch] [bp-88Ch]
  unsigned int chunksize_buf_index; // [sp+20h] [bp-888h]
  int sa; // [sp+24h] [bp-884h]
  unsigned int header_buf_used_0; // [sp+28h] [bp-880h]
  unsigned int header_buf_len; // [sp+2Ch] [bp-87Ch]
  unsigned int chunksize; // [sp+30h] [bp-878h]
  char *content_buf; // [sp+34h] [bp-874h]
  unsigned int v90; // [sp+38h] [bp-870h]
  char *v91; // [sp+3Ch] [bp-86Ch]
  int *status_codea; // [sp+40h] [bp-868h]
  char *v93; // [sp+44h] [bp-864h]
  int *v94; // [sp+48h] [bp-860h]
  int *sizea; // [sp+4Ch] [bp-85Ch]
  char *s2; // [sp+50h] [bp-858h]
  int *v97; // [sp+54h] [bp-854h]
  char chunksize_buf[32]; // [sp+5Ch] [bp-84Ch] BYREF
  char buf[2048]; // [sp+7Ch] [bp-82Ch] BYREF

  header_buf_len = s;
  v94 = status_code;
  v97 = size;
  if ( status_code )
    *status_code = -1;
  content_buf_used = (unsigned int)malloc(0x800u);
  if ( !content_buf_used )
  {
    v4 = 0;
    *v97 = -1;
    return v4;
  }
  v3 = (char *)malloc(0x800u);
  v4 = v3;
  if ( !v3 )
  {
    free((void *)content_buf_used);
    *v97 = -1;
    return v4;
  }
  v5 = 0;
  chunksize_buf[0] = 0;
  bytestocopy = 2048;
  content_buf = (_BYTE *)&loc_800;
  v82 = -1;
  content_length = (int)buf;
  v6 = 0;
  v7 = 0;
  v8 = v3;
  s2 = "content-length";
  sa = 0;
  header_buf = 0;
  header_buf_used_0 = 0;
  chunksize_buf_index = (unsigned int)chunksize_buf;
  do
  {
    while ( 1 )
    {
      v9 = receivedata(header_buf_len, content_length, 2048, 5000, 0);
      v10 = v9;
      if ( v9 <= 0 )
        goto end_of_stream;
      if ( header_buf_used_0 )
      {
        if ( !header_buf )
        {
          v18 = v9;
          goto LABEL_27;
        }
        goto LABEL_90;
      }
      v11 = v9 + sa;
      if ( v9 + sa > (unsigned int)content_buf )
      {
        chunksize = v9 + sa;
        v12 = realloc((void *)content_buf_used, v9 + sa);
        v11 = chunksize;
        if ( !v12 )
        {
          free((void *)content_buf_used);
          free(v8);
          v4 = (void *)header_buf_used_0;
          *v97 = -1;
          return v4;
        }
        content_buf_used = (unsigned int)v12;
        content_buf = (char *)chunksize;
      }
      chunksize = v11;
      memcpy((void *)(content_buf_used + sa), (const void *)content_length, v10);
      v13 = chunksize - 1;
      if ( (int)(chunksize - 1) > 0 )
        break;
LABEL_23:
      sa = chunksize;
    }
    v14 = 0;
    while ( 1 )
    {
LABEL_14:
      v15 = *(unsigned __int8 *)(content_buf_used + v14);
      v16 = v14 + 1;
      if ( v15 != 13 )
      {
LABEL_15:
        if ( v15 == 10 )
        {
          v14 += 2;
          if ( *(_BYTE *)(content_buf_used + v16) == 10 )
            break;
          goto LABEL_22;
        }
        goto LABEL_16;
      }
      while ( 1 )
      {
        v17 = v14 + 2;
        if ( *(_BYTE *)(content_buf_used + v16) != 10 )
        {
          if ( v13 <= v17 )
            goto LABEL_23;
          v14 += 2;
          goto LABEL_14;
        }
        v16 = v14 + 3;
        if ( (int)chunksize > v17 && *(_BYTE *)(content_buf_used + v17) == 13 )
          break;
LABEL_16:
        if ( v13 <= v16 )
          goto LABEL_23;
        v14 = v16;
        v15 = *(unsigned __int8 *)(content_buf_used + v16++);
        if ( v15 != 13 )
          goto LABEL_15;
      }
      v14 += 4;
      if ( (int)chunksize > v16 && *(_BYTE *)(content_buf_used + v16) == 10 )
        break;
LABEL_22:
      if ( v13 <= v14 )
        goto LABEL_23;
    }
    v25 = 0;
    status_codea = (int *)"transfer-encoding";
    v93 = "chunked";
    sa = v6;
    header_buf_used_0 = v5;
    v90 = v7;
    v91 = v8;
    v26 = content_buf_used;
    v27 = v94;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = chunksize;
    v32 = v14 - 1;
    chunksize = v14;
    while ( 1 )
    {
LABEL_57:
      v35 = v29 <= v28;
      if ( v29 >= v28 )
        v35 = v29 <= 0;
      v36 = *(unsigned __int8 *)(v26 + v30);
      v37 = (const char *)(v26 + v30);
      v38 = v30 + 1;
      if ( v35 )
        break;
      if ( v36 == 58 )
      {
        v33 = v30;
        do
        {
          v71 = *(unsigned __int8 *)++v37;
          v70 = v71;
          v72 = v33;
          v73 = v71 == 9;
          if ( v71 != 9 )
            v73 = v70 == 32;
          ++v33;
          if ( !v73 )
          {
            v25 = v72 + 1;
            v28 = v30;
            v30 = v25;
            goto LABEL_56;
          }
        }
        while ( v32 > v33 );
        v25 = v33 + 1;
        v28 = v30;
        v30 = v25;
        goto LABEL_56;
      }
      v34 = v36 == 10;
      if ( v36 != 10 )
        v34 = v36 == 13;
      if ( v34 )
        goto LABEL_74;
LABEL_55:
      ++v30;
LABEL_56:
      if ( v32 <= v30 )
        goto LABEL_85;
    }
    v39 = v36 == 10;
    if ( v36 != 10 )
      v39 = v36 == 13;
    if ( !v39 )
      goto LABEL_55;
    v40 = v29 == 0;
    if ( !v27 )
      v40 = 0;
    if ( v40 )
    {
      if ( v30 > 0 )
      {
        v41 = (const char *)v26;
        do
        {
          while ( 1 )
          {
            v42 = *(unsigned __int8 *)v41++;
            if ( v42 == 32 )
              break;
            if ( v37 == v41 )
              goto LABEL_74;
          }
          if ( *v27 >= 0 )
            break;
          *v27 = strtol(v41, 0u, 10);
        }
        while ( v37 != v41 );
      }
      goto LABEL_74;
    }
    v74 = v29 < v28;
    if ( v25 <= v28 )
      v74 = 0;
    if ( !v74 )
      goto LABEL_74;
    v75 = (const char *)(v26 + v29);
    sizea = (int *)(v28 - v29);
    if ( !strncasecmp((const char *)(v26 + v29), s2, v28 - v29) )
    {
      v82 = strtol((const char *)(v26 + v25), 0u, 10);
LABEL_74:
      if ( v30 < v31 )
        goto LABEL_75;
      goto LABEL_154;
    }
    if ( strncasecmp(v75, (const char *)status_codea, (size_t)sizea) )
      goto LABEL_74;
    v76 = strncasecmp((const char *)(v26 + v25), v93, 7u);
    v77 = header_buf;
    if ( !v76 )
      v77 = (_BYTE *)(getHTTPResponse + 1);
    header_buf = v77;
    if ( v30 >= v31 )
    {
LABEL_154:
      v28 = v30;
      v29 = v30;
      v25 = 0;
      ++v30;
      goto LABEL_56;
    }
LABEL_75:
    v43 = v26 + v30 - 1;
    while ( 1 )
    {
      v45 = *(unsigned __int8 *)++v43;
      v44 = v45;
      v29 = v30;
      v46 = v45 == 10;
      if ( v45 != 10 )
        v46 = v44 == 13;
      v25 = v46;
      v30 = v38;
      if ( !v46 )
        break;
      if ( v31 == v38 )
      {
        v30 = v29 + 2;
        v25 = 0;
        v28 = v31;
        v29 = v31;
        goto LABEL_56;
      }
      ++v38;
    }
    v28 = v29;
    if ( v32 > v38 )
      goto LABEL_57;
LABEL_85:
    v47 = chunksize;
    v10 = v31 - chunksize;
    v6 = sa;
    sa = v31;
    v48 = v31 - chunksize;
    v5 = header_buf_used_0;
    v7 = v90;
    v8 = v91;
    memcpy((void *)content_length, (const void *)(content_buf_used + chunksize), v48);
    v18 = v10;
    if ( !header_buf )
    {
      header_buf_used_0 = v47;
LABEL_27:
      v19 = v6 + v10;
      if ( (int)v82 <= 0 )
      {
        if ( bytestocopy < v19 )
        {
          if ( !v82 )
            goto LABEL_33;
          bytestocopy = v19;
LABEL_36:
          v22 = (char *)realloc(v8, bytestocopy);
          if ( !v22 )
          {
            free(v8);
            free((void *)content_buf_used);
            v4 = 0;
            *v97 = -1;
            return v4;
          }
          v8 = v22;
        }
      }
      else
      {
        v20 = v82 >= v19;
        if ( v82 < v19 )
          v19 = v82;
        if ( !v20 )
          v18 = v19 - v6;
        if ( bytestocopy < v19 )
        {
LABEL_33:
          v21 = v82;
          if ( v19 >= v82 )
            v21 = v19;
          bytestocopy = v21;
          goto LABEL_36;
        }
      }
      memcpy(&v8[v6], (const void *)content_length, v18);
      v6 = v19;
      header_buf = 0;
      goto LABEL_39;
    }
    if ( v10 <= 0 )
    {
      header_buf_used_0 = v47;
      goto LABEL_39;
    }
    header_buf_used_0 = v47;
LABEL_90:
    v49 = 0;
    while ( 2 )
    {
      if ( !v7 )
      {
        if ( v5 )
        {
LABEL_107:
          if ( v49 >= v10 )
            goto LABEL_140;
        }
        else
        {
          v55 = *((unsigned __int8 *)&v78 + v49 + 0x7C);
          if ( v55 != 13 )
          {
            if ( v55 != 10 )
              goto LABEL_107;
LABEL_156:
            ++v49;
            goto LABEL_107;
          }
          if ( ++v49 >= v10 )
            goto LABEL_140;
          if ( *((_BYTE *)&v78 + v49 + 0x7C) == 10 )
            goto LABEL_156;
        }
        v56 = *_ctype_b_loc();
        v57 = content_length + v49 - 1;
        v58 = (_BYTE *)(chunksize_buf_index + v5);
        while ( 1 )
        {
          v60 = *(unsigned __int8 *)++v57;
          v59 = v60;
          if ( ((v5 <= 0x1E) & (v56[v60] >> 0xC)) == 0 )
            break;
          ++v49;
          *v58 = v59;
          ++v5;
          *++v58 = 0;
          if ( v49 >= v10 )
            goto LABEL_140;
        }
        if ( v49 >= v10 )
          goto LABEL_140;
        v61 = content_length + v49;
        while ( 1 )
        {
          v63 = v59 == 10;
          if ( v59 != 10 )
            v63 = v59 == 13;
          if ( v63 )
            break;
          if ( ++v49 == v10 )
            goto LABEL_140;
          v62 = *(unsigned __int8 *)++v61;
          v59 = v62;
        }
        if ( v49 >= v10 )
        {
LABEL_140:
          header_buf = (_BYTE *)(getHTTPResponse + 1);
          goto LABEL_39;
        }
        if ( v59 == 13 )
        {
          if ( ++v49 >= v10 )
            goto LABEL_140;
          v59 = *((unsigned __int8 *)&v78 + v49 + 0x7C);
        }
        if ( v59 != 10 )
        {
          v51 = v6;
LABEL_102:
          v6 = v51;
          continue;
        }
        if ( !v5 )
          goto end_of_stream;
        v64 = (unsigned __int8 *)chunksize_buf_index;
        v7 = 0;
        v65 = (unsigned __int8 *)(chunksize_buf_index + v5);
        do
        {
          v67 = *v64++;
          v66 = v67;
          v68 = 16 * v7;
          if ( (unsigned int)(v67 - 0x30) > 9 )
          {
            v66 |= 0x20u;
            v69 = v68 - 0x57;
          }
          else
          {
            v69 = v68 - 0x30;
          }
          v7 = v66 + v69;
        }
        while ( v65 != v64 );
        ++v49;
        chunksize_buf[0] = 0;
        if ( !v7 )
          goto end_of_stream;
        v5 = 0;
      }
      break;
    }
    v50 = v10 - v49;
    if ( v10 - v49 >= v7 )
      v50 = v7;
    v51 = v50 + v6;
    if ( v50 + v6 > bytestocopy )
    {
      v52 = v82;
      if ( (v82 & 0x80000000) == 0 )
      {
        if ( v82 < v51 )
          v52 = v50 + v6;
        bytestocopy = v52;
      }
      else
      {
        bytestocopy = v50 + v6;
      }
      header_buf = (char *)v50;
      v53 = (char *)realloc(v8, bytestocopy);
      v50 = (size_t)header_buf;
      if ( !v53 )
      {
        bytestocopy = 0;
        free(v8);
        free((void *)content_buf_used);
        v4 = (void *)bytestocopy;
        *v97 = -1;
        return v4;
      }
      v8 = v53;
    }
    v54 = (const void *)(content_length + v49);
    v49 += v50;
    v7 -= v50;
    memcpy(&v8[v6], v54, v50);
    if ( v49 < v10 )
      goto LABEL_102;
    v6 = v51;
    header_buf = (_BYTE *)(getHTTPResponse + 1);
LABEL_39:
    v23 = (int)v82 > 0;
    if ( v6 < v82 )
      v23 = 0;
  }
  while ( !v23 );
end_of_stream:
  free((void *)content_buf_used);
  v4 = v8;
  *v97 = v6;
  if ( !v6 )
  {
    free(v8);
    return 0;
  }
  return v4;
}
