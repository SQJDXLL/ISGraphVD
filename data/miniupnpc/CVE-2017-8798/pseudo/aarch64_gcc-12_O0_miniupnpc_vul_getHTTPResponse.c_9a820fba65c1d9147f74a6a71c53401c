void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  unsigned int v4; // w0
  signed int v5; // w0
  int n; // [xsp+38h] [xbp+38h]
  int endofheaders; // [xsp+3Ch] [xbp+3Ch]
  int chunked; // [xsp+40h] [xbp+40h]
  int content_length; // [xsp+44h] [xbp+44h]
  signed int chunksize; // [xsp+48h] [xbp+48h]
  unsigned int header_buf_len; // [xsp+4Ch] [xbp+4Ch]
  signed int header_buf_used; // [xsp+50h] [xbp+50h]
  unsigned int content_buf_len; // [xsp+54h] [xbp+54h]
  unsigned int content_buf_used; // [xsp+58h] [xbp+58h]
  unsigned int chunksize_buf_index; // [xsp+5Ch] [xbp+5Ch]
  int i; // [xsp+60h] [xbp+60h]
  int ia; // [xsp+60h] [xbp+60h]
  int linestart; // [xsp+64h] [xbp+64h]
  int colon; // [xsp+68h] [xbp+68h]
  int valuestart; // [xsp+6Ch] [xbp+6Ch]
  int sp; // [xsp+70h] [xbp+70h]
  int i_0; // [xsp+74h] [xbp+74h]
  unsigned int j; // [xsp+78h] [xbp+78h]
  unsigned int bytestocopy; // [xsp+7Ch] [xbp+7Ch]
  char *header_buf; // [xsp+80h] [xbp+80h]
  char *content_buf; // [xsp+88h] [xbp+88h]
  char *tmp; // [xsp+90h] [xbp+90h]
  char *tmp_1; // [xsp+98h] [xbp+98h]
  char *tmp_0; // [xsp+A0h] [xbp+A0h]
  char chunksize_buf[32]; // [xsp+A8h] [xbp+A8h]
  char buf[2048]; // [xsp+C8h] [xbp+C8h] BYREF

  endofheaders = 0;
  chunked = 0;
  content_length = -1;
  chunksize = 0;
  header_buf_len = 2048;
  header_buf_used = 0;
  content_buf_len = 2048;
  content_buf_used = 0;
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800uLL);
  if ( !header_buf )
  {
    *size = -1;
    return 0LL;
  }
  content_buf = (char *)malloc(0x800uLL);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return 0LL;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  while ( 1 )
  {
    n = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( n <= 0 )
      break;
    if ( endofheaders )
      goto LABEL_65;
    linestart = 0;
    colon = 0;
    valuestart = 0;
    if ( header_buf_len < n + header_buf_used )
    {
      tmp = (char *)realloc(header_buf, (unsigned int)(n + header_buf_used));
      if ( !tmp )
      {
        free(header_buf);
        free(content_buf);
        *size = -1;
        return 0LL;
      }
      header_buf = tmp;
      header_buf_len = header_buf_used + n;
    }
    memcpy(&header_buf[header_buf_used], buf, n);
    header_buf_used += n;
    for ( i = 0; i < header_buf_used - 1 && !endofheaders; ++i )
    {
      if ( header_buf[i] == 13 )
      {
        if ( header_buf[++i] == 10
          && ++i < header_buf_used
          && header_buf[i] == 13
          && ++i < header_buf_used
          && header_buf[i] == 10 )
        {
          endofheaders = i + 1;
        }
      }
      else if ( header_buf[i] == 10 && header_buf[++i] == 10 )
      {
        endofheaders = i + 1;
      }
    }
    if ( endofheaders )
    {
      for ( ia = 0; ia < endofheaders - 1; ++ia )
      {
        if ( linestart > 0 && colon <= linestart && header_buf[ia] == 58 )
        {
          colon = ia;
          while ( ia < endofheaders - 1 && (header_buf[ia + 1] == 32 || header_buf[ia + 1] == 9) )
            ++ia;
          valuestart = ia + 1;
        }
        else if ( header_buf[ia] == 13 || header_buf[ia] == 10 )
        {
          if ( linestart || !status_code )
          {
            if ( colon > linestart && valuestart > colon )
            {
              if ( !strncasecmp(&header_buf[linestart], "content-length", colon - linestart) )
              {
                content_length = atoi(&header_buf[valuestart]);
              }
              else if ( !strncasecmp(&header_buf[linestart], "transfer-encoding", colon - linestart)
                     && !strncasecmp(&header_buf[valuestart], "chunked", 7uLL) )
              {
                chunked = 1;
              }
            }
          }
          else
          {
            for ( sp = 0; sp < ia; ++sp )
            {
              if ( header_buf[sp] == 32 )
              {
                if ( *status_code >= 0 )
                  break;
                *status_code = atoi(&header_buf[sp + 1]);
              }
            }
          }
          while ( ia < header_buf_used && (header_buf[ia] == 13 || header_buf[ia] == 10) )
            ++ia;
          linestart = ia;
          colon = ia;
          valuestart = 0;
        }
      }
      n = header_buf_used - endofheaders;
      memcpy(buf, &header_buf[endofheaders], header_buf_used - endofheaders);
LABEL_65:
      if ( chunked )
      {
        i_0 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            if ( i_0 >= n )
              goto LABEL_119;
            if ( !chunksize )
              break;
LABEL_97:
            v5 = chunksize;
            if ( n - i_0 <= chunksize )
              v5 = n - i_0;
            bytestocopy = v5;
            if ( content_buf_len < content_buf_used + v5 )
            {
              if ( content_length < (int)(content_buf_used + v5) )
                content_buf_len = content_buf_used + v5;
              else
                content_buf_len = content_length;
              tmp_0 = (char *)realloc(content_buf, content_buf_len);
              if ( !tmp_0 )
                goto LABEL_104;
              content_buf = tmp_0;
            }
            memcpy(&content_buf[content_buf_used], &buf[i_0], bytestocopy);
            content_buf_used += bytestocopy;
            i_0 += bytestocopy;
            chunksize -= bytestocopy;
          }
          if ( !chunksize_buf_index )
          {
            if ( i_0 < n && buf[i_0] == 13 )
              ++i_0;
            if ( i_0 < n && buf[i_0] == 10 )
              ++i_0;
          }
          while ( i_0 < n && ((*_ctype_b_loc())[(unsigned __int8)buf[i_0]] & 0x1000) != 0 && chunksize_buf_index <= 0x1E )
          {
            v4 = chunksize_buf_index++;
            chunksize_buf[v4] = buf[i_0];
            chunksize_buf[chunksize_buf_index] = 0;
            ++i_0;
          }
          while ( i_0 < n && buf[i_0] != 13 && buf[i_0] != 10 )
            ++i_0;
          if ( i_0 < n && buf[i_0] == 13 )
            ++i_0;
          if ( i_0 < n && buf[i_0] == 10 )
          {
            for ( j = 0; j < chunksize_buf_index; ++j )
            {
              if ( (unsigned __int8)chunksize_buf[j] <= 0x2Fu || (unsigned __int8)chunksize_buf[j] > 0x39u )
                chunksize = 16 * chunksize + ((unsigned __int8)chunksize_buf[j] | 0x20) - 0x57;
              else
                chunksize = 16 * chunksize + (unsigned __int8)chunksize_buf[j] - 0x30;
            }
            chunksize_buf[0] = 0;
            chunksize_buf_index = 0;
            ++i_0;
            if ( !chunksize )
              goto end_of_stream;
            goto LABEL_97;
          }
        }
      }
      if ( content_length > 0 && content_length < (int)(n + content_buf_used) )
        n = content_length - content_buf_used;
      if ( content_buf_len < n + content_buf_used )
      {
        if ( content_length < (int)(n + content_buf_used) )
          content_buf_len = content_buf_used + n;
        else
          content_buf_len = content_length;
        tmp_1 = (char *)realloc(content_buf, content_buf_len);
        if ( !tmp_1 )
        {
LABEL_104:
          free(content_buf);
          free(header_buf);
          *size = -1;
          return 0LL;
        }
        content_buf = tmp_1;
      }
      memcpy(&content_buf[content_buf_used], buf, n);
      content_buf_used += n;
LABEL_119:
      if ( content_length > 0 && content_length <= (int)content_buf_used )
        break;
    }
  }
end_of_stream:
  free(header_buf);
  *size = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0LL;
  }
  return content_buf;
}
