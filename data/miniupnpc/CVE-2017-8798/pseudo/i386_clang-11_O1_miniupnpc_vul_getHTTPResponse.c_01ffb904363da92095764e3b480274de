void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  void *v3; // eax
  char *v4; // eax
  char *v5; // ebp
  signed int v6; // ecx
  int v7; // eax
  char *v8; // ebx
  int v9; // edi
  int v10; // esi
  unsigned int v11; // edi
  void *v12; // esi
  void *v13; // eax
  char v14; // cl
  bool v15; // dl
  int v16; // ebx
  int v17; // eax
  int v18; // ecx
  char v19; // dl
  int v20; // edx
  int v21; // esi
  bool v22; // zf
  int v23; // eax
  int v24; // ebx
  _BYTE *v25; // edx
  signed int v26; // ebp
  signed int v27; // esi
  signed int v28; // edi
  signed int v29; // ecx
  bool v30; // al
  char v31; // cl
  int *v32; // ecx
  char *v33; // esi
  signed int i; // ebp
  int v35; // eax
  size_t v36; // ecx
  int v37; // eax
  const char *v38; // esi
  int v39; // eax
  signed int v40; // esi
  int v41; // eax
  char v42; // cl
  int v43; // esi
  int v44; // eax
  signed int v45; // ebx
  signed int v46; // eax
  int v47; // ebp
  size_t v48; // esi
  int v49; // eax
  int v50; // edi
  char *v51; // eax
  char v52; // cl
  int v53; // eax
  char v54; // cl
  unsigned int v55; // esi
  signed int v56; // ebp
  const unsigned __int16 *v57; // eax
  int v58; // ecx
  unsigned int v59; // edx
  signed int v60; // eax
  bool v61; // cc
  char v62; // cl
  signed int v63; // ebp
  char *v64; // eax
  int v65; // ecx
  int v66; // ebp
  int v67; // edi
  int v68; // ecx
  size_t v69; // esi
  void *v70; // edi
  void *v71; // eax
  void *result; // eax
  int v73; // eax
  const char *v74; // [esp+0h] [ebp-87Ch]
  int v75; // [esp+18h] [ebp-864h]
  size_t v76; // [esp+1Ch] [ebp-860h]
  void *ptr; // [esp+20h] [ebp-85Ch]
  int v78; // [esp+24h] [ebp-858h]
  int v79; // [esp+28h] [ebp-854h]
  int v80; // [esp+2Ch] [ebp-850h]
  int v81; // [esp+30h] [ebp-84Ch]
  void *v82; // [esp+34h] [ebp-848h]
  char *nptr; // [esp+38h] [ebp-844h]
  unsigned int v84; // [esp+3Ch] [ebp-840h]
  int v85; // [esp+40h] [ebp-83Ch]
  int v86; // [esp+44h] [ebp-838h]
  unsigned int v87; // [esp+48h] [ebp-834h]
  char v88[32]; // [esp+4Ch] [ebp-830h] BYREF
  char src[2064]; // [esp+6Ch] [ebp-810h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = malloc(0x800u);
  if ( !v3 )
  {
    *size = -1;
    return 0;
  }
  ptr = v3;
  v4 = (char *)malloc(0x800u);
  if ( !v4 )
  {
    free(ptr);
    *size = -1;
    return 0;
  }
  v5 = v4;
  v88[0] = 0;
  v87 = 2048;
  v6 = -1;
  v86 = 0;
  v7 = 0;
  v8 = 0;
  v84 = 2048;
  v79 = 0;
  v85 = 0;
  v9 = 0;
  while ( 2 )
  {
    v80 = v7;
    v82 = v5;
    do
    {
      v78 = v6;
      v76 = receivedata(s, src, 2048, 5000, 0);
      if ( (int)v76 <= 0 )
        goto end_of_stream;
      if ( v9 )
      {
        v6 = v78;
        v44 = v79;
        goto LABEL_82;
      }
      v10 = (int)&v8[v76];
      if ( (unsigned int)&v8[v76] <= v87 )
      {
        v13 = ptr;
      }
      else
      {
        v11 = (unsigned int)&v8[v76];
        v12 = ptr;
        v13 = realloc(ptr, (size_t)&v8[v76]);
        if ( v13 )
        {
          v14 = 1;
          v87 = v11;
        }
        else
        {
          free(v12);
          free(v5);
          *size = -1;
          v14 = 0;
          v13 = v12;
        }
        v10 = v11;
        if ( !v14 )
        {
          ptr = v13;
          v9 = 0;
          v23 = 1;
          goto LABEL_8;
        }
      }
      ptr = v13;
      memcpy(&v8[(_DWORD)v13], src, v76);
      v15 = 1;
      v16 = 0;
      v75 = v10;
      if ( v10 >= 2 )
      {
        v17 = v10 - 1;
        v16 = 0;
        v18 = 0;
        while ( 1 )
        {
          v19 = *((_BYTE *)ptr + v18);
          if ( v19 == 10 )
            break;
          if ( v19 == 13 )
          {
            if ( *((_BYTE *)ptr + v18 + 1) == 10 )
            {
              v20 = v18 + 2;
              if ( v18 + 2 >= v10 )
                goto LABEL_32;
              if ( *((_BYTE *)ptr + v20) == 13 )
              {
                v20 = v18 + 3;
                v10 = v75;
                if ( v18 + 3 >= v75 )
                  goto LABEL_32;
                v21 = v18 + 4;
                v22 = *((_BYTE *)ptr + v18 + 3) == 10;
LABEL_27:
                if ( v22 )
                  v16 = v21;
              }
              v10 = v75;
              goto LABEL_32;
            }
            ++v18;
          }
          v20 = v18;
LABEL_32:
          v18 = v20 + 1;
          v15 = v16 == 0;
          if ( v18 >= v17 || v16 )
            goto LABEL_34;
        }
        v20 = v18 + 1;
        v21 = v18 + 2;
        v22 = *((_BYTE *)ptr + v18 + 1) == 10;
        goto LABEL_27;
      }
LABEL_34:
      v23 = 2;
      if ( v15 )
      {
        v8 = (char *)v10;
        v9 = 0;
      }
      else
      {
        v81 = v16;
        if ( v16 >= 2 )
        {
          v24 = v16 - 1;
          v25 = ptr;
          nptr = (char *)ptr + 1;
          v26 = 0;
          v27 = 0;
          v76 = 0;
          v28 = 0;
          while ( 1 )
          {
            if ( (int)v76 > 0 && v27 <= (int)v76 && v25[v28] == 58 )
            {
              v26 = v28;
              do
              {
                v30 = v26 < v24 && (v25[v26 + 1] == 32 || v25[v26 + 1] == 9);
                ++v26;
              }
              while ( v30 );
              v29 = v26 - 1;
            }
            else
            {
              v31 = v25[v28];
              if ( v31 == 13 || v31 == 10 )
              {
                v32 = status_code;
                if ( !status_code || v76 )
                {
                  v36 = v27 - v76;
                  v37 = v78;
                  if ( v27 <= (int)v76 || v26 <= v27 )
                    goto LABEL_67;
                  v38 = &v25[v76];
                  v74 = &v25[v76];
                  v76 = v36;
                  if ( !strncasecmp(v74, "content-length", v36) )
                  {
                    v37 = atoi((const char *)ptr + v26);
                    goto LABEL_67;
                  }
                  v39 = strncasecmp(v38, "transfer-encoding", v76);
                  v40 = v75;
                  if ( !v39 )
                  {
                    v22 = strncasecmp((const char *)ptr + v26, "chunked", 7u) == 0;
                    v41 = v86;
                    if ( v22 )
                      v41 = 1;
                    v86 = v41;
                  }
                  v37 = v78;
                }
                else
                {
                  if ( v28 > 0 )
                  {
                    v33 = nptr;
                    for ( i = v28; i; --i )
                    {
                      if ( *(v33 - 1) == 32 )
                      {
                        if ( *v32 >= 0 )
                          break;
                        v35 = atoi(v33);
                        v32 = status_code;
                        *status_code = v35;
                      }
                      ++v33;
                    }
                  }
                  v37 = v78;
LABEL_67:
                  v40 = v75;
                }
                v26 = 0;
                v78 = v37;
                if ( v28 >= v40 )
                {
                  v29 = v28;
                  v76 = v28;
                  v25 = ptr;
                }
                else
                {
                  v25 = ptr;
                  do
                  {
                    v42 = *((_BYTE *)ptr + v28);
                    if ( v42 != 13 && v42 != 10 )
                    {
                      v29 = v28;
                      v76 = v28;
                      goto LABEL_38;
                    }
                    ++v28;
                  }
                  while ( v40 != v28 );
                  v29 = v40;
                  v76 = v40;
                  v28 = v40;
                }
                goto LABEL_38;
              }
              v29 = v28;
              v28 = v27;
            }
LABEL_38:
            v27 = v28;
            v28 = v29 + 1;
            if ( v29 + 1 >= v24 )
              goto LABEL_79;
          }
        }
        v25 = ptr;
LABEL_79:
        v43 = v75;
        v9 = v81;
        v76 = v75 - v81;
        memcpy(src, &v25[v81], v75 - v81);
        v23 = 0;
        v8 = (char *)v43;
        v5 = (char *)v82;
      }
LABEL_8:
      v6 = v78;
    }
    while ( v23 == 2 );
    v22 = v23 == 0;
    v44 = v79;
    if ( !v22 )
      return 0;
LABEL_82:
    if ( !v9 )
      goto LABEL_142;
    v78 = v6;
    if ( !v86 )
    {
      v81 = v9;
      v48 = v6 - v79;
      v49 = v79;
      if ( (int)(v76 + v79) <= v6 )
        v48 = v76;
      if ( v6 <= 0 )
        v48 = v76;
      v50 = v48 + v79;
      if ( v48 + v79 > v84 )
      {
        if ( v6 < v50 )
          v6 = v48 + v79;
        v84 = v6;
        v51 = (char *)realloc(v5, v6);
        if ( v51 )
        {
          v52 = 1;
          v5 = v51;
        }
        else
        {
          free(v5);
          free(ptr);
          *size = -1;
          v52 = 0;
        }
        v49 = v79;
        if ( !v52 )
          return 0;
      }
      memcpy(&v5[v49], src, v48);
      v79 = v50;
      v6 = v78;
      v9 = v81;
      goto LABEL_142;
    }
    if ( (int)v76 <= 0 )
    {
      v75 = v44;
      v53 = 0;
      v47 = v85;
    }
    else
    {
      nptr = v8;
      v45 = 0;
      v46 = v80;
      v47 = v85;
      v81 = v9;
      while ( 2 )
      {
        v75 = v79;
        v55 = v47;
        v56 = v76;
        while ( 1 )
        {
          if ( v46 )
          {
            v47 = v55;
            goto LABEL_128;
          }
          if ( !v55 )
          {
            v45 += src[v45] == 13;
            if ( v45 < v56 )
              v45 += src[v45] == 10;
          }
          if ( v45 < v56 )
          {
            v57 = *_ctype_b_loc();
            while ( v55 <= 0x1E )
            {
              v58 = src[v45];
              if ( (v57[v58] & 0x1000) == 0 )
                break;
              v59 = v55 + 1;
              v88[v55] = v58;
              v88[v55 + 1] = 0;
              ++v45;
              ++v55;
              if ( v56 == v45 )
              {
                v55 = v59;
                v45 = v56;
                break;
              }
            }
          }
          v60 = v45;
          v61 = v45 < v56;
          v45 = v56;
          if ( !v61 )
            v45 = v60;
          while ( v45 != v60 )
          {
            v62 = src[v60++];
            if ( v62 == 13 || v62 == 10 )
            {
              v45 = v60 - 1;
              if ( v62 == 13 )
                v45 = v60;
              break;
            }
          }
          v6 = v78;
          if ( v45 < v56 && src[v45] == 10 )
            break;
          v46 = 0;
          if ( v45 >= v56 )
          {
            v80 = 0;
            v47 = v55;
            v53 = 0;
            goto LABEL_136;
          }
        }
        v63 = 0;
        if ( v55 )
        {
          v63 = 0;
          v64 = v88;
          do
          {
            v65 = *v64;
            v66 = 16 * v63;
            v67 = v65 - 48;
            v68 = (v65 | 0x20) - 87;
            if ( (unsigned __int8)(*v64 - 48) < 0xAu )
              v68 = v67;
            v63 = v68 + v66;
            ++v64;
            --v55;
          }
          while ( v55 );
        }
        v88[0] = 0;
        if ( !v63 )
        {
          v53 = 25;
          v80 = 0;
          v6 = v78;
          v9 = v81;
          v47 = 0;
          break;
        }
        v46 = v63;
        ++v45;
        v6 = v78;
        v9 = v81;
        v47 = 0;
LABEL_128:
        v69 = v76 - v45;
        v80 = v46;
        if ( v46 <= (int)(v76 - v45) )
          v69 = v46;
        v79 = v69 + v75;
        if ( v69 + v75 <= v84 )
          goto LABEL_98;
        if ( v6 < (int)(v69 + v75) )
          v6 = v69 + v75;
        v70 = v82;
        v84 = v6;
        v71 = realloc(v82, v6);
        if ( v71 )
        {
          v54 = 1;
          v82 = v71;
        }
        else
        {
          free(v70);
          free(ptr);
          *size = -1;
          v54 = 0;
        }
        v9 = v81;
        if ( v54 )
        {
LABEL_98:
          memcpy((char *)v82 + v75, &src[v45], v69);
          v45 += v69;
          v46 = v80 - v69;
          v6 = v78;
          if ( v45 < (int)v76 )
            continue;
          v80 -= v69;
          v53 = 0;
          v75 = v79;
        }
        else
        {
          v53 = 1;
          v6 = v78;
        }
        break;
      }
LABEL_136:
      v8 = nptr;
    }
    if ( !v53 )
    {
      v85 = v47;
      v79 = v75;
      v5 = (char *)v82;
LABEL_142:
      v7 = v80;
      if ( v6 > 0 && v79 >= v6 )
        goto end_of_stream;
      continue;
    }
    break;
  }
  v22 = v53 == 25;
  v79 = v75;
  v5 = (char *)v82;
  result = 0;
  if ( !v22 )
    return result;
end_of_stream:
  free(ptr);
  v73 = v79;
  *size = v79;
  if ( v73 )
    return v5;
  free(v5);
  return 0;
}
