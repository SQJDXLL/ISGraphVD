void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int v3; // ecx
  char *v4; // eax
  char *v5; // esi
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  char v9; // dl
  char v10; // dl
  char *v11; // ebp
  int v12; // edx
  int v13; // ebx
  int v14; // esi
  int v15; // ecx
  char v16; // al
  char *v17; // edi
  int v18; // esi
  size_t v19; // eax
  char *v20; // edx
  char *v21; // ebx
  size_t v22; // edi
  bool v23; // zf
  size_t v24; // ebp
  unsigned int v25; // edi
  unsigned int v26; // eax
  char *v27; // eax
  bool v28; // si
  _DWORD *v29; // esi
  char v31; // al
  const char *v32; // edx
  int *v33; // ebp
  const char *v34; // esi
  const char *v35; // edi
  int v36; // ecx
  const unsigned __int16 *v37; // ebp
  unsigned int v38; // eax
  unsigned int v39; // edi
  char *v40; // ebx
  int v41; // ecx
  char v42; // bl
  char v43; // bl
  char *v44; // ebx
  int v45; // edx
  char *v46; // edi
  int v47; // eax
  int v48; // edx
  int v49; // eax
  size_t v50; // edx
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  char v55; // dl
  int v56; // edi
  int *v57; // esi
  int *v58; // esi
  unsigned int content_buf_used; // [esp+0h] [ebp-8A0h]
  unsigned int chunksize; // [esp+4h] [ebp-89Ch]
  char *content_buf; // [esp+10h] [ebp-890h]
  int header_buf_used_0; // [esp+18h] [ebp-888h]
  signed int header_buf_used_0a; // [esp+18h] [ebp-888h]
  unsigned int content_buf_len; // [esp+1Ch] [ebp-884h]
  unsigned int content_length; // [esp+20h] [ebp-880h]
  unsigned int chunksize_buf_index; // [esp+24h] [ebp-87Ch]
  int chunksize_buf_indexa; // [esp+24h] [ebp-87Ch]
  int n; // [esp+28h] [ebp-878h]
  char *header_buf; // [esp+2Ch] [ebp-874h]
  int valuestart; // [esp+30h] [ebp-870h]
  int endofheaders; // [esp+34h] [ebp-86Ch]
  int chunked; // [esp+38h] [ebp-868h]
  unsigned int header_buf_len; // [esp+3Ch] [ebp-864h]
  size_t v74; // [esp+40h] [ebp-860h]
  int i; // [esp+44h] [ebp-85Ch]
  char *s1; // [esp+48h] [ebp-858h]
  int *v77; // [esp+4Ch] [ebp-854h]
  int *v78; // [esp+50h] [ebp-850h]
  char chunksize_buf[32]; // [esp+60h] [ebp-840h] BYREF
  char buf[2048]; // [esp+80h] [ebp-820h] BYREF
  unsigned int v82; // [esp+880h] [ebp-20h]

  v77 = status_code;
  v82 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    *size = -1;
    return 0;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return 0;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  v78 = size;
  while ( 1 )
  {
    v3 = receivedata(s, buf, 2048, 5000, 0);
    if ( v3 <= 0 )
      goto end_of_stream;
    if ( endofheaders )
      break;
    header_buf_used_0 = v3 + valuestart;
    if ( header_buf_len < v3 + valuestart )
    {
      n = v3;
      v4 = (char *)realloc(header_buf, v3 + valuestart);
      v3 = n;
      if ( !v4 )
      {
        v58 = v78;
        free(header_buf);
        free(content_buf);
        *v58 = -1;
        return 0;
      }
      header_buf = v4;
      header_buf_len = header_buf_used_0;
    }
    v5 = header_buf;
    memcpy(&header_buf[valuestart], buf, v3);
    v6 = header_buf_used_0 - 1;
    if ( header_buf_used_0 <= 1 )
    {
      valuestart = header_buf_used_0;
      continue;
    }
    v7 = 0;
    do
    {
      v10 = v5[v7];
      if ( v10 == 13 )
      {
        if ( v5[v7 + 1] == 10 )
        {
          if ( v7 + 2 < header_buf_used_0 && v5[v7 + 2] == 13 )
          {
            if ( v7 + 3 < header_buf_used_0 && v5[v7 + 3] == 10 )
            {
              v23 = v7 == -4;
              v7 += 4;
              v9 = v23;
              v8 = v7;
            }
            else
            {
              v7 += 4;
              v8 = 0;
              v9 = 1;
            }
          }
          else
          {
            v7 += 3;
            v8 = 0;
            v9 = 1;
          }
LABEL_15:
          if ( v6 <= v7 )
            break;
          continue;
        }
      }
      else
      {
        if ( v10 != 10 )
        {
          ++v7;
          v8 = 0;
          v9 = 1;
          goto LABEL_15;
        }
        if ( v5[v7 + 1] == 10 )
        {
          v23 = v7 == -2;
          v7 += 2;
          v9 = v23;
          v8 = v7;
          goto LABEL_15;
        }
      }
      v7 += 2;
      v8 = 0;
      v9 = 1;
      if ( v6 <= v7 )
        break;
    }
    while ( v9 );
    if ( !v8 )
    {
      endofheaders = 0;
      valuestart = header_buf_used_0;
      continue;
    }
    if ( v8 - 1 <= 0 )
      goto LABEL_31;
    valuestart = 0;
    v11 = header_buf;
    v12 = 0;
    v13 = 0;
    endofheaders = v8;
    v14 = 0;
    n = v8 - 1;
    v15 = header_buf_used_0;
    while ( 2 )
    {
      v16 = v11[v14];
      v17 = (char *)(v14 + 1);
      if ( v13 <= 0 || v12 > v13 )
      {
        if ( v16 != 13 && v16 != 10 )
          goto LABEL_28;
        if ( !v13 && v77 )
        {
          if ( v14 <= 0 )
            goto LABEL_70;
          v32 = v11 + 1;
          v74 = (size_t)v11;
          v33 = v77;
          i = v14;
          s1 = (char *)(v14 + 1);
          v34 = &v32[v14];
          v35 = v32;
          valuestart = v15;
          while ( 1 )
          {
            if ( *(v35 - 1) == 32 )
            {
              if ( *v33 >= 0 )
              {
LABEL_65:
                v15 = valuestart;
                v11 = (char *)v74;
                v14 = i;
                v17 = s1;
                goto LABEL_66;
              }
              *v33 = strtol(v35, 0, 10);
            }
            if ( v34 == ++v35 )
              goto LABEL_65;
          }
        }
        if ( v12 <= v13 || v12 >= valuestart )
          goto LABEL_66;
        i = v15;
        s1 = &v11[v13];
        v74 = v12 - v13;
        v49 = strncasecmp(&v11[v13], "content-length", v12 - v13);
        v50 = v74;
        v74 = i;
        if ( !v49 )
        {
          content_length = strtol(&v11[valuestart], 0, 10);
          v15 = v74;
          goto LABEL_66;
        }
        v51 = strncasecmp(s1, "transfer-encoding", v50);
        v15 = v74;
        if ( v51 )
        {
LABEL_66:
          if ( v14 < v15 )
            goto LABEL_70;
        }
        else
        {
          v52 = strncasecmp(&v11[valuestart], "chunked", 7u);
          v15 = v74;
          v23 = v52 == 0;
          v53 = 1;
          if ( !v23 )
            v53 = chunked;
          chunked = v53;
          if ( v14 < (int)v74 )
          {
            while ( 1 )
            {
LABEL_70:
              v31 = v11[v14];
              v13 = v14;
              v14 = (int)v17;
              if ( v31 != 13 && v31 != 10 )
              {
                valuestart = 0;
                v12 = v13;
                goto LABEL_29;
              }
              if ( (char *)v15 == v17 )
                break;
              ++v17;
            }
            v14 = v13 + 2;
            valuestart = 0;
            v12 = v15;
            v13 = v15;
            goto LABEL_29;
          }
        }
        valuestart = 0;
        v12 = v14;
        v13 = v14;
        goto LABEL_28;
      }
      if ( v16 == 58 )
      {
        v54 = v14;
        if ( v14 >= n )
        {
          v56 = v14;
        }
        else
        {
          valuestart = v15;
          do
          {
            v55 = v11[v54 + 1];
            v56 = v54++;
            if ( v55 != 32 && v55 != 9 )
            {
              v15 = valuestart;
              goto LABEL_136;
            }
          }
          while ( n != v54 );
          v15 = valuestart;
          v56 = n;
        }
LABEL_136:
        v12 = v14;
        valuestart = v56 + 1;
        v14 = v56 + 1;
      }
      else
      {
        if ( v16 == 10 || v16 == 13 )
          goto LABEL_66;
LABEL_28:
        v14 = (int)v17;
      }
LABEL_29:
      if ( n > v14 )
        continue;
      break;
    }
    v8 = endofheaders;
LABEL_31:
    memcpy(buf, &header_buf[v8], header_buf_used_0 - v8);
    v3 = header_buf_used_0 - v8;
    valuestart = header_buf_used_0;
    endofheaders = v8;
    if ( !chunked )
      goto LABEL_49;
    if ( header_buf_used_0 - v8 > 0 )
      goto LABEL_33;
    v28 = content_buf_used >= content_length;
LABEL_58:
    if ( (int)content_length > 0 && v28 )
      goto end_of_stream;
  }
  if ( !chunked )
  {
LABEL_49:
    v24 = v3;
    v25 = content_buf_used + v3;
    if ( (int)content_length <= 0 )
    {
      if ( content_buf_len < v25 )
      {
        content_buf_len = content_buf_used + v3;
        if ( !content_length )
        {
          v26 = content_buf_used + v3;
          goto LABEL_54;
        }
        goto LABEL_55;
      }
      v28 = v25 >= content_length;
    }
    else
    {
      v26 = content_length;
      if ( content_length < v25 )
      {
        v25 = content_length;
        v28 = 1;
        v24 = content_length - content_buf_used;
        if ( content_buf_len < content_length )
          goto LABEL_54;
      }
      else if ( content_buf_len >= v25 )
      {
        v28 = content_length == v25;
      }
      else
      {
        if ( content_length < v25 )
          v26 = content_buf_used + v3;
LABEL_54:
        content_buf_len = v26;
LABEL_55:
        v27 = (char *)realloc(content_buf, content_buf_len);
        if ( !v27 )
          goto LABEL_152;
        content_buf = v27;
        v28 = v25 >= content_length;
      }
    }
    memcpy(&content_buf[content_buf_used], buf, v24);
    content_buf_used = v25;
    chunked = 0;
    goto LABEL_58;
  }
LABEL_33:
  header_buf_used_0a = v3;
  v18 = 0;
  while ( 2 )
  {
    if ( !chunksize )
    {
      v36 = header_buf_used_0a;
      if ( chunksize_buf_index )
        goto LABEL_101;
LABEL_84:
      if ( buf[v18] == 13 )
        ++v18;
      if ( v18 >= v36 )
      {
        chunksize = 0;
        v38 = 0;
LABEL_114:
        chunksize_buf_index = v38;
        v28 = content_buf_used >= content_length;
        goto LABEL_58;
      }
      if ( buf[v18] != 10 || (++v18, v18 < v36) )
      {
        do
        {
          n = v36;
          v37 = *_ctype_b_loc();
          v38 = chunksize_buf_index;
          chunksize_buf_indexa = n;
          v39 = n + v38 - v18;
          v40 = &buf[v18 - v38];
          do
          {
            v41 = v40[v38];
            if ( (v37[v41] & 0x1000) == 0 )
              break;
            if ( v38 > 0x1E )
              break;
            ++v38;
            ++v18;
            chunksize_buf[v38 - 1] = v41;
            chunksize_buf[v38] = 0;
          }
          while ( v38 != v39 );
          v36 = chunksize_buf_indexa;
          if ( v18 >= chunksize_buf_indexa )
            goto LABEL_103;
          while ( 1 )
          {
            v42 = buf[v18];
            if ( v42 == 13 || v42 == 10 )
              break;
            if ( ++v18 == chunksize_buf_indexa )
              goto LABEL_114;
          }
          if ( chunksize_buf_indexa <= v18 )
            goto LABEL_114;
          v43 = buf[v18];
          if ( v43 == 13 )
          {
            if ( ++v18 >= chunksize_buf_indexa )
              goto LABEL_114;
            if ( buf[v18] == 10 )
            {
LABEL_106:
              if ( !v38 )
                goto end_of_stream;
              v44 = chunksize_buf;
              v45 = 0;
              v46 = &chunksize_buf[v38];
              do
              {
                while ( 1 )
                {
                  v47 = *v44;
                  v48 = 16 * v45;
                  if ( (unsigned __int8)(v47 - 48) > 9u )
                    break;
                  ++v44;
                  v45 = v48 + v47 - 48;
                  if ( v46 == v44 )
                    goto LABEL_111;
                }
                ++v44;
                v45 = v48 + (char)(v47 | 0x20) - 87;
              }
              while ( v46 != v44 );
LABEL_111:
              chunksize_buf[0] = 0;
              ++v18;
              if ( !v45 )
              {
end_of_stream:
                v29 = v78;
                free(header_buf);
                *v29 = content_buf_used;
                if ( content_buf_used )
                  return content_buf;
                free(content_buf);
                return 0;
              }
              chunksize_buf_index = 0;
              chunksize = v45;
              goto LABEL_42;
            }
          }
          else if ( v43 == 10 )
          {
            goto LABEL_106;
          }
          chunksize_buf_index = v38;
          if ( !v38 )
            goto LABEL_84;
LABEL_101:
          ;
        }
        while ( v18 < v36 );
      }
      v38 = chunksize_buf_index;
LABEL_103:
      chunksize_buf_index = v38;
LABEL_40:
      if ( v18 >= header_buf_used_0a )
      {
        v38 = chunksize_buf_index;
        goto LABEL_114;
      }
      continue;
    }
    break;
  }
LABEL_42:
  v22 = header_buf_used_0a - v18;
  if ( header_buf_used_0a - v18 > chunksize )
    v22 = chunksize;
  if ( content_buf_len >= content_buf_used + v22 )
  {
    v20 = content_buf;
    goto LABEL_39;
  }
  v19 = content_length;
  if ( content_length < content_buf_used + v22 )
    v19 = content_buf_used + v22;
  if ( (content_length & 0x80000000) != 0 )
    v19 = content_buf_used + v22;
  content_buf_len = v19;
  v20 = (char *)realloc(content_buf, v19);
  if ( v20 )
  {
LABEL_39:
    content_buf = v20;
    v21 = &buf[v18];
    v18 += v22;
    memcpy(&v20[content_buf_used], v21, v22);
    chunksize -= v22;
    content_buf_used += v22;
    goto LABEL_40;
  }
LABEL_152:
  v57 = v78;
  free(content_buf);
  free(header_buf);
  *v57 = -1;
  return 0;
}
