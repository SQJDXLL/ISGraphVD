void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v4; // r0
  void *v5; // r4
  unsigned int v6; // r8
  unsigned int v7; // r11
  unsigned int v8; // r10
  char *v9; // r9
  int v10; // r0
  signed int v11; // r5
  unsigned int v12; // r3
  void *v13; // r0
  signed int v14; // r0
  signed int v15; // r6
  int v16; // r2
  signed int v17; // r1
  signed int v18; // r2
  size_t v19; // r4
  unsigned int v20; // r5
  bool v21; // cf
  unsigned int v22; // r3
  char *v23; // r0
  _BOOL4 v24; // r3
  int v26; // r4
  unsigned int v27; // r11
  int *v28; // r10
  int v29; // r2
  int v30; // r1
  int v31; // r5
  signed int v32; // r8
  int v33; // r9
  int v34; // r4
  bool v35; // zf
  bool v36; // cc
  int v37; // r0
  const char *v38; // r7
  int v39; // r6
  bool v40; // zf
  _BOOL4 v41; // r0
  const char *v42; // r4
  int v43; // t1
  unsigned int v44; // r2
  int v45; // r4
  int v46; // t1
  bool v47; // zf
  unsigned int v48; // r6
  size_t v49; // r2
  signed int v50; // r4
  size_t v51; // r2
  unsigned int v52; // r7
  unsigned int v53; // r3
  char *v54; // r0
  const void *v55; // r1
  int v56; // r3
  const unsigned __int16 *v57; // lr
  int v58; // r0
  _BYTE *v59; // r1
  int v60; // r3
  int v61; // t1
  int v62; // r2
  int v63; // t1
  bool v64; // zf
  unsigned __int8 *v65; // r3
  unsigned __int8 *v66; // r8
  int v67; // r2
  int v68; // t1
  int v69; // r10
  int v70; // r10
  int v71; // r3
  int v72; // t1
  int v73; // r2
  bool v74; // zf
  _BOOL4 v75; // r0
  const char *v76; // r7
  int v77; // r0
  char *v78; // r3
  int v79; // [sp+0h] [bp-8A8h] BYREF
  unsigned int bytestocopy; // [sp+Ch] [bp-89Ch]
  int content_length; // [sp+10h] [bp-898h]
  char *header_buf; // [sp+14h] [bp-894h]
  unsigned int v83; // [sp+18h] [bp-890h]
  unsigned int content_buf_used; // [sp+1Ch] [bp-88Ch]
  unsigned int chunksize_buf_index; // [sp+20h] [bp-888h]
  unsigned int header_buf_used_0; // [sp+24h] [bp-884h]
  unsigned int header_buf_len; // [sp+28h] [bp-880h]
  unsigned int chunksize; // [sp+2Ch] [bp-87Ch]
  char *content_buf; // [sp+30h] [bp-878h]
  unsigned int v90; // [sp+34h] [bp-874h]
  char *v91; // [sp+38h] [bp-870h]
  int *status_codea; // [sp+3Ch] [bp-86Ch]
  char *s2; // [sp+40h] [bp-868h]
  int *sizea; // [sp+44h] [bp-864h]
  size_t v95; // [sp+48h] [bp-860h]
  int *v96; // [sp+4Ch] [bp-85Ch]
  char chunksize_buf[32]; // [sp+54h] [bp-854h] BYREF
  char buf[2048]; // [sp+74h] [bp-834h] BYREF

  sizea = status_code;
  v96 = size;
  if ( status_code )
    *status_code = -1;
  content_buf_used = (unsigned int)malloc(0x800u);
  if ( !content_buf_used )
  {
    v5 = 0;
    *v96 = -1;
    return v5;
  }
  v4 = (char *)malloc(0x800u);
  v5 = v4;
  if ( !v4 )
  {
    free((void *)content_buf_used);
    *v96 = -1;
    return v5;
  }
  v6 = 0;
  chunksize_buf[0] = 0;
  bytestocopy = 2048;
  content_buf = (_BYTE *)&loc_800;
  v83 = -1;
  content_length = (int)buf;
  v7 = 0;
  v8 = 0;
  v9 = v4;
  header_buf_used_0 = 0;
  header_buf = 0;
  header_buf_len = 0;
  chunksize_buf_index = (unsigned int)chunksize_buf;
  do
  {
    while ( 1 )
    {
      v10 = receivedata(s, content_length, 2048, 5000, 0);
      v11 = v10;
      if ( v10 <= 0 )
        goto end_of_stream;
      if ( header_buf_len )
      {
        if ( !header_buf )
        {
          v19 = v10;
          goto LABEL_27;
        }
        goto LABEL_90;
      }
      v12 = v10 + header_buf_used_0;
      if ( v10 + header_buf_used_0 > (unsigned int)content_buf )
      {
        chunksize = v10 + header_buf_used_0;
        v13 = realloc((void *)content_buf_used, v10 + header_buf_used_0);
        v12 = chunksize;
        if ( !v13 )
        {
          free((void *)content_buf_used);
          free(v9);
          v5 = (void *)header_buf_len;
          *v96 = -1;
          return v5;
        }
        content_buf_used = (unsigned int)v13;
        content_buf = (char *)chunksize;
      }
      chunksize = v12;
      memcpy((void *)(content_buf_used + header_buf_used_0), (const void *)content_length, v11);
      v14 = chunksize - 1;
      if ( (int)(chunksize - 1) > 0 )
        break;
LABEL_23:
      header_buf_used_0 = chunksize;
    }
    v15 = 0;
    while ( 1 )
    {
LABEL_14:
      v16 = *(unsigned __int8 *)(content_buf_used + v15);
      v17 = v15 + 1;
      if ( v16 != 13 )
      {
LABEL_15:
        if ( v16 == 10 )
        {
          v15 += 2;
          if ( *(_BYTE *)(content_buf_used + v17) == 10 )
            break;
          goto LABEL_22;
        }
        goto LABEL_16;
      }
      while ( 1 )
      {
        v18 = v15 + 2;
        if ( *(_BYTE *)(content_buf_used + v17) != 10 )
        {
          if ( v14 <= v18 )
            goto LABEL_23;
          v15 += 2;
          goto LABEL_14;
        }
        v17 = v15 + 3;
        if ( (int)chunksize > v18 && *(_BYTE *)(content_buf_used + v18) == 13 )
          break;
LABEL_16:
        if ( v14 <= v17 )
          goto LABEL_23;
        v15 = v17;
        v16 = *(unsigned __int8 *)(content_buf_used + v17++);
        if ( v16 != 13 )
          goto LABEL_15;
      }
      v15 += 4;
      if ( (int)chunksize > v17 && *(_BYTE *)(content_buf_used + v17) == 10 )
        break;
LABEL_22:
      if ( v14 <= v15 )
        goto LABEL_23;
    }
    v26 = 0;
    status_codea = (int *)"transfer-encoding";
    s2 = "chunked";
    header_buf_used_0 = v7;
    header_buf_len = v6;
    v90 = v8;
    v91 = v9;
    v27 = content_buf_used;
    v28 = sizea;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = chunksize;
    v33 = v15 - 1;
    chunksize = v15;
    while ( 1 )
    {
LABEL_57:
      v36 = v30 <= v29;
      if ( v30 >= v29 )
        v36 = v30 <= 0;
      v37 = *(unsigned __int8 *)(v27 + v31);
      v38 = (const char *)(v27 + v31);
      v39 = v31 + 1;
      if ( v36 )
        break;
      if ( v37 == 58 )
      {
        v34 = v31;
        do
        {
          v72 = *(unsigned __int8 *)++v38;
          v71 = v72;
          v73 = v34;
          v74 = v72 == 9;
          if ( v72 != 9 )
            v74 = v71 == 32;
          ++v34;
          if ( !v74 )
          {
            v26 = v73 + 1;
            v29 = v31;
            v31 = v26;
            goto LABEL_56;
          }
        }
        while ( v33 > v34 );
        v26 = v34 + 1;
        v29 = v31;
        v31 = v26;
        goto LABEL_56;
      }
      v35 = v37 == 10;
      if ( v37 != 10 )
        v35 = v37 == 13;
      if ( v35 )
        goto LABEL_74;
LABEL_55:
      ++v31;
LABEL_56:
      if ( v33 <= v31 )
        goto LABEL_85;
    }
    v40 = v37 == 10;
    if ( v37 != 10 )
      v40 = v37 == 13;
    if ( !v40 )
      goto LABEL_55;
    v41 = v30 == 0;
    if ( !v28 )
      v41 = 0;
    if ( v41 )
    {
      if ( v31 > 0 )
      {
        v42 = (const char *)v27;
        do
        {
          while ( 1 )
          {
            v43 = *(unsigned __int8 *)v42++;
            if ( v43 == 32 )
              break;
            if ( v38 == v42 )
              goto LABEL_74;
          }
          if ( *v28 >= 0 )
            break;
          *v28 = strtol(v42, 0u, 10);
        }
        while ( v38 != v42 );
      }
      goto LABEL_74;
    }
    v75 = v30 < v29;
    if ( v26 <= v29 )
      v75 = 0;
    if ( !v75 )
      goto LABEL_74;
    v76 = (const char *)(v27 + v30);
    v95 = v29 - v30;
    if ( !strncasecmp((const char *)(v27 + v30), "content-length", v29 - v30) )
    {
      v83 = strtol((const char *)(v27 + v26), 0u, 10);
LABEL_74:
      if ( v31 < v32 )
        goto LABEL_75;
      goto LABEL_154;
    }
    if ( strncasecmp(v76, (const char *)status_codea, v95) )
      goto LABEL_74;
    v77 = strncasecmp((const char *)(v27 + v26), s2, 7u);
    v78 = header_buf;
    if ( !v77 )
      v78 = (_BYTE *)(getHTTPResponse + 1);
    header_buf = v78;
    if ( v31 >= v32 )
    {
LABEL_154:
      v29 = v31;
      v30 = v31;
      v26 = 0;
      ++v31;
      goto LABEL_56;
    }
LABEL_75:
    v44 = v27 + v31 - 1;
    while ( 1 )
    {
      v46 = *(unsigned __int8 *)++v44;
      v45 = v46;
      v30 = v31;
      v47 = v46 == 10;
      if ( v46 != 10 )
        v47 = v45 == 13;
      v26 = v47;
      v31 = v39;
      if ( !v47 )
        break;
      if ( v32 == v39 )
      {
        v31 = v30 + 2;
        v26 = 0;
        v29 = v32;
        v30 = v32;
        goto LABEL_56;
      }
      ++v39;
    }
    v29 = v30;
    if ( v33 > v39 )
      goto LABEL_57;
LABEL_85:
    v48 = chunksize;
    v11 = v32 - chunksize;
    v7 = header_buf_used_0;
    header_buf_used_0 = v32;
    v49 = v32 - chunksize;
    v6 = header_buf_len;
    v8 = v90;
    v9 = v91;
    memcpy((void *)content_length, (const void *)(content_buf_used + chunksize), v49);
    v19 = v11;
    if ( !header_buf )
    {
      header_buf_len = v48;
LABEL_27:
      v20 = v7 + v11;
      if ( (int)v83 <= 0 )
      {
        if ( bytestocopy < v20 )
        {
          if ( !v83 )
            goto LABEL_33;
          bytestocopy = v20;
LABEL_36:
          v23 = (char *)realloc(v9, bytestocopy);
          if ( !v23 )
          {
            free(v9);
            free((void *)content_buf_used);
            v5 = 0;
            *v96 = -1;
            return v5;
          }
          v9 = v23;
        }
      }
      else
      {
        v21 = v83 >= v20;
        if ( v83 < v20 )
          v20 = v83;
        if ( !v21 )
          v19 = v20 - v7;
        if ( bytestocopy < v20 )
        {
LABEL_33:
          v22 = v83;
          if ( v20 >= v83 )
            v22 = v20;
          bytestocopy = v22;
          goto LABEL_36;
        }
      }
      memcpy(&v9[v7], (const void *)content_length, v19);
      v7 = v20;
      header_buf = 0;
      goto LABEL_39;
    }
    if ( v11 <= 0 )
    {
      header_buf_len = v48;
      goto LABEL_39;
    }
    header_buf_len = v48;
LABEL_90:
    v50 = 0;
    while ( 2 )
    {
      if ( !v8 )
      {
        if ( v6 )
        {
LABEL_107:
          if ( v50 >= v11 )
            goto LABEL_140;
        }
        else
        {
          v56 = *((unsigned __int8 *)&v79 + v50 + 116);
          if ( v56 != 13 )
          {
            if ( v56 != 10 )
              goto LABEL_107;
LABEL_156:
            ++v50;
            goto LABEL_107;
          }
          if ( ++v50 >= v11 )
            goto LABEL_140;
          if ( *((_BYTE *)&v79 + v50 + 116) == 10 )
            goto LABEL_156;
        }
        v57 = *_ctype_b_loc();
        v58 = content_length + v50 - 1;
        v59 = (_BYTE *)(chunksize_buf_index + v6);
        while ( 1 )
        {
          v61 = *(unsigned __int8 *)++v58;
          v60 = v61;
          if ( ((v6 <= 0x1E) & (v57[v61] >> 0xC)) == 0 )
            break;
          ++v50;
          *v59 = v60;
          ++v6;
          *++v59 = 0;
          if ( v50 >= v11 )
            goto LABEL_140;
        }
        if ( v50 >= v11 )
          goto LABEL_140;
        v62 = content_length + v50;
        while ( 1 )
        {
          v64 = v60 == 10;
          if ( v60 != 10 )
            v64 = v60 == 13;
          if ( v64 )
            break;
          if ( ++v50 == v11 )
            goto LABEL_140;
          v63 = *(unsigned __int8 *)++v62;
          v60 = v63;
        }
        if ( v50 >= v11 )
        {
LABEL_140:
          header_buf = (_BYTE *)(getHTTPResponse + 1);
          goto LABEL_39;
        }
        if ( v60 == 13 )
        {
          if ( ++v50 >= v11 )
            goto LABEL_140;
          v60 = *((unsigned __int8 *)&v79 + v50 + 116);
        }
        if ( v60 != 10 )
        {
          v52 = v7;
LABEL_102:
          v7 = v52;
          continue;
        }
        if ( !v6 )
          goto end_of_stream;
        v65 = (unsigned __int8 *)chunksize_buf_index;
        v8 = 0;
        v66 = (unsigned __int8 *)(chunksize_buf_index + v6);
        do
        {
          v68 = *v65++;
          v67 = v68;
          v69 = 16 * v8;
          if ( (unsigned int)(v68 - 0x30) > 9 )
          {
            v67 |= 0x20u;
            v70 = v69 - 0x57;
          }
          else
          {
            v70 = v69 - 0x30;
          }
          v8 = v67 + v70;
        }
        while ( v66 != v65 );
        ++v50;
        chunksize_buf[0] = 0;
        if ( !v8 )
          goto end_of_stream;
        v6 = 0;
      }
      break;
    }
    v51 = v11 - v50;
    if ( v11 - v50 >= v8 )
      v51 = v8;
    v52 = v51 + v7;
    if ( v51 + v7 > bytestocopy )
    {
      v53 = v83;
      if ( (v83 & 0x80000000) == 0 )
      {
        if ( v83 < v52 )
          v53 = v51 + v7;
        bytestocopy = v53;
      }
      else
      {
        bytestocopy = v51 + v7;
      }
      header_buf = (char *)v51;
      v54 = (char *)realloc(v9, bytestocopy);
      v51 = (size_t)header_buf;
      if ( !v54 )
      {
        bytestocopy = 0;
        free(v9);
        free((void *)content_buf_used);
        v5 = (void *)bytestocopy;
        *v96 = -1;
        return v5;
      }
      v9 = v54;
    }
    v55 = (const void *)(content_length + v50);
    v50 += v51;
    v8 -= v51;
    memcpy(&v9[v7], v55, v51);
    if ( v50 < v11 )
      goto LABEL_102;
    v7 = v52;
    header_buf = (_BYTE *)(getHTTPResponse + 1);
LABEL_39:
    v24 = (int)v83 > 0;
    if ( v7 < v83 )
      v24 = 0;
  }
  while ( !v24 );
end_of_stream:
  free((void *)content_buf_used);
  v5 = v9;
  *v96 = v7;
  if ( !v7 )
  {
    free(v9);
    return 0;
  }
  return v5;
}
