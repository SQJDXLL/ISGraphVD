void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  int v3; // $v0
  unsigned int v4; // $v0
  size_t v6; // [sp+1Ch] [+1Ch]
  bool v7; // [sp+24h] [+24h]
  bool v8; // [sp+28h] [+28h]
  bool v9; // [sp+2Ch] [+2Ch]
  bool v10; // [sp+30h] [+30h]
  bool v11; // [sp+34h] [+34h]
  bool v12; // [sp+38h] [+38h]
  bool v13; // [sp+3Ch] [+3Ch]
  void *v14; // [sp+44h] [+44h]
  void *v15; // [sp+48h] [+48h]
  unsigned int m; // [sp+4Ch] [+4Ch]
  signed int v17; // [sp+50h] [+50h]
  int k; // [sp+54h] [+54h]
  void *v19; // [sp+58h] [+58h]
  int v20; // [sp+5Ch] [+5Ch]
  int v21; // [sp+60h] [+60h]
  int v22; // [sp+64h] [+64h]
  int i; // [sp+68h] [+68h]
  int j; // [sp+68h] [+68h]
  unsigned int v25; // [sp+6Ch] [+6Ch]
  char v26[32]; // [sp+70h] [+70h]
  unsigned int v27; // [sp+90h] [+90h]
  size_t v28; // [sp+94h] [+94h]
  void *v29; // [sp+98h] [+98h]
  int v30; // [sp+9Ch] [+9Ch]
  size_t sizea; // [sp+A0h] [+A0h]
  void *ptr; // [sp+A4h] [+A4h]
  size_t v33; // [sp+A8h] [+A8h]
  unsigned int v34; // [sp+ACh] [+ACh]
  int v35; // [sp+B0h] [+B0h]
  int v36; // [sp+B4h] [+B4h]
  int v37; // [sp+B8h] [+B8h]
  size_t n; // [sp+BCh] [+BCh]
  char v39[2048]; // [sp+C0h] [+C0h] BYREF
  int *v40; // [sp+8C0h] [+8C0h]
  int *v41; // [sp+8C4h] [+8C4h]
  int v42; // [sp+8C8h] [+8C8h]

  v42 = s;
  v41 = size;
  v40 = status_code;
  v37 = 0;
  v36 = 0;
  v35 = -1;
  v34 = 0;
  v33 = 0;
  sizea = 2048;
  v30 = 0;
  v28 = 2048;
  v27 = 0;
  if ( status_code )
    *v40 = -1;
  ptr = malloc(sizea);
  if ( !ptr )
  {
    *v41 = -1;
    return 0;
  }
  v29 = malloc(v28);
  if ( !v29 )
  {
    free(ptr);
    *v41 = -1;
    return 0;
  }
  v26[0] = 0;
  v25 = 0;
  while ( 1 )
  {
    n = receivedata(v42, v39, 2048, 5000);
    if ( (int)n <= 0 )
      break;
    if ( v37 )
      goto LABEL_72;
    v22 = 0;
    v21 = 0;
    v20 = 0;
    if ( sizea < v30 + n )
    {
      v19 = realloc(ptr, v30 + n);
      if ( !v19 )
      {
        free(ptr);
        free(v29);
        *v41 = -1;
        return 0;
      }
      ptr = v19;
      sizea = v30 + n;
    }
    memcpy((char *)ptr + v30, v39, n);
    v30 += n;
    for ( i = 0; ; ++i )
    {
      v13 = 0;
      if ( i < v30 - 1 )
        v13 = v37 == 0;
      if ( !v13 )
        break;
      if ( *((_BYTE *)ptr + i) == 13 )
      {
        ++i;
        if ( *((_BYTE *)ptr + i) == 10
          && ++i < v30
          && *((_BYTE *)ptr + i) == 13
          && ++i < v30
          && *((_BYTE *)ptr + i) == 10 )
        {
          v37 = i + 1;
        }
      }
      else if ( *((_BYTE *)ptr + i) == 10 )
      {
        ++i;
        if ( *((_BYTE *)ptr + i) == 10 )
          v37 = i + 1;
      }
    }
    if ( v37 )
    {
      for ( j = 0; j < v37 - 1; ++j )
      {
        if ( v22 > 0 && v22 >= v21 && *((_BYTE *)ptr + j) == 58 )
        {
          v21 = j;
          while ( 1 )
          {
            v12 = 0;
            if ( j < v37 - 1 )
            {
              v11 = 1;
              if ( *((_BYTE *)ptr + j + 1) != 32 )
                v11 = *((_BYTE *)ptr + j + 1) == 9;
              v12 = v11;
            }
            if ( !v12 )
              break;
            ++j;
          }
          v20 = j + 1;
        }
        else if ( *((_BYTE *)ptr + j) == 13 || *((_BYTE *)ptr + j) == 10 )
        {
          if ( v22 || !v40 )
          {
            if ( v22 < v21 && v21 < v20 )
            {
              if ( !strncasecmp((const char *)ptr + v22, "content-length", v21 - v22) )
              {
                v35 = atoi((const char *)ptr + v20);
              }
              else if ( !strncasecmp((const char *)ptr + v22, "transfer-encoding", v21 - v22)
                     && !strncasecmp((const char *)ptr + v20, "chunked", 7u) )
              {
                v36 = 1;
              }
            }
          }
          else
          {
            for ( k = 0; k < j; ++k )
            {
              if ( *((_BYTE *)ptr + k) == 32 )
              {
                if ( *v40 >= 0 )
                  goto LABEL_63;
                v3 = atoi((const char *)ptr + k + 1);
                *v40 = v3;
              }
            }
          }
          while ( 1 )
          {
LABEL_63:
            v10 = 0;
            if ( j < v30 )
            {
              v9 = 1;
              if ( *((_BYTE *)ptr + j) != 13 )
                v9 = *((_BYTE *)ptr + j) == 0xA;
              v10 = v9;
            }
            if ( !v10 )
              break;
            ++j;
          }
          v22 = j;
          v21 = j;
          v20 = 0;
        }
      }
      n = v30 - v37;
      memcpy(v39, (char *)ptr + v37, v30 - v37);
LABEL_72:
      if ( v37 )
      {
        if ( v36 )
        {
          v17 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( v17 >= (int)n )
                goto LABEL_133;
              if ( !v34 )
                break;
LABEL_109:
              if ( v34 >= n - v17 )
                v6 = n - v17;
              else
                v6 = v34;
              v33 = v6;
              if ( v28 < v27 + v6 )
              {
                if ( v35 < 0 || v35 < v27 + v33 )
                  v28 = v27 + v33;
                else
                  v28 = v35;
                v15 = realloc(v29, v28);
                if ( !v15 )
                  goto LABEL_118;
                v29 = v15;
              }
              memcpy((char *)v29 + v27, &v39[v17], v33);
              v27 += v33;
              v17 += v33;
              v34 -= v33;
            }
            if ( !v25 )
            {
              if ( v17 < (int)n && v39[v17] == 13 )
                ++v17;
              if ( v17 < (int)n && v39[v17] == 10 )
                ++v17;
            }
            while ( 1 )
            {
              v8 = 0;
              if ( v17 < (int)n )
              {
                v8 = 0;
                if ( ((*_ctype_b_loc())[v39[v17]] & 0x1000) != 0 )
                  v8 = v25 < 0x1F;
              }
              if ( !v8 )
                break;
              v4 = v25++;
              v26[v4] = v39[v17];
              v26[v25] = 0;
              ++v17;
            }
            while ( 1 )
            {
              v7 = 0;
              if ( v17 < (int)n )
              {
                v7 = 0;
                if ( v39[v17] != 13 )
                  v7 = v39[v17] != 0xA;
              }
              if ( !v7 )
                break;
              ++v17;
            }
            if ( v17 < (int)n && v39[v17] == 13 )
              ++v17;
            if ( v17 < (int)n && v39[v17] == 10 )
            {
              for ( m = 0; m < v25; ++m )
              {
                if ( v26[m] < 48 || v26[m] >= 58 )
                  v34 = (v26[m] | 0x20) + 16 * v34 - 87;
                else
                  v34 = v26[m] + 16 * v34 - 48;
              }
              v26[0] = 0;
              v25 = 0;
              ++v17;
              if ( !v34 )
                goto end_of_stream;
              goto LABEL_109;
            }
          }
        }
        if ( v35 > 0 && v35 < v27 + n )
          n = v35 - v27;
        if ( v28 < v27 + n )
        {
          if ( v35 < 0 || v35 < v27 + n )
            v28 = v27 + n;
          else
            v28 = v35;
          v14 = realloc(v29, v28);
          if ( !v14 )
          {
LABEL_118:
            free(v29);
            free(ptr);
            *v41 = -1;
            return 0;
          }
          v29 = v14;
        }
        memcpy((char *)v29 + v27, v39, n);
        v27 += n;
      }
LABEL_133:
      if ( v35 > 0 && v27 >= v35 )
        break;
    }
  }
end_of_stream:
  free(ptr);
  ptr = 0;
  *v41 = v27;
  if ( !v27 )
  {
    free(v29);
    return 0;
  }
  return v29;
}
