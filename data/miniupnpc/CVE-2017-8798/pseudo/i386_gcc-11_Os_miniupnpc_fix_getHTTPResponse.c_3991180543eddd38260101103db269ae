void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // eax
  char *v4; // ecx
  int v5; // esi
  int v6; // eax
  char *v7; // eax
  unsigned int v8; // eax
  char *v9; // edx
  int v10; // edx
  char v11; // cl
  int v12; // eax
  int v13; // edi
  int v14; // ecx
  int v15; // eax
  int j; // esi
  char v17; // dl
  int v18; // edi
  int v19; // edx
  char v20; // cl
  const char *k; // edi
  size_t v22; // esi
  bool v23; // zf
  int v24; // eax
  char v25; // al
  int v26; // edx
  const unsigned __int16 **v27; // eax
  char v28; // al
  int m; // ecx
  int v30; // edi
  int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // eax
  char *v34; // eax
  char *v35; // esi
  unsigned int v36; // ecx
  int v38; // [esp+0h] [ebp-894h]
  unsigned int header_buf_len; // [esp+Ch] [ebp-888h]
  int chunked; // [esp+10h] [ebp-884h]
  unsigned int content_buf_used_0; // [esp+14h] [ebp-880h]
  unsigned int bytestocopy; // [esp+18h] [ebp-87Ch]
  char bytestocopya; // [esp+18h] [ebp-87Ch]
  unsigned int bytestocopyb; // [esp+18h] [ebp-87Ch]
  unsigned int header_buf_used; // [esp+1Ch] [ebp-878h]
  const char *header_buf_useda; // [esp+1Ch] [ebp-878h]
  unsigned int chunksize_buf_index; // [esp+28h] [ebp-86Ch]
  int endofheaders; // [esp+2Ch] [ebp-868h]
  signed int header_buf_used_0; // [esp+30h] [ebp-864h]
  unsigned int header_buf_used_0a; // [esp+30h] [ebp-864h]
  unsigned int header_buf_used_0b; // [esp+30h] [ebp-864h]
  char header_buf_used_0c; // [esp+30h] [ebp-864h]
  unsigned int content_buf_used; // [esp+34h] [ebp-860h]
  unsigned int content_buf_len; // [esp+38h] [ebp-85Ch]
  int content_length; // [esp+3Ch] [ebp-858h]
  int i; // [esp+40h] [ebp-854h]
  int ia; // [esp+40h] [ebp-854h]
  char *content_buf; // [esp+44h] [ebp-850h]
  char *ptr; // [esp+48h] [ebp-84Ch]
  char chunksize_buf[32]; // [esp+58h] [ebp-83Ch]
  char buf[2048]; // [esp+78h] [ebp-81Ch] BYREF
  unsigned int v63; // [esp+878h] [ebp-1Ch]

  v63 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    *size = -1;
    return content_buf;
  }
  v3 = (char *)malloc(0x800u);
  if ( !v3 )
    goto LABEL_17;
  v4 = content_buf;
  content_buf = v3;
  v5 = 0;
  chunksize_buf[0] = 0;
  ptr = v4;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  header_buf_used = 0;
  header_buf_len = 2048;
  bytestocopy = 0;
  content_length = -1;
  chunked = 0;
  while ( 2 )
  {
    i = receivedata(s, buf, 2048, 5000, 0);
    if ( i <= 0 )
      break;
    if ( v5 )
    {
      endofheaders = v5;
      goto LABEL_77;
    }
    header_buf_used_0 = header_buf_used + i;
    if ( header_buf_used + i > header_buf_len )
    {
      v7 = (char *)realloc(ptr, header_buf_used + i);
      if ( !v7 )
      {
        free(ptr);
LABEL_17:
        free(content_buf);
LABEL_26:
        *size = -1;
        return 0;
      }
      ptr = v7;
      header_buf_len = header_buf_used + i;
    }
    endofheaders = 0;
    v6 = 0;
    qmemcpy(&ptr[header_buf_used], buf, i);
    while ( header_buf_used_0 - 1 > v6 )
    {
      if ( endofheaders )
        goto LABEL_41;
      v10 = v6 + 1;
      v11 = ptr[v6];
      if ( v11 == 13 )
      {
        if ( ptr[v6 + 1] == 10 )
        {
          v10 = v6 + 2;
          if ( header_buf_used_0 > v6 + 2 && ptr[v6 + 2] == 13 )
          {
            v10 = v6 + 3;
            if ( header_buf_used_0 > v6 + 3 && ptr[v6 + 3] == 10 )
            {
              v12 = v6 + 4;
LABEL_38:
              endofheaders = v12;
            }
          }
        }
      }
      else
      {
        if ( v11 == 10 )
        {
          if ( ptr[v10] != 10 )
            goto LABEL_40;
          v12 = v6 + 2;
          goto LABEL_38;
        }
        v10 = v6;
      }
LABEL_40:
      v6 = v10 + 1;
    }
    header_buf_used += i;
    if ( !endofheaders )
      goto LABEL_11;
LABEL_41:
    v13 = 0;
    v14 = 0;
    v15 = 0;
    for ( j = 0; endofheaders - 1 > j; ++j )
    {
      ia = j;
      v17 = ptr[j];
      if ( v15 > 0 && v15 >= v14 && v17 == 58 )
      {
        v18 = j;
        while ( 1 )
        {
          v19 = v18;
          v20 = ptr[++v18];
          if ( v20 != 32 && v20 != 9 )
            break;
          if ( endofheaders - 1 <= v18 )
          {
            v19 = v18;
            break;
          }
        }
        v14 = j;
        v13 = v19 + 1;
        j = v19;
      }
      else if ( v17 == 13 || v17 == 10 )
      {
        if ( v15 || !status_code )
        {
          if ( v15 < v14 && v14 < v13 )
          {
            v22 = v14 - v15;
            header_buf_useda = &ptr[v15];
            if ( !strncasecmp(&ptr[v15], "content-length", v14 - v15) )
            {
              content_length = atoi(&ptr[v13]);
            }
            else if ( !strncasecmp(header_buf_useda, "transfer-encoding", v22) )
            {
              v23 = strncasecmp(&ptr[v13], "chunked", 7u) == 0;
              v24 = 1;
              if ( !v23 )
                v24 = chunked;
              chunked = v24;
            }
          }
        }
        else
        {
          for ( k = ptr + 1; k - ptr - 1 < j; ++k )
          {
            if ( *(k - 1) == 32 )
            {
              if ( *status_code >= 0 )
                goto LABEL_70;
              *status_code = atoi(k);
            }
          }
        }
        do
        {
LABEL_70:
          j = ia;
          if ( header_buf_used_0 <= ia )
            break;
          ++ia;
          v25 = ptr[j];
        }
        while ( v25 == 13 || v25 == 10 );
        v13 = 0;
        v14 = j;
        v15 = j;
      }
    }
    i = header_buf_used_0 - endofheaders;
    qmemcpy(buf, &ptr[endofheaders], header_buf_used_0 - endofheaders);
    header_buf_used = header_buf_used_0;
LABEL_77:
    if ( !chunked )
    {
      if ( content_length > 0 && content_length < content_buf_used + i )
        i = content_length - content_buf_used;
      v8 = content_buf_used + i;
      if ( content_buf_used + i <= content_buf_len )
      {
        v9 = content_buf;
      }
      else
      {
        content_buf_len = content_buf_used + i;
        if ( content_length >= 0 )
        {
          if ( content_length >= v8 )
            v8 = content_length;
          content_buf_len = v8;
        }
        v9 = (char *)realloc(content_buf, content_buf_len);
        if ( !v9 )
        {
LABEL_25:
          free(content_buf);
          free(ptr);
          goto LABEL_26;
        }
      }
      content_buf = v9;
      qmemcpy(&v9[content_buf_used], buf, i);
      content_buf_used += i;
      goto LABEL_120;
    }
    v26 = 0;
LABEL_79:
    while ( i > v26 )
    {
      header_buf_used_0a = bytestocopy;
      if ( !bytestocopy )
      {
        if ( chunksize_buf_index )
          goto LABEL_86;
        if ( buf[v26] != 13 || (++v26, i > v26) )
        {
          if ( buf[v26] == 10 )
            ++v26;
LABEL_86:
          while ( 1 )
          {
            header_buf_used_0b = v26;
            if ( i <= v26 )
              break;
            v27 = _ctype_b_loc();
            v26 = header_buf_used_0b;
            header_buf_used_0c = buf[header_buf_used_0b];
            if ( ((*v27)[header_buf_used_0c] & 0x1000) == 0 || chunksize_buf_index > 0x1E )
            {
              while ( i > v26 )
              {
                v28 = buf[v26];
                if ( v28 == 10 || v28 == 13 )
                {
                  if ( buf[v26] == 13 && i <= ++v26 )
                    goto LABEL_120;
                  if ( buf[v26] != 10 )
                    goto LABEL_79;
                  header_buf_used_0a = 0;
                  for ( m = 0; chunksize_buf_index != m; ++m )
                  {
                    bytestocopya = chunksize_buf[m];
                    v30 = 16 * header_buf_used_0a;
                    if ( (unsigned __int8)(bytestocopya - 48) > 9u )
                      v31 = v30 + (bytestocopya | 0x20) - 87;
                    else
                      v31 = v30 + bytestocopya - 48;
                    header_buf_used_0a = v31;
                  }
                  ++v26;
                  chunksize_buf[0] = 0;
                  if ( header_buf_used_0a )
                  {
                    chunksize_buf_index = 0;
                    goto LABEL_106;
                  }
                  goto end_of_stream;
                }
                ++v26;
              }
              goto LABEL_120;
            }
            ++chunksize_buf_index;
            ++v26;
            chunksize_buf[chunksize_buf_index - 1] = header_buf_used_0c;
            chunksize_buf[chunksize_buf_index] = 0;
          }
        }
        break;
      }
LABEL_106:
      v32 = i - v26;
      if ( i - v26 > header_buf_used_0a )
        v32 = header_buf_used_0a;
      bytestocopyb = v32;
      v33 = v32 + content_buf_used;
      content_buf_used_0 = v33;
      if ( v33 > content_buf_len )
      {
        content_buf_len = v33;
        if ( content_length >= 0 )
        {
          if ( content_length >= v33 )
            v33 = content_length;
          content_buf_len = v33;
        }
        v38 = v26;
        v34 = (char *)realloc(content_buf, content_buf_len);
        v26 = v38;
        if ( !v34 )
          goto LABEL_25;
        content_buf = v34;
      }
      v35 = &buf[v26];
      v36 = bytestocopyb;
      v26 += bytestocopyb;
      bytestocopy = header_buf_used_0a - bytestocopyb;
      qmemcpy(&content_buf[content_buf_used], v35, v36);
      content_buf_used = content_buf_used_0;
    }
LABEL_120:
    if ( content_length <= 0 || content_length > content_buf_used )
    {
LABEL_11:
      v5 = endofheaders;
      continue;
    }
    break;
  }
end_of_stream:
  free(ptr);
  *size = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
