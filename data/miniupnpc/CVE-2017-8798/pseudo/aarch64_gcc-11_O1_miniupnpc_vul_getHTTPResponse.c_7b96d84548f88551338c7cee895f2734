void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x23
  unsigned int v4; // w20
  unsigned int v5; // w27
  int v6; // w25
  int v7; // w28
  int v8; // w0
  int v9; // w22
  bool v10; // cc
  int v11; // w1
  int v12; // w4
  int v13; // w1
  int v14; // w21
  int v15; // w3
  __int64 v16; // x0
  int i; // w19
  int v18; // w2
  int v19; // w3
  bool v20; // zf
  char *v21; // x1
  int v22; // w1
  int v25; // w2
  int v27; // w1
  bool v29; // zf
  int v31; // w0
  const char *j; // x21
  int v33; // w21
  int v34; // w19
  const unsigned __int16 *v35; // x3
  char *v36; // x0
  unsigned int v38; // w2
  char *v39; // x1
  int v40; // w0
  int v42; // w26
  char *v43; // x1
  int v44; // w0
  int v45; // w2
  unsigned int v46; // w22
  int v47; // w0
  size_t v48; // x1
  char *v49; // x22
  unsigned int v51; // w19
  int v53; // w26
  char *v54; // x0
  char *tmp; // [xsp+60h] [xbp+60h]
  int v56; // [xsp+68h] [xbp+68h]
  unsigned int content_buf_len; // [xsp+74h] [xbp+74h]
  char *s1; // [xsp+78h] [xbp+78h]
  char *s1a; // [xsp+78h] [xbp+78h]
  unsigned int header_buf_used; // [xsp+80h] [xbp+80h]
  int endofheaders; // [xsp+90h] [xbp+90h]
  unsigned int header_buf_len; // [xsp+98h] [xbp+98h]
  int chunked; // [xsp+9Ch] [xbp+9Ch]
  size_t v66; // [xsp+A8h] [xbp+A8h]
  char chunksize_buf[32]; // [xsp+C8h] [xbp+C8h] BYREF
  char buf[2048]; // [xsp+E8h] [xbp+E8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
  {
    *size = -1;
    return 0LL;
  }
  tmp = (char *)malloc(0x800uLL);
  if ( !tmp )
  {
    free(v3);
    *size = -1;
    return tmp;
  }
  chunksize_buf[0] = 0;
  v4 = 0;
  v5 = 0;
  content_buf_len = 2048;
  header_buf_used = 0;
  header_buf_len = 2048;
  v6 = 0;
  v7 = -1;
  chunked = 0;
  endofheaders = 0;
  do
  {
    while ( 1 )
    {
      v33 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
      if ( v33 <= 0 )
        goto end_of_stream;
      if ( endofheaders )
        break;
      v53 = v33 + header_buf_used;
      if ( v33 + header_buf_used > header_buf_len )
      {
        v54 = (char *)realloc(v3, (unsigned int)v53);
        if ( !v54 )
        {
          free(v3);
          free(tmp);
          *size = -1;
          return 0LL;
        }
        header_buf_len = v33 + header_buf_used;
        v3 = v54;
      }
      memcpy(&v3[header_buf_used], buf, v33);
      if ( v53 - 1 <= 0 )
      {
        header_buf_used += v33;
      }
      else
      {
        v8 = 0;
        do
        {
          v11 = (unsigned __int8)v3[v8];
          if ( v11 == 13 )
          {
            if ( v3[v8 + 1] == 10 )
            {
              if ( v8 + 2 >= v53 )
              {
                v8 += 2;
                v9 = endofheaders;
              }
              else if ( v3[v8 + 2] == 13 )
              {
                v13 = v8 + 3;
                if ( v8 + 3 >= v53 )
                {
                  v8 += 3;
                  v9 = endofheaders;
                }
                else
                {
                  v9 = v8 + 4;
                  v8 += 3;
                  if ( v3[v13] != 10 )
                    v9 = endofheaders;
                }
              }
              else
              {
                v8 += 2;
                v9 = endofheaders;
              }
            }
            else
            {
              ++v8;
              v9 = endofheaders;
            }
          }
          else
          {
            v9 = endofheaders;
            if ( v11 == 10 )
            {
              v12 = (unsigned __int8)v3[v8 + 1];
              v9 = v8 + 2;
              ++v8;
              if ( v12 != 10 )
                v9 = endofheaders;
            }
          }
          ++v8;
          if ( v9 )
            v10 = 0;
          else
            v10 = v8 < v53 - 1;
        }
        while ( v10 );
        if ( v9 )
        {
          v56 = v9 - 1;
          if ( v9 - 1 > 0 )
          {
            v14 = 0;
            v15 = 0;
            LODWORD(v16) = 0;
            for ( i = 0; i < v56; ++i )
            {
              if ( (int)v16 <= 0 || (int)v16 < v15 )
              {
                v22 = (unsigned __int8)v3[i];
                if ( v22 == 13 || v22 == 10 )
                {
                  if ( (_DWORD)v16 )
                    v29 = 1;
                  else
                    v29 = status_code == 0LL;
                  if ( v29 )
                  {
                    if ( (int)v16 < v15 && v15 < v14 )
                    {
                      s1 = &v3[(int)v16];
                      v66 = v15 - (int)v16;
                      if ( !strncasecmp(s1, "content-length", v66) )
                      {
                        v7 = strtol(&v3[v14], 0uLL, 10);
                      }
                      else if ( !strncasecmp(s1, "transfer-encoding", v66) )
                      {
                        v20 = strncasecmp(&v3[v14], "chunked", 7uLL) == 0;
                        v31 = chunked;
                        if ( v20 )
                          v31 = 1;
                        chunked = v31;
                      }
                    }
                  }
                  else if ( i > 0 )
                  {
                    for ( j = v3 + 1; j != &v3[i - 1 + 2]; ++j )
                    {
                      if ( *(j - 1) == 32 )
                      {
                        if ( (*status_code & 0x80000000) == 0 )
                          break;
                        *status_code = strtol(j, 0uLL, 10);
                      }
                    }
                  }
LABEL_58:
                  if ( v53 <= i )
                  {
                    v14 = 0;
                    v15 = i;
                    LODWORD(v16) = i;
                  }
                  else
                  {
                    v16 = i;
                    do
                    {
                      i = v16;
                      v27 = (unsigned __int8)v3[v16];
                      if ( v27 != 13 && v27 != 10 )
                      {
                        v14 = 0;
                        v15 = v16;
                        goto LABEL_47;
                      }
                      i = ++v16;
                    }
                    while ( v53 > (int)v16 );
                    v14 = 0;
                    v15 = i;
                    LODWORD(v16) = i;
                  }
                }
              }
              else
              {
                v21 = &v3[i];
                v25 = (unsigned __int8)*v21;
                if ( v25 == 58 )
                {
                  if ( v56 <= i )
                  {
                    v18 = i;
                  }
                  else
                  {
                    v18 = i;
                    while ( 1 )
                    {
                      v19 = (unsigned __int8)v21[1];
                      v20 = v19 == 32 || v19 == 9;
                      if ( !v20 )
                        break;
                      ++v18;
                      ++v21;
                      if ( v18 == v9 - 1 )
                      {
                        v18 = v9 - 1;
                        break;
                      }
                    }
                  }
                  v14 = v18 + 1;
                  v15 = i;
                  i = v18;
                  continue;
                }
                if ( v25 == 13 || v25 == 10 )
                  goto LABEL_58;
              }
LABEL_47:
              ;
            }
          }
          v33 = v53 - v9;
          memcpy(buf, &v3[v9], v53 - v9);
          header_buf_used = v53;
          endofheaders = v9;
          if ( !chunked )
            goto LABEL_158;
          if ( v33 <= 0 )
          {
            header_buf_used = v53;
            endofheaders = v9;
            goto LABEL_165;
          }
          goto LABEL_95;
        }
        header_buf_used += v33;
        endofheaders = 0;
      }
    }
    if ( !chunked )
    {
LABEL_158:
      if ( v7 > 0 )
      {
        v51 = v33 + v5;
        if ( (int)(v33 + v5) <= v7 )
        {
          v49 = tmp;
          if ( v51 <= content_buf_len )
            goto LABEL_164;
          goto LABEL_156;
        }
        v33 = v7 - v5;
      }
      v51 = v33 + v5;
      if ( v33 + v5 <= content_buf_len )
      {
        v49 = tmp;
        goto LABEL_164;
      }
      content_buf_len = v33 + v5;
      if ( (int)v51 > v7 )
      {
LABEL_163:
        v49 = (char *)realloc(tmp, content_buf_len);
        if ( !v49 )
        {
LABEL_131:
          free(tmp);
          free(v3);
          *size = -1;
          return 0LL;
        }
LABEL_164:
        memcpy(&v49[v5], buf, v33);
        v5 = v51;
        tmp = v49;
        continue;
      }
LABEL_156:
      content_buf_len = v7;
      goto LABEL_163;
    }
LABEL_95:
    v34 = 0;
    while ( 1 )
    {
      if ( v6 )
        goto LABEL_135;
      if ( v4 )
        goto LABEL_102;
      if ( buf[v34] == 13 )
        ++v34;
      if ( v34 >= v33 )
        break;
      if ( buf[v34] == 10 )
      {
        ++v34;
LABEL_102:
        if ( v34 >= v33 )
        {
          v38 = v4;
          goto LABEL_154;
        }
      }
      v35 = *_ctype_b_loc();
      v36 = &buf[v34];
      while ( (v35[(unsigned __int8)*v36] & 0x1000) != 0 && v4 <= 0x1E )
      {
        v38 = v4 + 1;
        chunksize_buf[v4] = *v36;
        chunksize_buf[v4 + 1] = 0;
        ++v34;
        ++v36;
        if ( v34 >= v33 )
          goto LABEL_154;
        ++v4;
      }
      if ( v33 <= v34 )
        goto LABEL_165;
      v39 = &buf[v34];
      while ( 1 )
      {
        v40 = (unsigned __int8)*v39;
        if ( v40 == 10 || v40 == 13 )
          break;
        ++v34;
        ++v39;
        if ( v34 == v33 )
          goto LABEL_165;
      }
      if ( v33 <= v34 )
        goto LABEL_165;
      if ( buf[v34] == 13 && ++v34 >= v33 )
        goto LABEL_165;
      v42 = v5;
      if ( buf[v34] != 10 )
        goto LABEL_133;
      if ( !v4 )
        goto end_of_stream;
      v43 = chunksize_buf;
      v44 = 0;
      do
      {
        v45 = (unsigned __int8)*v43;
        if ( (unsigned __int8)(v45 - 0x30) > 9u )
          v44 = (v45 | 0x20) + 16 * v44 - 0x57;
        else
          v44 = v45 + 16 * v44 - 0x30;
        ++v43;
      }
      while ( v43 != &chunksize_buf[v4] );
      chunksize_buf[0] = 0;
      ++v34;
      if ( !v44 )
        goto end_of_stream;
      v4 = 0;
      v6 = v44;
LABEL_135:
      v46 = v33 - v34;
      if ( v33 - v34 > v6 )
        v46 = v6;
      v42 = v46 + v5;
      if ( v46 + v5 > content_buf_len )
      {
        if ( v42 <= v7 )
          v47 = v7;
        else
          v47 = v46 + v5;
        content_buf_len = v47;
        if ( v42 <= v7 )
          v48 = (unsigned int)v7;
        else
          v48 = (unsigned int)v42;
        s1a = (char *)realloc(tmp, v48);
        if ( !s1a )
          goto LABEL_131;
        tmp = s1a;
      }
      memcpy(&tmp[v5], &buf[v34], v46);
      v34 += v46;
      v6 -= v46;
      if ( v34 >= v33 )
      {
        v5 += v46;
        goto LABEL_165;
      }
LABEL_133:
      v5 = v42;
    }
    v38 = 0;
LABEL_154:
    v4 = v38;
LABEL_165:
    ;
  }
  while ( v7 <= 0 || (int)v5 < v7 );
end_of_stream:
  free(v3);
  *size = v5;
  if ( !v5 )
  {
    free(tmp);
    return 0LL;
  }
  return tmp;
}
