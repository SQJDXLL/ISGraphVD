void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int v4; // $v0
  unsigned int v5; // $v1
  int v6; // $v0
  _BYTE v7[16]; // [sp+0h] [+0h] BYREF
  int v8; // [sp+10h] [+10h]
  int *status_codea; // [sp+20h] [+20h]
  int *sizea; // [sp+24h] [+24h]
  int n; // [sp+28h] [+28h]
  int endofheaders; // [sp+2Ch] [+2Ch]
  int chunked; // [sp+30h] [+30h]
  int content_length; // [sp+34h] [+34h]
  unsigned int chunksize; // [sp+38h] [+38h]
  char *header_buf; // [sp+3Ch] [+3Ch]
  unsigned int header_buf_len; // [sp+40h] [+40h]
  unsigned int header_buf_used; // [sp+44h] [+44h]
  char *content_buf; // [sp+48h] [+48h]
  unsigned int content_buf_len; // [sp+4Ch] [+4Ch]
  unsigned int content_buf_used; // [sp+50h] [+50h]
  unsigned int chunksize_buf_index; // [sp+54h] [+54h]
  int i; // [sp+58h] [+58h]
  int linestart; // [sp+5Ch] [+5Ch]
  int colon; // [sp+60h] [+60h]
  int valuestart; // [sp+64h] [+64h]
  int sp_0; // [sp+68h] [+68h]
  int i_0; // [sp+6Ch] [+6Ch]
  unsigned int j; // [sp+70h] [+70h]
  unsigned int bytestocopy; // [sp+74h] [+74h]
  char *tmp; // [sp+78h] [+78h]
  char *tmp_1; // [sp+7Ch] [+7Ch]
  char *tmp_0; // [sp+80h] [+80h]
  char chunksize_buf[32]; // [sp+84h] [+84h]
  char buf[2048]; // [sp+A4h] [+A4h] BYREF

  sizea = size;
  status_codea = status_code;
  endofheaders = 0;
  chunked = 0;
  content_length = -1;
  chunksize = 0;
  bytestocopy = 0;
  header_buf_len = 2048;
  header_buf_used = 0;
  content_buf_len = 2048;
  content_buf_used = 0;
  if ( status_code )
    *status_codea = -1;
  header_buf = (char *)malloc(header_buf_len);
  if ( !header_buf )
  {
    *sizea = -1;
    return 0;
  }
  content_buf = (char *)malloc(content_buf_len);
  if ( !content_buf )
  {
    free(header_buf);
    *sizea = -1;
    return 0;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  while ( 1 )
  {
    v8 = 0;
    n = receivedata(s, buf, 2048, 5000);
    if ( n <= 0 )
      break;
    if ( endofheaders )
      goto LABEL_65;
    linestart = 0;
    colon = 0;
    valuestart = 0;
    if ( header_buf_len < n + header_buf_used )
    {
      tmp = (char *)realloc(header_buf, n + header_buf_used);
      if ( !tmp )
      {
        free(header_buf);
        free(content_buf);
        *sizea = -1;
        return 0;
      }
      header_buf = tmp;
      header_buf_len = header_buf_used + n;
    }
    memcpy(&header_buf[header_buf_used], buf, n);
    header_buf_used += n;
    for ( i = 0; i < (int)(header_buf_used - 1) && !endofheaders; ++i )
    {
      if ( header_buf[i] == 13 )
      {
        if ( header_buf[++i] == 10
          && ++i < (int)header_buf_used
          && header_buf[i] == 13
          && ++i < (int)header_buf_used
          && header_buf[i] == 10 )
        {
          endofheaders = i + 1;
        }
      }
      else if ( header_buf[i] == 10 && header_buf[++i] == 10 )
      {
        endofheaders = i + 1;
      }
    }
    if ( endofheaders )
    {
      for ( i = 0; i < endofheaders - 1; ++i )
      {
        if ( linestart > 0 && linestart >= colon && header_buf[i] == 58 )
        {
          colon = i;
          while ( i < endofheaders - 1 && (header_buf[i + 1] == 32 || header_buf[i + 1] == 9) )
            ++i;
          valuestart = i + 1;
        }
        else if ( header_buf[i] == 13 || header_buf[i] == 10 )
        {
          if ( linestart || !status_codea )
          {
            if ( linestart < colon && colon < valuestart )
            {
              if ( strncasecmp(&header_buf[linestart], "content-length", colon - linestart) )
              {
                if ( !strncasecmp(&header_buf[linestart], "transfer-encoding", colon - linestart)
                  && !strncasecmp(&header_buf[valuestart], "chunked", 7u) )
                {
                  chunked = 1;
                }
              }
              else
              {
                content_length = atoi(&header_buf[valuestart]);
              }
            }
          }
          else
          {
            for ( sp_0 = 0; sp_0 < i; ++sp_0 )
            {
              if ( header_buf[sp_0] == 32 )
              {
                if ( *status_codea >= 0 )
                  break;
                v4 = atoi(&header_buf[sp_0 + 1]);
                *status_codea = v4;
              }
            }
          }
          while ( i < (int)header_buf_used && (header_buf[i] == 13 || header_buf[i] == 10) )
            ++i;
          linestart = i;
          colon = i;
          valuestart = 0;
        }
      }
      n = header_buf_used - endofheaders;
      memcpy(buf, &header_buf[endofheaders], header_buf_used - endofheaders);
LABEL_65:
      if ( endofheaders )
      {
        if ( chunked )
        {
          i_0 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( i_0 >= n )
                goto LABEL_122;
              if ( !chunksize )
                break;
LABEL_98:
              v6 = n - i_0;
              if ( n - i_0 >= chunksize )
                v6 = chunksize;
              bytestocopy = v6;
              if ( content_buf_len < content_buf_used + v6 )
              {
                if ( content_length < 0 || content_length < content_buf_used + bytestocopy )
                  content_buf_len = content_buf_used + bytestocopy;
                else
                  content_buf_len = content_length;
                tmp_0 = (char *)realloc(content_buf, content_buf_len);
                if ( !tmp_0 )
                  goto LABEL_106;
                content_buf = tmp_0;
              }
              memcpy(&content_buf[content_buf_used], &buf[i_0], bytestocopy);
              content_buf_used += bytestocopy;
              i_0 += bytestocopy;
              chunksize -= bytestocopy;
            }
            if ( !chunksize_buf_index )
            {
              if ( i_0 < n && v7[i_0 + 164] == 13 )
                ++i_0;
              if ( i_0 < n && v7[i_0 + 164] == 10 )
                ++i_0;
            }
            while ( i_0 < n && ((*_ctype_b_loc())[(char)v7[i_0 + 164]] & 0x10) != 0 && chunksize_buf_index < 0x1F )
            {
              v5 = chunksize_buf_index++;
              v7[v5 + 132] = v7[i_0 + 164];
              v7[chunksize_buf_index + 132] = 0;
              ++i_0;
            }
            while ( i_0 < n && v7[i_0 + 164] != 13 && v7[i_0 + 164] != 10 )
              ++i_0;
            if ( i_0 < n && v7[i_0 + 164] == 13 )
              ++i_0;
            if ( i_0 < n && v7[i_0 + 164] == 10 )
            {
              for ( j = 0; j < chunksize_buf_index; ++j )
              {
                if ( (char)v7[j + 132] < 48 || (char)v7[j + 132] >= 58 )
                  chunksize = 16 * chunksize + (char)(v7[j + 132] | 0x20) - 87;
                else
                  chunksize = 16 * chunksize + (char)v7[j + 132] - 48;
              }
              chunksize_buf[0] = 0;
              chunksize_buf_index = 0;
              ++i_0;
              if ( !chunksize )
                goto end_of_stream;
              goto LABEL_98;
            }
          }
        }
        if ( content_length > 0 && content_length < n + content_buf_used )
          n = content_length - content_buf_used;
        if ( content_buf_len < n + content_buf_used )
        {
          if ( content_length < 0 || content_length < n + content_buf_used )
            content_buf_len = content_buf_used + n;
          else
            content_buf_len = content_length;
          tmp_1 = (char *)realloc(content_buf, content_buf_len);
          if ( !tmp_1 )
          {
LABEL_106:
            free(content_buf);
            free(header_buf);
            *sizea = -1;
            return 0;
          }
          content_buf = tmp_1;
        }
        memcpy(&content_buf[content_buf_used], buf, n);
        content_buf_used += n;
      }
LABEL_122:
      if ( content_length > 0 && content_buf_used >= content_length )
        break;
    }
  }
end_of_stream:
  free(header_buf);
  header_buf = 0;
  *sizea = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
