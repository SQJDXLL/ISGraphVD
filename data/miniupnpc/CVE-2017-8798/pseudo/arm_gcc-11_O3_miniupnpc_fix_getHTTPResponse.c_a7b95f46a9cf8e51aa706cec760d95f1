void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // r0
  void *v4; // r4
  unsigned int v5; // r11
  unsigned int v6; // r9
  unsigned int v7; // r8
  char *v8; // r10
  int v9; // r0
  signed int v10; // r6
  void *v11; // r0
  char *v12; // r3
  char *v13; // r2
  char *i; // r5
  int v15; // r3
  int v16; // r6
  int v17; // r3
  size_t v18; // r4
  unsigned int v19; // r6
  bool v20; // cf
  int v21; // r3
  size_t v22; // r1
  char *v23; // r0
  _BOOL4 v24; // r3
  int v26; // r8
  char *v27; // r11
  const char *v28; // r6
  int *v29; // r10
  char *v30; // r2
  char *v31; // r1
  int v32; // r4
  int v33; // r5
  int v34; // r5
  bool v35; // zf
  bool v36; // cc
  int v37; // r0
  const char *v38; // r9
  char *v39; // r7
  bool v40; // zf
  _BOOL4 v41; // r0
  const char *v42; // r5
  int v43; // t1
  const char *v44; // r2
  int v45; // r5
  int v46; // t1
  bool v47; // zf
  char *v48; // r5
  signed int v49; // r4
  size_t v50; // r2
  unsigned int v51; // r7
  int v52; // r3
  size_t v53; // r1
  char *v54; // r0
  const void *v55; // r1
  int v56; // r3
  const unsigned __int16 *v57; // lr
  int v58; // r0
  _BYTE *v59; // r1
  int v60; // r3
  int v61; // t1
  int v62; // r2
  int v63; // t1
  bool v64; // zf
  unsigned __int8 *v65; // r3
  unsigned __int8 *v66; // r11
  int v67; // r2
  int v68; // t1
  int v69; // r8
  int v70; // r8
  int v71; // r3
  int v72; // t1
  int v73; // r2
  bool v74; // zf
  _BOOL4 v75; // r0
  const char *v76; // r9
  int v77; // r0
  int v78; // r3
  unsigned int content_buf_len[2]; // [sp+0h] [bp-8A8h] BYREF
  unsigned int header_buf_used_0; // [sp+8h] [bp-8A0h]
  int content_length; // [sp+Ch] [bp-89Ch]
  char *header_buf; // [sp+10h] [bp-898h]
  int chunked; // [sp+14h] [bp-894h]
  void *ptr; // [sp+18h] [bp-890h]
  unsigned int content_buf_used; // [sp+1Ch] [bp-88Ch]
  unsigned int chunksize_buf_index; // [sp+20h] [bp-888h]
  int sa; // [sp+24h] [bp-884h]
  unsigned int header_buf_len; // [sp+28h] [bp-880h]
  int v89; // [sp+2Ch] [bp-87Ch]
  unsigned int chunksize; // [sp+30h] [bp-878h]
  char *content_buf; // [sp+34h] [bp-874h]
  unsigned int v92; // [sp+38h] [bp-870h]
  char *v93; // [sp+3Ch] [bp-86Ch]
  int *status_codea; // [sp+40h] [bp-868h]
  char *v95; // [sp+44h] [bp-864h]
  int *v96; // [sp+48h] [bp-860h]
  int *sizea; // [sp+4Ch] [bp-85Ch]
  char *s2; // [sp+50h] [bp-858h]
  int *v99; // [sp+54h] [bp-854h]
  char chunksize_buf[32]; // [sp+5Ch] [bp-84Ch] BYREF
  char buf[2048]; // [sp+7Ch] [bp-82Ch] BYREF

  v89 = s;
  v96 = status_code;
  v99 = size;
  if ( status_code )
    *status_code = -1;
  ptr = malloc(0x800u);
  if ( !ptr )
  {
    v4 = 0;
    *v99 = -1;
    return v4;
  }
  v3 = (char *)malloc(0x800u);
  v4 = v3;
  if ( !v3 )
  {
    free(ptr);
    *v99 = -1;
    return v4;
  }
  v5 = 0;
  chunksize_buf[0] = 0;
  header_buf_used_0 = 2048;
  chunksize = 2048;
  chunked = -1;
  content_length = (int)buf;
  v6 = 0;
  v7 = 0;
  v8 = v3;
  s2 = "content-length";
  sa = 0;
  content_buf_used = 0;
  header_buf_len = 0;
  chunksize_buf_index = (unsigned int)chunksize_buf;
  do
  {
    while ( 1 )
    {
      v9 = receivedata(v89, content_length, 2048, 5000, 0);
      v10 = v9;
      if ( v9 <= 0 )
        goto end_of_stream;
      if ( header_buf_len )
      {
        if ( content_buf_used )
          goto LABEL_89;
        v18 = v9;
LABEL_29:
        v19 = v6 + v10;
        if ( chunked <= 0 )
        {
          if ( header_buf_used_0 >= v19 )
            goto LABEL_40;
          if ( chunked )
          {
            v22 = v19;
            header_buf_used_0 = v19;
LABEL_38:
            v23 = (char *)realloc(v8, v22);
            if ( !v23 )
            {
              free(v8);
              free(ptr);
              v4 = 0;
              *v99 = -1;
              return v4;
            }
            v8 = v23;
LABEL_40:
            memcpy(&v8[v6], (const void *)content_length, v18);
            v6 = v19;
            content_buf_used = 0;
            goto LABEL_41;
          }
        }
        else
        {
          v20 = chunked >= v19;
          if ( chunked < v19 )
            v19 = chunked;
          if ( !v20 )
            v18 = v19 - v6;
          if ( header_buf_used_0 >= v19 )
            goto LABEL_40;
        }
        v21 = chunked;
        if ( v19 >= chunked )
          v21 = v19;
        v22 = v21;
        header_buf_used_0 = v21;
        goto LABEL_38;
      }
      header_buf = (char *)(v9 + sa);
      if ( v9 + sa > chunksize )
      {
        v11 = realloc(ptr, v9 + sa);
        if ( !v11 )
        {
          free(ptr);
          free(v8);
          v4 = (void *)header_buf_len;
          *v99 = -1;
          return v4;
        }
        ptr = v11;
        chunksize = (unsigned int)header_buf;
      }
      memcpy((char *)ptr + sa, (const void *)content_length, v10);
      v12 = header_buf;
      v13 = header_buf + -0x1;
      if ( (int)(header_buf + -0x1) <= 0 )
      {
LABEL_25:
        sa = (int)v12;
        continue;
      }
      for ( i = 0; ; i += 2 )
      {
LABEL_14:
        v15 = (unsigned __int8)i[(_DWORD)ptr];
        v16 = (int)(i + 1);
        if ( v15 != 13 )
        {
LABEL_15:
          if ( v15 != 10 )
          {
            if ( (int)v13 <= v16 )
              goto LABEL_24;
            goto LABEL_17;
          }
          i += 2;
          goto LABEL_22;
        }
LABEL_18:
        v17 = (int)(i + 2);
        if ( *((_BYTE *)ptr + v16) == 10 )
          break;
        if ( (int)v13 <= v17 )
          goto LABEL_24;
      }
      v16 = (int)(i + 3);
      if ( (int)header_buf > v17 && *((_BYTE *)ptr + v17) == 13 )
        break;
      if ( (int)v13 > v16 )
      {
LABEL_17:
        i = (char *)v16;
        v15 = *((unsigned __int8 *)ptr + v16++);
        if ( v15 != 13 )
          goto LABEL_15;
        goto LABEL_18;
      }
      sa = (int)header_buf;
    }
    v12 = header_buf;
    i += 4;
    if ( (int)header_buf <= v16 )
    {
      if ( (int)v13 <= (int)i )
        goto LABEL_25;
      goto LABEL_14;
    }
LABEL_22:
    if ( *((_BYTE *)ptr + v16) != 10 )
    {
      if ( (int)v13 <= (int)i )
      {
LABEL_24:
        v12 = header_buf;
        goto LABEL_25;
      }
      goto LABEL_14;
    }
    status_codea = (int *)"transfer-encoding";
    header_buf_len = v5;
    v95 = "chunked";
    content_buf = i;
    v92 = v7;
    v93 = v8;
    v26 = v16;
    v27 = header_buf;
    v28 = (const char *)ptr;
    v29 = v96;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    sa = v6;
    while ( 1 )
    {
LABEL_59:
      v36 = (int)v31 <= (int)v30;
      if ( (int)v31 >= (int)v30 )
        v36 = (int)v31 <= 0;
      v37 = (unsigned __int8)v28[v32];
      v38 = &v28[v32];
      v39 = (char *)(v32 + 1);
      if ( v36 )
        break;
      if ( v37 == 58 )
      {
        v34 = v32;
        do
        {
          v72 = *(unsigned __int8 *)++v38;
          v71 = v72;
          v73 = v34;
          v74 = v72 == 9;
          if ( v72 != 9 )
            v74 = v71 == 32;
          ++v34;
          if ( !v74 )
          {
            v33 = v73 + 1;
            v30 = (char *)v32;
            v32 = v33;
            goto LABEL_58;
          }
        }
        while ( v26 > v34 );
        v33 = v34 + 1;
        v30 = (char *)v32;
        v32 = v33;
        goto LABEL_58;
      }
      v35 = v37 == 10;
      if ( v37 != 10 )
        v35 = v37 == 13;
      if ( v35 )
        goto LABEL_76;
LABEL_57:
      ++v32;
LABEL_58:
      if ( v26 <= v32 )
        goto LABEL_87;
    }
    v40 = v37 == 10;
    if ( v37 != 10 )
      v40 = v37 == 13;
    if ( !v40 )
      goto LABEL_57;
    v41 = v31 == 0;
    if ( !v29 )
      v41 = 0;
    if ( v41 )
    {
      if ( v32 > 0 )
      {
        v42 = v28;
        do
        {
          while ( 1 )
          {
            v43 = *(unsigned __int8 *)v42++;
            if ( v43 == 32 )
              break;
            if ( v38 == v42 )
              goto LABEL_76;
          }
          if ( *v29 >= 0 )
            break;
          *v29 = strtol(v42, 0u, 10);
        }
        while ( v38 != v42 );
      }
      goto LABEL_76;
    }
    v75 = (int)v31 < (int)v30;
    if ( v33 <= (int)v30 )
      v75 = 0;
    if ( !v75 )
      goto LABEL_76;
    v76 = &v31[(_DWORD)v28];
    sizea = (int *)(v30 - v31);
    if ( !strncasecmp(&v31[(_DWORD)v28], s2, v30 - v31) )
    {
      chunked = strtol(&v28[v33], 0u, 10);
LABEL_76:
      if ( v32 < (int)v27 )
        goto LABEL_77;
      goto LABEL_153;
    }
    if ( strncasecmp(v76, (const char *)status_codea, (size_t)sizea) )
      goto LABEL_76;
    v77 = strncasecmp(&v28[v33], v95, 7u);
    v78 = content_buf_used;
    if ( !v77 )
      v78 = 1;
    content_buf_used = v78;
    if ( v32 >= (int)v27 )
    {
LABEL_153:
      v30 = (char *)v32;
      v31 = (char *)v32;
      v33 = 0;
      ++v32;
      goto LABEL_58;
    }
LABEL_77:
    v44 = &v28[v32 - 1];
    while ( 1 )
    {
      v46 = *(unsigned __int8 *)++v44;
      v45 = v46;
      v31 = (char *)v32;
      v47 = v46 == 10;
      if ( v46 != 10 )
        v47 = v45 == 13;
      v33 = v47;
      v32 = (int)v39;
      if ( !v47 )
        break;
      if ( v27 == v39 )
      {
        v32 = (int)(v31 + 2);
        v33 = 0;
        v30 = v27;
        v31 = v27;
        goto LABEL_58;
      }
      ++v39;
    }
    v30 = v31;
    if ( v26 > (int)v39 )
      goto LABEL_59;
LABEL_87:
    v48 = content_buf;
    v7 = v92;
    v8 = v93;
    v10 = header_buf - content_buf;
    v6 = sa;
    v5 = header_buf_len;
    memcpy((void *)content_length, &content_buf[(_DWORD)ptr], header_buf - content_buf);
    v18 = v10;
    header_buf_len = (unsigned int)v48;
    sa = (int)header_buf;
    if ( !content_buf_used )
      goto LABEL_29;
    if ( v10 <= 0 )
      goto LABEL_41;
LABEL_89:
    v49 = 0;
    while ( 2 )
    {
      if ( !v7 )
      {
        if ( v5 )
        {
LABEL_106:
          if ( v49 >= v10 )
            goto LABEL_139;
        }
        else
        {
          v56 = *((unsigned __int8 *)&content_buf_len[0x1F] + v49);
          if ( v56 != 13 )
          {
            if ( v56 != 10 )
              goto LABEL_106;
LABEL_155:
            ++v49;
            goto LABEL_106;
          }
          if ( ++v49 >= v10 )
            goto LABEL_139;
          if ( *((_BYTE *)&content_buf_len[0x1F] + v49) == 10 )
            goto LABEL_155;
        }
        v57 = *_ctype_b_loc();
        v58 = content_length + v49 - 1;
        v59 = (_BYTE *)(chunksize_buf_index + v5);
        while ( 1 )
        {
          v61 = *(unsigned __int8 *)++v58;
          v60 = v61;
          if ( ((v5 <= 0x1E) & (v57[v61] >> 0xC)) == 0 )
            break;
          ++v49;
          *v59 = v60;
          ++v5;
          *++v59 = 0;
          if ( v49 >= v10 )
            goto LABEL_139;
        }
        if ( v49 >= v10 )
          goto LABEL_139;
        v62 = content_length + v49;
        while ( 1 )
        {
          v64 = v60 == 10;
          if ( v60 != 10 )
            v64 = v60 == 13;
          if ( v64 )
            break;
          if ( ++v49 == v10 )
            goto LABEL_139;
          v63 = *(unsigned __int8 *)++v62;
          v60 = v63;
        }
        if ( v49 >= v10 )
        {
LABEL_139:
          content_buf_used = 1;
          goto LABEL_41;
        }
        if ( v60 == 13 )
        {
          if ( ++v49 >= v10 )
            goto LABEL_139;
          v60 = *((unsigned __int8 *)&content_buf_len[0x1F] + v49);
        }
        if ( v60 != 10 )
        {
          v51 = v6;
LABEL_101:
          v6 = v51;
          continue;
        }
        if ( !v5 )
          goto end_of_stream;
        v65 = (unsigned __int8 *)chunksize_buf_index;
        v7 = 0;
        v66 = (unsigned __int8 *)(chunksize_buf_index + v5);
        do
        {
          v68 = *v65++;
          v67 = v68;
          v69 = 16 * v7;
          if ( (unsigned int)(v68 - 0x30) > 9 )
          {
            v70 = v69 - 0x57;
            v67 |= 0x20u;
          }
          else
          {
            v70 = v69 - 0x30;
          }
          v7 = v70 + v67;
        }
        while ( v65 != v66 );
        ++v49;
        chunksize_buf[0] = 0;
        if ( !v7 )
          goto end_of_stream;
        v5 = 0;
      }
      break;
    }
    v50 = v10 - v49;
    if ( v10 - v49 >= v7 )
      v50 = v7;
    v51 = v50 + v6;
    if ( v50 + v6 > header_buf_used_0 )
    {
      v52 = chunked;
      if ( chunked >= 0 )
      {
        if ( chunked < v51 )
          v52 = v50 + v6;
        v53 = v52;
        header_buf_used_0 = v52;
      }
      else
      {
        v53 = v50 + v6;
        header_buf_used_0 = v50 + v6;
      }
      header_buf = (char *)v50;
      v54 = (char *)realloc(v8, v53);
      v50 = (size_t)header_buf;
      if ( !v54 )
      {
        header_buf_used_0 = 0;
        free(v8);
        free(ptr);
        v4 = (void *)header_buf_used_0;
        *v99 = -1;
        return v4;
      }
      v8 = v54;
    }
    v55 = (const void *)(content_length + v49);
    v49 += v50;
    v7 -= v50;
    memcpy(&v8[v6], v55, v50);
    if ( v49 < v10 )
      goto LABEL_101;
    v6 = v51;
    content_buf_used = 1;
LABEL_41:
    v24 = chunked > 0;
    if ( v6 < chunked )
      v24 = 0;
  }
  while ( !v24 );
end_of_stream:
  free(ptr);
  v4 = v8;
  *v99 = v6;
  if ( !v6 )
  {
    free(v8);
    return 0;
  }
  return v4;
}
