void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  void *v3; // r5
  void *v4; // r0
  void *v5; // r0
  unsigned int v6; // r7
  void *v7; // r6
  char *v8; // r10
  int v9; // r9
  int v10; // r4
  int v11; // r0
  signed int v12; // r8
  signed int v13; // r11
  void *v14; // r0
  int v15; // r3
  int v16; // r4
  char *v17; // r2
  char *v18; // r1
  char *v19; // r3
  signed int v20; // r4
  int v21; // r1
  int v22; // r2
  int v23; // r3
  bool v24; // cc
  int v25; // r12
  char *v26; // r8
  char *v27; // r2
  signed int v28; // r0
  bool v29; // zf
  _BOOL4 v30; // r0
  const char *v31; // r4
  bool v32; // cc
  int v33; // r12
  int v34; // t1
  signed int v35; // lr
  bool v36; // zf
  int v37; // t1
  int v38; // r0
  int v39; // r4
  bool v40; // zf
  int v41; // r0
  int v42; // r3
  unsigned int v43; // r11
  _BYTE *v44; // r11
  const unsigned __int16 **v45; // r0
  int v46; // r1
  int v47; // r3
  bool v48; // zf
  int v49; // r2
  unsigned __int8 *v50; // r1
  _BOOL4 v51; // r3
  int v52; // r3
  int v53; // t1
  int v54; // r11
  int v55; // r11
  char *v56; // r2
  char *v57; // r3
  int *v58; // r1
  void *v59; // r0
  unsigned int v60; // r2
  int *v61; // r3
  void *v62; // r4
  int endofheaders; // [sp+0h] [bp-898h] BYREF
  char *v65; // [sp+8h] [bp-890h]
  int *sizea; // [sp+Ch] [bp-88Ch]
  unsigned int header_buf_used; // [sp+10h] [bp-888h]
  int *status_codea; // [sp+14h] [bp-884h]
  unsigned int chunksize; // [sp+18h] [bp-880h]
  int chunked; // [sp+1Ch] [bp-87Ch]
  unsigned int header_buf_len; // [sp+20h] [bp-878h]
  int v72; // [sp+24h] [bp-874h]
  int sa; // [sp+28h] [bp-870h]
  unsigned int content_buf_used; // [sp+2Ch] [bp-86Ch]
  int v75; // [sp+30h] [bp-868h]
  char *s2; // [sp+34h] [bp-864h]
  char *v77; // [sp+38h] [bp-860h]
  char *v78; // [sp+3Ch] [bp-85Ch]
  char *s1; // [sp+40h] [bp-858h]
  size_t v80; // [sp+44h] [bp-854h]
  char chunksize_buf[32]; // [sp+4Ch] [bp-84Ch] BYREF
  char buf[2048]; // [sp+6Ch] [bp-82Ch] BYREF

  status_codea = size;
  v75 = s;
  chunked = (int)status_code;
  if ( status_code )
    *status_code = -1;
  v3 = malloc(0x800u);
  if ( !v3 )
  {
    *status_codea = -1;
    return v3;
  }
  v4 = malloc(0x800u);
  if ( !v4 )
    goto LABEL_6;
  v6 = 0;
  v7 = v3;
  sizea = (_DWORD *)&loc_800;
  v3 = v4;
  sa = 2048;
  v8 = 0;
  v9 = -1;
  v10 = 0;
  chunksize_buf[0] = 0;
  chunksize = 0;
  header_buf_len = 0;
  v72 = 0;
  content_buf_used = (unsigned int)chunksize_buf;
  while ( 2 )
  {
    header_buf_used = (unsigned int)buf;
    v11 = receivedata(v75, buf, 2048, 5000, 0);
    v12 = v11;
    if ( v11 <= 0 )
      break;
    if ( v10 )
    {
      v65 = (char *)v10;
      goto LABEL_22;
    }
    v13 = v11 + chunksize;
    if ( v11 + chunksize > sa )
    {
      v14 = realloc(v7, v11 + chunksize);
      if ( !v14 )
      {
        free(v7);
LABEL_6:
        v5 = v3;
LABEL_7:
        free(v5);
        v3 = 0;
        *status_codea = -1;
        return v3;
      }
      v7 = v14;
      sa = v13;
    }
    memcpy((char *)v7 + chunksize, (const void *)header_buf_used, v12);
    v15 = 0;
    v65 = 0;
    while ( v13 - 1 > v15 )
    {
      if ( v65 )
        goto LABEL_19;
      v21 = *((unsigned __int8 *)v7 + v15);
      v22 = v15 + 1;
      if ( v21 == 13 )
      {
        if ( *((_BYTE *)v7 + v22) == 10 )
        {
          v22 = v15 + 2;
          if ( v13 > v15 + 2 && *((_BYTE *)v7 + v22) == 13 )
          {
            v22 = v15 + 3;
            if ( v13 > v15 + 3 && *((_BYTE *)v7 + v22) == 10 )
            {
              v23 = v15 + 4;
LABEL_36:
              v65 = (char *)v23;
            }
          }
        }
      }
      else
      {
        if ( v21 != 10 )
        {
          v22 = v15;
          goto LABEL_31;
        }
        if ( *((_BYTE *)v7 + v22) == 10 )
        {
          v23 = v15 + 2;
          goto LABEL_36;
        }
      }
LABEL_31:
      v15 = v22 + 1;
    }
    if ( !v65 )
    {
      chunksize = v13;
      goto LABEL_40;
    }
LABEL_19:
    v16 = 0;
    chunksize = (unsigned int)(v65 + -0x1);
    v17 = 0;
    s2 = "content-length";
    v18 = 0;
    v77 = "transfer-encoding";
    v19 = 0;
    v78 = "chunked";
    while ( (int)chunksize > (int)v19 )
    {
      v24 = (int)v18 <= (int)v17;
      if ( (int)v18 >= (int)v17 )
        v24 = (int)v18 <= 0;
      v25 = (unsigned __int8)v19[(_DWORD)v7];
      v26 = v19;
      if ( v24 || v25 != 58 )
      {
        v29 = v25 == 10;
        if ( v25 != 10 )
          v29 = v25 == 13;
        if ( v29 )
        {
          v30 = v18 == 0;
          if ( !chunked )
            v30 = 0;
          if ( v30 )
          {
            v31 = (const char *)v7;
            while ( (int)v19 > v31 - (_BYTE *)v7 )
            {
              v37 = *(unsigned __int8 *)v31++;
              if ( v37 == 32 )
              {
                s1 = v19;
                if ( *(int *)chunked >= 0 )
                  break;
                v38 = atoi(v31);
                *(_DWORD *)chunked = v38;
                v19 = s1;
              }
            }
          }
          else
          {
            v32 = (int)v18 < (int)v17;
            if ( (int)v18 < (int)v17 )
              v32 = (int)v17 < v16;
            if ( v32 )
            {
              v80 = v17 - v18;
              s1 = &v18[(_DWORD)v7];
              if ( !strncasecmp(&v18[(_DWORD)v7], s2, v17 - v18) )
              {
                v9 = atoi((const char *)v7 + v16);
              }
              else if ( !strncasecmp(s1, v77, v80) )
              {
                v41 = strncasecmp((const char *)v7 + v16, v78, 7u);
                v42 = v72;
                if ( !v41 )
                  v42 = 1;
                v72 = v42;
              }
            }
          }
          while ( 1 )
          {
            v19 = v26;
            if ( v13 <= (int)v26 )
              break;
            v39 = (unsigned __int8)(v26++)[(_DWORD)v7];
            v40 = v39 == 10;
            if ( v39 != 10 )
              v40 = v39 == 13;
            v16 = v40;
            if ( !v40 )
              goto LABEL_78;
          }
          v16 = 0;
LABEL_78:
          v17 = v19;
          v18 = v19;
        }
      }
      else
      {
        v27 = &v19[(_DWORD)v7];
        v28 = (signed int)v19;
        while ( 1 )
        {
          v34 = (unsigned __int8)*++v27;
          v33 = v34;
          v35 = v28;
          v36 = v34 == 9;
          if ( v34 != 9 )
            v36 = v33 == 32;
          ++v28;
          if ( !v36 )
            break;
          if ( (int)chunksize <= v28 )
            goto LABEL_65;
        }
        v28 = v35;
LABEL_65:
        v17 = v19;
        v16 = v28 + 1;
        v19 = (char *)v28;
      }
      ++v19;
    }
    v12 = v13 - (_DWORD)v65;
    memcpy((void *)header_buf_used, &v65[(_DWORD)v7], v13 - (_DWORD)v65);
    chunksize = v13;
LABEL_22:
    if ( !v72 )
    {
      if ( v9 > 0 && v9 < (unsigned int)&v8[v12] )
        v12 = v9 - (_DWORD)v8;
      if ( &v8[v12] <= (char *)sizea )
      {
        v62 = v3;
      }
      else
      {
        if ( v9 >= 0 )
        {
          if ( v9 < (unsigned int)&v8[v12] )
            v61 = (int *)&v8[v12];
          else
            v61 = (int *)v9;
          sizea = v61;
        }
        else
        {
          sizea = (int *)&v8[v12];
        }
        v62 = realloc(v3, (size_t)sizea);
        if ( !v62 )
        {
          free(v3);
          v5 = v7;
          goto LABEL_7;
        }
      }
      memcpy(&v8[(_DWORD)v62], (const void *)header_buf_used, v12);
      v8 += v12;
      v3 = v62;
      goto LABEL_106;
    }
    v20 = 0;
LABEL_105:
    while ( v12 > v20 )
    {
      if ( !header_buf_len )
      {
        if ( !v6 )
        {
          if ( *((_BYTE *)&endofheaders + v20 + 0x6C) == 13 && v12 <= ++v20 )
            break;
          if ( *((_BYTE *)&endofheaders + v20 + 0x6C) == 10 )
            ++v20;
        }
        v44 = (_BYTE *)(content_buf_used + v6);
        while ( v12 > v20 )
        {
          v45 = _ctype_b_loc();
          v46 = *(unsigned __int8 *)(header_buf_used + v20);
          if ( ((v6 <= 0x1E) & ((*v45)[v46] >> 0xC)) == 0 )
          {
            while ( v12 > v20 )
            {
              v47 = *(unsigned __int8 *)(header_buf_used + v20);
              v48 = v47 == 10;
              if ( v47 != 10 )
                v48 = v47 == 13;
              if ( v48 )
              {
                if ( *((_BYTE *)&endofheaders + v20 + 0x6C) == 13 && v12 <= ++v20 )
                  goto LABEL_106;
                if ( *((_BYTE *)&endofheaders + v20 + 0x6C) != 10 )
                  goto LABEL_105;
                v49 = 0;
                v50 = (unsigned __int8 *)content_buf_used;
                v43 = 0;
                while ( v6 != v49 )
                {
                  v53 = *v50++;
                  v52 = v53;
                  v54 = 16 * v43;
                  if ( (unsigned int)(v53 - 0x30) > 9 )
                  {
                    v52 |= 0x20u;
                    v55 = v54 - 0x57;
                  }
                  else
                  {
                    v55 = v54 - 0x30;
                  }
                  v43 = v52 + v55;
                  ++v49;
                }
                v6 = 0;
                ++v20;
                chunksize_buf[0] = 0;
                if ( !v43 )
                  goto end_of_stream;
                goto LABEL_117;
              }
              ++v20;
            }
            goto LABEL_106;
          }
          ++v6;
          ++v20;
          *v44 = v46;
          *++v44 = 0;
        }
        break;
      }
      v43 = header_buf_len;
LABEL_117:
      v56 = (char *)(v12 - v20);
      if ( v12 - v20 >= v43 )
        v56 = (char *)v43;
      v57 = &v56[(_DWORD)v8];
      if ( &v56[(int)v8] > (char *)sizea )
      {
        if ( v9 >= 0 )
        {
          if ( v9 < (unsigned int)v57 )
            v58 = (int *)&v56[(_DWORD)v8];
          else
            v58 = (int *)v9;
          sizea = v58;
        }
        else
        {
          sizea = (int *)&v56[(_DWORD)v8];
        }
        s2 = v56;
        header_buf_len = (unsigned int)&v56[(_DWORD)v8];
        v59 = realloc(v3, (size_t)sizea);
        v57 = (char *)header_buf_len;
        v56 = s2;
        if ( !v59 )
        {
          v65 = 0;
          free(v3);
          free(v7);
          v3 = v65;
          *status_codea = -1;
          return v3;
        }
        v3 = v59;
      }
      s2 = v57;
      header_buf_len = (unsigned int)v56;
      memcpy(&v8[(_DWORD)v3], (const void *)(header_buf_used + v20), (size_t)v56);
      v60 = header_buf_len;
      header_buf_len = v43 - header_buf_len;
      v20 += v60;
      v8 = s2;
    }
LABEL_106:
    v51 = v9 > 0;
    if ( v9 > (unsigned int)v8 )
      v51 = 0;
    if ( !v51 )
    {
LABEL_40:
      v10 = (int)v65;
      continue;
    }
    break;
  }
end_of_stream:
  free(v7);
  *status_codea = (int)v8;
  if ( !v8 )
  {
    free(v3);
    return 0;
  }
  return v3;
}
