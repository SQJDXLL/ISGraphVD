void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int *v3; // ebp
  int v4; // eax
  int v5; // esi
  char v6; // dl
  int v7; // ecx
  signed int v8; // ebx
  int v9; // esi
  char *v10; // edi
  int v11; // eax
  char v12; // dl
  char v13; // al
  char v14; // al
  unsigned int v15; // edx
  const char *v16; // ebp
  const char *v17; // esi
  int *v18; // edi
  bool v19; // zf
  int v20; // eax
  char v21; // al
  int v22; // edi
  int v23; // esi
  int v24; // esi
  const unsigned __int16 *v25; // ebp
  unsigned int v26; // eax
  unsigned int v27; // ebx
  char *v28; // edi
  char v29; // cl
  char v30; // dl
  signed int v31; // edi
  char *v32; // ecx
  char *v33; // edi
  int v34; // edx
  char v35; // al
  int *v36; // ebp
  size_t v37; // ebp
  size_t v38; // eax
  char *v39; // eax
  char *v40; // esi
  int *v41; // ebp
  char *v43; // eax
  size_t v44; // ebp
  unsigned int v45; // edi
  char *v46; // eax
  char *v47; // ebp
  int n; // [esp+0h] [ebp-89Ch]
  int na; // [esp+0h] [ebp-89Ch]
  signed int content_buf_used; // [esp+4h] [ebp-898h]
  signed int chunksize; // [esp+Ch] [ebp-890h]
  char *content_buf; // [esp+14h] [ebp-888h]
  unsigned int content_buf_len; // [esp+18h] [ebp-884h]
  signed int content_length; // [esp+1Ch] [ebp-880h]
  int endofheaders; // [esp+20h] [ebp-87Ch]
  unsigned int chunksize_buf_index; // [esp+24h] [ebp-878h]
  char *header_buf; // [esp+28h] [ebp-874h]
  unsigned int header_buf_used; // [esp+2Ch] [ebp-870h]
  int v59; // [esp+30h] [ebp-86Ch]
  int valuestart; // [esp+34h] [ebp-868h]
  int chunked; // [esp+38h] [ebp-864h]
  unsigned int header_buf_len; // [esp+3Ch] [ebp-860h]
  int v63; // [esp+40h] [ebp-85Ch]
  size_t v64; // [esp+44h] [ebp-858h]
  int *v65; // [esp+48h] [ebp-854h]
  int *v66; // [esp+4Ch] [ebp-850h]
  char chunksize_buf[32]; // [esp+5Ch] [ebp-840h] BYREF
  char buf[2048]; // [esp+7Ch] [ebp-820h] BYREF
  unsigned int v70; // [esp+87Ch] [ebp-20h]

  v65 = status_code;
  v70 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    *size = -1;
    return 0;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  header_buf_used = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  v66 = size;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( 2 )
      {
        na = receivedata(s, buf, 2048, 5000, 0);
        if ( na <= 0 )
        {
          v41 = v66;
          goto end_of_stream;
        }
        if ( endofheaders )
        {
          if ( chunked )
            goto LABEL_80;
LABEL_137:
          if ( content_length > 0 )
          {
            v44 = na;
            v45 = content_buf_used + na;
            if ( content_buf_used + na <= content_length )
            {
              v40 = content_buf;
              if ( content_buf_len >= v45 )
                goto LABEL_144;
              goto LABEL_135;
            }
            na = content_length - content_buf_used;
          }
          v44 = na;
          v45 = content_buf_used + na;
          if ( content_buf_len >= content_buf_used + na )
          {
            v40 = content_buf;
            goto LABEL_144;
          }
          content_buf_len = content_buf_used + na;
          if ( (int)v45 > content_length )
          {
            v43 = (char *)realloc(content_buf, content_buf_len);
LABEL_143:
            v40 = v43;
            if ( !v43 )
            {
LABEL_111:
              v36 = v66;
              free(content_buf);
              free(header_buf);
              *v36 = -1;
              return 0;
            }
LABEL_144:
            memcpy(&v40[content_buf_used], buf, v44);
            content_buf_used = v45;
            content_buf = v40;
            goto LABEL_145;
          }
LABEL_135:
          content_buf_len = content_length;
          v43 = (char *)realloc(content_buf, content_length);
          goto LABEL_143;
        }
        v22 = header_buf_used + na;
        if ( header_buf_len < header_buf_used + na )
        {
          v46 = (char *)realloc(header_buf, header_buf_used + na);
          if ( !v46 )
          {
            v3 = v66;
            free(header_buf);
            free(content_buf);
            *v3 = -1;
            return 0;
          }
          header_buf_len = v22;
          header_buf = v46;
        }
        v47 = header_buf;
        memcpy(&header_buf[header_buf_used], buf, na);
        if ( v22 <= 1 )
        {
          header_buf_used = v22;
          continue;
        }
        break;
      }
      v4 = 0;
      do
      {
        v6 = v47[v4];
        if ( v6 == 13 )
        {
          if ( v47[v4 + 1] == 10 )
          {
            if ( v4 + 2 >= v22 )
            {
              v4 += 2;
              v5 = 0;
            }
            else if ( v47[v4 + 2] == 13 )
            {
              if ( v4 + 3 >= v22 )
              {
                v4 += 3;
                v5 = 0;
              }
              else if ( v47[v4 + 3] == 10 )
              {
                v5 = v4 + 4;
                v4 += 3;
              }
              else
              {
                v4 += 3;
                v5 = 0;
              }
            }
            else
            {
              v4 += 2;
              v5 = 0;
            }
          }
          else
          {
            ++v4;
            v5 = 0;
          }
        }
        else
        {
          v5 = 0;
          if ( v6 == 10 )
          {
            if ( v47[v4 + 1] == 10 )
              v5 = v4 + 2;
            ++v4;
          }
        }
        ++v4;
      }
      while ( v4 < v22 - 1 && !v5 );
      v59 = v5;
      if ( !v5 )
      {
        header_buf_used = v22;
        endofheaders = 0;
        continue;
      }
      break;
    }
    n = v5 - 1;
    if ( v5 - 1 <= 0 )
      goto LABEL_75;
    valuestart = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v63 = 0;
    header_buf_used = v22;
    v10 = header_buf;
    do
    {
      if ( v8 <= 0 || v8 < v7 )
      {
        v13 = v10[v9];
        if ( v13 != 13 && v13 != 10 )
          goto LABEL_41;
        if ( v8 || !v65 )
        {
          if ( v8 < v7 && v7 < valuestart )
          {
            v64 = v7 - v8;
            if ( !strncasecmp(&v10[v8], "content-length", v7 - v8) )
            {
              content_length = strtol(&v10[valuestart], 0, 10);
            }
            else if ( !strncasecmp(&v10[v8], "transfer-encoding", v64) )
            {
              v19 = strncasecmp(&v10[valuestart], "chunked", 7u) == 0;
              v20 = 1;
              if ( !v19 )
                v20 = chunked;
              chunked = v20;
            }
          }
        }
        else
        {
          if ( v9 <= 0 )
          {
            v15 = header_buf_used;
            goto LABEL_68;
          }
          v16 = v10 + 1;
          valuestart = v9;
          v64 = (size_t)v10;
          v17 = &v10[v9 + 1];
          v18 = v65;
          do
          {
            if ( *(v16 - 1) == 32 )
            {
              if ( *v18 >= 0 )
              {
                v9 = valuestart;
                v10 = (char *)v64;
                goto LABEL_47;
              }
              *v18 = strtol(v16, 0, 10);
            }
            ++v16;
          }
          while ( v16 != v17 );
          v9 = valuestart;
          v10 = (char *)v64;
        }
        goto LABEL_47;
      }
      v14 = v10[v9];
      if ( v14 != 58 )
      {
        if ( v14 != 10 && v14 != 13 )
          goto LABEL_41;
LABEL_47:
        if ( (int)header_buf_used <= v9 )
        {
          valuestart = 0;
          v7 = v9;
          v8 = v9;
        }
        else
        {
          v15 = header_buf_used;
          do
          {
LABEL_68:
            v21 = v10[v9];
            if ( v21 != 13 && v21 != 10 )
            {
              valuestart = v63;
              v7 = v9;
              v8 = v9;
              goto LABEL_41;
            }
            ++v9;
          }
          while ( v9 != v15 );
          valuestart = v63;
          v9 = header_buf_used;
          v7 = header_buf_used;
          v8 = header_buf_used;
        }
        goto LABEL_41;
      }
      if ( n <= v9 )
      {
        v11 = v9;
      }
      else
      {
        v11 = v9;
        while ( 1 )
        {
          v12 = v10[v11 + 1];
          if ( v12 != 32 && v12 != 9 )
            break;
          if ( ++v11 == v59 - 1 )
          {
            v11 = v59 - 1;
            break;
          }
        }
      }
      valuestart = v11 + 1;
      v7 = v9;
      v9 = v11;
LABEL_41:
      ++v9;
    }
    while ( v9 < n );
    v22 = header_buf_used;
LABEL_75:
    v23 = v22 - v59;
    na = v22 - v59;
    memcpy(buf, &header_buf[v59], v22 - v59);
    if ( !chunked )
    {
      header_buf_used = v22;
      endofheaders = v59;
      goto LABEL_137;
    }
    if ( v23 > 0 )
    {
      header_buf_used = v22;
      endofheaders = v59;
LABEL_80:
      v24 = 0;
      while ( 1 )
      {
        if ( chunksize )
          goto LABEL_115;
        if ( !chunksize_buf_index )
        {
          if ( buf[v24] == 13 )
            ++v24;
          if ( na <= v24 )
          {
LABEL_133:
            v26 = chunksize_buf_index;
LABEL_97:
            chunksize_buf_index = v26;
            goto LABEL_145;
          }
          if ( buf[v24] != 10 )
            goto LABEL_88;
          ++v24;
        }
        if ( v24 >= na )
          goto LABEL_133;
LABEL_88:
        v25 = *_ctype_b_loc();
        v26 = chunksize_buf_index;
        v27 = chunksize_buf_index + na - v24;
        v28 = &buf[v24 - chunksize_buf_index];
        while ( 1 )
        {
          v29 = v28[v26];
          if ( (v25[v29] & 0x1000) == 0 || v26 > 0x1E )
            break;
          chunksize_buf[v26++] = v29;
          chunksize_buf[v26] = 0;
          ++v24;
          if ( v26 == v27 )
          {
            v26 = v27;
            break;
          }
        }
        if ( v24 >= na )
          goto LABEL_97;
        while ( 1 )
        {
          v30 = buf[v24];
          if ( v30 == 10 || v30 == 13 )
            break;
          if ( na == ++v24 )
            goto LABEL_97;
        }
        if ( na <= v24 )
          goto LABEL_97;
        if ( buf[v24] == 13 && na <= ++v24 )
          goto LABEL_97;
        if ( buf[v24] != 10 )
        {
          v31 = content_buf_used;
          chunksize_buf_index = v26;
          goto LABEL_113;
        }
        if ( !v26 )
        {
          v41 = v66;
          goto end_of_stream;
        }
        v32 = chunksize_buf;
        v33 = &chunksize_buf[v26];
        v34 = 0;
        do
        {
          v35 = *v32;
          if ( (unsigned __int8)(*v32 - 48) > 9u )
            v34 = 16 * v34 + (v35 | 0x20) - 87;
          else
            v34 = 16 * v34 + v35 - 48;
          ++v32;
        }
        while ( v32 != v33 );
        chunksize_buf[0] = 0;
        ++v24;
        if ( !v34 )
        {
          v41 = v66;
          goto end_of_stream;
        }
        chunksize_buf_index = 0;
        chunksize = v34;
LABEL_115:
        v37 = na - v24;
        if ( na - v24 > chunksize )
          v37 = chunksize;
        v31 = v37 + content_buf_used;
        if ( content_buf_len < v37 + content_buf_used )
        {
          v38 = content_length;
          if ( content_length < v31 )
            v38 = v37 + content_buf_used;
          content_buf_len = v38;
          v39 = (char *)realloc(content_buf, v38);
          if ( !v39 )
            goto LABEL_111;
          content_buf = v39;
        }
        memcpy(&content_buf[content_buf_used], &buf[v24], v37);
        v24 += v37;
        chunksize -= v37;
        if ( na <= v24 )
        {
          content_buf_used += v37;
          goto LABEL_145;
        }
LABEL_113:
        content_buf_used = v31;
      }
    }
    header_buf_used = v22;
    endofheaders = v59;
LABEL_145:
    if ( content_length <= 0 || content_buf_used < content_length )
      continue;
    break;
  }
  v41 = v66;
end_of_stream:
  free(header_buf);
  *v41 = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
