void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  void *result; // x0
  char *v6; // x22
  char *v7; // x0
  unsigned int v8; // w26
  unsigned __int64 v9; // x27
  int v10; // w20
  unsigned int v11; // w24
  int v12; // w23
  int v13; // w23
  int v14; // w8
  int v15; // w0
  int v16; // w27
  char *v17; // x0
  int *v18; // x26
  int v19; // w9
  int v20; // w10
  __int64 v21; // x10
  int v22; // w11
  int v23; // w9
  int v24; // w11
  __int64 v25; // x21
  int v26; // w9
  int v27; // w8
  int v28; // w19
  int v29; // w10
  int v30; // w9
  int v31; // w10
  __int64 v32; // x21
  const char *v33; // x28
  int v34; // w10
  const char *v35; // x28
  size_t v36; // x26
  int v37; // w0
  int v38; // w8
  char *v39; // x8
  __int64 v40; // x9
  int v41; // w10
  int v42; // w8
  __int64 v43; // x28
  unsigned int v44; // w11
  int v46; // w21
  unsigned int v47; // w19
  size_t v49; // x1
  char *v50; // x0
  int v51; // w8
  int v52; // w8
  unsigned int v53; // w24
  const unsigned __int16 *v54; // x8
  char *v55; // x9
  __int64 v56; // x10
  __int64 v57; // x11
  __int64 v58; // x8
  int v59; // w9
  unsigned int v60; // w12
  __int64 v61; // x8
  char *v62; // x9
  int v63; // t1
  int v64; // w11
  int v65; // w10
  unsigned int v66; // w21
  unsigned int v67; // w9
  bool v68; // nf
  size_t v69; // x1
  char *v70; // x0
  unsigned int v71; // [xsp+0h] [xbp-880h]
  int v72; // [xsp+Ch] [xbp-874h]
  unsigned int v73; // [xsp+Ch] [xbp-874h]
  unsigned __int64 v74; // [xsp+10h] [xbp-870h]
  unsigned int v75; // [xsp+1Ch] [xbp-864h]
  char *ptr; // [xsp+20h] [xbp-860h]
  int v77; // [xsp+28h] [xbp-858h]
  int v78; // [xsp+2Ch] [xbp-854h]
  int v80; // [xsp+38h] [xbp-848h]
  unsigned int v81; // [xsp+3Ch] [xbp-844h]
  int *v82; // [xsp+40h] [xbp-840h]
  char v83[32]; // [xsp+58h] [xbp-828h] BYREF
  char dest[2056]; // [xsp+78h] [xbp-808h] BYREF

  if ( status_code )
    *status_code = -1;
  result = malloc(0x800uLL);
  if ( !result )
    goto LABEL_161;
  v6 = (char *)result;
  v7 = (char *)malloc(0x800uLL);
  if ( !v7 )
  {
    free(v6);
    result = 0LL;
LABEL_161:
    *size = -1;
    return result;
  }
  v8 = 0;
  v9 = 0LL;
  v10 = 0;
  v11 = 2048;
  v12 = -1;
  v82 = status_code;
  ptr = v7;
  v77 = 0;
  v78 = s;
  v72 = 0;
  v75 = 0;
  v83[0] = 0;
  v71 = 2048;
  while ( 2 )
  {
    v74 = v9;
    v80 = v12;
    while ( 2 )
    {
      v15 = receivedata((unsigned int)s, dest, 2048LL, 5000LL, 0LL);
      if ( v15 < 1 )
        goto end_of_stream;
      v13 = v15;
      if ( v10 )
        goto LABEL_75;
      v16 = v15 + v8;
      if ( v15 + v8 > v11 )
      {
        v17 = (char *)realloc(v6, (unsigned int)v16);
        if ( !v17 )
        {
          free(v6);
          free(ptr);
          *size = -1;
          v10 = 0;
          v14 = 1;
          goto LABEL_8;
        }
        v6 = v17;
        v11 = v16;
      }
      memcpy(&v6[v8], dest, v13);
      if ( v16 < 2 )
      {
LABEL_31:
        v10 = 0;
        v14 = 2;
        v8 = v16;
        goto LABEL_8;
      }
      v18 = v82;
      v10 = 0;
      v19 = 0;
      do
      {
        v20 = (unsigned __int8)v6[v19];
        if ( v20 == 10 )
        {
          LODWORD(v21) = v19 + 1;
          v22 = (unsigned __int8)v6[v19 + 1];
          v23 = v19 + 2;
LABEL_24:
          if ( v22 == 10 )
            v10 = v23;
          goto LABEL_28;
        }
        if ( v20 != 13 )
        {
          LODWORD(v21) = v19;
          goto LABEL_28;
        }
        LODWORD(v21) = v19 + 1;
        if ( v6[v19 + 1] == 10 )
        {
          v21 = v19 + 2LL;
          if ( v19 + 2 < v16 && v6[v21] == 13 )
          {
            v21 = v19 + 3LL;
            if ( v19 + 3 < v16 )
            {
              v22 = (unsigned __int8)v6[v21];
              v23 = v19 + 4;
              goto LABEL_24;
            }
          }
        }
LABEL_28:
        v19 = v21 + 1;
      }
      while ( (int)v21 + 1 < v16 - 1 && !v10 );
      if ( !v10 )
        goto LABEL_31;
      if ( v10 >= 2 )
      {
        v24 = v10 - 1;
        LODWORD(v25) = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        do
        {
          if ( v27 >= 1 && v26 <= v27 && v6[v28] == 58 )
          {
            v25 = v28;
            while ( v25 < v10 - 1 )
            {
              v30 = (unsigned __int8)v6[++v25];
              if ( v30 != 32 && v30 != 9 )
                goto LABEL_44;
            }
            LODWORD(v25) = v25 + 1;
LABEL_44:
            v29 = v25 - 1;
          }
          else
          {
            v31 = (unsigned __int8)v6[v28];
            if ( v31 == 13 || v31 == 10 )
            {
              if ( !v18 || v27 )
              {
                v34 = v26 - v27;
                if ( v26 > v27 && (int)v25 > v26 )
                {
                  v35 = &v6[v27];
                  v36 = v34;
                  if ( !strncasecmp(v35, "content-length", v34) )
                  {
                    v80 = atoi(&v6[(int)v25]);
                  }
                  else if ( !strncasecmp(v35, "transfer-encoding", v36) )
                  {
                    v37 = strncasecmp(&v6[(int)v25], "chunked", 7uLL);
                    v38 = v77;
                    if ( !v37 )
                      v38 = 1;
                    v77 = v38;
                  }
                  v18 = v82;
LABEL_65:
                  v24 = v10 - 1;
                }
              }
              else if ( v28 >= 1 )
              {
                v32 = (unsigned int)v28;
                v33 = v6 + 1;
                while ( 1 )
                {
                  if ( *(v33 - 1) == 32 )
                  {
                    if ( (*v18 & 0x80000000) == 0 )
                      goto LABEL_65;
                    *v18 = atoi(v33);
                  }
                  --v32;
                  ++v33;
                  if ( !v32 )
                    goto LABEL_65;
                }
              }
              if ( v28 < v16 )
              {
                v39 = &v6[v28];
                v40 = v16 - (__int64)v28;
                while ( 1 )
                {
                  v41 = (unsigned __int8)*v39;
                  if ( v41 != 13 && v41 != 10 )
                    break;
                  ++v28;
                  --v40;
                  ++v39;
                  if ( !v40 )
                  {
                    LODWORD(v25) = 0;
                    v29 = v16;
                    v27 = v16;
                    v28 = v16;
                    goto LABEL_36;
                  }
                }
              }
              LODWORD(v25) = 0;
              v29 = v28;
              v27 = v28;
            }
            else
            {
              v29 = v28;
              v28 = v26;
            }
          }
LABEL_36:
          v26 = v28;
          v28 = v29 + 1;
        }
        while ( v29 + 1 < v24 );
      }
      v13 = v16 - v10;
      memcpy(dest, &v6[v10], v16 - v10);
      s = v78;
      v14 = 0;
      v8 = v16;
LABEL_8:
      if ( v14 == 2 )
        continue;
      break;
    }
    if ( v14 )
      return 0LL;
LABEL_75:
    if ( !v10 )
    {
      v12 = v80;
LABEL_153:
      v9 = v74;
      goto LABEL_154;
    }
    if ( !v77 )
    {
      v44 = v75;
      if ( v13 + v75 <= v80 || v80 <= 0 )
        v46 = v13;
      else
        v46 = v80 - v75;
      v47 = v46 + v75;
      if ( v46 + v75 <= v71 )
      {
        v12 = v80;
      }
      else
      {
        if ( v80 < v47 || v80 < 0 )
          v49 = v47;
        else
          v49 = (unsigned int)v80;
        v71 = v49;
        v50 = (char *)realloc(ptr, v49);
        if ( v50 )
        {
          v51 = 1;
          ptr = v50;
        }
        else
        {
          free(ptr);
          free(v6);
          v51 = 0;
          *size = -1;
        }
        v12 = v80;
        v44 = v75;
        if ( !v51 )
          return 0LL;
      }
      memcpy(&ptr[v44], dest, v46);
      v75 += v46;
      goto LABEL_153;
    }
    v9 = v74;
    if ( v13 < 1 )
    {
      v12 = v80;
LABEL_154:
      if ( v12 < 1 || v75 < v12 )
        continue;
end_of_stream:
      free(v6);
      *size = v75;
      if ( v75 )
        return ptr;
      free(ptr);
      return 0LL;
    }
    break;
  }
  v42 = v72;
  LODWORD(v43) = 0;
  v81 = v11;
  while ( 2 )
  {
    v53 = v75;
    while ( 1 )
    {
      if ( v42 )
      {
        v73 = v42;
        goto LABEL_135;
      }
      if ( !(_DWORD)v9 )
      {
        v43 = dest[(int)v43] == 13 ? (int)v43 + 1LL : (int)v43;
        if ( (int)v43 < v13 && dest[v43] == 10 )
          LODWORD(v43) = v43 + 1;
      }
      if ( (int)v43 < v13 )
      {
        v54 = *_ctype_b_loc();
        v9 = (unsigned int)v9;
        v55 = &dest[(int)v43];
        v56 = v13 - (__int64)(int)v43;
        while ( v9 <= 0x1E )
        {
          v57 = (unsigned __int8)*v55;
          if ( (v54[v57] & 0x1000) == 0 )
            break;
          v83[v9++] = v57;
          LODWORD(v43) = v43 + 1;
          --v56;
          ++v55;
          v83[(unsigned int)v9] = 0;
          if ( !v56 )
          {
            LODWORD(v43) = v13;
            break;
          }
        }
      }
      v58 = (int)v43;
      v43 = (int)v43 <= (__int64)v13 ? v13 : (int)v43;
      while ( v43 != v58 )
      {
        v59 = (unsigned __int8)dest[v58++];
        if ( v59 == 13 || v59 == 10 )
        {
          if ( v59 == 13 )
            LODWORD(v43) = v58;
          else
            LODWORD(v43) = v58 - 1;
          break;
        }
      }
      if ( v13 > (int)v43 && dest[(int)v43] == 10 )
        break;
      v42 = 0;
      if ( v13 <= (int)v43 )
      {
        v72 = 0;
        goto LABEL_148;
      }
    }
    v60 = 0;
    if ( (_DWORD)v9 )
    {
      v61 = (unsigned int)v9;
      v62 = v83;
      do
      {
        v63 = (unsigned __int8)*v62++;
        v64 = v63 - 0x30;
        v65 = (v63 | 0x20) - 0x57;
        if ( (unsigned int)(v63 - 0x30) < 0xA )
          v65 = v64;
        --v61;
        v60 = v65 + 16 * v60;
      }
      while ( v61 );
    }
    v9 = 0LL;
    v83[0] = 0;
    if ( !v60 )
    {
      v42 = 25;
      v72 = 0;
      goto LABEL_148;
    }
    LODWORD(v43) = v43 + 1;
    v73 = v60;
LABEL_135:
    if ( v73 >= v13 - (int)v43 )
      v66 = v13 - v43;
    else
      v66 = v73;
    v67 = v66 + v75;
    v75 += v66;
    if ( v66 + v53 > v71 )
    {
      v68 = v80 < v67 || v80 < 0;
      v69 = v68 ? v67 : (unsigned int)v80;
      v71 = v69;
      v70 = (char *)realloc(ptr, v69);
      if ( v70 )
      {
        v52 = 1;
        ptr = v70;
      }
      else
      {
        free(ptr);
        free(v6);
        v52 = 0;
        *size = -1;
      }
      s = v78;
      if ( !v52 )
      {
        v75 = v53;
        v42 = 1;
        goto LABEL_162;
      }
    }
    memcpy(&ptr[v53], &dest[(int)v43], v66);
    LODWORD(v43) = v66 + v43;
    v42 = v73 - v66;
    if ( (int)v43 < v13 )
      continue;
    break;
  }
  v72 = v73 - v66;
  v42 = 0;
LABEL_148:
  v11 = v81;
  v12 = v80;
  if ( !v42 )
    goto LABEL_154;
LABEL_162:
  if ( v42 == 25 )
    goto end_of_stream;
  return 0LL;
}
