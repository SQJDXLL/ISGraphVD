void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x19
  char *v4; // x0
  char *v5; // x0
  char *v6; // x20
  unsigned int v7; // w26
  unsigned int v8; // w27
  unsigned int v9; // w24
  int v10; // w21
  int v11; // w22
  int v12; // w28
  int v13; // w25
  char *v14; // x0
  int i; // w1
  int v16; // w4
  int v17; // w2
  int v18; // w0
  int j; // w1
  int v20; // w25
  int v21; // w2
  int v22; // w0
  int v23; // w5
  __int64 v24; // x28
  bool v25; // cc
  int v26; // w5
  int v27; // w2
  bool v28; // zf
  bool v30; // zf
  const char *v31; // x2
  int k; // w4
  int v33; // w0
  int v35; // w0
  int v37; // w0
  __int64 v38; // x1
  char *v39; // x2
  const unsigned __int16 **v40; // x0
  __int64 v41; // x5
  __int64 v42; // x0
  int v43; // w1
  unsigned int v44; // w4
  __int64 v45; // x1
  int v46; // w4
  int v47; // w0
  unsigned int v48; // w2
  unsigned int v49; // w5
  int v50; // w0
  unsigned int v51; // w5
  unsigned int v52; // w6
  char *v53; // x0
  unsigned int v55; // w4
  char *v56; // x0
  char *v57; // x25
  unsigned int header_buf_used; // [xsp+70h] [xbp+70h]
  signed int header_buf_useda; // [xsp+70h] [xbp+70h]
  int chunked; // [xsp+74h] [xbp+74h]
  unsigned int chunksize; // [xsp+80h] [xbp+80h]
  unsigned int chunksizea; // [xsp+80h] [xbp+80h]
  unsigned int chunksizeb; // [xsp+80h] [xbp+80h]
  unsigned int header_buf_len; // [xsp+84h] [xbp+84h]
  __int64 content_buf_used; // [xsp+88h] [xbp+88h]
  unsigned int content_buf_useda; // [xsp+88h] [xbp+88h]
  unsigned int content_buf_usedb; // [xsp+88h] [xbp+88h]
  unsigned int content_buf_usedc; // [xsp+88h] [xbp+88h]
  char *bytestocopy; // [xsp+90h] [xbp+90h]
  unsigned int bytestocopya; // [xsp+90h] [xbp+90h]
  unsigned int bytestocopyb; // [xsp+90h] [xbp+90h]
  const char *v75; // [xsp+A8h] [xbp+A8h]
  const char *v76; // [xsp+A8h] [xbp+A8h]
  int v77; // [xsp+B0h] [xbp+B0h]
  size_t v78; // [xsp+B0h] [xbp+B0h]
  int sp; // [xsp+BCh] [xbp+BCh]
  int spa; // [xsp+BCh] [xbp+BCh]
  char chunksize_buf[32]; // [xsp+C8h] [xbp+C8h] BYREF
  char buf[2048]; // [xsp+E8h] [xbp+E8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
  {
    *size = -1;
    return v3;
  }
  v4 = (char *)malloc(0x800uLL);
  if ( !v4 )
  {
LABEL_7:
    v5 = v3;
    goto LABEL_8;
  }
  v6 = v3;
  v7 = 2048;
  v3 = v4;
  v8 = 0;
  v9 = 0;
  v10 = -1;
  v11 = 0;
  header_buf_used = 0;
  chunked = 0;
  chunksize = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
    v12 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v12 <= 0 )
      break;
    if ( v11 )
      goto LABEL_23;
    v13 = v12 + header_buf_used;
    if ( v12 + header_buf_used > header_buf_len )
    {
      v14 = (char *)realloc(v6, (unsigned int)v13);
      if ( !v14 )
      {
        free(v6);
        goto LABEL_7;
      }
      v6 = v14;
      header_buf_len = v12 + header_buf_used;
    }
    v11 = 0;
    memcpy(&v6[header_buf_used], buf, v12);
    for ( i = 0; v13 - 1 > i; i = v22 + 1 )
    {
      if ( v11 )
        goto LABEL_20;
      v21 = (unsigned __int8)v6[i];
      v22 = i + 1;
      if ( v21 == 13 )
      {
        if ( v6[v22] == 10 )
        {
          v22 = i + 2;
          if ( v13 > i + 2 && v6[v22] == 13 )
          {
            v22 = i + 3;
            if ( v13 > i + 3 && v6[v22] == 10 )
              v11 = i + 4;
          }
        }
      }
      else if ( v21 == 10 )
      {
        if ( v6[v22] == 10 )
          v11 = i + 2;
      }
      else
      {
        v22 = i;
      }
    }
    header_buf_used += v12;
    if ( v11 )
    {
LABEL_20:
      header_buf_useda = v11 - 1;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      for ( j = 0; header_buf_useda > j; ++j )
      {
        v23 = (unsigned __int8)v6[j];
        v24 = j;
        v25 = v18 <= 0 || v18 < v17;
        if ( v25 || v23 != 58 )
        {
          if ( v23 == 13 || v23 == 10 )
          {
            if ( v18 )
              v30 = 1;
            else
              v30 = status_code == 0LL;
            if ( !v30 )
            {
              v31 = v6 + 1;
              for ( k = 0; ; ++k )
              {
                if ( j <= k )
                  goto LABEL_63;
                if ( *(v31 - 1) == 32 )
                {
                  v77 = j;
                  sp = k;
                  if ( (*status_code & 0x80000000) == 0 )
                    goto LABEL_63;
                  v75 = v31;
                  v35 = atoi(v31);
                  k = sp;
                  v31 = v75;
                  *status_code = v35;
                  j = v77;
                }
                ++v31;
              }
            }
            spa = v16;
            if ( v18 < v17 && v17 < v16 )
            {
              v76 = &v6[v18];
              v78 = v17 - v18;
              if ( !strncasecmp(v76, "content-length", v78) )
              {
                v10 = atoi(&v6[spa]);
              }
              else if ( !strncasecmp(v76, "transfer-encoding", v78) )
              {
                v28 = strncasecmp(&v6[spa], "chunked", 7uLL) == 0;
                v37 = chunked;
                if ( v28 )
                  v37 = 1;
                chunked = v37;
              }
            }
LABEL_63:
            while ( 1 )
            {
              j = v24;
              if ( v13 <= (int)v24 )
                break;
              v33 = (unsigned __int8)v6[v24++];
              if ( v33 != 13 && v33 != 10 )
              {
                v17 = j;
                v18 = j;
                v16 = 0;
                goto LABEL_51;
              }
            }
            v17 = v24;
            v18 = v24;
            v16 = 0;
          }
        }
        else
        {
          while ( 1 )
          {
            v26 = v24 + 1;
            v27 = (unsigned __int8)v6[v24 + 1];
            v28 = v27 == 32 || v27 == 9;
            if ( !v28 )
              break;
            if ( header_buf_useda <= (int)++v24 )
              goto LABEL_50;
          }
          v26 = v24;
LABEL_50:
          v17 = j;
          v16 = v26 + 1;
          j = v26;
        }
LABEL_51:
        ;
      }
      v12 = v13 - v11;
      memcpy(buf, &v6[v11], v13 - v11);
      header_buf_used = v13;
LABEL_23:
      if ( chunked )
      {
        v20 = 0;
        while ( 1 )
        {
LABEL_124:
          if ( v12 <= v20 )
            goto LABEL_125;
          if ( !chunksize )
            break;
          v44 = chunksize;
LABEL_111:
          v51 = v12 - v20;
          if ( v12 - v20 > v44 )
            v51 = v44;
          v52 = v9 + v51;
          if ( v9 + v51 > v7 )
          {
            if ( (v10 & 0x80000000) != 0 )
            {
              v7 = v9 + v51;
            }
            else if ( v10 < v52 )
            {
              v7 = v9 + v51;
            }
            else
            {
              v7 = v10;
            }
            chunksizea = v9 + v51;
            content_buf_useda = v44;
            bytestocopya = v51;
            v53 = (char *)realloc(v3, v7);
            v52 = chunksizea;
            v44 = content_buf_useda;
            v51 = bytestocopya;
            if ( !v53 )
              goto LABEL_119;
            v3 = v53;
          }
          chunksizeb = v51;
          content_buf_usedb = v52;
          bytestocopyb = v44;
          memcpy(&v3[v9], &buf[v20], v51);
          v20 += chunksizeb;
          v9 = content_buf_usedb;
          chunksize = bytestocopyb - chunksizeb;
        }
        if ( v8 )
        {
LABEL_92:
          v38 = v20;
          v39 = &chunksize_buf[v8];
          while ( 1 )
          {
            content_buf_used = v38;
            bytestocopy = v39;
            v20 = v38;
            if ( v12 <= (int)v38 )
              break;
            v40 = _ctype_b_loc();
            v41 = (unsigned __int8)buf[content_buf_used];
            if ( ((*v40)[v41] & 0x1000) == 0 || v8 > 0x1E )
              break;
            ++v8;
            v38 = content_buf_used + 1;
            *bytestocopy = v41;
            v39 = bytestocopy + 1;
            chunksize_buf[v8] = 0;
          }
        }
        else if ( buf[v20] != 13 || (++v20, v12 > v20) )
        {
          if ( buf[v20] == 10 )
            ++v20;
          goto LABEL_92;
        }
        v42 = v20;
        while ( 1 )
        {
          v20 = v42;
          if ( v12 <= (int)v42 )
            goto LABEL_125;
          v43 = (unsigned __int8)buf[v42];
          if ( v43 != 13 )
          {
            ++v42;
            if ( v43 != 10 )
              continue;
          }
          if ( buf[v20] == 13 && v12 <= ++v20 )
            goto LABEL_125;
          if ( buf[v20] != 10 )
            goto LABEL_124;
          v44 = 0;
          v45 = 0LL;
          while ( v8 > (unsigned int)v45 )
          {
            v46 = 16 * v44;
            v47 = (unsigned __int8)chunksize_buf[v45++];
            v48 = v46 - 0x30 + v47;
            v49 = (unsigned __int8)(v47 - 0x30);
            v50 = (v47 | 0x20) + v46 - 0x57;
            if ( v49 <= 9 )
              v44 = v48;
            else
              v44 = v50;
          }
          chunksize_buf[0] = 0;
          ++v20;
          if ( v44 )
          {
            v8 = 0;
            goto LABEL_111;
          }
          goto end_of_stream;
        }
      }
      if ( v10 > 0 && v10 < v12 + v9 )
        v12 = v10 - v9;
      v55 = v12 + v9;
      if ( v12 + v9 <= v7 )
      {
        v57 = v3;
      }
      else
      {
        if ( (v10 & 0x80000000) != 0 )
        {
          v7 = v12 + v9;
        }
        else if ( v10 < v55 )
        {
          v7 = v12 + v9;
        }
        else
        {
          v7 = v10;
        }
        v56 = (char *)realloc(v3, v7);
        v55 = v12 + v9;
        v57 = v56;
        if ( !v56 )
        {
LABEL_119:
          free(v3);
          v5 = v6;
LABEL_8:
          free(v5);
          *size = -1;
          return 0LL;
        }
      }
      content_buf_usedc = v55;
      memcpy(&v57[v9], buf, v12);
      v3 = v57;
      v9 = content_buf_usedc;
LABEL_125:
      if ( v10 > 0 && v10 <= v9 )
        break;
    }
  }
end_of_stream:
  free(v6);
  *size = v9;
  if ( !v9 )
  {
    free(v3);
    return 0LL;
  }
  return v3;
}
