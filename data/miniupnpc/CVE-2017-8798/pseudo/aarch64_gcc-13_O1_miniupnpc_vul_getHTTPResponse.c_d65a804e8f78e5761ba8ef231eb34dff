void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x23
  unsigned int v4; // w20
  unsigned int v5; // w28
  int v6; // w25
  int v7; // w0
  int v8; // w22
  bool v9; // cc
  int v10; // w1
  int v11; // w4
  int v12; // w1
  int v13; // w27
  int v14; // w21
  int v15; // w3
  __int64 v16; // x0
  int i; // w19
  int v18; // w2
  int v19; // w3
  bool v20; // zf
  char *v21; // x1
  int v22; // w1
  int v25; // w2
  int v27; // w1
  bool v29; // zf
  int v31; // w0
  const char *v32; // x21
  int v33; // w21
  int v34; // w19
  const unsigned __int16 *v35; // x4
  __int64 v36; // x1
  unsigned int v37; // w3
  char *v39; // x1
  int v40; // w0
  int v42; // w26
  char *v43; // x1
  char *v44; // x20
  int v45; // w0
  int v46; // w2
  unsigned int v47; // w22
  int v48; // w1
  size_t v49; // x1
  char *v50; // x22
  unsigned int v52; // w19
  int v54; // w26
  char *v55; // x0
  char *tmp; // [xsp+60h] [xbp+60h]
  unsigned int content_buf_len; // [xsp+6Ch] [xbp+6Ch]
  char *s1; // [xsp+70h] [xbp+70h]
  char *s1a; // [xsp+70h] [xbp+70h]
  int content_length; // [xsp+78h] [xbp+78h]
  int endofheaders; // [xsp+7Ch] [xbp+7Ch]
  unsigned int header_buf_used; // [xsp+88h] [xbp+88h]
  int chunked; // [xsp+90h] [xbp+90h]
  unsigned int header_buf_len; // [xsp+94h] [xbp+94h]
  size_t v67; // [xsp+98h] [xbp+98h]
  char chunksize_buf[32]; // [xsp+B8h] [xbp+B8h] BYREF
  char buf[2048]; // [xsp+D8h] [xbp+D8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
  {
    *size = -1;
    return 0LL;
  }
  tmp = (char *)malloc(0x800uLL);
  if ( !tmp )
  {
    free(v3);
    *size = -1;
    return tmp;
  }
  chunksize_buf[0] = 0;
  v4 = 0;
  v5 = 0;
  content_buf_len = 2048;
  header_buf_used = 0;
  header_buf_len = 2048;
  v6 = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  while ( 1 )
  {
    v33 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v33 <= 0 )
      break;
    if ( endofheaders )
    {
      if ( chunked )
        goto LABEL_97;
      goto LABEL_159;
    }
    v54 = v33 + header_buf_used;
    if ( v33 + header_buf_used > header_buf_len )
    {
      v55 = (char *)realloc(v3, (unsigned int)v54);
      if ( !v55 )
      {
        free(v3);
        free(tmp);
        *size = -1;
        return 0LL;
      }
      header_buf_len = v33 + header_buf_used;
      v3 = v55;
    }
    memcpy(&v3[header_buf_used], buf, v33);
    if ( v54 <= 1 )
    {
      header_buf_used += v33;
    }
    else
    {
      v7 = 0;
      do
      {
        v10 = (unsigned __int8)v3[v7];
        if ( v10 == 13 )
        {
          if ( v3[v7 + 1] == 10 )
          {
            if ( v7 + 2 >= v54 )
            {
              v7 += 2;
              v8 = 0;
            }
            else if ( v3[v7 + 2] == 13 )
            {
              v12 = v7 + 3;
              if ( v7 + 3 >= v54 )
              {
                v7 += 3;
                v8 = 0;
              }
              else
              {
                v8 = v7 + 4;
                v7 += 3;
                if ( v3[v12] != 10 )
                  v8 = 0;
              }
            }
            else
            {
              v7 += 2;
              v8 = 0;
            }
          }
          else
          {
            ++v7;
            v8 = endofheaders;
          }
        }
        else
        {
          v8 = endofheaders;
          if ( v10 == 10 )
          {
            v11 = (unsigned __int8)v3[v7 + 1];
            v8 = v7 + 2;
            ++v7;
            if ( v11 != 10 )
              v8 = endofheaders;
          }
        }
        ++v7;
        if ( v8 )
          v9 = 0;
        else
          v9 = v7 < v54 - 1;
      }
      while ( v9 );
      if ( v8 )
      {
        v13 = v8 - 1;
        if ( v8 - 1 > 0 )
        {
          v14 = 0;
          v15 = 0;
          LODWORD(v16) = 0;
          for ( i = 0; i < v13; ++i )
          {
            if ( (int)v16 <= 0 || (int)v16 < v15 )
            {
              v22 = (unsigned __int8)v3[i];
              if ( v22 != 13 && v22 != 10 )
                continue;
              if ( (_DWORD)v16 )
                v29 = 1;
              else
                v29 = status_code == 0LL;
              if ( !v29 )
              {
                if ( i > 0 )
                {
                  v32 = v3 + 1;
                  while ( 1 )
                  {
                    if ( *(v32 - 1) == 32 )
                    {
                      if ( (*status_code & 0x80000000) == 0 )
                        goto LABEL_58;
                      *status_code = strtol(v32, 0uLL, 10);
                    }
                    if ( ++v32 == &v3[i + 1] )
                      goto LABEL_58;
                  }
                }
LABEL_59:
                v16 = i;
                do
                {
                  i = v16;
                  v27 = (unsigned __int8)v3[v16];
                  if ( v27 != 13 && v27 != 10 )
                  {
                    v14 = endofheaders;
                    v15 = v16;
                    goto LABEL_47;
                  }
                  ++v16;
                }
                while ( v54 > (int)v16 );
                ++i;
                v14 = endofheaders;
                v15 = i;
                LODWORD(v16) = i;
                continue;
              }
              if ( (int)v16 < v15 && v15 < v14 )
              {
                s1 = &v3[(int)v16];
                v67 = v15 - (int)v16;
                if ( !strncasecmp(s1, "content-length", v67) )
                {
                  content_length = strtol(&v3[v14], 0uLL, 10);
                }
                else if ( !strncasecmp(s1, "transfer-encoding", v67) )
                {
                  v20 = strncasecmp(&v3[v14], "chunked", 7uLL) == 0;
                  v31 = chunked;
                  if ( v20 )
                    v31 = 1;
                  chunked = v31;
                }
              }
            }
            else
            {
              v21 = &v3[i];
              v25 = (unsigned __int8)*v21;
              if ( v25 == 58 )
              {
                if ( v13 <= i )
                {
                  v18 = i;
                }
                else
                {
                  v18 = i;
                  while ( 1 )
                  {
                    v19 = (unsigned __int8)v21[1];
                    v20 = v19 == 32 || v19 == 9;
                    if ( !v20 )
                      break;
                    ++v18;
                    ++v21;
                    if ( v18 == v8 - 1 )
                    {
                      v18 = v8 - 1;
                      break;
                    }
                  }
                }
                v14 = v18 + 1;
                v15 = i;
                i = v18;
                continue;
              }
              if ( v25 != 10 && v25 != 13 )
                continue;
            }
LABEL_58:
            if ( v54 > i )
              goto LABEL_59;
            v14 = 0;
            v15 = i;
            LODWORD(v16) = i;
LABEL_47:
            ;
          }
        }
        v33 = v54 - v8;
        memcpy(buf, &v3[v8], v54 - v8);
        if ( chunked )
        {
          if ( v33 <= 0 )
          {
            header_buf_used = v54;
            endofheaders = v8;
            goto LABEL_166;
          }
          header_buf_used = v54;
          endofheaders = v8;
LABEL_97:
          v34 = 0;
LABEL_137:
          if ( v6 )
          {
LABEL_138:
            v47 = v33 - v34;
            if ( v33 - v34 > v6 )
              v47 = v6;
            v42 = v47 + v5;
            if ( v47 + v5 > content_buf_len )
            {
              if ( v42 <= content_length )
                v48 = content_length;
              else
                v48 = v47 + v5;
              content_buf_len = v48;
              if ( v42 <= content_length )
                v49 = (unsigned int)content_length;
              else
                v49 = (unsigned int)v42;
              s1a = (char *)realloc(tmp, v49);
              if ( !s1a )
                goto LABEL_134;
              tmp = s1a;
            }
            memcpy(&tmp[v5], &buf[v34], v47);
            v34 += v47;
            v6 -= v47;
            if ( v33 <= v34 )
            {
              v5 += v47;
              goto LABEL_166;
            }
            goto LABEL_136;
          }
          if ( v4 )
          {
LABEL_104:
            if ( v34 >= v33 )
              goto LABEL_166;
          }
          else
          {
            if ( buf[v34] == 13 )
              ++v34;
            if ( v33 <= v34 )
              goto LABEL_166;
            if ( buf[v34] == 10 )
            {
              ++v34;
              goto LABEL_104;
            }
          }
          v35 = *_ctype_b_loc();
          v36 = v34 + 1;
          v37 = v33 + v4 - v34;
          while ( (v35[(unsigned __int8)buf[v36 - 1]] & 0x1000) != 0 && v4 <= 0x1E )
          {
            chunksize_buf[v4] = buf[v36 - 1];
            chunksize_buf[v4 + 1] = 0;
            if ( v4 + 1 == v37 )
            {
              v34 = v36;
              v4 = v37;
              goto LABEL_114;
            }
            ++v36;
            ++v4;
          }
          v34 = v36 - 1;
LABEL_114:
          if ( v34 >= v33 )
            goto LABEL_166;
          v39 = &buf[v34];
          while ( 1 )
          {
            v40 = (unsigned __int8)*v39;
            if ( v40 == 10 || v40 == 13 )
              break;
            ++v34;
            ++v39;
            if ( v33 == v34 )
              goto LABEL_166;
          }
          if ( v33 <= v34 )
            goto LABEL_166;
          if ( buf[v34] == 13 && v33 <= ++v34 )
            goto LABEL_166;
          v42 = v5;
          if ( buf[v34] == 10 )
          {
            if ( !v4 )
              break;
            v43 = chunksize_buf;
            v44 = &chunksize_buf[v4];
            v45 = 0;
            do
            {
              v46 = (unsigned __int8)*v43;
              if ( (unsigned __int8)(v46 - 0x30) > 9u )
                v45 = (v46 | 0x20) + 16 * v45 - 0x57;
              else
                v45 = v46 + 16 * v45 - 0x30;
              ++v43;
            }
            while ( v43 != v44 );
            chunksize_buf[0] = 0;
            ++v34;
            if ( !v45 )
              break;
            v4 = 0;
            v6 = v45;
            goto LABEL_138;
          }
LABEL_136:
          v5 = v42;
          goto LABEL_137;
        }
        header_buf_used = v54;
        endofheaders = v8;
LABEL_159:
        if ( content_length <= 0 )
          goto LABEL_162;
        v52 = v33 + v5;
        if ( (int)(v33 + v5) > content_length )
        {
          v33 = content_length - v5;
LABEL_162:
          v52 = v33 + v5;
          if ( v33 + v5 <= content_buf_len )
          {
            v50 = tmp;
            goto LABEL_165;
          }
          content_buf_len = v33 + v5;
          if ( (int)v52 > content_length )
            goto LABEL_164;
          goto LABEL_157;
        }
        v50 = tmp;
        if ( v52 <= content_buf_len )
          goto LABEL_165;
LABEL_157:
        content_buf_len = content_length;
LABEL_164:
        v50 = (char *)realloc(tmp, content_buf_len);
        if ( !v50 )
        {
LABEL_134:
          free(tmp);
          free(v3);
          *size = -1;
          return 0LL;
        }
LABEL_165:
        memcpy(&v50[v5], buf, v33);
        v5 = v52;
        tmp = v50;
LABEL_166:
        if ( content_length > 0 && (int)v5 >= content_length )
          break;
      }
      else
      {
        header_buf_used += v33;
        endofheaders = 0;
      }
    }
  }
  free(v3);
  *size = v5;
  if ( !v5 )
  {
    free(tmp);
    return 0LL;
  }
  return tmp;
}
