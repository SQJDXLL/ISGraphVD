void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  unsigned int v3; // ebp
  char *v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  char v8; // al
  int v9; // esi
  signed int v10; // eax
  signed int v11; // edi
  unsigned int v12; // esi
  unsigned int v13; // eax
  char *v14; // eax
  char *v16; // ebp
  int v17; // eax
  int v18; // esi
  int v19; // ecx
  char v20; // dl
  size_t v21; // edi
  int v22; // esi
  signed int v23; // edi
  int v24; // esi
  size_t v25; // edi
  unsigned int v26; // ecx
  size_t v27; // eax
  char *v28; // eax
  char *v29; // edx
  unsigned int v30; // ecx
  char v31; // al
  const unsigned __int16 *v32; // ecx
  unsigned int v33; // edx
  int v34; // edx
  char v35; // al
  signed int v36; // eax
  signed int v37; // ecx
  char v38; // dl
  const char *v39; // edx
  int *v40; // ebp
  const char *v41; // ecx
  const char *v42; // esi
  const char *v43; // edi
  char *v44; // ecx
  int v45; // edx
  char *v46; // ebp
  int v47; // eax
  bool v48; // zf
  int v49; // eax
  int v50; // edx
  char v51; // cl
  int v52; // edi
  char *v53; // [esp-10h] [ebp-8ACh]
  int n; // [esp+0h] [ebp-89Ch]
  int na; // [esp+0h] [ebp-89Ch]
  unsigned int content_buf_used; // [esp+4h] [ebp-898h]
  unsigned int chunksize; // [esp+8h] [ebp-894h]
  unsigned int chunksizea; // [esp+8h] [ebp-894h]
  signed int header_buf_used_0; // [esp+Ch] [ebp-890h]
  int header_buf_used_0a; // [esp+Ch] [ebp-890h]
  char *content_buf; // [esp+10h] [ebp-88Ch]
  int chunked; // [esp+18h] [ebp-884h]
  int chunkeda; // [esp+18h] [ebp-884h]
  unsigned int content_buf_len; // [esp+1Ch] [ebp-880h]
  int content_length; // [esp+20h] [ebp-87Ch]
  char *header_buf; // [esp+24h] [ebp-878h]
  int valuestart; // [esp+28h] [ebp-874h]
  unsigned int chunksize_buf_index; // [esp+2Ch] [ebp-870h]
  unsigned int header_buf_len; // [esp+30h] [ebp-86Ch]
  int v70; // [esp+34h] [ebp-868h]
  char *v71; // [esp+38h] [ebp-864h]
  int *v72; // [esp+3Ch] [ebp-860h]
  int i; // [esp+40h] [ebp-85Ch]
  size_t v74; // [esp+44h] [ebp-858h]
  char *s2; // [esp+48h] [ebp-854h]
  int *v76; // [esp+4Ch] [ebp-850h]
  char chunksize_buf[32]; // [esp+5Ch] [ebp-840h] BYREF
  char buf[2048]; // [esp+7Ch] [ebp-820h] BYREF
  unsigned int v79; // [esp+87Ch] [ebp-20h]

  v76 = size;
  v72 = status_code;
  v79 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    content_buf = 0;
    *v76 = -1;
    return content_buf;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    free(header_buf);
    *v76 = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  v3 = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  chunksize_buf_index = 0;
  s2 = "content-length";
  do
  {
    while ( 1 )
    {
      n = receivedata(s, buf, 2048, 5000, 0);
      if ( n <= 0 )
        goto end_of_stream;
      if ( chunksize_buf_index )
      {
        v11 = n;
        if ( chunked )
          goto LABEL_53;
LABEL_24:
        v12 = content_buf_used + v11;
        v13 = content_length;
        if ( content_length <= 0 )
        {
          if ( content_buf_len >= v12 )
            goto LABEL_33;
          if ( content_length )
          {
            content_buf_len = content_buf_used + v11;
LABEL_31:
            v14 = (char *)realloc(content_buf, content_buf_len);
            if ( !v14 )
            {
LABEL_138:
              free(content_buf);
              v53 = header_buf;
LABEL_139:
              free(v53);
              *v76 = -1;
              return 0;
            }
            content_buf = v14;
LABEL_33:
            memcpy(&content_buf[content_buf_used], buf, v11);
            content_buf_used = v12;
            chunked = 0;
            goto LABEL_34;
          }
          v13 = 0;
        }
        else
        {
          if ( content_length < v12 )
          {
            v12 = content_length;
            v11 = content_length - content_buf_used;
          }
          if ( content_buf_len >= v12 )
            goto LABEL_33;
        }
        if ( v12 >= v13 )
          v13 = v12;
        content_buf_len = v13;
        goto LABEL_31;
      }
      header_buf_used_0 = valuestart + n;
      if ( valuestart + n <= header_buf_len )
        goto LABEL_11;
      v4 = (char *)realloc(header_buf, valuestart + n);
      if ( !v4 )
      {
        free(header_buf);
        v53 = content_buf;
        goto LABEL_139;
      }
      header_buf = v4;
      header_buf_len = header_buf_used_0;
LABEL_11:
      memcpy(&header_buf[valuestart], buf, n);
      v5 = header_buf_used_0;
      v6 = 0;
      v7 = header_buf_used_0 - 1;
      if ( header_buf_used_0 - 1 <= 0 )
        goto LABEL_22;
LABEL_12:
      v8 = header_buf[v6];
      v9 = v6 + 1;
      if ( v8 == 13 )
        goto LABEL_16;
LABEL_13:
      if ( v8 != 10 )
        break;
      v6 += 2;
      if ( header_buf[v9] == 10 )
        goto LABEL_43;
LABEL_20:
      if ( v7 > v6 )
        goto LABEL_12;
LABEL_21:
      v5 = header_buf_used_0;
LABEL_22:
      valuestart = v5;
    }
    while ( 2 )
    {
      if ( v7 <= v9 )
        goto LABEL_21;
      v6 = v9;
      v8 = header_buf[v9++];
      if ( v8 != 13 )
        goto LABEL_13;
LABEL_16:
      v10 = v6 + 2;
      if ( header_buf[v6 + 1] != 10 )
      {
        if ( v7 <= v10 )
          goto LABEL_21;
        v6 += 2;
        goto LABEL_12;
      }
      v9 = v6 + 3;
      if ( header_buf_used_0 <= v10 || header_buf[v10] != 13 )
        continue;
      break;
    }
    v6 += 4;
    if ( header_buf_used_0 <= v9 || header_buf[v9] != 10 )
      goto LABEL_20;
LABEL_43:
    chunksize_buf_index = v3;
    v16 = header_buf;
    valuestart = 0;
    v17 = 0;
    v71 = "transfer-encoding";
    na = v9;
    v18 = 0;
    v70 = v6;
    v19 = 0;
    while ( 2 )
    {
      v20 = v16[v18];
      v21 = v18 + 1;
      if ( v17 <= 0 || v17 < v19 )
      {
        if ( v20 == 13 || v20 == 10 )
        {
          if ( !v17 && v72 )
          {
            if ( v18 > 0 )
            {
              v39 = v16 + 1;
              valuestart = (int)v16;
              v40 = v72;
              v41 = &v39[v18];
              i = v18;
              v42 = v39;
              v74 = v21;
              v43 = v41;
              while ( 1 )
              {
                if ( *(v42 - 1) == 32 )
                {
                  if ( *v40 >= 0 )
                  {
LABEL_85:
                    v16 = (char *)valuestart;
                    v18 = i;
                    v21 = v74;
                    goto LABEL_86;
                  }
                  *v40 = strtol(v42, 0, 10);
                }
                if ( ++v42 == v43 )
                  goto LABEL_85;
              }
            }
            goto LABEL_86;
          }
          if ( v17 >= v19 || valuestart <= v19 )
            goto LABEL_86;
          v74 = v19 - v17;
          i = (int)&v16[v17];
          if ( !strncasecmp(&v16[v17], s2, v19 - v17) )
          {
            content_length = strtol(&v16[valuestart], 0, 10);
            goto LABEL_86;
          }
          if ( !strncasecmp((const char *)i, v71, v74) )
          {
            v48 = strncasecmp(&v16[valuestart], "chunked", 7u) == 0;
            v49 = 1;
            if ( !v48 )
              v49 = chunked;
            chunked = v49;
            v36 = header_buf_used_0;
            if ( v18 >= header_buf_used_0 )
            {
LABEL_127:
              valuestart = 0;
              v19 = v18;
              v17 = v18;
              goto LABEL_49;
            }
          }
          else
          {
LABEL_86:
            v36 = header_buf_used_0;
            if ( v18 >= header_buf_used_0 )
              goto LABEL_127;
          }
          v37 = v36;
          while ( 1 )
          {
            v38 = v16[v18];
            v17 = v18;
            v18 = v21;
            if ( v38 != 13 && v38 != 10 )
            {
              valuestart = 0;
              v19 = v17;
              goto LABEL_50;
            }
            if ( v37 == v21 )
              break;
            ++v21;
          }
          v18 = v17 + 2;
          v17 = header_buf_used_0;
          valuestart = 0;
          v19 = header_buf_used_0;
        }
        else
        {
LABEL_49:
          v18 = v21;
        }
      }
      else
      {
        if ( v20 != 58 )
        {
          if ( v20 != 13 && v20 != 10 )
            goto LABEL_49;
          goto LABEL_86;
        }
        valuestart = v17;
        v50 = v18;
        while ( 1 )
        {
          v51 = v16[v50 + 1];
          v52 = v50++;
          if ( v51 != 32 && v51 != 9 )
            break;
          if ( na <= v50 )
          {
            v17 = valuestart;
            goto LABEL_133;
          }
        }
        v17 = valuestart;
        v50 = v52;
LABEL_133:
        v19 = v18;
        valuestart = v50 + 1;
        v18 = v50 + 1;
      }
LABEL_50:
      if ( na > v18 )
        continue;
      break;
    }
    v22 = header_buf_used_0;
    v3 = chunksize_buf_index;
    v23 = header_buf_used_0;
    header_buf_used_0a = v70;
    v11 = v23 - v70;
    n = v11;
    memcpy(buf, &header_buf[v70], v11);
    valuestart = v22;
    chunksize_buf_index = header_buf_used_0a;
    if ( !chunked )
      goto LABEL_24;
    if ( v11 > 0 )
    {
LABEL_53:
      v24 = 0;
LABEL_65:
      if ( chunksize )
        goto LABEL_54;
      if ( v3 )
      {
LABEL_69:
        if ( v24 >= n )
        {
          v33 = v3;
          goto LABEL_114;
        }
      }
      else
      {
        v31 = buf[v24];
        if ( v31 != 13 )
        {
          if ( v31 != 10 )
            goto LABEL_69;
LABEL_135:
          ++v24;
          goto LABEL_69;
        }
        if ( ++v24 >= n )
        {
          v33 = 0;
LABEL_114:
          v3 = v33;
LABEL_115:
          chunked = 1;
          continue;
        }
        if ( buf[v24] == 10 )
          goto LABEL_135;
      }
      v32 = *_ctype_b_loc();
      while ( 1 )
      {
        v34 = buf[v24];
        v35 = buf[v24];
        if ( (v32[v34] & 0x1000) == 0 || v3 > 0x1E )
          break;
        chunksize_buf[v3] = v34;
        v33 = v3 + 1;
        ++v24;
        chunksize_buf[v3 + 1] = 0;
        if ( v24 >= n )
          goto LABEL_114;
        ++v3;
      }
      if ( v24 >= n )
        goto LABEL_115;
      while ( v35 != 10 && v35 != 13 )
      {
        if ( ++v24 == n )
          goto LABEL_115;
        v35 = buf[v24];
      }
      if ( v24 >= n )
        goto LABEL_115;
      if ( v35 == 13 )
      {
        if ( ++v24 >= n )
          goto LABEL_115;
        if ( buf[v24] != 10 )
        {
          v30 = content_buf_used;
          goto LABEL_64;
        }
      }
      if ( !v3 )
        break;
      v44 = chunksize_buf;
      v45 = 0;
      v46 = &chunksize_buf[v3];
      do
      {
        while ( 1 )
        {
          v47 = *v44;
          chunksizea = 16 * v45;
          if ( (unsigned __int8)(v47 - 48) > 9u )
            break;
          ++v44;
          v45 = chunksizea + v47 - 48;
          if ( v46 == v44 )
            goto LABEL_110;
        }
        ++v44;
        v45 = chunksizea + (char)(v47 | 0x20) - 87;
      }
      while ( v46 != v44 );
LABEL_110:
      chunksize_buf[0] = 0;
      ++v24;
      if ( !v45 )
        break;
      chunksize = v45;
      v3 = 0;
LABEL_54:
      v25 = n - v24;
      if ( n - v24 > chunksize )
        v25 = chunksize;
      v26 = v25 + content_buf_used;
      if ( v25 + content_buf_used > content_buf_len )
      {
        v27 = content_length;
        if ( content_length < v26 )
          v27 = v25 + content_buf_used;
        if ( content_length < 0 )
          v27 = v25 + content_buf_used;
        content_buf_len = v27;
        v28 = (char *)realloc(content_buf, v27);
        v26 = v25 + content_buf_used;
        if ( !v28 )
          goto LABEL_138;
        content_buf = v28;
      }
      chunkeda = v26;
      v29 = &buf[v24];
      v24 += v25;
      memcpy(&content_buf[content_buf_used], v29, v25);
      chunksize -= v25;
      v30 = chunkeda;
      if ( v24 >= n )
      {
        content_buf_used = chunkeda;
        chunked = 1;
        continue;
      }
LABEL_64:
      content_buf_used = v30;
      goto LABEL_65;
    }
LABEL_34:
    ;
  }
  while ( content_length <= 0 || content_buf_used < content_length );
end_of_stream:
  free(header_buf);
  *v76 = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
