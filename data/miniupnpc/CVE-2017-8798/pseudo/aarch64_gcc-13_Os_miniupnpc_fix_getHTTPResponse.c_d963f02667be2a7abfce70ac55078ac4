void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x19
  char *v4; // x20
  char *v5; // x0
  unsigned int v6; // w26
  unsigned int v7; // w24
  unsigned int v8; // w27
  int v9; // w21
  int v10; // w22
  int v11; // w28
  int v12; // w25
  char *v13; // x0
  int v14; // w1
  int v15; // w4
  int v16; // w2
  int v17; // w0
  int v18; // w28
  __int64 v19; // x25
  int v20; // w2
  int v21; // w0
  int v22; // w5
  __int64 v23; // x27
  bool v24; // cc
  int v25; // w5
  int v26; // w2
  bool v27; // zf
  bool v29; // zf
  const char *v30; // x2
  int i; // w4
  int v32; // w0
  int v34; // w0
  const char *v36; // x28
  int v37; // w0
  char *v38; // x1
  const unsigned __int16 **v39; // x0
  unsigned __int8 v40; // w2
  __int64 j; // x0
  int v42; // w1
  unsigned int v43; // w4
  __int64 v44; // x1
  int v45; // w4
  int v46; // w0
  unsigned int v47; // w2
  unsigned int v48; // w5
  int v49; // w0
  unsigned int v50; // w5
  unsigned int v51; // w6
  char *v52; // x0
  char *v54; // x0
  char *v55; // x0
  unsigned int chunksize_buf_index; // [xsp+70h] [xbp+70h]
  int chunked; // [xsp+74h] [xbp+74h]
  unsigned int chunksize; // [xsp+80h] [xbp+80h]
  unsigned int chunksizea; // [xsp+80h] [xbp+80h]
  unsigned int chunksizeb; // [xsp+80h] [xbp+80h]
  unsigned int header_buf_len; // [xsp+84h] [xbp+84h]
  int content_buf_used; // [xsp+88h] [xbp+88h]
  _BYTE *content_buf_useda; // [xsp+88h] [xbp+88h]
  unsigned int content_buf_usedb; // [xsp+88h] [xbp+88h]
  unsigned int content_buf_usedc; // [xsp+88h] [xbp+88h]
  const char *bytestocopya; // [xsp+90h] [xbp+90h]
  size_t bytestocopy; // [xsp+90h] [xbp+90h]
  unsigned int bytestocopyb; // [xsp+90h] [xbp+90h]
  unsigned int bytestocopyc; // [xsp+90h] [xbp+90h]
  int sp; // [xsp+9Ch] [xbp+9Ch]
  int spa; // [xsp+9Ch] [xbp+9Ch]
  char chunksize_buf[32]; // [xsp+A8h] [xbp+A8h] BYREF
  char buf[2048]; // [xsp+C8h] [xbp+C8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
    goto LABEL_4;
  v4 = (char *)malloc(0x800uLL);
  if ( !v4 )
    goto LABEL_8;
  v6 = 2048;
  v7 = 0;
  v8 = 0;
  v9 = -1;
  v10 = 0;
  chunksize_buf_index = 0;
  chunked = 0;
  chunksize = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
    v11 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v11 <= 0 )
      break;
    if ( v10 )
      goto LABEL_23;
    v12 = v11 + v8;
    if ( v11 + v8 > header_buf_len )
    {
      v13 = (char *)realloc(v3, (unsigned int)v12);
      if ( !v13 )
      {
        free(v3);
        v5 = v4;
        goto LABEL_9;
      }
      v3 = v13;
      header_buf_len = v11 + v8;
    }
    memcpy(&v3[v8], buf, v11);
    v14 = 0;
    v10 = 0;
    while ( v12 - 1 > v14 )
    {
      if ( v10 )
        goto LABEL_20;
      v20 = (unsigned __int8)v3[v14];
      v21 = v14 + 1;
      if ( v20 == 13 )
      {
        if ( v3[v21] == 10 )
        {
          v21 = v14 + 2;
          if ( v12 > v14 + 2 && v3[v21] == 13 )
          {
            v21 = v14 + 3;
            if ( v12 > v14 + 3 && v3[v21] == 10 )
              v10 = v14 + 4;
          }
        }
      }
      else if ( v20 == 10 )
      {
        if ( v3[v21] == 10 )
          v10 = v14 + 2;
      }
      else
      {
        v21 = v14;
      }
      v14 = v21 + 1;
    }
    if ( v10 )
    {
LABEL_20:
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      content_buf_used = v10 - 1;
      while ( content_buf_used > v18 )
      {
        v22 = (unsigned __int8)v3[v18];
        v23 = v18;
        v24 = v17 <= 0 || v17 < v16;
        if ( v24 || v22 != 58 )
        {
          if ( v22 == 13 || v22 == 10 )
          {
            if ( v17 )
              v29 = 1;
            else
              v29 = status_code == 0LL;
            if ( !v29 )
            {
              v30 = v3 + 1;
              for ( i = 0; ; ++i )
              {
                if ( v18 <= i )
                  goto LABEL_61;
                if ( *(v30 - 1) == 32 )
                {
                  sp = i;
                  if ( (*status_code & 0x80000000) == 0 )
                    goto LABEL_61;
                  bytestocopya = v30;
                  v34 = atoi(v30);
                  v30 = bytestocopya;
                  i = sp;
                  *status_code = v34;
                }
                ++v30;
              }
            }
            spa = v15;
            if ( v17 < v16 && v16 < v15 )
            {
              v36 = &v3[v17];
              bytestocopy = v16 - v17;
              if ( !strncasecmp(v36, "content-length", bytestocopy) )
              {
                v9 = atoi(&v3[spa]);
              }
              else if ( !strncasecmp(v36, "transfer-encoding", bytestocopy) )
              {
                v27 = strncasecmp(&v3[spa], "chunked", 7uLL) == 0;
                v37 = chunked;
                if ( v27 )
                  v37 = 1;
                chunked = v37;
              }
            }
LABEL_61:
            while ( 1 )
            {
              v25 = v23;
              if ( v12 <= (int)v23 )
                break;
              v32 = (unsigned __int8)v3[v23++];
              if ( v32 != 13 && v32 != 10 )
              {
                v18 = v25;
                v17 = v25;
                v15 = 0;
                goto LABEL_49;
              }
            }
            v18 = v23;
            v17 = v23;
            v15 = 0;
          }
          else
          {
            v25 = v18;
            v18 = v16;
          }
        }
        else
        {
          do
          {
            v25 = v23;
            v15 = v23 + 1;
            if ( content_buf_used <= (int)v23 )
              break;
            v26 = (unsigned __int8)v3[++v23];
            v27 = v26 == 32 || v26 == 9;
          }
          while ( v27 );
        }
LABEL_49:
        v16 = v18;
        v18 = v25 + 1;
      }
      v8 = v12;
      v11 = v12 - v10;
      memcpy(buf, &v3[v10], v12 - v10);
LABEL_23:
      if ( chunked )
      {
        LODWORD(v19) = 0;
        while ( 1 )
        {
          if ( v11 <= (int)v19 )
            goto LABEL_125;
          if ( chunksize )
            break;
          if ( !chunksize_buf_index )
          {
            if ( buf[(int)v19] != 13 || (LODWORD(v19) = v19 + 1, v11 > (int)v19) )
            {
              if ( buf[(int)v19] == 10 )
                LODWORD(v19) = v19 + 1;
            }
          }
          v19 = (int)v19;
          v38 = &chunksize_buf[chunksize_buf_index];
          while ( 1 )
          {
            content_buf_useda = v38;
            if ( v11 <= (int)v19 )
              break;
            v39 = _ctype_b_loc();
            v40 = buf[v19];
            if ( ((*v39)[v40] & 0x1000) == 0 || chunksize_buf_index > 0x1E )
              break;
            ++v19;
            *content_buf_useda = v40;
            v38 = content_buf_useda + 1;
            chunksize_buf[++chunksize_buf_index] = 0;
          }
          for ( j = (int)v19; v11 > (int)j; ++j )
          {
            v42 = (unsigned __int8)buf[j];
            if ( v42 == 13 || v42 == 10 )
              break;
          }
          LODWORD(v19) = j;
          if ( v11 <= (int)j )
            goto LABEL_125;
          if ( buf[(int)j] == 13 )
          {
            LODWORD(v19) = j + 1;
            if ( v11 <= (int)j + 1 )
              goto LABEL_125;
          }
          if ( buf[(int)v19] == 10 )
          {
            v43 = 0;
            v44 = 0LL;
            while ( chunksize_buf_index > (unsigned int)v44 )
            {
              v45 = 16 * v43;
              v46 = (unsigned __int8)chunksize_buf[v44++];
              v47 = v45 - 0x30 + v46;
              v48 = (unsigned __int8)(v46 - 0x30);
              v49 = (v46 | 0x20) + v45 - 0x57;
              if ( v48 <= 9 )
                v43 = v47;
              else
                v43 = v49;
            }
            chunksize_buf[0] = 0;
            LODWORD(v19) = v19 + 1;
            if ( !v43 )
              goto end_of_stream;
            chunksize_buf_index = 0;
LABEL_111:
            v50 = v11 - v19;
            if ( v11 - (int)v19 > v43 )
              v50 = v43;
            v51 = v7 + v50;
            if ( v7 + v50 > v6 )
            {
              if ( (v9 & 0x80000000) != 0 )
              {
                v6 = v7 + v50;
              }
              else if ( v9 < v51 )
              {
                v6 = v7 + v50;
              }
              else
              {
                v6 = v9;
              }
              chunksizea = v7 + v50;
              content_buf_usedb = v43;
              bytestocopyb = v50;
              v52 = (char *)realloc(v4, v6);
              v51 = chunksizea;
              v43 = content_buf_usedb;
              v50 = bytestocopyb;
              if ( !v52 )
                goto LABEL_119;
              v4 = v52;
            }
            chunksizeb = v50;
            content_buf_usedc = v51;
            bytestocopyc = v43;
            memcpy(&v4[v7], &buf[(int)v19], v50);
            LODWORD(v19) = v19 + chunksizeb;
            v7 = content_buf_usedc;
            chunksize = bytestocopyc - chunksizeb;
          }
        }
        v43 = chunksize;
        goto LABEL_111;
      }
      if ( v9 > 0 && v9 < v11 + v7 )
        v11 = v9 - v7;
      if ( v11 + v7 > v6 )
      {
        if ( (v9 & 0x80000000) != 0 )
        {
          v6 = v11 + v7;
        }
        else if ( v9 < v11 + v7 )
        {
          v6 = v11 + v7;
        }
        else
        {
          v6 = v9;
        }
        v54 = (char *)realloc(v4, v6);
        if ( !v54 )
        {
LABEL_119:
          free(v4);
LABEL_8:
          v5 = v3;
LABEL_9:
          free(v5);
LABEL_4:
          *size = -1;
          return 0LL;
        }
        v4 = v54;
      }
      v55 = &v4[v7];
      v7 += v11;
      memcpy(v55, buf, v11);
LABEL_125:
      if ( v9 > 0 && v9 <= v7 )
        break;
    }
    else
    {
      v8 += v11;
    }
  }
end_of_stream:
  free(v3);
  *size = v7;
  if ( !v7 )
  {
    free(v4);
    return 0LL;
  }
  return v4;
}
