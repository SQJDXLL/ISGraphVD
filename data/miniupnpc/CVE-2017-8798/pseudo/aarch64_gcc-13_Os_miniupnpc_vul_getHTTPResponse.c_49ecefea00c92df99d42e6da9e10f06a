void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x19
  char *v4; // x20
  char *v5; // x0
  unsigned int v6; // w27
  unsigned int v7; // w24
  unsigned int v8; // w28
  int v9; // w21
  int v10; // w22
  int v11; // w26
  int v12; // w25
  char *v13; // x0
  int v14; // w1
  int v15; // w4
  int v16; // w2
  int v17; // w0
  int v18; // w26
  __int64 v19; // x25
  int v20; // w2
  int v21; // w0
  int v22; // w5
  __int64 v23; // x28
  bool v24; // cc
  int v25; // w5
  int v26; // w2
  bool v27; // zf
  bool v29; // zf
  const char *v30; // x2
  int i; // w4
  int v32; // w0
  int v34; // w0
  const char *v36; // x26
  int v37; // w0
  char *v38; // x1
  __int64 j; // x0
  int v40; // w1
  int v41; // w4
  __int64 v42; // x1
  int v43; // w4
  int v44; // w0
  int v45; // w2
  unsigned int v46; // w5
  int v47; // w0
  unsigned int v48; // w5
  int v49; // w6
  int v50; // w0
  size_t v51; // x1
  char *v52; // x0
  int v54; // w25
  int v55; // w0
  size_t v56; // x1
  char *v57; // x0
  char *v58; // x0
  unsigned int content_buf_len; // [xsp+70h] [xbp+70h]
  int chunked; // [xsp+74h] [xbp+74h]
  unsigned int chunksize; // [xsp+80h] [xbp+80h]
  unsigned int chunksizea; // [xsp+80h] [xbp+80h]
  unsigned int chunksizeb; // [xsp+80h] [xbp+80h]
  unsigned int header_buf_len; // [xsp+84h] [xbp+84h]
  int content_buf_used; // [xsp+88h] [xbp+88h]
  char *content_buf_useda; // [xsp+88h] [xbp+88h]
  int content_buf_usedb; // [xsp+88h] [xbp+88h]
  unsigned int content_buf_usedc; // [xsp+88h] [xbp+88h]
  const char *bytestocopya; // [xsp+90h] [xbp+90h]
  size_t bytestocopy; // [xsp+90h] [xbp+90h]
  unsigned int bytestocopyb; // [xsp+90h] [xbp+90h]
  int bytestocopyc; // [xsp+90h] [xbp+90h]
  int sp; // [xsp+9Ch] [xbp+9Ch]
  int spa; // [xsp+9Ch] [xbp+9Ch]
  char chunksize_buf[32]; // [xsp+A8h] [xbp+A8h] BYREF
  char buf[2048]; // [xsp+C8h] [xbp+C8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
    goto LABEL_4;
  v4 = (char *)malloc(0x800uLL);
  if ( !v4 )
    goto LABEL_8;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = -1;
  v10 = 0;
  content_buf_len = 2048;
  chunked = 0;
  chunksize = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
    v11 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v11 <= 0 )
      break;
    if ( v10 )
      goto LABEL_23;
    v12 = v11 + v8;
    if ( v11 + v8 > header_buf_len )
    {
      v13 = (char *)realloc(v3, (unsigned int)v12);
      if ( !v13 )
      {
        free(v3);
        v5 = v4;
        goto LABEL_9;
      }
      v3 = v13;
      header_buf_len = v11 + v8;
    }
    memcpy(&v3[v8], buf, v11);
    v14 = 0;
    v10 = 0;
    while ( v12 - 1 > v14 )
    {
      if ( v10 )
        goto LABEL_20;
      v20 = (unsigned __int8)v3[v14];
      v21 = v14 + 1;
      if ( v20 == 13 )
      {
        if ( v3[v21] == 10 )
        {
          v21 = v14 + 2;
          if ( v12 > v14 + 2 && v3[v21] == 13 )
          {
            v21 = v14 + 3;
            if ( v12 > v14 + 3 && v3[v21] == 10 )
              v10 = v14 + 4;
          }
        }
      }
      else if ( v20 == 10 )
      {
        if ( v3[v21] == 10 )
          v10 = v14 + 2;
      }
      else
      {
        v21 = v14;
      }
      v14 = v21 + 1;
    }
    if ( v10 )
    {
LABEL_20:
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      content_buf_used = v10 - 1;
      while ( content_buf_used > v18 )
      {
        v22 = (unsigned __int8)v3[v18];
        v23 = v18;
        v24 = v17 <= 0 || v17 < v16;
        if ( v24 || v22 != 58 )
        {
          if ( v22 == 13 || v22 == 10 )
          {
            if ( v17 )
              v29 = 1;
            else
              v29 = status_code == 0LL;
            if ( !v29 )
            {
              v30 = v3 + 1;
              for ( i = 0; ; ++i )
              {
                if ( v18 <= i )
                  goto LABEL_61;
                if ( *(v30 - 1) == 32 )
                {
                  sp = i;
                  if ( (*status_code & 0x80000000) == 0 )
                    goto LABEL_61;
                  bytestocopya = v30;
                  v34 = atoi(v30);
                  v30 = bytestocopya;
                  i = sp;
                  *status_code = v34;
                }
                ++v30;
              }
            }
            spa = v15;
            if ( v17 < v16 && v16 < v15 )
            {
              v36 = &v3[v17];
              bytestocopy = v16 - v17;
              if ( !strncasecmp(v36, "content-length", bytestocopy) )
              {
                v9 = atoi(&v3[spa]);
              }
              else if ( !strncasecmp(v36, "transfer-encoding", bytestocopy) )
              {
                v27 = strncasecmp(&v3[spa], "chunked", 7uLL) == 0;
                v37 = chunked;
                if ( v27 )
                  v37 = 1;
                chunked = v37;
              }
            }
LABEL_61:
            while ( 1 )
            {
              v25 = v23;
              if ( v12 <= (int)v23 )
                break;
              v32 = (unsigned __int8)v3[v23++];
              if ( v32 != 13 && v32 != 10 )
              {
                v18 = v25;
                v17 = v25;
                v15 = 0;
                goto LABEL_49;
              }
            }
            v18 = v23;
            v17 = v23;
            v15 = 0;
          }
          else
          {
            v25 = v18;
            v18 = v16;
          }
        }
        else
        {
          do
          {
            v25 = v23;
            v15 = v23 + 1;
            if ( content_buf_used <= (int)v23 )
              break;
            v26 = (unsigned __int8)v3[++v23];
            v27 = v26 == 32 || v26 == 9;
          }
          while ( v27 );
        }
LABEL_49:
        v16 = v18;
        v18 = v25 + 1;
      }
      v8 = v12;
      v11 = v12 - v10;
      memcpy(buf, &v3[v10], v12 - v10);
LABEL_23:
      if ( chunked )
      {
        LODWORD(v19) = 0;
        while ( 1 )
        {
          if ( v11 <= (int)v19 )
            goto LABEL_126;
          if ( chunksize )
            break;
          if ( !v6 )
          {
            if ( buf[(int)v19] != 13 || (LODWORD(v19) = v19 + 1, v11 > (int)v19) )
            {
              if ( buf[(int)v19] == 10 )
                LODWORD(v19) = v19 + 1;
            }
          }
          v19 = (int)v19;
          v38 = &chunksize_buf[v6];
          while ( 1 )
          {
            content_buf_useda = v38;
            if ( v11 <= (int)v19 || ((*_ctype_b_loc())[(unsigned __int8)buf[v19]] & 0x1000) == 0 || v6 > 0x1E )
              break;
            ++v6;
            *content_buf_useda = buf[v19];
            v38 = content_buf_useda + 1;
            ++v19;
            chunksize_buf[v6] = 0;
          }
          for ( j = (int)v19; v11 > (int)j; ++j )
          {
            v40 = (unsigned __int8)buf[j];
            if ( v40 == 13 || v40 == 10 )
              break;
          }
          LODWORD(v19) = j;
          if ( v11 <= (int)j )
            goto LABEL_126;
          if ( buf[(int)j] == 13 )
          {
            LODWORD(v19) = j + 1;
            if ( v11 <= (int)j + 1 )
              goto LABEL_126;
          }
          if ( buf[(int)v19] == 10 )
          {
            v41 = 0;
            v42 = 0LL;
            while ( v6 > (unsigned int)v42 )
            {
              v43 = 16 * v41;
              v44 = (unsigned __int8)chunksize_buf[v42++];
              v45 = v43 - 0x30 + v44;
              v46 = (unsigned __int8)(v44 - 0x30);
              v47 = (v44 | 0x20) + v43 - 0x57;
              if ( v46 <= 9 )
                v41 = v45;
              else
                v41 = v47;
            }
            chunksize_buf[0] = 0;
            LODWORD(v19) = v19 + 1;
            if ( !v41 )
              goto end_of_stream;
            v6 = 0;
LABEL_111:
            v48 = v11 - v19;
            if ( v11 - (int)v19 > v41 )
              v48 = v41;
            v49 = v7 + v48;
            if ( v7 + v48 > content_buf_len )
            {
              chunksizea = v7 + v48;
              if ( v49 <= v9 )
                v50 = v9;
              else
                v50 = v7 + v48;
              if ( v49 <= v9 )
                v51 = (unsigned int)v9;
              else
                v51 = (unsigned int)v49;
              content_buf_len = v50;
              content_buf_usedb = v41;
              bytestocopyb = v48;
              v52 = (char *)realloc(v4, v51);
              v49 = chunksizea;
              v41 = content_buf_usedb;
              v48 = bytestocopyb;
              if ( !v52 )
                goto LABEL_121;
              v4 = v52;
            }
            chunksizeb = v48;
            content_buf_usedc = v49;
            bytestocopyc = v41;
            memcpy(&v4[v7], &buf[(int)v19], v48);
            LODWORD(v19) = v19 + chunksizeb;
            v7 = content_buf_usedc;
            chunksize = bytestocopyc - chunksizeb;
          }
        }
        v41 = chunksize;
        goto LABEL_111;
      }
      if ( v9 > 0 && v9 < (int)(v11 + v7) )
        v11 = v9 - v7;
      v54 = v11 + v7;
      if ( v11 + v7 > content_buf_len )
      {
        if ( v9 >= v54 )
          v55 = v9;
        else
          v55 = v11 + v7;
        if ( v9 >= v54 )
          v56 = (unsigned int)v9;
        else
          v56 = (unsigned int)v54;
        content_buf_len = v55;
        v57 = (char *)realloc(v4, v56);
        if ( !v57 )
        {
LABEL_121:
          free(v4);
LABEL_8:
          v5 = v3;
LABEL_9:
          free(v5);
LABEL_4:
          *size = -1;
          return 0LL;
        }
        v4 = v57;
      }
      v58 = &v4[v7];
      v7 += v11;
      memcpy(v58, buf, v11);
LABEL_126:
      if ( v9 > 0 && (int)v7 >= v9 )
        break;
    }
    else
    {
      v8 += v11;
    }
  }
end_of_stream:
  free(v3);
  *size = v7;
  if ( !v7 )
  {
    free(v4);
    return 0LL;
  }
  return v4;
}
