void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x22
  unsigned int v4; // w19
  unsigned int v5; // w23
  unsigned int v6; // w24
  int v7; // w26
  unsigned int v8; // w28
  int v9; // w27
  unsigned int v10; // w6
  char *v11; // x0
  int v12; // w6
  int v13; // w3
  int v14; // w0
  int v15; // w25
  _BOOL4 v16; // w1
  int v18; // w1
  int v19; // w2
  int v20; // w9
  int v21; // w10
  int v22; // w2
  int v23; // w1
  int v24; // w3
  int v25; // w0
  __int64 v26; // x27
  bool v27; // cc
  int v28; // w7
  bool v29; // zf
  int v30; // w25
  unsigned int v31; // w2
  unsigned int v32; // w6
  char *v33; // x1
  char *v34; // x0
  char *v35; // x1
  unsigned int v38; // w2
  int v39; // w0
  char *v40; // x0
  _BOOL4 v41; // w3
  char *v42; // x0
  size_t v45; // x2
  int v46; // w0
  int v47; // w0
  int v48; // w0
  int v49; // w0
  const unsigned __int16 *v51; // x7
  unsigned int v52; // w6
  __int64 j; // x2
  char *v55; // x2
  int v56; // w1
  int v58; // w0
  char *v59; // x6
  int v60; // t1
  int v61; // w19
  int v62; // w0
  unsigned int v63; // w0
  bool v65; // zf
  const char *v66; // x4
  __int64 v67; // x10
  int v68; // w0
  int v69; // w0
  __int64 v70; // x0
  int v71; // w2
  char *v73; // x0
  char *content_buf; // [xsp+68h] [xbp+68h]
  int header_buf_used_0; // [xsp+70h] [xbp+70h]
  unsigned int header_buf_used_0e; // [xsp+70h] [xbp+70h]
  unsigned int header_buf_used_0a; // [xsp+70h] [xbp+70h]
  _BOOL4 header_buf_used_0b; // [xsp+70h] [xbp+70h]
  size_t header_buf_used_0c; // [xsp+70h] [xbp+70h]
  __int64 header_buf_used_0d; // [xsp+70h] [xbp+70h]
  unsigned int bytestocopya; // [xsp+78h] [xbp+78h]
  const char *bytestocopy; // [xsp+78h] [xbp+78h]
  const char *bytestocopyb; // [xsp+78h] [xbp+78h]
  unsigned int header_buf_used; // [xsp+80h] [xbp+80h]
  signed int header_buf_useda; // [xsp+80h] [xbp+80h]
  unsigned int header_buf_usedb; // [xsp+80h] [xbp+80h]
  int endofheaders; // [xsp+84h] [xbp+84h]
  int endofheadersa; // [xsp+84h] [xbp+84h]
  int endofheadersb; // [xsp+84h] [xbp+84h]
  int chunked; // [xsp+90h] [xbp+90h]
  int i; // [xsp+98h] [xbp+98h]
  int ia; // [xsp+98h] [xbp+98h]
  int v95; // [xsp+9Ch] [xbp+9Ch]
  int v96; // [xsp+9Ch] [xbp+9Ch]
  unsigned int header_buf_len; // [xsp+A0h] [xbp+A0h]
  int valuestart; // [xsp+A4h] [xbp+A4h]
  char chunksize_buf[32]; // [xsp+B8h] [xbp+B8h] BYREF
  char buf[2048]; // [xsp+D8h] [xbp+D8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
    goto LABEL_173;
  content_buf = (char *)malloc(0x800uLL);
  if ( !content_buf )
  {
    free(v3);
LABEL_173:
    content_buf = 0LL;
    *size = -1;
    return content_buf;
  }
  v4 = 0;
  v5 = 2048;
  v6 = 0;
  v7 = -1;
  v8 = 0;
  header_buf_used = 0;
  endofheaders = 0;
  chunked = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
    v9 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v9 <= 0 )
      goto end_of_stream;
    if ( endofheaders )
      break;
    v10 = v9 + header_buf_used;
    if ( v9 + header_buf_used > header_buf_len )
    {
      v11 = (char *)realloc(v3, v10);
      v10 = v9 + header_buf_used;
      if ( !v11 )
      {
        free(v3);
        v73 = content_buf;
        goto LABEL_171;
      }
      v3 = v11;
      header_buf_len = v9 + header_buf_used;
    }
    header_buf_used_0 = v10;
    memcpy(&v3[header_buf_used], buf, v9);
    v12 = header_buf_used_0;
    v13 = header_buf_used_0 - 1;
    if ( header_buf_used_0 <= 1 )
    {
      header_buf_used = header_buf_used_0;
    }
    else
    {
      v14 = 0;
      do
      {
        while ( 1 )
        {
          v18 = (unsigned __int8)v3[v14];
          v19 = v14 + 1;
          if ( v18 != 13 )
            break;
          if ( v3[v19] == 10 )
          {
            if ( v14 + 2 < header_buf_used_0 && v3[v14 + 2] == 13 )
            {
              if ( v14 + 3 < header_buf_used_0 && v3[v14 + 3] == 10 )
              {
                v14 += 4;
                v16 = v14 == 0;
                v15 = v14;
              }
              else
              {
                v14 += 4;
                v15 = 0;
                v16 = 1;
              }
            }
            else
            {
              v14 += 3;
              v15 = 0;
              v16 = 1;
            }
            goto LABEL_15;
          }
LABEL_21:
          v14 += 2;
          v15 = 0;
          if ( v13 <= v14 )
            goto LABEL_22;
        }
        if ( v18 == 10 )
        {
          if ( v3[v19] != 10 )
            goto LABEL_21;
          v14 += 2;
          v16 = v14 == 0;
          v15 = v14;
        }
        else
        {
          ++v14;
          v15 = 0;
          v16 = 1;
        }
LABEL_15:
        ;
      }
      while ( v16 && v13 > v14 );
LABEL_22:
      if ( v15 )
      {
        v20 = v15 - 1;
        if ( v15 - 1 > 0 )
        {
          v21 = 0;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          do
          {
            v25 = (unsigned __int8)v3[v24];
            v26 = v24;
            v27 = v23 > 0 && v22 <= v23;
            v28 = v24 + 1;
            if ( v27 )
            {
              if ( v25 == 58 )
              {
                v70 = v28;
                while ( 1 )
                {
                  v21 = v70;
                  if ( v20 <= (int)v70 - 1 )
                    break;
                  v71 = (unsigned __int8)v3[v70++];
                  if ( v71 != 32 && v71 != 9 )
                  {
                    v22 = v24;
                    v24 = v21;
                    goto LABEL_36;
                  }
                }
                v22 = v24;
                v24 = v70;
                continue;
              }
              v29 = v25 == 10 || v25 == 13;
              if ( v29 )
                goto LABEL_91;
            }
            else if ( v25 == 13 || v25 == 10 )
            {
              if ( v23 )
                v65 = 1;
              else
                v65 = status_code == 0LL;
              if ( !v65 )
              {
                if ( v24 > 0 )
                {
                  v66 = v3 + 1;
                  v67 = (__int64)&v3[v24 + 1];
                  while ( 1 )
                  {
                    if ( *(v66 - 1) == 32 )
                    {
                      header_buf_used_0d = v67;
                      if ( (*status_code & 0x80000000) == 0 )
                        goto LABEL_91;
                      bytestocopyb = v66;
                      header_buf_usedb = v12;
                      endofheadersb = v20;
                      ia = v24;
                      v96 = v28;
                      v68 = strtol(v66, 0uLL, 10);
                      v67 = header_buf_used_0d;
                      v66 = bytestocopyb;
                      v12 = header_buf_usedb;
                      v20 = endofheadersb;
                      *status_code = v68;
                      v24 = ia;
                      v28 = v96;
                    }
                    if ( (const char *)v67 == ++v66 )
                      goto LABEL_91;
                  }
                }
                do
                {
LABEL_94:
                  v49 = (unsigned __int8)v3[v26];
                  v23 = v26;
                  v24 = v26 + 1;
                  if ( v49 != 13 && v49 != 10 )
                  {
                    v22 = v26;
                    v21 = 0;
                    goto LABEL_36;
                  }
                  ++v26;
                }
                while ( v12 > (int)v26 );
                v69 = v23 + 2;
                v22 = v24;
                v23 = v24;
                v21 = 0;
                v24 = v69;
                continue;
              }
              valuestart = v21;
              if ( v22 > v23 && v22 < v21 )
              {
                v45 = v22 - v23;
                header_buf_used_0c = (int)v45;
                bytestocopy = &v3[v23];
                header_buf_useda = v12;
                endofheadersa = v20;
                i = v24;
                v95 = v24 + 1;
                if ( strncasecmp(bytestocopy, "content-length", v45) )
                {
                  v46 = strncasecmp(bytestocopy, "transfer-encoding", header_buf_used_0c);
                  v12 = header_buf_useda;
                  v20 = endofheadersa;
                  v24 = i;
                  v28 = v95;
                  if ( !v46 )
                  {
                    v47 = strncasecmp(&v3[valuestart], "chunked", 7uLL);
                    v12 = header_buf_useda;
                    v29 = v47 == 0;
                    v20 = endofheadersa;
                    v48 = chunked;
                    v24 = i;
                    v28 = v95;
                    if ( v29 )
                      v48 = 1;
                    chunked = v48;
                  }
                  goto LABEL_91;
                }
                v7 = strtol(&v3[valuestart], 0uLL, 10);
                v24 = i;
                v28 = v95;
                v12 = header_buf_useda;
                v20 = endofheadersa;
                if ( header_buf_useda > i )
                  goto LABEL_94;
              }
              else
              {
LABEL_91:
                if ( v12 > v24 )
                  goto LABEL_94;
              }
              v22 = v24;
              v23 = v24;
              v21 = 0;
              v24 = v28;
              continue;
            }
            ++v24;
LABEL_36:
            ;
          }
          while ( v20 > v24 );
        }
        v9 = v12 - v15;
        header_buf_used = v12;
        endofheaders = v15;
        memcpy(buf, &v3[v15], v12 - v15);
        if ( chunked )
        {
          if ( v9 > 0 )
            goto LABEL_39;
LABEL_55:
          if ( v7 > 0 && v6 >= v7 )
            goto end_of_stream;
        }
        else
        {
LABEL_64:
          v38 = v9 + v6;
          if ( v7 <= 0 )
          {
            v41 = v7 <= v38;
            if ( v5 < v38 )
            {
              v5 = v9 + v6;
              if ( !v7 )
              {
                v39 = v9 + v6;
LABEL_67:
                v5 = v39;
              }
              header_buf_used_0a = v38;
              v40 = (char *)realloc(content_buf, v5);
              if ( !v40 )
                goto LABEL_170;
              v38 = header_buf_used_0a;
              content_buf = v40;
              v41 = header_buf_used_0a >= v7;
            }
          }
          else
          {
            v39 = v7;
            if ( v7 < v38 )
            {
              v9 = v7 - v6;
              v38 = v7;
              v41 = 1;
              if ( v7 > v5 )
                goto LABEL_67;
            }
            else
            {
              if ( v5 < v38 )
                goto LABEL_67;
              v41 = v7 == v38;
            }
          }
          header_buf_used_0b = v41;
          chunked = 0;
          v42 = &content_buf[v6];
          v6 = v38;
          memcpy(v42, buf, v9);
          if ( v7 > 0 && header_buf_used_0b )
          {
            free(v3);
            *size = v6;
            if ( v6 )
              return content_buf;
            goto LABEL_75;
          }
        }
      }
      else
      {
        header_buf_used = header_buf_used_0;
        endofheaders = 0;
      }
    }
  }
  if ( !chunked )
    goto LABEL_64;
LABEL_39:
  v30 = 0;
  if ( !v4 )
    goto LABEL_51;
  while ( 2 )
  {
    while ( 2 )
    {
      v31 = v9 - v30;
      if ( v9 - v30 > v4 )
        v31 = v4;
      v32 = v6 + v31;
      if ( v6 + v31 > v5 )
      {
        v5 = v6 + v31;
        if ( (v7 & 0x80000000) == 0 )
        {
          if ( v7 < v32 )
            v5 = v6 + v31;
          else
            v5 = v7;
        }
        header_buf_used_0e = v6 + v31;
        bytestocopya = v31;
        v33 = (char *)realloc(content_buf, v5);
        v32 = header_buf_used_0e;
        v31 = bytestocopya;
        if ( v33 )
          goto LABEL_48;
LABEL_170:
        free(content_buf);
        v73 = v3;
LABEL_171:
        free(v73);
        content_buf = 0LL;
        *size = -1;
        return content_buf;
      }
      v33 = content_buf;
LABEL_48:
      v34 = &v33[v6];
      v4 -= v31;
      v6 = v32;
      content_buf = v33;
      v35 = &buf[v30];
      v30 += v31;
      memcpy(v34, v35, v31);
LABEL_49:
      if ( v9 <= v30 )
        goto LABEL_55;
      if ( v4 )
        continue;
      break;
    }
LABEL_51:
    while ( 2 )
    {
      if ( v8 )
      {
LABEL_102:
        if ( v30 >= v9 )
          goto LABEL_49;
      }
      else
      {
        if ( buf[v30] == 13 )
          ++v30;
        if ( v9 <= v30 )
          goto LABEL_55;
        if ( buf[v30] == 10 )
        {
          ++v30;
          goto LABEL_102;
        }
      }
      v51 = *_ctype_b_loc();
      v52 = v9 + v8 - v30;
      for ( j = v30 + 1; ; ++j )
      {
        if ( (v51[(unsigned __int8)buf[j - 1]] & 0x1000) == 0 || v8 > 0x1E )
        {
          v30 = j - 1;
          goto LABEL_112;
        }
        chunksize_buf[v8] = buf[j - 1];
        chunksize_buf[v8 + 1] = 0;
        if ( v8 + 1 == v52 )
          break;
        ++v8;
      }
      v30 = j;
      v8 = v52;
LABEL_112:
      if ( v30 >= v9 )
        goto LABEL_49;
      v55 = &buf[v30];
      while ( 1 )
      {
        v56 = (unsigned __int8)*v55;
        if ( v56 == 13 || v56 == 10 )
          break;
        ++v30;
        ++v55;
        if ( v9 == v30 )
          goto LABEL_55;
      }
      if ( v9 <= v30 )
        goto LABEL_55;
      v58 = (unsigned __int8)buf[v30];
      if ( v58 == 13 )
      {
        if ( v9 <= ++v30 )
          goto LABEL_55;
        v58 = (unsigned __int8)buf[v30];
      }
      if ( v58 != 10 )
        continue;
      break;
    }
    if ( v8 )
    {
      v59 = chunksize_buf;
      v4 = 0;
      do
      {
        v60 = (unsigned __int8)*v59++;
        v61 = 16 * v4;
        v62 = v61 - 0x57;
        v4 = v61 - 0x30 + v60;
        v63 = v62 + (v60 | 0x20);
        if ( (unsigned __int8)(v60 - 0x30) > 9u )
          v4 = v63;
      }
      while ( v59 != &chunksize_buf[v8] );
      chunksize_buf[0] = 0;
      ++v30;
      if ( v4 )
      {
        v8 = 0;
        continue;
      }
    }
    break;
  }
end_of_stream:
  free(v3);
  *size = v6;
  if ( !v6 )
  {
LABEL_75:
    free(content_buf);
    return 0LL;
  }
  return content_buf;
}
