void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int v3; // ecx
  char *v4; // eax
  char *v5; // esi
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  char v10; // dl
  char v11; // dl
  char *v12; // ebp
  int v13; // edx
  int v14; // ebx
  int v15; // esi
  int v16; // ecx
  char v17; // al
  char *v18; // edi
  int v19; // esi
  size_t v20; // eax
  char *v21; // edx
  char *v22; // ebx
  size_t v23; // edi
  bool v24; // zf
  size_t v25; // ebp
  unsigned int v26; // edi
  unsigned int v27; // eax
  char *v28; // eax
  bool v29; // si
  _DWORD *v30; // esi
  char v32; // al
  const char *v33; // edx
  int *v34; // ebp
  const char *v35; // esi
  const char *v36; // edi
  int v37; // ecx
  const unsigned __int16 *v38; // ebp
  unsigned int v39; // eax
  unsigned int v40; // edi
  char *v41; // ebx
  int v42; // ecx
  char v43; // bl
  char v44; // bl
  char *v45; // ebx
  int v46; // edx
  char *v47; // edi
  int v48; // eax
  int v49; // edx
  int v50; // eax
  size_t v51; // edx
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  char v56; // dl
  int v57; // edi
  int *v58; // esi
  int *v59; // esi
  unsigned int content_buf_used; // [esp+0h] [ebp-8A0h]
  unsigned int chunksize; // [esp+4h] [ebp-89Ch]
  char *content_buf; // [esp+10h] [ebp-890h]
  int header_buf_used_0; // [esp+18h] [ebp-888h]
  signed int header_buf_used_0a; // [esp+18h] [ebp-888h]
  unsigned int content_buf_len; // [esp+1Ch] [ebp-884h]
  unsigned int content_length; // [esp+20h] [ebp-880h]
  unsigned int chunksize_buf_index; // [esp+24h] [ebp-87Ch]
  int chunksize_buf_indexa; // [esp+24h] [ebp-87Ch]
  int n; // [esp+28h] [ebp-878h]
  char *header_buf; // [esp+2Ch] [ebp-874h]
  int valuestart; // [esp+30h] [ebp-870h]
  int endofheaders; // [esp+34h] [ebp-86Ch]
  int chunked; // [esp+38h] [ebp-868h]
  unsigned int header_buf_len; // [esp+3Ch] [ebp-864h]
  size_t v75; // [esp+40h] [ebp-860h]
  int i; // [esp+44h] [ebp-85Ch]
  char *s1; // [esp+48h] [ebp-858h]
  int *v78; // [esp+4Ch] [ebp-854h]
  int *v79; // [esp+50h] [ebp-850h]
  char chunksize_buf[32]; // [esp+60h] [ebp-840h] BYREF
  char buf[2048]; // [esp+80h] [ebp-820h] BYREF
  unsigned int v83; // [esp+880h] [ebp-20h]

  v78 = status_code;
  v83 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    *size = -1;
    return 0;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return 0;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  v79 = size;
  while ( 1 )
  {
    v3 = receivedata(s, buf, 2048, 5000, 0);
    if ( v3 <= 0 )
      goto end_of_stream;
    if ( endofheaders )
      break;
    header_buf_used_0 = v3 + valuestart;
    if ( header_buf_len < v3 + valuestart )
    {
      n = v3;
      v4 = (char *)realloc(header_buf, v3 + valuestart);
      v3 = n;
      if ( !v4 )
      {
        v59 = v79;
        free(header_buf);
        free(content_buf);
        *v59 = -1;
        return 0;
      }
      header_buf = v4;
      header_buf_len = header_buf_used_0;
    }
    v5 = header_buf;
    memcpy(&header_buf[valuestart], buf, v3);
    v6 = header_buf_used_0 - 1;
    if ( header_buf_used_0 <= 1 )
    {
      valuestart = header_buf_used_0;
      continue;
    }
    v7 = 0;
    do
    {
      v11 = v5[v7];
      v9 = v7 + 1;
      if ( v11 == 13 )
      {
        if ( v5[v7 + 1] == 10 )
        {
          if ( v7 + 2 < header_buf_used_0 && v5[v7 + 2] == 13 )
          {
            v9 = v7 + 3;
            if ( v7 + 3 < header_buf_used_0 && v5[v7 + 3] == 10 )
            {
              v24 = v7 == -4;
              v7 += 4;
              v10 = v24;
              v8 = v7;
            }
            else
            {
              v7 += 4;
              v8 = 0;
              v9 = -1;
              v10 = 1;
            }
          }
          else
          {
            v7 += 3;
            v8 = 0;
            v9 = -1;
            v10 = 1;
          }
LABEL_15:
          if ( v6 <= v7 )
            break;
          continue;
        }
      }
      else
      {
        if ( v11 != 10 )
        {
          ++v7;
          v8 = 0;
          v9 = -1;
          v10 = 1;
          goto LABEL_15;
        }
        if ( v5[v9] == 10 )
        {
          v24 = v7 == -2;
          v7 += 2;
          v10 = v24;
          v8 = v7;
          goto LABEL_15;
        }
      }
      v7 += 2;
      v8 = 0;
      v9 = -1;
      v10 = 1;
      if ( v6 <= v7 )
        break;
    }
    while ( v10 );
    if ( !v8 )
    {
      endofheaders = 0;
      valuestart = header_buf_used_0;
      continue;
    }
    if ( v9 <= 0 )
      goto LABEL_31;
    valuestart = 0;
    v12 = header_buf;
    v13 = 0;
    v14 = 0;
    endofheaders = v8;
    v15 = 0;
    n = v9;
    v16 = header_buf_used_0;
    while ( 2 )
    {
      v17 = v12[v15];
      v18 = (char *)(v15 + 1);
      if ( v14 <= 0 || v13 > v14 )
      {
        if ( v17 != 13 && v17 != 10 )
          goto LABEL_28;
        if ( !v14 && v78 )
        {
          if ( v15 <= 0 )
            goto LABEL_70;
          v33 = v12 + 1;
          v75 = (size_t)v12;
          v34 = v78;
          i = v15;
          s1 = (char *)(v15 + 1);
          v35 = &v33[v15];
          v36 = v33;
          valuestart = v16;
          while ( 1 )
          {
            if ( *(v36 - 1) == 32 )
            {
              if ( *v34 >= 0 )
              {
LABEL_65:
                v16 = valuestart;
                v12 = (char *)v75;
                v15 = i;
                v18 = s1;
                goto LABEL_66;
              }
              *v34 = strtol(v36, 0, 10);
            }
            if ( v35 == ++v36 )
              goto LABEL_65;
          }
        }
        if ( v13 <= v14 || v13 >= valuestart )
          goto LABEL_66;
        i = v16;
        s1 = &v12[v14];
        v75 = v13 - v14;
        v50 = strncasecmp(&v12[v14], "content-length", v13 - v14);
        v51 = v75;
        v75 = i;
        if ( !v50 )
        {
          content_length = strtol(&v12[valuestart], 0, 10);
          v16 = v75;
          goto LABEL_66;
        }
        v52 = strncasecmp(s1, "transfer-encoding", v51);
        v16 = v75;
        if ( v52 )
        {
LABEL_66:
          if ( v15 < v16 )
            goto LABEL_70;
        }
        else
        {
          v53 = strncasecmp(&v12[valuestart], "chunked", 7u);
          v16 = v75;
          v24 = v53 == 0;
          v54 = 1;
          if ( !v24 )
            v54 = chunked;
          chunked = v54;
          if ( v15 < (int)v75 )
          {
            while ( 1 )
            {
LABEL_70:
              v32 = v12[v15];
              v14 = v15;
              v15 = (int)v18;
              if ( v32 != 13 && v32 != 10 )
              {
                valuestart = 0;
                v13 = v14;
                goto LABEL_29;
              }
              if ( (char *)v16 == v18 )
                break;
              ++v18;
            }
            v15 = v14 + 2;
            valuestart = 0;
            v13 = v16;
            v14 = v16;
            goto LABEL_29;
          }
        }
        valuestart = 0;
        v13 = v15;
        v14 = v15;
        goto LABEL_28;
      }
      if ( v17 == 58 )
      {
        v55 = v15;
        if ( v15 >= n )
        {
          v57 = v15;
        }
        else
        {
          valuestart = v16;
          do
          {
            v56 = v12[v55 + 1];
            v57 = v55++;
            if ( v56 != 32 && v56 != 9 )
            {
              v16 = valuestart;
              goto LABEL_136;
            }
          }
          while ( n != v55 );
          v16 = valuestart;
          v57 = n;
        }
LABEL_136:
        v13 = v15;
        valuestart = v57 + 1;
        v15 = v57 + 1;
      }
      else
      {
        if ( v17 == 10 || v17 == 13 )
          goto LABEL_66;
LABEL_28:
        v15 = (int)v18;
      }
LABEL_29:
      if ( n > v15 )
        continue;
      break;
    }
    v8 = endofheaders;
LABEL_31:
    memcpy(buf, &header_buf[v8], header_buf_used_0 - v8);
    v3 = header_buf_used_0 - v8;
    valuestart = header_buf_used_0;
    endofheaders = v8;
    if ( !chunked )
      goto LABEL_49;
    if ( header_buf_used_0 - v8 > 0 )
      goto LABEL_33;
    v29 = content_buf_used >= content_length;
LABEL_58:
    if ( (int)content_length > 0 && v29 )
      goto end_of_stream;
  }
  if ( !chunked )
  {
LABEL_49:
    v25 = v3;
    v26 = content_buf_used + v3;
    if ( (int)content_length <= 0 )
    {
      if ( content_buf_len < v26 )
      {
        content_buf_len = content_buf_used + v3;
        if ( !content_length )
        {
          v27 = content_buf_used + v3;
          goto LABEL_54;
        }
        goto LABEL_55;
      }
      v29 = v26 >= content_length;
    }
    else
    {
      v27 = content_length;
      if ( content_length < v26 )
      {
        v26 = content_length;
        v29 = 1;
        v25 = content_length - content_buf_used;
        if ( content_buf_len < content_length )
          goto LABEL_54;
      }
      else if ( content_buf_len >= v26 )
      {
        v29 = content_length == v26;
      }
      else
      {
        if ( content_length < v26 )
          v27 = content_buf_used + v3;
LABEL_54:
        content_buf_len = v27;
LABEL_55:
        v28 = (char *)realloc(content_buf, content_buf_len);
        if ( !v28 )
          goto LABEL_152;
        content_buf = v28;
        v29 = v26 >= content_length;
      }
    }
    memcpy(&content_buf[content_buf_used], buf, v25);
    content_buf_used = v26;
    chunked = 0;
    goto LABEL_58;
  }
LABEL_33:
  header_buf_used_0a = v3;
  v19 = 0;
  while ( 2 )
  {
    if ( !chunksize )
    {
      v37 = header_buf_used_0a;
      if ( chunksize_buf_index )
        goto LABEL_101;
LABEL_84:
      if ( buf[v19] == 13 )
        ++v19;
      if ( v19 >= v37 )
      {
        chunksize = 0;
        v39 = 0;
LABEL_114:
        chunksize_buf_index = v39;
        v29 = content_buf_used >= content_length;
        goto LABEL_58;
      }
      if ( buf[v19] != 10 || (++v19, v19 < v37) )
      {
        do
        {
          n = v37;
          v38 = *_ctype_b_loc();
          v39 = chunksize_buf_index;
          chunksize_buf_indexa = n;
          v40 = n + v39 - v19;
          v41 = &buf[v19 - v39];
          do
          {
            v42 = v41[v39];
            if ( (v38[v42] & 0x1000) == 0 )
              break;
            if ( v39 > 0x1E )
              break;
            ++v39;
            ++v19;
            chunksize_buf[v39 - 1] = v42;
            chunksize_buf[v39] = 0;
          }
          while ( v39 != v40 );
          v37 = chunksize_buf_indexa;
          if ( v19 >= chunksize_buf_indexa )
            goto LABEL_103;
          while ( 1 )
          {
            v43 = buf[v19];
            if ( v43 == 13 || v43 == 10 )
              break;
            if ( ++v19 == chunksize_buf_indexa )
              goto LABEL_114;
          }
          if ( v19 >= chunksize_buf_indexa )
            goto LABEL_114;
          v44 = buf[v19];
          if ( v44 == 13 )
          {
            if ( ++v19 >= chunksize_buf_indexa )
              goto LABEL_114;
            if ( buf[v19] == 10 )
            {
LABEL_106:
              if ( !v39 )
                goto end_of_stream;
              v45 = chunksize_buf;
              v46 = 0;
              v47 = &chunksize_buf[v39];
              do
              {
                while ( 1 )
                {
                  v48 = *v45;
                  v49 = 16 * v46;
                  if ( (unsigned __int8)(v48 - 48) > 9u )
                    break;
                  ++v45;
                  v46 = v49 + v48 - 48;
                  if ( v47 == v45 )
                    goto LABEL_111;
                }
                ++v45;
                v46 = v49 + (char)(v48 | 0x20) - 87;
              }
              while ( v47 != v45 );
LABEL_111:
              chunksize_buf[0] = 0;
              ++v19;
              if ( !v46 )
              {
end_of_stream:
                v30 = v79;
                free(header_buf);
                *v30 = content_buf_used;
                if ( content_buf_used )
                  return content_buf;
                free(content_buf);
                return 0;
              }
              chunksize_buf_index = 0;
              chunksize = v46;
              goto LABEL_42;
            }
          }
          else if ( v44 == 10 )
          {
            goto LABEL_106;
          }
          chunksize_buf_index = v39;
          if ( !v39 )
            goto LABEL_84;
LABEL_101:
          ;
        }
        while ( v19 < v37 );
      }
      v39 = chunksize_buf_index;
LABEL_103:
      chunksize_buf_index = v39;
LABEL_40:
      if ( v19 >= header_buf_used_0a )
      {
        v39 = chunksize_buf_index;
        goto LABEL_114;
      }
      continue;
    }
    break;
  }
LABEL_42:
  v23 = header_buf_used_0a - v19;
  if ( header_buf_used_0a - v19 > chunksize )
    v23 = chunksize;
  if ( content_buf_len >= v23 + content_buf_used )
  {
    v21 = content_buf;
    goto LABEL_39;
  }
  v20 = content_length;
  if ( content_length < v23 + content_buf_used )
    v20 = v23 + content_buf_used;
  if ( (content_length & 0x80000000) != 0 )
    v20 = v23 + content_buf_used;
  content_buf_len = v20;
  v21 = (char *)realloc(content_buf, v20);
  if ( v21 )
  {
LABEL_39:
    content_buf = v21;
    v22 = &buf[v19];
    v19 += v23;
    memcpy(&v21[content_buf_used], v22, v23);
    chunksize -= v23;
    content_buf_used += v23;
    goto LABEL_40;
  }
LABEL_152:
  v58 = v79;
  free(content_buf);
  free(header_buf);
  *v58 = -1;
  return 0;
}
