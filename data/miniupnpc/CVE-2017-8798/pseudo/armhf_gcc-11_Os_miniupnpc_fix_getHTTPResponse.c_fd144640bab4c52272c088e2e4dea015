void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  void *v4; // r5
  void *v5; // r0
  void *v6; // r0
  unsigned int v7; // r10
  char *v8; // r9
  void *v9; // r6
  int v10; // r8
  int *v11; // r4
  int v12; // r0
  signed int v13; // r7
  signed int v14; // r11
  void *v15; // r0
  int v16; // r3
  int v17; // r4
  char *v18; // r2
  char *v19; // r1
  char *i; // r3
  signed int v21; // r4
  int v22; // r1
  int v23; // r2
  int *v24; // r3
  bool v25; // cc
  int v26; // r12
  char *v27; // r7
  char *v28; // r2
  signed int v29; // r0
  bool v30; // zf
  _BOOL4 v31; // r0
  const char *v32; // r4
  bool v33; // cc
  int v34; // r12
  int v35; // t1
  signed int v36; // lr
  bool v37; // zf
  int v38; // t1
  int v39; // r0
  int v40; // r4
  bool v41; // zf
  int v42; // r0
  int v43; // r3
  unsigned int v44; // r11
  char *v45; // r11
  const unsigned __int16 **v46; // r0
  int v47; // r1
  int v48; // r3
  bool v49; // zf
  int v50; // r2
  char *v51; // r1
  _BOOL4 v52; // r3
  int v53; // r3
  int v54; // t1
  int v55; // r11
  int v56; // r11
  char *v57; // r2
  char *v58; // r3
  unsigned int v59; // r1
  void *v60; // r0
  unsigned int v61; // r2
  unsigned int v62; // r3
  void *v63; // r4
  int v65; // [sp+0h] [bp-8A0h] BYREF
  int *sizea; // [sp+Ch] [bp-894h]
  unsigned int header_buf_used; // [sp+10h] [bp-890h]
  int *status_codea; // [sp+14h] [bp-88Ch]
  unsigned int chunksize; // [sp+18h] [bp-888h]
  int chunked; // [sp+1Ch] [bp-884h]
  unsigned int header_buf_len; // [sp+20h] [bp-880h]
  int v72; // [sp+24h] [bp-87Ch]
  unsigned int content_buf_used; // [sp+28h] [bp-878h]
  char *v74; // [sp+2Ch] [bp-874h]
  char *s1; // [sp+30h] [bp-870h]
  size_t v76; // [sp+34h] [bp-86Ch]
  char chunksize_buf[32]; // [sp+3Ch] [bp-864h] BYREF
  char buf[2048]; // [sp+5Ch] [bp-844h] BYREF

  status_codea = size;
  chunked = (int)status_code;
  if ( status_code )
    *status_code = -1;
  v4 = malloc(0x800u);
  if ( !v4 )
  {
    *status_codea = -1;
    return v4;
  }
  v5 = malloc(0x800u);
  if ( !v5 )
    goto LABEL_6;
  v7 = 0;
  v8 = 0;
  chunksize_buf[0] = 0;
  v9 = v4;
  header_buf_used = 2048;
  v4 = v5;
  content_buf_used = 2048;
  v10 = -1;
  v11 = 0;
  chunksize = 0;
  header_buf_len = 0;
  v72 = 0;
  v74 = chunksize_buf;
  while ( 2 )
  {
    v12 = receivedata(s, buf, 2048, 5000, 0);
    v13 = v12;
    if ( v12 <= 0 )
      break;
    if ( v11 )
    {
      sizea = v11;
      goto LABEL_22;
    }
    v14 = v12 + chunksize;
    if ( v12 + chunksize > content_buf_used )
    {
      v15 = realloc(v9, v12 + chunksize);
      if ( !v15 )
      {
        free(v9);
LABEL_6:
        v6 = v4;
LABEL_7:
        free(v6);
        v4 = 0;
        *status_codea = -1;
        return v4;
      }
      v9 = v15;
      content_buf_used = v14;
    }
    memcpy((char *)v9 + chunksize, buf, v13);
    v16 = 0;
    sizea = 0;
    while ( v14 - 1 > v16 )
    {
      if ( sizea )
        goto LABEL_19;
      v22 = *((unsigned __int8 *)v9 + v16);
      v23 = v16 + 1;
      if ( v22 == 13 )
      {
        if ( *((_BYTE *)v9 + v23) == 10 )
        {
          v23 = v16 + 2;
          if ( v14 > v16 + 2 && *((_BYTE *)v9 + v23) == 13 )
          {
            v23 = v16 + 3;
            if ( v14 > v16 + 3 && *((_BYTE *)v9 + v23) == 10 )
            {
              v24 = (int *)(v16 + 4);
LABEL_36:
              sizea = v24;
            }
          }
        }
      }
      else
      {
        if ( v22 != 10 )
        {
          v23 = v16;
          goto LABEL_31;
        }
        if ( *((_BYTE *)v9 + v23) == 10 )
        {
          v24 = (int *)(v16 + 2);
          goto LABEL_36;
        }
      }
LABEL_31:
      v16 = v23 + 1;
    }
    if ( !sizea )
    {
      chunksize = v14;
      goto LABEL_40;
    }
LABEL_19:
    v17 = 0;
    chunksize = (unsigned int)sizea + -0x1;
    v18 = 0;
    v19 = 0;
    for ( i = 0; (int)chunksize > (int)i; ++i )
    {
      v25 = (int)v19 <= (int)v18;
      if ( (int)v19 >= (int)v18 )
        v25 = (int)v19 <= 0;
      v26 = (unsigned __int8)i[(_DWORD)v9];
      v27 = i;
      if ( v25 || v26 != 58 )
      {
        v30 = v26 == 10;
        if ( v26 != 10 )
          v30 = v26 == 13;
        if ( v30 )
        {
          v31 = v19 == 0;
          if ( !chunked )
            v31 = 0;
          if ( v31 )
          {
            v32 = (const char *)v9;
            while ( (int)i > v32 - (_BYTE *)v9 )
            {
              v38 = *(unsigned __int8 *)v32++;
              if ( v38 == 32 )
              {
                s1 = i;
                if ( *(int *)chunked >= 0 )
                  break;
                v39 = atoi(v32);
                *(_DWORD *)chunked = v39;
                i = s1;
              }
            }
          }
          else
          {
            v33 = (int)v19 < (int)v18;
            if ( (int)v19 < (int)v18 )
              v33 = (int)v18 < v17;
            if ( v33 )
            {
              v76 = v18 - v19;
              s1 = &v19[(_DWORD)v9];
              if ( !strncasecmp(&v19[(_DWORD)v9], "content-length", v18 - v19) )
              {
                v10 = atoi((const char *)v9 + v17);
              }
              else if ( !strncasecmp(s1, "transfer-encoding", v76) )
              {
                v42 = strncasecmp((const char *)v9 + v17, "chunked", 7u);
                v43 = v72;
                if ( !v42 )
                  v43 = 1;
                v72 = v43;
              }
            }
          }
          while ( 1 )
          {
            i = v27;
            if ( v14 <= (int)v27 )
              break;
            v40 = (unsigned __int8)(v27++)[(_DWORD)v9];
            v41 = v40 == 10;
            if ( v40 != 10 )
              v41 = v40 == 13;
            v17 = v41;
            if ( !v41 )
              goto LABEL_78;
          }
          v17 = 0;
LABEL_78:
          v18 = i;
          v19 = i;
        }
      }
      else
      {
        v28 = &i[(_DWORD)v9];
        v29 = (signed int)i;
        while ( 1 )
        {
          v35 = (unsigned __int8)*++v28;
          v34 = v35;
          v36 = v29;
          v37 = v35 == 9;
          if ( v35 != 9 )
            v37 = v34 == 32;
          ++v29;
          if ( !v37 )
            break;
          if ( (int)chunksize <= v29 )
            goto LABEL_65;
        }
        v29 = v36;
LABEL_65:
        v18 = i;
        v17 = v29 + 1;
        i = (char *)v29;
      }
    }
    v13 = v14 - (_DWORD)sizea;
    memcpy(buf, (char *)sizea + (_DWORD)v9, v14 - (_DWORD)sizea);
    chunksize = v14;
LABEL_22:
    if ( !v72 )
    {
      if ( v10 > 0 && v10 < (unsigned int)&v8[v13] )
        v13 = v10 - (_DWORD)v8;
      if ( (unsigned int)&v8[v13] <= header_buf_used )
      {
        v63 = v4;
      }
      else
      {
        if ( v10 >= 0 )
        {
          if ( v10 < (unsigned int)&v8[v13] )
            v62 = (unsigned int)&v8[v13];
          else
            v62 = v10;
          header_buf_used = v62;
        }
        else
        {
          header_buf_used = (unsigned int)&v8[v13];
        }
        v63 = realloc(v4, header_buf_used);
        if ( !v63 )
        {
          free(v4);
          v6 = v9;
          goto LABEL_7;
        }
      }
      memcpy(&v8[(_DWORD)v63], buf, v13);
      v8 += v13;
      v4 = v63;
      goto LABEL_106;
    }
    v21 = 0;
LABEL_105:
    while ( v13 > v21 )
    {
      if ( !header_buf_len )
      {
        if ( !v7 )
        {
          if ( *((_BYTE *)&v65 + v21 + 0x5C) == 13 && v13 <= ++v21 )
            break;
          if ( *((_BYTE *)&v65 + v21 + 0x5C) == 10 )
            ++v21;
        }
        v45 = &v74[v7];
        while ( v13 > v21 )
        {
          v46 = _ctype_b_loc();
          v47 = (unsigned __int8)buf[v21];
          if ( ((v7 <= 0x1E) & ((*v46)[v47] >> 0xC)) == 0 )
          {
            while ( v13 > v21 )
            {
              v48 = (unsigned __int8)buf[v21];
              v49 = v48 == 10;
              if ( v48 != 10 )
                v49 = v48 == 13;
              if ( v49 )
              {
                if ( *((_BYTE *)&v65 + v21 + 0x5C) == 13 && v13 <= ++v21 )
                  goto LABEL_106;
                if ( *((_BYTE *)&v65 + v21 + 0x5C) != 10 )
                  goto LABEL_105;
                v50 = 0;
                v51 = v74;
                v44 = 0;
                while ( v7 != v50 )
                {
                  v54 = (unsigned __int8)*v51++;
                  v53 = v54;
                  v55 = 16 * v44;
                  if ( (unsigned int)(v54 - 0x30) > 9 )
                  {
                    v53 |= 0x20u;
                    v56 = v55 - 0x57;
                  }
                  else
                  {
                    v56 = v55 - 0x30;
                  }
                  v44 = v53 + v56;
                  ++v50;
                }
                ++v21;
                chunksize_buf[0] = 0;
                if ( v44 )
                {
                  v7 = 0;
                  goto LABEL_118;
                }
                goto end_of_stream;
              }
              ++v21;
            }
            goto LABEL_106;
          }
          ++v7;
          ++v21;
          *v45 = v47;
          *++v45 = 0;
        }
        break;
      }
      v44 = header_buf_len;
LABEL_118:
      v57 = (char *)(v13 - v21);
      if ( v13 - v21 >= v44 )
        v57 = (char *)v44;
      v58 = &v57[(_DWORD)v8];
      if ( &v57[(int)v8] > (char *)header_buf_used )
      {
        if ( v10 >= 0 )
        {
          if ( v10 < (unsigned int)v58 )
            v59 = (unsigned int)&v57[(_DWORD)v8];
          else
            v59 = v10;
          header_buf_used = v59;
        }
        else
        {
          header_buf_used = (unsigned int)&v57[(_DWORD)v8];
        }
        s1 = v57;
        header_buf_len = (unsigned int)&v57[(_DWORD)v8];
        v60 = realloc(v4, header_buf_used);
        v58 = (char *)header_buf_len;
        v57 = s1;
        if ( !v60 )
        {
          sizea = 0;
          free(v4);
          free(v9);
          v4 = sizea;
          *status_codea = -1;
          return v4;
        }
        v4 = v60;
      }
      s1 = v58;
      header_buf_len = (unsigned int)v57;
      memcpy(&v8[(_DWORD)v4], &buf[v21], (size_t)v57);
      v61 = header_buf_len;
      header_buf_len = v44 - header_buf_len;
      v21 += v61;
      v8 = s1;
    }
LABEL_106:
    v52 = v10 > 0;
    if ( v10 > (unsigned int)v8 )
      v52 = 0;
    if ( !v52 )
    {
LABEL_40:
      v11 = sizea;
      continue;
    }
    break;
  }
end_of_stream:
  free(v9);
  *status_codea = (int)v8;
  if ( !v8 )
  {
    free(v4);
    return 0;
  }
  return v4;
}
