void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  void *v3; // eax
  char *v4; // eax
  char *v5; // ebp
  int v6; // ecx
  int v7; // eax
  char *v8; // ebx
  int v9; // edi
  int v10; // esi
  unsigned int v11; // edi
  void *v12; // esi
  void *v13; // eax
  char v14; // cl
  bool v15; // dl
  int v16; // ebx
  int v17; // eax
  int v18; // ecx
  char v19; // dl
  int v20; // edx
  int v21; // esi
  bool v22; // zf
  int v23; // eax
  int v24; // ebx
  _BYTE *v25; // edx
  signed int v26; // ebp
  signed int v27; // esi
  signed int v28; // edi
  signed int v29; // ecx
  bool v30; // al
  char v31; // cl
  int *v32; // ecx
  char *v33; // esi
  signed int i; // ebp
  int v35; // eax
  size_t v36; // ecx
  int v37; // eax
  const char *v38; // esi
  int v39; // eax
  signed int v40; // esi
  int v41; // eax
  char v42; // cl
  int v43; // esi
  unsigned int v44; // eax
  signed int v45; // ebx
  unsigned int v46; // eax
  int v47; // ebp
  size_t v48; // esi
  unsigned int v49; // eax
  unsigned int v50; // edi
  size_t v51; // eax
  char *v52; // eax
  char v53; // cl
  int v54; // eax
  char v55; // cl
  unsigned int v56; // esi
  signed int v57; // ebp
  const unsigned __int16 *v58; // eax
  int v59; // ecx
  unsigned int v60; // edx
  signed int v61; // eax
  bool v62; // cc
  char v63; // cl
  unsigned int v64; // ebp
  char *v65; // eax
  int v66; // ecx
  int v67; // ebp
  int v68; // edi
  int v69; // ecx
  size_t v70; // esi
  size_t v71; // eax
  void *v72; // edi
  void *v73; // eax
  void *result; // eax
  unsigned int v75; // eax
  const char *v76; // [esp+0h] [ebp-87Ch]
  int v77; // [esp+18h] [ebp-864h]
  size_t v78; // [esp+1Ch] [ebp-860h]
  void *ptr; // [esp+20h] [ebp-85Ch]
  int v80; // [esp+24h] [ebp-858h]
  unsigned int v81; // [esp+28h] [ebp-854h]
  unsigned int v82; // [esp+2Ch] [ebp-850h]
  int v83; // [esp+30h] [ebp-84Ch]
  void *v84; // [esp+34h] [ebp-848h]
  char *nptr; // [esp+38h] [ebp-844h]
  unsigned int v86; // [esp+3Ch] [ebp-840h]
  int v87; // [esp+40h] [ebp-83Ch]
  int v88; // [esp+44h] [ebp-838h]
  unsigned int v89; // [esp+48h] [ebp-834h]
  char v90[32]; // [esp+4Ch] [ebp-830h] BYREF
  char src[2064]; // [esp+6Ch] [ebp-810h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = malloc(0x800u);
  if ( !v3 )
  {
    *size = -1;
    return 0;
  }
  ptr = v3;
  v4 = (char *)malloc(0x800u);
  if ( !v4 )
  {
    free(ptr);
    *size = -1;
    return 0;
  }
  v5 = v4;
  v90[0] = 0;
  v89 = 2048;
  v6 = -1;
  v88 = 0;
  v7 = 0;
  v8 = 0;
  v86 = 2048;
  v81 = 0;
  v87 = 0;
  v9 = 0;
  while ( 2 )
  {
    v82 = v7;
    v84 = v5;
    do
    {
      v80 = v6;
      v78 = receivedata(s, src, 2048, 5000, 0);
      if ( (int)v78 <= 0 )
        goto end_of_stream;
      if ( v9 )
      {
        v6 = v80;
        v44 = v81;
        goto LABEL_82;
      }
      v10 = (int)&v8[v78];
      if ( (unsigned int)&v8[v78] <= v89 )
      {
        v13 = ptr;
      }
      else
      {
        v11 = (unsigned int)&v8[v78];
        v12 = ptr;
        v13 = realloc(ptr, (size_t)&v8[v78]);
        if ( v13 )
        {
          v14 = 1;
          v89 = v11;
        }
        else
        {
          free(v12);
          free(v5);
          *size = -1;
          v14 = 0;
          v13 = v12;
        }
        v10 = v11;
        if ( !v14 )
        {
          ptr = v13;
          v9 = 0;
          v23 = 1;
          goto LABEL_8;
        }
      }
      ptr = v13;
      memcpy(&v8[(_DWORD)v13], src, v78);
      v15 = 1;
      v16 = 0;
      v77 = v10;
      if ( v10 >= 2 )
      {
        v17 = v10 - 1;
        v16 = 0;
        v18 = 0;
        while ( 1 )
        {
          v19 = *((_BYTE *)ptr + v18);
          if ( v19 == 10 )
            break;
          if ( v19 == 13 )
          {
            if ( *((_BYTE *)ptr + v18 + 1) == 10 )
            {
              v20 = v18 + 2;
              if ( v18 + 2 >= v10 )
                goto LABEL_32;
              if ( *((_BYTE *)ptr + v20) == 13 )
              {
                v20 = v18 + 3;
                v10 = v77;
                if ( v18 + 3 >= v77 )
                  goto LABEL_32;
                v21 = v18 + 4;
                v22 = *((_BYTE *)ptr + v18 + 3) == 10;
LABEL_27:
                if ( v22 )
                  v16 = v21;
              }
              v10 = v77;
              goto LABEL_32;
            }
            ++v18;
          }
          v20 = v18;
LABEL_32:
          v18 = v20 + 1;
          v15 = v16 == 0;
          if ( v18 >= v17 || v16 )
            goto LABEL_34;
        }
        v20 = v18 + 1;
        v21 = v18 + 2;
        v22 = *((_BYTE *)ptr + v18 + 1) == 10;
        goto LABEL_27;
      }
LABEL_34:
      v23 = 2;
      if ( v15 )
      {
        v8 = (char *)v10;
        v9 = 0;
      }
      else
      {
        v83 = v16;
        if ( v16 >= 2 )
        {
          v24 = v16 - 1;
          v25 = ptr;
          nptr = (char *)ptr + 1;
          v26 = 0;
          v27 = 0;
          v78 = 0;
          v28 = 0;
          while ( 1 )
          {
            if ( (int)v78 > 0 && v27 <= (int)v78 && v25[v28] == 58 )
            {
              v26 = v28;
              do
              {
                v30 = v26 < v24 && (v25[v26 + 1] == 32 || v25[v26 + 1] == 9);
                ++v26;
              }
              while ( v30 );
              v29 = v26 - 1;
            }
            else
            {
              v31 = v25[v28];
              if ( v31 == 13 || v31 == 10 )
              {
                v32 = status_code;
                if ( !status_code || v78 )
                {
                  v36 = v27 - v78;
                  v37 = v80;
                  if ( v27 <= (int)v78 || v26 <= v27 )
                    goto LABEL_67;
                  v38 = &v25[v78];
                  v76 = &v25[v78];
                  v78 = v36;
                  if ( !strncasecmp(v76, "content-length", v36) )
                  {
                    v37 = atoi((const char *)ptr + v26);
                    goto LABEL_67;
                  }
                  v39 = strncasecmp(v38, "transfer-encoding", v78);
                  v40 = v77;
                  if ( !v39 )
                  {
                    v22 = strncasecmp((const char *)ptr + v26, "chunked", 7u) == 0;
                    v41 = v88;
                    if ( v22 )
                      v41 = 1;
                    v88 = v41;
                  }
                  v37 = v80;
                }
                else
                {
                  if ( v28 > 0 )
                  {
                    v33 = nptr;
                    for ( i = v28; i; --i )
                    {
                      if ( *(v33 - 1) == 32 )
                      {
                        if ( *v32 >= 0 )
                          break;
                        v35 = atoi(v33);
                        v32 = status_code;
                        *status_code = v35;
                      }
                      ++v33;
                    }
                  }
                  v37 = v80;
LABEL_67:
                  v40 = v77;
                }
                v26 = 0;
                v80 = v37;
                if ( v28 >= v40 )
                {
                  v29 = v28;
                  v78 = v28;
                  v25 = ptr;
                }
                else
                {
                  v25 = ptr;
                  do
                  {
                    v42 = *((_BYTE *)ptr + v28);
                    if ( v42 != 13 && v42 != 10 )
                    {
                      v29 = v28;
                      v78 = v28;
                      goto LABEL_38;
                    }
                    ++v28;
                  }
                  while ( v40 != v28 );
                  v29 = v40;
                  v78 = v40;
                  v28 = v40;
                }
                goto LABEL_38;
              }
              v29 = v28;
              v28 = v27;
            }
LABEL_38:
            v27 = v28;
            v28 = v29 + 1;
            if ( v29 + 1 >= v24 )
              goto LABEL_79;
          }
        }
        v25 = ptr;
LABEL_79:
        v43 = v77;
        v9 = v83;
        v78 = v77 - v83;
        memcpy(src, &v25[v83], v77 - v83);
        v23 = 0;
        v8 = (char *)v43;
        v5 = (char *)v84;
      }
LABEL_8:
      v6 = v80;
    }
    while ( v23 == 2 );
    v22 = v23 == 0;
    v44 = v81;
    if ( !v22 )
      return 0;
LABEL_82:
    if ( !v9 )
      goto LABEL_146;
    v80 = v6;
    if ( !v88 )
    {
      v83 = v9;
      v48 = v6 - v81;
      v49 = v81;
      if ( v78 + v81 <= v6 )
        v48 = v78;
      if ( v6 <= 0 )
        v48 = v78;
      v50 = v48 + v81;
      if ( v48 + v81 > v86 )
      {
        v51 = v6;
        if ( v6 < v50 )
          v51 = v48 + v81;
        if ( v6 < 0 )
          v51 = v48 + v81;
        v86 = v51;
        v52 = (char *)realloc(v5, v51);
        if ( v52 )
        {
          v53 = 1;
          v5 = v52;
        }
        else
        {
          free(v5);
          free(ptr);
          *size = -1;
          v53 = 0;
        }
        v49 = v81;
        if ( !v53 )
          return 0;
      }
      memcpy(&v5[v49], src, v48);
      v81 = v50;
      v6 = v80;
      v9 = v83;
      goto LABEL_146;
    }
    if ( (int)v78 <= 0 )
    {
      v77 = v44;
      v54 = 0;
      v47 = v87;
    }
    else
    {
      nptr = v8;
      v45 = 0;
      v46 = v82;
      v47 = v87;
      v83 = v9;
      while ( 2 )
      {
        v77 = v81;
        v56 = v47;
        v57 = v78;
        while ( 1 )
        {
          if ( v46 )
          {
            v47 = v56;
            goto LABEL_130;
          }
          if ( !v56 )
          {
            v45 += src[v45] == 13;
            if ( v45 < v57 )
              v45 += src[v45] == 10;
          }
          if ( v45 < v57 )
          {
            v58 = *_ctype_b_loc();
            while ( v56 <= 0x1E )
            {
              v59 = src[v45];
              if ( (v58[v59] & 0x1000) == 0 )
                break;
              v60 = v56 + 1;
              v90[v56] = v59;
              v90[v56 + 1] = 0;
              ++v45;
              ++v56;
              if ( v57 == v45 )
              {
                v56 = v60;
                v45 = v57;
                break;
              }
            }
          }
          v61 = v45;
          v62 = v45 < v57;
          v45 = v57;
          if ( !v62 )
            v45 = v61;
          while ( v45 != v61 )
          {
            v63 = src[v61++];
            if ( v63 == 13 || v63 == 10 )
            {
              v45 = v61 - 1;
              if ( v63 == 13 )
                v45 = v61;
              break;
            }
          }
          v6 = v80;
          if ( v45 < v57 && src[v45] == 10 )
            break;
          v46 = 0;
          if ( v45 >= v57 )
          {
            v82 = 0;
            v47 = v56;
            v54 = 0;
            goto LABEL_140;
          }
        }
        v64 = 0;
        if ( v56 )
        {
          v64 = 0;
          v65 = v90;
          do
          {
            v66 = *v65;
            v67 = 16 * v64;
            v68 = v66 - 48;
            v69 = (v66 | 0x20) - 87;
            if ( (unsigned __int8)(*v65 - 48) < 0xAu )
              v69 = v68;
            v64 = v69 + v67;
            ++v65;
            --v56;
          }
          while ( v56 );
        }
        v90[0] = 0;
        if ( !v64 )
        {
          v54 = 25;
          v82 = 0;
          v6 = v80;
          v9 = v83;
          v47 = 0;
          break;
        }
        v46 = v64;
        ++v45;
        v6 = v80;
        v9 = v83;
        v47 = 0;
LABEL_130:
        v70 = v78 - v45;
        v82 = v46;
        if ( v46 < v78 - v45 )
          v70 = v46;
        v81 = v70 + v77;
        if ( v70 + v77 <= v86 )
          goto LABEL_100;
        v71 = v6;
        if ( v6 < v70 + v77 )
          v71 = v70 + v77;
        if ( v6 < 0 )
          v71 = v70 + v77;
        v72 = v84;
        v86 = v71;
        v73 = realloc(v84, v71);
        if ( v73 )
        {
          v55 = 1;
          v84 = v73;
        }
        else
        {
          free(v72);
          free(ptr);
          *size = -1;
          v55 = 0;
        }
        v9 = v83;
        if ( v55 )
        {
LABEL_100:
          memcpy((char *)v84 + v77, &src[v45], v70);
          v45 += v70;
          v46 = v82 - v70;
          v6 = v80;
          if ( v45 < (int)v78 )
            continue;
          v82 -= v70;
          v54 = 0;
          v77 = v81;
        }
        else
        {
          v54 = 1;
          v6 = v80;
        }
        break;
      }
LABEL_140:
      v8 = nptr;
    }
    if ( !v54 )
    {
      v87 = v47;
      v81 = v77;
      v5 = (char *)v84;
LABEL_146:
      v7 = v82;
      if ( v6 > 0 && v81 >= v6 )
        goto end_of_stream;
      continue;
    }
    break;
  }
  v22 = v54 == 25;
  v81 = v77;
  v5 = (char *)v84;
  result = 0;
  if ( !v22 )
    return result;
end_of_stream:
  free(ptr);
  v75 = v81;
  *size = v81;
  if ( v75 )
    return v5;
  free(v5);
  return 0;
}
