void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // r0
  void *v4; // r4
  unsigned int v5; // r11
  unsigned int v6; // r9
  char *v7; // r8
  char *v8; // r10
  int v9; // r0
  char *v10; // r6
  void *v11; // r0
  char *v12; // r3
  char *v13; // r2
  int i; // r5
  int v15; // r3
  int v16; // r6
  int v17; // r3
  size_t v18; // r7
  signed int v19; // r6
  int v20; // r5
  int v21; // r4
  _BOOL4 v22; // r3
  int v23; // r5
  char *v24; // r9
  int v25; // r10
  int *v26; // r11
  const char *v27; // r6
  char *v28; // r2
  char *v29; // r1
  int v30; // r4
  int v31; // r5
  int v32; // r5
  bool v33; // zf
  _BOOL4 v34; // r0
  const char *v35; // r8
  int v36; // r0
  char *v37; // r7
  bool v38; // zf
  _BOOL4 v39; // r0
  const char *v40; // r5
  int v41; // t1
  const char *v42; // r2
  int v43; // r5
  int v44; // t1
  bool v45; // zf
  int v46; // r5
  int v47; // r4
  char *v48; // r2
  int v49; // r7
  int v50; // r3
  char *v51; // r0
  const void *v52; // r1
  int v53; // r3
  const unsigned __int16 *v54; // lr
  unsigned int v55; // r0
  _BYTE *v56; // r1
  int v57; // r3
  int v58; // t1
  unsigned int v59; // r2
  int v60; // t1
  bool v61; // zf
  unsigned __int8 *v62; // r3
  unsigned __int8 *v63; // r11
  int v64; // r2
  int v65; // t1
  int v66; // r8
  int v67; // r8
  int v68; // r3
  int v69; // t1
  int v70; // r2
  bool v71; // zf
  char *v72; // r0
  _BOOL4 v73; // r0
  const char *v74; // r8
  int v75; // r0
  int v76; // r3
  int v78; // [sp+0h] [bp-8A8h] BYREF
  unsigned int header_buf_used_0; // [sp+8h] [bp-8A0h]
  int content_length; // [sp+Ch] [bp-89Ch]
  char *header_buf; // [sp+10h] [bp-898h]
  int chunked; // [sp+14h] [bp-894h]
  void *ptr; // [sp+18h] [bp-890h]
  unsigned int header_buf_used; // [sp+1Ch] [bp-88Ch]
  unsigned int content_buf_used; // [sp+20h] [bp-888h]
  int sa; // [sp+24h] [bp-884h]
  unsigned int header_buf_len; // [sp+28h] [bp-880h]
  unsigned int chunksize; // [sp+2Ch] [bp-87Ch]
  unsigned int chunksize_buf_index; // [sp+30h] [bp-878h]
  char *content_buf; // [sp+34h] [bp-874h]
  unsigned int v91; // [sp+38h] [bp-870h]
  char *v92; // [sp+3Ch] [bp-86Ch]
  int *status_codea; // [sp+40h] [bp-868h]
  char *v94; // [sp+44h] [bp-864h]
  int *v95; // [sp+48h] [bp-860h]
  int *sizea; // [sp+4Ch] [bp-85Ch]
  char *s2; // [sp+50h] [bp-858h]
  int *v98; // [sp+54h] [bp-854h]
  char chunksize_buf[32]; // [sp+5Ch] [bp-84Ch] BYREF
  char buf[2048]; // [sp+7Ch] [bp-82Ch] BYREF

  chunksize = s;
  v95 = status_code;
  v98 = size;
  if ( status_code )
    *status_code = -1;
  ptr = malloc(0x800u);
  if ( !ptr )
  {
    v4 = 0;
    *v98 = -1;
    return v4;
  }
  v3 = (char *)malloc(0x800u);
  v4 = v3;
  if ( !v3 )
  {
    free(ptr);
    *v98 = -1;
    return v4;
  }
  v5 = 0;
  chunksize_buf[0] = 0;
  content_length = 2048;
  chunksize_buf_index = 2048;
  chunked = -1;
  header_buf_used_0 = (unsigned int)buf;
  v6 = 0;
  v7 = 0;
  v8 = v3;
  s2 = "content-length";
  sa = 0;
  header_buf_used = 0;
  header_buf_len = 0;
  content_buf_used = (unsigned int)chunksize_buf;
  do
  {
    while ( 1 )
    {
      v9 = receivedata(chunksize, header_buf_used_0, 2048, 5000, 0);
      v10 = (char *)v9;
      if ( v9 <= 0 )
      {
LABEL_154:
        v4 = v8;
        v23 = v6;
        goto end_of_stream;
      }
      if ( header_buf_len )
      {
        if ( header_buf_used )
          goto LABEL_80;
        v18 = v9;
LABEL_29:
        v19 = (signed int)&v10[v6];
        v20 = v19;
        if ( chunked <= 0 )
        {
          if ( content_length < (unsigned int)v19 )
          {
            if ( chunked < v19 )
            {
              v21 = v19;
              goto LABEL_132;
            }
LABEL_136:
            v21 = v19;
            v20 = chunked;
            goto LABEL_132;
          }
        }
        else
        {
          if ( chunked < v19 )
          {
            v19 = chunked;
            v21 = chunked;
            v18 = chunked - v6;
            if ( chunked <= (unsigned int)content_length )
              goto LABEL_32;
            v21 = chunked;
            v20 = chunked;
LABEL_132:
            v72 = (char *)realloc(v8, v20);
            if ( !v72 )
            {
              free(v8);
              free(ptr);
              v4 = 0;
              *v98 = -1;
              return v4;
            }
            v8 = v72;
            v19 = v21;
            content_length = v20;
LABEL_32:
            memcpy(&v8[v6], (const void *)header_buf_used_0, v18);
            v6 = v21;
            header_buf_used = 0;
            goto LABEL_33;
          }
          if ( content_length < (unsigned int)v19 )
            goto LABEL_136;
        }
        v21 = v19;
        goto LABEL_32;
      }
      header_buf = (char *)(v9 + sa);
      if ( v9 + sa > chunksize_buf_index )
      {
        v11 = realloc(ptr, v9 + sa);
        if ( !v11 )
        {
          free(ptr);
          free(v8);
          v4 = (void *)header_buf_len;
          *v98 = -1;
          return v4;
        }
        ptr = v11;
        chunksize_buf_index = (unsigned int)header_buf;
      }
      memcpy((char *)ptr + sa, (const void *)header_buf_used_0, (size_t)v10);
      v12 = header_buf;
      v13 = header_buf + -0x1;
      if ( (int)(header_buf + -0x1) <= 0 )
      {
LABEL_25:
        sa = (int)v12;
        continue;
      }
      for ( i = 0; ; i += 2 )
      {
LABEL_14:
        v15 = *((unsigned __int8 *)ptr + i);
        v16 = i + 1;
        if ( v15 != 13 )
        {
LABEL_15:
          if ( v15 != 10 )
          {
            if ( (int)v13 <= v16 )
              goto LABEL_24;
            goto LABEL_17;
          }
          i += 2;
          goto LABEL_22;
        }
LABEL_18:
        v17 = i + 2;
        if ( *((_BYTE *)ptr + v16) == 10 )
          break;
        if ( (int)v13 <= v17 )
          goto LABEL_24;
      }
      v16 = i + 3;
      if ( (int)header_buf > v17 && *((_BYTE *)ptr + v17) == 13 )
        break;
      if ( (int)v13 > v16 )
      {
LABEL_17:
        i = v16;
        v15 = *((unsigned __int8 *)ptr + v16++);
        if ( v15 != 13 )
          goto LABEL_15;
        goto LABEL_18;
      }
      sa = (int)header_buf;
    }
    v12 = header_buf;
    i += 4;
    if ( (int)header_buf <= v16 )
    {
      if ( (int)v13 <= i )
        goto LABEL_25;
      goto LABEL_14;
    }
LABEL_22:
    if ( *((_BYTE *)ptr + v16) != 10 )
    {
      if ( (int)v13 <= i )
      {
LABEL_24:
        v12 = header_buf;
        goto LABEL_25;
      }
      goto LABEL_14;
    }
    status_codea = (int *)"transfer-encoding";
    sa = i;
    v94 = "chunked";
    header_buf_len = v6;
    v91 = v5;
    v92 = v8;
    v24 = header_buf;
    v25 = v16;
    v26 = v95;
    v27 = (const char *)ptr;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    content_buf = v7;
    while ( 1 )
    {
LABEL_49:
      v34 = (int)v29 > 0;
      if ( (int)v28 > (int)v29 )
        v34 = 0;
      v33 = !v34;
      v35 = &v27[v30];
      v36 = (unsigned __int8)v27[v30];
      v37 = (char *)(v30 + 1);
      if ( v33 )
        break;
      if ( v36 == 58 )
      {
        v32 = v30;
        do
        {
          v69 = *(unsigned __int8 *)++v35;
          v68 = v69;
          v70 = v32;
          v71 = v69 == 9;
          if ( v69 != 9 )
            v71 = v68 == 32;
          ++v32;
          if ( !v71 )
          {
            v31 = v70 + 1;
            v28 = (char *)v30;
            v30 = v31;
            goto LABEL_48;
          }
        }
        while ( v25 > v32 );
        v31 = v32 + 1;
        v28 = (char *)v30;
        v30 = v31;
        goto LABEL_48;
      }
      v33 = v36 == 10;
      if ( v36 != 10 )
        v33 = v36 == 13;
      if ( v33 )
        goto LABEL_66;
LABEL_47:
      ++v30;
LABEL_48:
      if ( v25 <= v30 )
        goto LABEL_77;
    }
    v38 = v36 == 10;
    if ( v36 != 10 )
      v38 = v36 == 13;
    if ( !v38 )
      goto LABEL_47;
    v39 = v29 == 0;
    if ( !v26 )
      v39 = 0;
    if ( v39 )
    {
      if ( v30 > 0 )
      {
        v40 = v27;
        do
        {
          while ( 1 )
          {
            v41 = *(unsigned __int8 *)v40++;
            if ( v41 == 32 )
              break;
            if ( v35 == v40 )
              goto LABEL_66;
          }
          if ( *v26 >= 0 )
            break;
          *v26 = strtol(v40, 0u, 10);
        }
        while ( v35 != v40 );
      }
      goto LABEL_66;
    }
    v73 = (int)v28 > (int)v29;
    if ( (int)v28 >= v31 )
      v73 = 0;
    if ( !v73 )
      goto LABEL_66;
    v74 = &v29[(_DWORD)v27];
    sizea = (int *)(v28 - v29);
    if ( !strncasecmp(&v29[(_DWORD)v27], s2, v28 - v29) )
    {
      chunked = strtol(&v27[v31], 0u, 10);
LABEL_66:
      if ( (int)v24 > v30 )
        goto LABEL_67;
      goto LABEL_145;
    }
    if ( strncasecmp(v74, (const char *)status_codea, (size_t)sizea) )
      goto LABEL_66;
    v75 = strncasecmp(&v27[v31], v94, 7u);
    v76 = header_buf_used;
    if ( !v75 )
      v76 = 1;
    header_buf_used = v76;
    if ( (int)v24 <= v30 )
    {
LABEL_145:
      v28 = (char *)v30;
      v29 = (char *)v30;
      v31 = 0;
      ++v30;
      goto LABEL_48;
    }
LABEL_67:
    v42 = &v27[v30 - 1];
    while ( 1 )
    {
      v44 = *(unsigned __int8 *)++v42;
      v43 = v44;
      v29 = (char *)v30;
      v45 = v44 == 10;
      if ( v44 != 10 )
        v45 = v43 == 13;
      v31 = v45;
      v30 = (int)v37;
      if ( !v45 )
        break;
      if ( v24 == v37 )
      {
        v30 = (int)(v29 + 2);
        v31 = 0;
        v28 = v24;
        v29 = v24;
        goto LABEL_48;
      }
      ++v37;
    }
    v28 = v29;
    if ( v25 > (int)v37 )
      goto LABEL_49;
LABEL_77:
    v46 = sa;
    v10 = &header_buf[-sa];
    v6 = header_buf_len;
    v7 = content_buf;
    v5 = v91;
    v8 = v92;
    memcpy((void *)header_buf_used_0, (char *)ptr + sa, (size_t)&header_buf[-sa]);
    v18 = (size_t)v10;
    header_buf_len = v46;
    sa = (int)header_buf;
    if ( !header_buf_used )
      goto LABEL_29;
    if ( (int)v10 <= 0 )
    {
      v19 = v6;
      goto LABEL_33;
    }
LABEL_80:
    v47 = 0;
    while ( 2 )
    {
      if ( !v7 )
      {
        if ( v5 )
        {
LABEL_94:
          if ( v47 >= (int)v10 )
            goto LABEL_127;
        }
        else
        {
          v53 = *((unsigned __int8 *)&v78 + v47 + 0x7C);
          if ( v53 != 13 )
          {
            if ( v53 != 10 )
              goto LABEL_94;
LABEL_148:
            ++v47;
            goto LABEL_94;
          }
          if ( ++v47 >= (int)v10 )
            goto LABEL_127;
          if ( *((_BYTE *)&v78 + v47 + 0x7C) == 10 )
            goto LABEL_148;
        }
        v54 = *_ctype_b_loc();
        v55 = header_buf_used_0 + v47 - 1;
        v56 = (_BYTE *)(content_buf_used + v5);
        while ( 1 )
        {
          v58 = *(unsigned __int8 *)++v55;
          v57 = v58;
          if ( ((v5 <= 0x1E) & (v54[v58] >> 0xC)) == 0 )
            break;
          ++v47;
          *v56 = v57;
          ++v5;
          *++v56 = 0;
          if ( v47 >= (int)v10 )
            goto LABEL_127;
        }
        if ( v47 >= (int)v10 )
          goto LABEL_127;
        v59 = header_buf_used_0 + v47;
        while ( 1 )
        {
          v61 = v57 == 10;
          if ( v57 != 10 )
            v61 = v57 == 13;
          if ( v61 )
            break;
          if ( (char *)++v47 == v10 )
            goto LABEL_127;
          v60 = *(unsigned __int8 *)++v59;
          v57 = v60;
        }
        if ( v47 >= (int)v10 )
        {
LABEL_127:
          v19 = v6;
          header_buf_used = 1;
          goto LABEL_33;
        }
        if ( v57 == 13 )
        {
          if ( ++v47 >= (int)v10 )
            goto LABEL_127;
          v57 = *((unsigned __int8 *)&v78 + v47 + 0x7C);
        }
        if ( v57 != 10 )
        {
          v49 = v6;
LABEL_89:
          v6 = v49;
          continue;
        }
        if ( !v5 )
          goto LABEL_154;
        v62 = (unsigned __int8 *)content_buf_used;
        v7 = 0;
        v63 = (unsigned __int8 *)(content_buf_used + v5);
        do
        {
          v65 = *v62++;
          v64 = v65;
          v66 = 16 * (_DWORD)v7;
          if ( (unsigned int)(v65 - 0x30) > 9 )
          {
            v67 = v66 - 0x57;
            v64 |= 0x20u;
          }
          else
          {
            v67 = v66 - 0x30;
          }
          v7 = (char *)(v67 + v64);
        }
        while ( v62 != v63 );
        ++v47;
        chunksize_buf[0] = 0;
        if ( !v7 )
          goto LABEL_154;
        v5 = 0;
      }
      break;
    }
    v48 = &v10[-v47];
    if ( (int)&v10[-v47] >= (int)v7 )
      v48 = v7;
    v49 = (int)&v48[v6];
    if ( (unsigned int)&v48[v6] > content_length )
    {
      v50 = chunked;
      if ( chunked < v49 )
        v50 = (int)&v48[v6];
      header_buf = v48;
      content_length = v50;
      v51 = (char *)realloc(v8, v50);
      v48 = header_buf;
      if ( !v51 )
      {
        header_buf_used_0 = 0;
        free(v8);
        free(ptr);
        v4 = (void *)header_buf_used_0;
        *v98 = -1;
        return v4;
      }
      v8 = v51;
    }
    v52 = (const void *)(header_buf_used_0 + v47);
    v47 += (int)v48;
    v7 -= (int)v48;
    memcpy(&v8[v6], v52, (size_t)v48);
    if ( v47 < (int)v10 )
      goto LABEL_89;
    v6 = v49;
    v19 = v49;
    header_buf_used = 1;
LABEL_33:
    v22 = chunked > 0;
    if ( chunked > v19 )
      v22 = 0;
  }
  while ( !v22 );
  v23 = v19;
  v4 = v8;
end_of_stream:
  free(ptr);
  *v98 = v23;
  if ( !v6 )
  {
    free(v4);
    return 0;
  }
  return v4;
}
