void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  unsigned int v3; // eax
  unsigned int v5; // [esp+1Ch] [ebp-88Ch]
  bool v6; // [esp+21h] [ebp-887h]
  bool v7; // [esp+22h] [ebp-886h]
  bool v8; // [esp+23h] [ebp-885h]
  bool v9; // [esp+24h] [ebp-884h]
  bool v10; // [esp+25h] [ebp-883h]
  bool v11; // [esp+26h] [ebp-882h]
  bool v12; // [esp+27h] [ebp-881h]
  char *tmp_1; // [esp+28h] [ebp-880h]
  char *tmp_0; // [esp+2Ch] [ebp-87Ch]
  unsigned int j; // [esp+30h] [ebp-878h]
  int i_0; // [esp+34h] [ebp-874h]
  int sp_0; // [esp+38h] [ebp-870h]
  char *tmp; // [esp+3Ch] [ebp-86Ch]
  int valuestart; // [esp+40h] [ebp-868h]
  int colon; // [esp+44h] [ebp-864h]
  int linestart; // [esp+48h] [ebp-860h]
  int i; // [esp+4Ch] [ebp-85Ch]
  int ia; // [esp+4Ch] [ebp-85Ch]
  unsigned int chunksize_buf_index; // [esp+50h] [ebp-858h]
  char chunksize_buf[32]; // [esp+54h] [ebp-854h]
  unsigned int content_buf_used; // [esp+74h] [ebp-834h]
  unsigned int content_buf_len; // [esp+78h] [ebp-830h]
  char *content_buf; // [esp+7Ch] [ebp-82Ch]
  unsigned int header_buf_used; // [esp+80h] [ebp-828h]
  unsigned int header_buf_len; // [esp+84h] [ebp-824h]
  char *header_buf; // [esp+88h] [ebp-820h]
  unsigned int bytestocopy; // [esp+8Ch] [ebp-81Ch]
  unsigned int chunksize; // [esp+90h] [ebp-818h]
  int content_length; // [esp+94h] [ebp-814h]
  int chunked; // [esp+98h] [ebp-810h]
  int endofheaders; // [esp+9Ch] [ebp-80Ch]
  int n; // [esp+A0h] [ebp-808h]
  char buf[2048]; // [esp+A4h] [ebp-804h] BYREF

  endofheaders = 0;
  chunked = 0;
  content_length = -1;
  chunksize = 0;
  bytestocopy = 0;
  header_buf_len = 2048;
  header_buf_used = 0;
  content_buf_len = 2048;
  content_buf_used = 0;
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(header_buf_len);
  if ( !header_buf )
  {
    *size = -1;
    return 0;
  }
  content_buf = (char *)malloc(content_buf_len);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return 0;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  while ( 1 )
  {
    n = receivedata(s, buf, 2048, 5000, 0);
    if ( n <= 0 )
      break;
    if ( endofheaders )
      goto LABEL_72;
    linestart = 0;
    colon = 0;
    valuestart = 0;
    if ( n + header_buf_used > header_buf_len )
    {
      tmp = (char *)realloc(header_buf, n + header_buf_used);
      if ( !tmp )
      {
        free(header_buf);
        free(content_buf);
        *size = -1;
        return 0;
      }
      header_buf = tmp;
      header_buf_len = n + header_buf_used;
    }
    memcpy(&header_buf[header_buf_used], buf, n);
    header_buf_used += n;
    for ( i = 0; ; ++i )
    {
      v12 = 0;
      if ( i < (int)(header_buf_used - 1) )
        v12 = endofheaders == 0;
      if ( !v12 )
        break;
      if ( header_buf[i] == 13 )
      {
        if ( header_buf[++i] == 10
          && ++i < (int)header_buf_used
          && header_buf[i] == 13
          && ++i < (int)header_buf_used
          && header_buf[i] == 10 )
        {
          endofheaders = i + 1;
        }
      }
      else if ( header_buf[i] == 10 && header_buf[++i] == 10 )
      {
        endofheaders = i + 1;
      }
    }
    if ( endofheaders )
    {
      for ( ia = 0; ia < endofheaders - 1; ++ia )
      {
        if ( linestart > 0 && colon <= linestart && header_buf[ia] == 58 )
        {
          colon = ia;
          while ( 1 )
          {
            v11 = 0;
            if ( ia < endofheaders - 1 )
            {
              v10 = 1;
              if ( header_buf[ia + 1] != 32 )
                v10 = header_buf[ia + 1] == 9;
              v11 = v10;
            }
            if ( !v11 )
              break;
            ++ia;
          }
          valuestart = ia + 1;
        }
        else if ( header_buf[ia] == 13 || header_buf[ia] == 10 )
        {
          if ( linestart || !status_code )
          {
            if ( colon > linestart && valuestart > colon )
            {
              if ( !strncasecmp(&header_buf[linestart], "content-length", colon - linestart) )
              {
                content_length = atoi(&header_buf[valuestart]);
              }
              else if ( !strncasecmp(&header_buf[linestart], "transfer-encoding", colon - linestart)
                     && !strncasecmp(&header_buf[valuestart], "chunked", 7u) )
              {
                chunked = 1;
              }
            }
          }
          else
          {
            for ( sp_0 = 0; sp_0 < ia; ++sp_0 )
            {
              if ( header_buf[sp_0] == 32 )
              {
                if ( *status_code >= 0 )
                  goto LABEL_63;
                *status_code = atoi(&header_buf[sp_0 + 1]);
              }
            }
          }
          while ( 1 )
          {
LABEL_63:
            v9 = 0;
            if ( ia < (int)header_buf_used )
            {
              v8 = 1;
              if ( header_buf[ia] != 13 )
                v8 = header_buf[ia] == 10;
              v9 = v8;
            }
            if ( !v9 )
              break;
            ++ia;
          }
          linestart = ia;
          colon = ia;
          valuestart = 0;
        }
      }
      n = header_buf_used - endofheaders;
      memcpy(buf, &header_buf[endofheaders], header_buf_used - endofheaders);
LABEL_72:
      if ( endofheaders )
      {
        if ( chunked )
        {
          i_0 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( i_0 >= n )
                goto LABEL_131;
              if ( !chunksize )
                break;
LABEL_109:
              if ( (int)chunksize >= n - i_0 )
                v5 = n - i_0;
              else
                v5 = chunksize;
              bytestocopy = v5;
              if ( v5 + content_buf_used > content_buf_len )
              {
                if ( content_length < (int)(bytestocopy + content_buf_used) )
                  content_buf_len = bytestocopy + content_buf_used;
                else
                  content_buf_len = content_length;
                tmp_0 = (char *)realloc(content_buf, content_buf_len);
                if ( !tmp_0 )
                  goto LABEL_117;
                content_buf = tmp_0;
              }
              memcpy(&content_buf[content_buf_used], &buf[i_0], bytestocopy);
              content_buf_used += bytestocopy;
              i_0 += bytestocopy;
              chunksize -= bytestocopy;
            }
            if ( !chunksize_buf_index )
            {
              if ( i_0 < n && buf[i_0] == 13 )
                ++i_0;
              if ( i_0 < n && buf[i_0] == 10 )
                ++i_0;
            }
            while ( 1 )
            {
              v7 = 0;
              if ( i_0 < n )
              {
                v7 = 0;
                if ( ((*_ctype_b_loc())[buf[i_0]] & 0x1000) != 0 )
                  v7 = chunksize_buf_index < 0x1F;
              }
              if ( !v7 )
                break;
              v3 = chunksize_buf_index++;
              chunksize_buf[v3] = buf[i_0];
              chunksize_buf[chunksize_buf_index] = 0;
              ++i_0;
            }
            while ( 1 )
            {
              v6 = 0;
              if ( i_0 < n )
              {
                v6 = 0;
                if ( buf[i_0] != 13 )
                  v6 = buf[i_0] != 10;
              }
              if ( !v6 )
                break;
              ++i_0;
            }
            if ( i_0 < n && buf[i_0] == 13 )
              ++i_0;
            if ( i_0 < n && buf[i_0] == 10 )
            {
              for ( j = 0; j < chunksize_buf_index; ++j )
              {
                if ( chunksize_buf[j] < 48 || chunksize_buf[j] > 57 )
                  chunksize = (chunksize_buf[j] | 0x20) - 97 + 10 + 16 * chunksize;
                else
                  chunksize = chunksize_buf[j] - 48 + 16 * chunksize;
              }
              chunksize_buf[0] = 0;
              chunksize_buf_index = 0;
              ++i_0;
              if ( !chunksize )
                goto end_of_stream;
              goto LABEL_109;
            }
          }
        }
        if ( content_length > 0 && (int)(n + content_buf_used) > content_length )
          n = content_length - content_buf_used;
        if ( n + content_buf_used > content_buf_len )
        {
          if ( content_length < (int)(n + content_buf_used) )
            content_buf_len = n + content_buf_used;
          else
            content_buf_len = content_length;
          tmp_1 = (char *)realloc(content_buf, content_buf_len);
          if ( !tmp_1 )
          {
LABEL_117:
            free(content_buf);
            free(header_buf);
            *size = -1;
            return 0;
          }
          content_buf = tmp_1;
        }
        memcpy(&content_buf[content_buf_used], buf, n);
        content_buf_used += n;
      }
LABEL_131:
      if ( content_length > 0 && (int)content_buf_used >= content_length )
        break;
    }
  }
end_of_stream:
  free(header_buf);
  header_buf = 0;
  *size = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
