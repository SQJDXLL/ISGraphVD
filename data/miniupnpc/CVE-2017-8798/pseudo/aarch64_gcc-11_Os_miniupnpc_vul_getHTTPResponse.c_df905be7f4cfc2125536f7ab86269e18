void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x19
  char *v4; // x0
  char *v5; // x0
  char *v6; // x20
  unsigned int v7; // w26
  unsigned int v8; // w24
  unsigned int v9; // w27
  int v10; // w21
  int v11; // w22
  int v12; // w28
  int v13; // w25
  char *v14; // x0
  int v15; // w1
  int v16; // w28
  int v17; // w2
  int v18; // w0
  int i; // w1
  int v20; // w25
  int v21; // w2
  int v22; // w0
  int v23; // w5
  __int64 v24; // x27
  bool v25; // cc
  int v26; // w5
  int v27; // w2
  bool v28; // zf
  bool v30; // zf
  const char *v31; // x2
  int j; // w28
  int v33; // w0
  int v35; // w0
  int v37; // w0
  __int64 v38; // x1
  char *v39; // x2
  const unsigned __int16 **v40; // x0
  __int64 v41; // x5
  __int64 v42; // x0
  int v43; // w1
  signed int v44; // w4
  __int64 v45; // x1
  int v46; // w4
  int v47; // w0
  signed int v48; // w2
  unsigned int v49; // w5
  int v50; // w0
  unsigned int v51; // w5
  int v52; // w6
  int v53; // w0
  size_t v54; // x1
  char *v55; // x0
  int v57; // w4
  int v58; // w0
  size_t v59; // x1
  char *v60; // x25
  unsigned int content_buf_len; // [xsp+7Ch] [xbp+7Ch]
  int chunked; // [xsp+80h] [xbp+80h]
  unsigned int chunksize; // [xsp+84h] [xbp+84h]
  unsigned int chunksizea; // [xsp+84h] [xbp+84h]
  unsigned int chunksizeb; // [xsp+84h] [xbp+84h]
  int content_buf_used; // [xsp+90h] [xbp+90h]
  __int64 content_buf_useda; // [xsp+90h] [xbp+90h]
  signed int content_buf_usedb; // [xsp+90h] [xbp+90h]
  unsigned int content_buf_usedc; // [xsp+90h] [xbp+90h]
  unsigned int content_buf_usedd; // [xsp+90h] [xbp+90h]
  unsigned int header_buf_len; // [xsp+98h] [xbp+98h]
  char *bytestocopy; // [xsp+A0h] [xbp+A0h]
  unsigned int bytestocopya; // [xsp+A0h] [xbp+A0h]
  signed int bytestocopyb; // [xsp+A0h] [xbp+A0h]
  const char *v79; // [xsp+C0h] [xbp+C0h]
  const char *v80; // [xsp+C0h] [xbp+C0h]
  int v81; // [xsp+C8h] [xbp+C8h]
  size_t v82; // [xsp+C8h] [xbp+C8h]
  char chunksize_buf[32]; // [xsp+D8h] [xbp+D8h] BYREF
  char buf[2048]; // [xsp+F8h] [xbp+F8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
  {
    *size = -1;
    return v3;
  }
  v4 = (char *)malloc(0x800uLL);
  if ( !v4 )
  {
LABEL_7:
    v5 = v3;
    goto LABEL_8;
  }
  v6 = v3;
  v3 = v4;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = -1;
  v11 = 0;
  content_buf_len = 2048;
  chunked = 0;
  chunksize = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
    v12 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    if ( v12 <= 0 )
      break;
    if ( v11 )
      goto LABEL_23;
    v13 = v12 + v9;
    if ( v12 + v9 > header_buf_len )
    {
      v14 = (char *)realloc(v6, (unsigned int)v13);
      if ( !v14 )
      {
        free(v6);
        goto LABEL_7;
      }
      v6 = v14;
      header_buf_len = v12 + v9;
    }
    memcpy(&v6[v9], buf, v12);
    v15 = 0;
    v11 = 0;
    while ( v13 - 1 > v15 )
    {
      if ( v11 )
        goto LABEL_20;
      v21 = (unsigned __int8)v6[v15];
      v22 = v15 + 1;
      if ( v21 == 13 )
      {
        if ( v6[v22] == 10 )
        {
          v22 = v15 + 2;
          if ( v13 > v15 + 2 && v6[v22] == 13 )
          {
            v22 = v15 + 3;
            if ( v13 > v15 + 3 && v6[v22] == 10 )
              v11 = v15 + 4;
          }
        }
      }
      else if ( v21 == 10 )
      {
        if ( v6[v22] == 10 )
          v11 = v15 + 2;
      }
      else
      {
        v22 = v15;
      }
      v15 = v22 + 1;
    }
    v9 += v12;
    if ( v11 )
    {
LABEL_20:
      content_buf_used = v11 - 1;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      for ( i = 0; content_buf_used > i; ++i )
      {
        v23 = (unsigned __int8)v6[i];
        v24 = i;
        v25 = v18 <= 0 || v18 < v17;
        if ( v25 || v23 != 58 )
        {
          if ( v23 == 13 || v23 == 10 )
          {
            if ( v18 )
              v30 = 1;
            else
              v30 = status_code == 0LL;
            if ( !v30 )
            {
              v31 = v6 + 1;
              for ( j = 0; ; ++j )
              {
                if ( i <= j )
                  goto LABEL_63;
                if ( *(v31 - 1) == 32 )
                {
                  v81 = i;
                  if ( (*status_code & 0x80000000) == 0 )
                    goto LABEL_63;
                  v79 = v31;
                  v35 = atoi(v31);
                  v31 = v79;
                  *status_code = v35;
                  i = v81;
                }
                ++v31;
              }
            }
            if ( v18 < v17 && v17 < v16 )
            {
              v80 = &v6[v18];
              v82 = v17 - v18;
              if ( !strncasecmp(v80, "content-length", v82) )
              {
                v10 = atoi(&v6[v16]);
              }
              else if ( !strncasecmp(v80, "transfer-encoding", v82) )
              {
                v28 = strncasecmp(&v6[v16], "chunked", 7uLL) == 0;
                v37 = chunked;
                if ( v28 )
                  v37 = 1;
                chunked = v37;
              }
            }
LABEL_63:
            while ( 1 )
            {
              i = v24;
              if ( v13 <= (int)v24 )
                break;
              v33 = (unsigned __int8)v6[v24++];
              if ( v33 != 13 && v33 != 10 )
              {
                v17 = i;
                v18 = i;
                v16 = 0;
                goto LABEL_51;
              }
            }
            v17 = v24;
            v18 = v24;
            v16 = 0;
          }
        }
        else
        {
          while ( 1 )
          {
            v26 = v24 + 1;
            v27 = (unsigned __int8)v6[v24 + 1];
            v28 = v27 == 32 || v27 == 9;
            if ( !v28 )
              break;
            if ( content_buf_used <= (int)++v24 )
              goto LABEL_50;
          }
          v26 = v24;
LABEL_50:
          v17 = i;
          v16 = v26 + 1;
          i = v26;
        }
LABEL_51:
        ;
      }
      v9 = v13;
      v12 = v13 - v11;
      memcpy(buf, &v6[v11], v13 - v11);
LABEL_23:
      if ( chunked )
      {
        v20 = 0;
        while ( 1 )
        {
LABEL_125:
          if ( v12 <= v20 )
            goto LABEL_126;
          if ( !chunksize )
            break;
          v44 = chunksize;
LABEL_111:
          v51 = v12 - v20;
          if ( v12 - v20 > v44 )
            v51 = v44;
          v52 = v8 + v51;
          if ( v8 + v51 > content_buf_len )
          {
            chunksizea = v8 + v51;
            if ( v52 <= v10 )
              v53 = v10;
            else
              v53 = v8 + v51;
            if ( v52 <= v10 )
              v54 = (unsigned int)v10;
            else
              v54 = (unsigned int)v52;
            content_buf_len = v53;
            content_buf_usedb = v44;
            bytestocopya = v51;
            v55 = (char *)realloc(v3, v54);
            v52 = chunksizea;
            v44 = content_buf_usedb;
            v51 = bytestocopya;
            if ( !v55 )
              goto LABEL_121;
            v3 = v55;
          }
          chunksizeb = v51;
          content_buf_usedc = v52;
          bytestocopyb = v44;
          memcpy(&v3[v8], &buf[v20], v51);
          v20 += chunksizeb;
          v8 = content_buf_usedc;
          chunksize = bytestocopyb - chunksizeb;
        }
        if ( v7 )
        {
LABEL_92:
          v38 = v20;
          v39 = &chunksize_buf[v7];
          while ( 1 )
          {
            content_buf_useda = v38;
            v20 = v38;
            bytestocopy = v39;
            if ( v12 <= (int)v38 )
              break;
            v40 = _ctype_b_loc();
            v41 = (unsigned __int8)buf[content_buf_useda];
            if ( ((*v40)[v41] & 0x1000) == 0 || v7 > 0x1E )
              break;
            ++v7;
            *bytestocopy = v41;
            v39 = bytestocopy + 1;
            v38 = content_buf_useda + 1;
            chunksize_buf[v7] = 0;
          }
        }
        else if ( buf[v20] != 13 || (++v20, v12 > v20) )
        {
          if ( buf[v20] == 10 )
            ++v20;
          goto LABEL_92;
        }
        v42 = v20;
        while ( 1 )
        {
          v20 = v42;
          if ( v12 <= (int)v42 )
            goto LABEL_126;
          v43 = (unsigned __int8)buf[v42];
          if ( v43 != 13 )
          {
            ++v42;
            if ( v43 != 10 )
              continue;
          }
          if ( buf[v20] == 13 && v12 <= ++v20 )
            goto LABEL_126;
          if ( buf[v20] != 10 )
            goto LABEL_125;
          v44 = 0;
          v45 = 0LL;
          while ( v7 > (unsigned int)v45 )
          {
            v46 = 16 * v44;
            v47 = (unsigned __int8)chunksize_buf[v45++];
            v48 = v46 - 0x30 + v47;
            v49 = (unsigned __int8)(v47 - 0x30);
            v50 = (v47 | 0x20) + v46 - 0x57;
            if ( v49 <= 9 )
              v44 = v48;
            else
              v44 = v50;
          }
          chunksize_buf[0] = 0;
          ++v20;
          if ( v44 )
          {
            v7 = 0;
            goto LABEL_111;
          }
          goto end_of_stream;
        }
      }
      if ( v10 > 0 && v10 < (int)(v12 + v8) )
        v12 = v10 - v8;
      v57 = v12 + v8;
      if ( v12 + v8 <= content_buf_len )
      {
        v60 = v3;
      }
      else
      {
        if ( v10 >= v57 )
          v58 = v10;
        else
          v58 = v12 + v8;
        if ( v10 >= v57 )
          v59 = (unsigned int)v10;
        else
          v59 = (unsigned int)v57;
        content_buf_len = v58;
        v60 = (char *)realloc(v3, v59);
        v57 = v12 + v8;
        if ( !v60 )
        {
LABEL_121:
          free(v3);
          v5 = v6;
LABEL_8:
          free(v5);
          *size = -1;
          return 0LL;
        }
      }
      content_buf_usedd = v57;
      memcpy(&v60[v8], buf, v12);
      v3 = v60;
      v8 = content_buf_usedd;
LABEL_126:
      if ( v10 > 0 && (int)v8 >= v10 )
        break;
    }
  }
end_of_stream:
  free(v6);
  *size = v8;
  if ( !v8 )
  {
    free(v3);
    return 0LL;
  }
  return v3;
}
