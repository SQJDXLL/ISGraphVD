void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // x19
  char *v4; // x20
  char *v5; // x0
  unsigned int v6; // w27
  unsigned int v7; // w24
  int v8; // w5
  int v9; // w21
  int v10; // w22
  int v11; // w26
  int v12; // w5
  int v13; // w25
  char *v14; // x0
  int v15; // w2
  int v16; // w1
  int v17; // w4
  int v18; // w2
  int v19; // w0
  int v20; // w26
  int v21; // w3
  int v22; // w3
  int v23; // w0
  int v24; // w1
  bool v25; // zf
  int v26; // w5
  __int64 v27; // x28
  bool v28; // cc
  int v29; // w5
  int v30; // w2
  bool v33; // zf
  const char *v34; // x2
  int i; // w4
  int v36; // w0
  int v38; // w0
  const char *v40; // x26
  int v41; // w0
  __int64 v42; // x1
  char *v43; // x2
  const unsigned __int16 **v44; // x0
  __int64 v45; // x5
  __int64 j; // x0
  int v47; // w1
  int v48; // w5
  __int64 v49; // x1
  int v50; // w5
  int v51; // w0
  int v52; // w2
  unsigned int v53; // w6
  int v54; // w0
  unsigned int v55; // w6
  int v56; // w7
  int v57; // w0
  size_t v58; // x1
  char *v59; // x0
  int v61; // w3
  int v62; // w0
  size_t v63; // x1
  char *v64; // x0
  unsigned int content_buf_len; // [xsp+70h] [xbp+70h]
  int chunked; // [xsp+74h] [xbp+74h]
  unsigned int chunksize; // [xsp+80h] [xbp+80h]
  unsigned int chunksizea; // [xsp+80h] [xbp+80h]
  unsigned int chunksizeb; // [xsp+80h] [xbp+80h]
  unsigned int header_buf_len; // [xsp+84h] [xbp+84h]
  int header_buf_used; // [xsp+88h] [xbp+88h]
  int header_buf_useda; // [xsp+88h] [xbp+88h]
  __int64 header_buf_usedb; // [xsp+88h] [xbp+88h]
  int header_buf_usedc; // [xsp+88h] [xbp+88h]
  unsigned int header_buf_usedd; // [xsp+88h] [xbp+88h]
  unsigned int header_buf_usede; // [xsp+88h] [xbp+88h]
  const char *content_buf_usedb; // [xsp+90h] [xbp+90h]
  size_t content_buf_used; // [xsp+90h] [xbp+90h]
  char *content_buf_useda; // [xsp+90h] [xbp+90h]
  int content_buf_usedc; // [xsp+90h] [xbp+90h]
  unsigned int content_buf_usedd; // [xsp+90h] [xbp+90h]
  int sp; // [xsp+9Ch] [xbp+9Ch]
  int spa; // [xsp+9Ch] [xbp+9Ch]
  int spb; // [xsp+9Ch] [xbp+9Ch]
  int spc; // [xsp+9Ch] [xbp+9Ch]
  char chunksize_buf[32]; // [xsp+A8h] [xbp+A8h] BYREF
  char buf[2048]; // [xsp+C8h] [xbp+C8h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
    goto LABEL_4;
  v4 = (char *)malloc(0x800uLL);
  if ( !v4 )
    goto LABEL_8;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = -1;
  v10 = 0;
  content_buf_len = 2048;
  chunked = 0;
  chunksize = 0;
  header_buf_len = 2048;
  chunksize_buf[0] = 0;
  while ( 1 )
  {
    header_buf_used = v8;
    v11 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
    v12 = header_buf_used;
    if ( v11 <= 0 )
      break;
    if ( v10 )
    {
      v13 = header_buf_used;
      goto LABEL_23;
    }
    v13 = v11 + header_buf_used;
    if ( v11 + header_buf_used > header_buf_len )
    {
      v14 = (char *)realloc(v3, (unsigned int)v13);
      v12 = header_buf_used;
      if ( !v14 )
      {
        free(v3);
        v5 = v4;
        goto LABEL_9;
      }
      v3 = v14;
      header_buf_len = v11 + header_buf_used;
    }
    memcpy(&v3[v12], buf, v11);
    v15 = v13 - 1;
    v16 = 0;
    v10 = 0;
    while ( 2 )
    {
      if ( v15 > v16 )
      {
        if ( v10 )
          goto LABEL_20;
        while ( 2 )
        {
          v22 = (unsigned __int8)v3[v16];
          v23 = v16 + 1;
          if ( v22 == 13 )
          {
            v25 = v3[v23] == 10;
            v23 = v16 + 2;
            if ( !v25 )
              goto LABEL_28;
            if ( v13 <= v23 )
              goto LABEL_29;
            v25 = v3[v23] == 13;
            v23 = v16 + 3;
            if ( !v25 )
              goto LABEL_28;
            if ( v13 <= v23 )
              goto LABEL_29;
            v24 = v16 + 4;
            v25 = v3[v23] == 10;
          }
          else
          {
            if ( v22 != 10 )
            {
LABEL_28:
              if ( v15 <= v23 )
                goto LABEL_29;
              v16 = v23;
              continue;
            }
            v24 = v16 + 2;
            v25 = v3[v23] == 10;
          }
          break;
        }
        if ( v25 )
        {
          v10 = v24;
          v16 = v23 + 1;
          continue;
        }
        v23 = v24;
        goto LABEL_28;
      }
      break;
    }
    if ( !v10 )
      goto LABEL_29;
LABEL_20:
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    header_buf_useda = v10 - 1;
    while ( header_buf_useda > v20 )
    {
      v26 = (unsigned __int8)v3[v20];
      v27 = v20;
      v28 = v19 <= 0 || v19 < v18;
      if ( v28 || v26 != 58 )
      {
        if ( v26 == 13 || v26 == 10 )
        {
          if ( v19 )
            v33 = 1;
          else
            v33 = status_code == 0LL;
          if ( !v33 )
          {
            v34 = v3 + 1;
            for ( i = 0; ; ++i )
            {
              if ( v20 <= i )
                goto LABEL_64;
              if ( *(v34 - 1) == 32 )
              {
                sp = i;
                if ( (*status_code & 0x80000000) == 0 )
                  goto LABEL_64;
                content_buf_usedb = v34;
                v38 = atoi(v34);
                v34 = content_buf_usedb;
                i = sp;
                *status_code = v38;
              }
              ++v34;
            }
          }
          spa = v17;
          if ( v19 < v18 && v18 < v17 )
          {
            v40 = &v3[v19];
            content_buf_used = v18 - v19;
            if ( !strncasecmp(v40, "content-length", content_buf_used) )
            {
              v9 = atoi(&v3[spa]);
            }
            else if ( !strncasecmp(v40, "transfer-encoding", content_buf_used) )
            {
              v25 = strncasecmp(&v3[spa], "chunked", 7uLL) == 0;
              v41 = chunked;
              if ( v25 )
                v41 = 1;
              chunked = v41;
            }
          }
LABEL_64:
          while ( 1 )
          {
            v29 = v27;
            if ( v13 <= (int)v27 )
              break;
            v36 = (unsigned __int8)v3[v27++];
            if ( v36 != 13 && v36 != 10 )
            {
              v20 = v29;
              v19 = v29;
              v17 = 0;
              goto LABEL_52;
            }
          }
          v20 = v27;
          v19 = v27;
          v17 = 0;
        }
        else
        {
          v29 = v20;
          v20 = v18;
        }
      }
      else
      {
        do
        {
          v29 = v27;
          v17 = v27 + 1;
          if ( header_buf_useda <= (int)v27 )
            break;
          v30 = (unsigned __int8)v3[++v27];
        }
        while ( v30 == 32 || v30 == 9 );
      }
LABEL_52:
      v18 = v20;
      v20 = v29 + 1;
    }
    v11 = v13 - v10;
    memcpy(buf, &v3[v10], v13 - v10);
LABEL_23:
    if ( chunked )
    {
      v21 = 0;
      while ( 1 )
      {
        if ( v11 <= v21 )
          goto LABEL_130;
        if ( chunksize )
          break;
        if ( !v6 )
        {
          if ( buf[v21] != 13 || (++v21, v11 > v21) )
          {
            if ( buf[v21] == 10 )
              ++v21;
          }
        }
        v42 = v21;
        v43 = &chunksize_buf[v6];
        while ( 1 )
        {
          content_buf_useda = v43;
          if ( v11 <= (int)v42 )
            break;
          header_buf_usedb = v42;
          v44 = _ctype_b_loc();
          LODWORD(v42) = header_buf_usedb;
          v45 = (unsigned __int8)buf[header_buf_usedb];
          if ( ((*v44)[v45] & 0x1000) == 0 || v6 > 0x1E )
            break;
          ++v6;
          *content_buf_useda = v45;
          v43 = content_buf_useda + 1;
          v42 = header_buf_usedb + 1;
          chunksize_buf[v6] = 0;
        }
        for ( j = (int)v42; v11 > (int)j; ++j )
        {
          v47 = (unsigned __int8)buf[j];
          if ( v47 == 13 || v47 == 10 )
            break;
        }
        v21 = j;
        if ( v11 <= (int)j )
          goto LABEL_130;
        if ( buf[(int)j] == 13 )
        {
          v21 = j + 1;
          if ( v11 <= (int)j + 1 )
            goto LABEL_130;
        }
        if ( buf[v21] == 10 )
        {
          v48 = 0;
          v49 = 0LL;
          while ( v6 > (unsigned int)v49 )
          {
            v50 = 16 * v48;
            v51 = (unsigned __int8)chunksize_buf[v49++];
            v52 = v50 - 0x30 + v51;
            v53 = (unsigned __int8)(v51 - 0x30);
            v54 = (v51 | 0x20) + v50 - 0x57;
            if ( v53 <= 9 )
              v48 = v52;
            else
              v48 = v54;
          }
          chunksize_buf[0] = 0;
          ++v21;
          if ( !v48 )
            goto end_of_stream;
          v6 = 0;
LABEL_115:
          v55 = v11 - v21;
          if ( v11 - v21 > v48 )
            v55 = v48;
          v56 = v7 + v55;
          if ( v7 + v55 > content_buf_len )
          {
            chunksizea = v7 + v55;
            if ( v56 <= v9 )
              v57 = v9;
            else
              v57 = v7 + v55;
            if ( v56 <= v9 )
              v58 = (unsigned int)v9;
            else
              v58 = (unsigned int)v56;
            content_buf_len = v57;
            header_buf_usedc = v21;
            content_buf_usedc = v48;
            spb = v55;
            v59 = (char *)realloc(v4, v58);
            v56 = chunksizea;
            v21 = header_buf_usedc;
            v48 = content_buf_usedc;
            v55 = spb;
            if ( !v59 )
              goto LABEL_125;
            v4 = v59;
          }
          chunksizeb = v21;
          header_buf_usedd = v55;
          content_buf_usedd = v56;
          spc = v48;
          memcpy(&v4[v7], &buf[v21], v55);
          v21 = chunksizeb + header_buf_usedd;
          v7 = content_buf_usedd;
          chunksize = spc - header_buf_usedd;
        }
      }
      v48 = chunksize;
      goto LABEL_115;
    }
    if ( v9 > 0 && v9 < (int)(v11 + v7) )
      v11 = v9 - v7;
    v61 = v11 + v7;
    if ( v11 + v7 > content_buf_len )
    {
      if ( v9 >= v61 )
        v62 = v9;
      else
        v62 = v11 + v7;
      if ( v9 >= v61 )
        v63 = (unsigned int)v9;
      else
        v63 = (unsigned int)v61;
      content_buf_len = v62;
      v64 = (char *)realloc(v4, v63);
      v61 = v11 + v7;
      if ( !v64 )
      {
LABEL_125:
        free(v4);
LABEL_8:
        v5 = v3;
LABEL_9:
        free(v5);
LABEL_4:
        *size = -1;
        return 0LL;
      }
      v4 = v64;
    }
    header_buf_usede = v61;
    memcpy(&v4[v7], buf, v11);
    v7 = header_buf_usede;
LABEL_130:
    if ( v9 > 0 && (int)v7 >= v9 )
      break;
LABEL_29:
    v8 = v13;
  }
end_of_stream:
  free(v3);
  *size = v7;
  if ( v7 )
    return v4;
  free(v4);
  return 0LL;
}
