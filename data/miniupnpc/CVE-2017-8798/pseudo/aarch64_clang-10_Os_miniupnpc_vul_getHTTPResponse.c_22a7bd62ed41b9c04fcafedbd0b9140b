void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  void *result; // x0
  char *v6; // x21
  char *v7; // x0
  int v8; // w23
  int v9; // w26
  int v10; // w20
  unsigned int v11; // w25
  int v12; // w9
  __int64 v13; // x10
  int v14; // w22
  unsigned int v15; // w19
  int v16; // w0
  int v17; // w27
  char *v18; // x0
  int v19; // w9
  int v20; // w11
  __int64 v21; // x11
  __int64 v22; // x10
  int v23; // w11
  int v24; // w9
  bool v25; // w10
  int v26; // w19
  int v27; // w27
  int v28; // w9
  int v29; // w8
  int v30; // w22
  int v31; // w28
  __int64 v32; // x9
  int v33; // w12
  __int64 v34; // x19
  const char *v35; // x27
  int *v36; // x9
  unsigned int v37; // w24
  int *v38; // x25
  int v39; // w10
  const char *v40; // x24
  int v41; // w0
  int v42; // w8
  char *v43; // x8
  __int64 i; // x9
  char v45; // t1
  int v46; // w9
  __int64 v47; // x22
  int v48; // w24
  unsigned int v49; // w23
  const unsigned __int16 *v50; // x10
  __int64 v51; // x8
  __int64 v52; // x15
  char *v53; // x16
  int v54; // w8
  __int64 v55; // x8
  char *v56; // x9
  int v57; // t1
  int v58; // w11
  int v59; // w10
  unsigned int v60; // w28
  int v61; // w9
  char *v62; // x25
  size_t v63; // x1
  char *v64; // x0
  int v66; // w22
  int v67; // w9
  int v68; // w19
  unsigned int v69; // w27
  size_t v70; // x1
  char *v71; // x0
  char *v72; // x0
  size_t v73; // [xsp+0h] [xbp-8B0h]
  int *v74; // [xsp+18h] [xbp-898h]
  int v75; // [xsp+24h] [xbp-88Ch]
  char *ptr; // [xsp+30h] [xbp-880h]
  char *nptr; // [xsp+38h] [xbp-878h]
  int v78; // [xsp+44h] [xbp-86Ch]
  unsigned int v79; // [xsp+48h] [xbp-868h]
  int v80; // [xsp+54h] [xbp-85Ch]
  int v82; // [xsp+6Ch] [xbp-844h]
  int v83; // [xsp+6Ch] [xbp-844h]
  __int64 v84; // [xsp+70h] [xbp-840h]
  __int64 v85; // [xsp+70h] [xbp-840h]
  int v86; // [xsp+78h] [xbp-838h]
  int v87; // [xsp+78h] [xbp-838h]
  unsigned int v88; // [xsp+84h] [xbp-82Ch]
  char v89[32]; // [xsp+88h] [xbp-828h] BYREF
  char src[2056]; // [xsp+A8h] [xbp-808h] BYREF

  if ( status_code )
    *status_code = -1;
  result = malloc(0x800uLL);
  if ( !result )
    goto LABEL_150;
  v6 = (char *)result;
  v7 = (char *)malloc(0x800uLL);
  if ( !v7 )
  {
    free(v6);
    result = 0LL;
LABEL_150:
    *size = -1;
    return result;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 2048;
  v12 = -1;
  v13 = 2048LL;
  ptr = v7;
  v74 = size;
  v75 = 0;
  v78 = 0;
  v88 = 0;
  v89[0] = 0;
  while ( 1 )
  {
    v14 = v10;
    v84 = v13;
    v80 = v12;
    do
    {
      v15 = v9;
      v16 = receivedata((unsigned int)s, src, 2048LL, 5000LL, 0LL);
      if ( v16 < 1 )
        goto end_of_stream;
      v17 = v16;
      if ( v14 )
      {
        v10 = v14;
        goto LABEL_83;
      }
      v9 += v16;
      if ( v16 + v15 <= v11 )
      {
        v18 = v6;
      }
      else
      {
        v18 = (char *)realloc(v6, (unsigned int)v9);
        v11 = v9;
        if ( !v18 )
        {
          free(v6);
          v72 = ptr;
          goto LABEL_151;
        }
      }
      v6 = v18;
      memcpy(&v18[v15], src, (unsigned int)v17);
      if ( v9 >= 2 )
      {
        v19 = 0;
        while ( 1 )
        {
          v20 = (unsigned __int8)v6[v19];
          if ( v20 == 10 )
            break;
          if ( v20 == 13 )
          {
            LODWORD(v21) = v19 + 1;
            if ( v6[v19 + 1] == 10 )
            {
              v21 = v19 + 2LL;
              if ( v19 + 2 < v9 && v6[v21] == 13 )
              {
                v22 = v19 + 3LL;
                if ( (int)v22 >= v9 )
                {
                  v10 = 0;
                }
                else
                {
                  v23 = (unsigned __int8)v6[v22];
                  v24 = v19 + 4;
LABEL_23:
                  if ( v23 == 10 )
                    v10 = v24;
                  else
                    v10 = 0;
                }
                v19 = v22;
                goto LABEL_29;
              }
            }
            v10 = 0;
            v19 = v21;
          }
          else
          {
            v10 = 0;
          }
LABEL_29:
          ++v19;
          v25 = v10 == 0;
          if ( v19 >= v9 - 1 || v10 )
            goto LABEL_34;
        }
        v22 = v19 + 1LL;
        v23 = (unsigned __int8)v6[v22];
        v24 = v19 + 2;
        goto LABEL_23;
      }
      v10 = 0;
      v25 = 1;
LABEL_34:
      v14 = 0;
    }
    while ( v25 );
    if ( v10 >= 2 )
    {
      v26 = v10 - 1;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      nptr = v6 + 1;
      v82 = s;
      do
      {
        v31 = (unsigned __int8)v6[v30];
        v86 = v30;
        if ( v31 == 58 && v29 >= 1 && v28 <= v29 )
        {
          if ( v30 < v26 )
          {
            s = v82;
            v32 = 0LL;
            while ( 1 )
            {
              v33 = (unsigned __int8)nptr[v30 + v32];
              if ( v33 != 32 && v33 != 9 )
                break;
              if ( v10 - 1 - (__int64)v30 == ++v32 )
              {
                v28 = v30;
                v30 = v26;
                v27 = v10;
                goto LABEL_77;
              }
            }
            v30 += v32;
            v27 = v30 + 1;
            v28 = v86;
            goto LABEL_77;
          }
          v27 = v30 + 1;
        }
        else
        {
          if ( v31 != 13 && v31 != 10 )
            goto LABEL_76;
          if ( !status_code || v29 )
          {
            v39 = v28 - v29;
            if ( v28 > v29 && v27 > v28 )
            {
              v40 = &v6[v29];
              v73 = v39;
              if ( !strncasecmp(v40, "content-length", v39) )
              {
                v80 = atoi(&v6[v27]);
              }
              else if ( !strncasecmp(v40, "transfer-encoding", v73) )
              {
                v41 = strncasecmp(&v6[v27], "chunked", 7uLL);
                v42 = v75;
                if ( !v41 )
                  v42 = 1;
                v75 = v42;
              }
            }
          }
          else if ( v30 >= 1 )
          {
            v34 = (unsigned int)v30;
            v35 = v6 + 1;
            v36 = status_code;
            do
            {
              if ( *(v35 - 1) == 32 )
              {
                v37 = v11;
                if ( (*v36 & 0x80000000) == 0 )
                  break;
                v38 = v36;
                *v36 = atoi(v35);
                v36 = v38;
                v11 = v37;
              }
              --v34;
              ++v35;
            }
            while ( v34 );
            v26 = v10 - 1;
          }
          if ( v30 < v9 )
          {
            v43 = &nptr[v30];
            for ( i = v9 - 1LL - v30; ; --i )
            {
              if ( (unsigned __int8)v31 != 13 && (unsigned __int8)v31 != 10 )
              {
                v27 = 0;
                v29 = v30;
                v28 = v30;
                goto LABEL_76;
              }
              if ( !i )
                break;
              v45 = *v43++;
              LOBYTE(v31) = v45;
              ++v30;
            }
            v27 = 0;
            v30 = v9;
            v29 = v9;
            v28 = v9;
            goto LABEL_76;
          }
          v27 = 0;
          v29 = v30;
        }
        v28 = v30;
LABEL_76:
        s = v82;
LABEL_77:
        ++v30;
      }
      while ( v30 < v26 );
    }
    v17 = v9 - v10;
    memcpy(src, &v6[v10], v9 - v10);
LABEL_83:
    v46 = v78;
    if ( !v75 )
      break;
    if ( v17 >= 1 )
    {
      v13 = v84;
      LODWORD(v47) = 0;
      v48 = v78;
      v83 = s;
      while ( 2 )
      {
        v85 = v13;
        do
        {
          if ( v8 )
            goto LABEL_118;
          v49 = v88;
          if ( !v88 )
          {
            v47 = src[(int)v47] == 13 ? (int)v47 + 1LL : (int)v47;
            if ( (int)v47 < v17 && src[v47] == 10 )
              LODWORD(v47) = v47 + 1;
          }
          if ( (int)v47 < v17 )
          {
            v50 = *_ctype_b_loc();
            v51 = 0LL;
            while ( (unsigned __int64)v88 + v51 <= 0x1E )
            {
              v52 = (unsigned __int8)src[(int)v47 + v51];
              if ( (v50[v52] & 0x1000) == 0 )
                break;
              v53 = &v89[v88 + 1 + v51++];
              *(v53 - 1) = v52;
              *v53 = 0;
              if ( (unsigned int)v17 - (__int64)(int)v47 == v51 )
              {
                v49 = v17 + v88 - v47;
                LODWORD(v47) = v17;
                goto LABEL_102;
              }
            }
            LODWORD(v47) = v47 + v51;
            v49 = v88 + v51;
LABEL_102:
            v13 = v85;
          }
          v47 = (int)v47;
          while ( v47 < (unsigned int)v17 )
          {
            v54 = (unsigned __int8)src[v47++];
            if ( v54 == 13 || v54 == 10 )
            {
              if ( v54 != 13 )
                LODWORD(v47) = v47 - 1;
              break;
            }
          }
          v88 = v49;
          if ( v17 <= (int)v47 )
          {
            v8 = 0;
            v46 = v48;
            goto LABEL_146;
          }
          v8 = 0;
        }
        while ( src[(int)v47] != 10 );
        if ( !v88 )
        {
          v89[0] = 0;
LABEL_154:
          v78 = v48;
          goto end_of_stream;
        }
        v8 = 0;
        v55 = v88;
        v56 = v89;
        do
        {
          v57 = (unsigned __int8)*v56++;
          v58 = v57 - 0x30;
          v59 = (v57 | 0x20) - 0x57;
          if ( (unsigned int)(v57 - 0x30) < 0xA )
            v59 = v58;
          --v55;
          v8 = v59 + 16 * v8;
        }
        while ( v55 );
        v89[0] = 0;
        if ( !v8 )
          goto LABEL_154;
        LODWORD(v13) = v85;
        LODWORD(v47) = v47 + 1;
        v88 = 0;
LABEL_118:
        if ( v8 >= v17 - (int)v47 )
          v60 = v17 - v47;
        else
          v60 = v8;
        v61 = v60 + v48;
        v87 = v48;
        if ( v60 + v48 <= (unsigned int)v13 )
        {
          v64 = ptr;
          v48 += v60;
        }
        else
        {
          v79 = v11;
          v62 = ptr;
          v48 += v60;
          if ( v80 >= v61 )
            v63 = (unsigned int)v80;
          else
            v63 = (unsigned int)v61;
          v85 = v63;
          v64 = (char *)realloc(ptr, v63);
          if ( !v64 )
            goto LABEL_152;
          v11 = v79;
        }
        ptr = v64;
        memcpy(&v64[v87], &src[(int)v47], v60);
        LODWORD(v47) = v60 + v47;
        v8 -= v60;
        s = v83;
        v13 = v85;
        v46 = v48;
        if ( (int)v47 < v17 )
          continue;
        goto LABEL_146;
      }
    }
LABEL_145:
    v13 = v84;
LABEL_146:
    v78 = v46;
    v12 = v80;
    if ( v80 >= 1 && v78 >= v80 )
    {
end_of_stream:
      free(v6);
      *v74 = v78;
      if ( v78 )
        return ptr;
      free(ptr);
      return 0LL;
    }
  }
  if ( v17 + v78 <= v80 || v80 <= 0 )
    v66 = v17;
  else
    v66 = v80 - v78;
  v67 = v78;
  v68 = v66 + v78;
  if ( v66 + v78 <= (unsigned int)v84 )
  {
    v71 = ptr;
    goto LABEL_144;
  }
  v69 = v11;
  v62 = ptr;
  if ( v80 >= v68 )
    v70 = (unsigned int)v80;
  else
    v70 = (unsigned int)v68;
  v84 = v70;
  v71 = (char *)realloc(ptr, v70);
  if ( v71 )
  {
    v67 = v78;
    v11 = v69;
LABEL_144:
    ptr = v71;
    memcpy(&v71[v67], src, v66);
    v46 = v66 + v78;
    goto LABEL_145;
  }
LABEL_152:
  free(v62);
  v72 = v6;
LABEL_151:
  free(v72);
  result = 0LL;
  *v74 = -1;
  return result;
}
