void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int v3; // w0
  __int64 v4; // x11
  int v6; // [xsp+8h] [xbp-8D8h]
  bool v7; // [xsp+Ch] [xbp-8D4h]
  bool v8; // [xsp+10h] [xbp-8D0h]
  bool v9; // [xsp+14h] [xbp-8CCh]
  bool v10; // [xsp+18h] [xbp-8C8h]
  bool v11; // [xsp+1Ch] [xbp-8C4h]
  bool v12; // [xsp+20h] [xbp-8C0h]
  bool v13; // [xsp+24h] [xbp-8BCh]
  void *v14; // [xsp+28h] [xbp-8B8h]
  void *v15; // [xsp+30h] [xbp-8B0h]
  unsigned int m; // [xsp+3Ch] [xbp-8A4h]
  int v17; // [xsp+40h] [xbp-8A0h]
  int k; // [xsp+44h] [xbp-89Ch]
  void *v19; // [xsp+48h] [xbp-898h]
  int v20; // [xsp+54h] [xbp-88Ch]
  int v21; // [xsp+58h] [xbp-888h]
  int v22; // [xsp+5Ch] [xbp-884h]
  int i; // [xsp+60h] [xbp-880h]
  int j; // [xsp+60h] [xbp-880h]
  unsigned int v25; // [xsp+64h] [xbp-87Ch]
  char v26[32]; // [xsp+68h] [xbp-878h]
  unsigned int v27; // [xsp+88h] [xbp-858h]
  _DWORD v28[3]; // [xsp+8Ch] [xbp-854h]
  int v29; // [xsp+98h] [xbp-848h]
  _DWORD v30[3]; // [xsp+9Ch] [xbp-844h]
  size_t v31; // [xsp+A8h] [xbp-838h]
  unsigned int v32; // [xsp+B0h] [xbp-830h]
  int v33; // [xsp+B4h] [xbp-82Ch]
  int v34; // [xsp+B8h] [xbp-828h]
  int n; // [xsp+BCh] [xbp-824h]
  _BYTE n_4[2048]; // [xsp+C0h] [xbp-820h] BYREF
  int *v37; // [xsp+8C0h] [xbp-20h]
  int *v38; // [xsp+8C8h] [xbp-18h]
  unsigned int v39; // [xsp+8D4h] [xbp-Ch]

  v39 = s;
  v38 = size;
  v37 = status_code;
  v34 = 0;
  v33 = 0;
  v32 = -1;
  v31 = 0LL;
  v30[0] = 2048;
  v29 = 0;
  v28[0] = 2048;
  v27 = 0;
  if ( status_code )
    *v37 = -1;
  *(_QWORD *)&v30[1] = malloc(v30[0]);
  if ( !*(_QWORD *)&v30[1] )
  {
    *v38 = -1;
    return 0LL;
  }
  *(_QWORD *)&v28[1] = malloc(v28[0]);
  if ( !*(_QWORD *)&v28[1] )
  {
    free(*(void **)&v30[1]);
    *v38 = -1;
    return 0LL;
  }
  v26[0] = 0;
  v25 = 0;
  while ( 1 )
  {
    n = receivedata(v39, n_4, 2048LL, 5000LL, 0LL);
    if ( n <= 0 )
      break;
    if ( v34 )
      goto LABEL_72;
    v22 = 0;
    v21 = 0;
    v20 = 0;
    if ( (unsigned int)(v29 + n) > v30[0] )
    {
      v19 = realloc(*(void **)&v30[1], (unsigned int)(v29 + n));
      if ( !v19 )
      {
        free(*(void **)&v30[1]);
        free(*(void **)&v28[1]);
        *v38 = -1;
        return 0LL;
      }
      *(_QWORD *)&v30[1] = v19;
      v30[0] = v29 + n;
    }
    memcpy((void *)(*(_QWORD *)&v30[1] + (unsigned int)v29), n_4, n);
    v29 += n;
    for ( i = 0; ; ++i )
    {
      v13 = 0;
      if ( i < v29 - 1 )
        v13 = v34 == 0;
      if ( !v13 )
        break;
      if ( *(_BYTE *)(*(_QWORD *)&v30[1] + i) == 0xD )
      {
        if ( *(_BYTE *)(*(_QWORD *)&v30[1] + ++i) == 0xA
          && ++i < v29
          && *(_BYTE *)(*(_QWORD *)&v30[1] + i) == 0xD
          && ++i < v29
          && *(_BYTE *)(*(_QWORD *)&v30[1] + i) == 0xA )
        {
          v34 = i + 1;
        }
      }
      else if ( *(_BYTE *)(*(_QWORD *)&v30[1] + i) == 0xA && *(_BYTE *)(*(_QWORD *)&v30[1] + ++i) == 0xA )
      {
        v34 = i + 1;
      }
    }
    if ( v34 )
    {
      for ( j = 0; j < v34 - 1; ++j )
      {
        if ( v22 > 0 && v21 <= v22 && *(_BYTE *)(*(_QWORD *)&v30[1] + j) == 0x3A )
        {
          v21 = j;
          while ( 1 )
          {
            v12 = 0;
            if ( j < v34 - 1 )
            {
              v11 = 1;
              if ( *(_BYTE *)(*(_QWORD *)&v30[1] + j + 1) != 0x20 )
                v11 = *(_BYTE *)(*(_QWORD *)&v30[1] + j + 1) == 9;
              v12 = v11;
            }
            if ( !v12 )
              break;
            ++j;
          }
          v20 = j + 1;
        }
        else if ( *(_BYTE *)(*(_QWORD *)&v30[1] + j) == 0xD || *(_BYTE *)(*(_QWORD *)&v30[1] + j) == 0xA )
        {
          if ( v22 || !v37 )
          {
            if ( v21 > v22 && v20 > v21 )
            {
              if ( !strncasecmp((const char *)(*(_QWORD *)&v30[1] + v22), "content-length", v21 - v22) )
              {
                v32 = atoi((const char *)(*(_QWORD *)&v30[1] + v20));
              }
              else if ( !strncasecmp((const char *)(*(_QWORD *)&v30[1] + v22), "transfer-encoding", v21 - v22)
                     && !strncasecmp((const char *)(*(_QWORD *)&v30[1] + v20), "chunked", 7uLL) )
              {
                v33 = 1;
              }
            }
          }
          else
          {
            for ( k = 0; k < j; ++k )
            {
              if ( *(_BYTE *)(*(_QWORD *)&v30[1] + k) == 0x20 )
              {
                if ( *v37 >= 0 )
                  goto LABEL_63;
                v3 = atoi((const char *)(*(_QWORD *)&v30[1] + k + 1LL));
                *v37 = v3;
              }
            }
          }
          while ( 1 )
          {
LABEL_63:
            v10 = 0;
            if ( j < v29 )
            {
              v9 = 1;
              if ( *(_BYTE *)(*(_QWORD *)&v30[1] + j) != 0xD )
                v9 = *(_BYTE *)(*(_QWORD *)&v30[1] + j) == 0xA;
              v10 = v9;
            }
            if ( !v10 )
              break;
            ++j;
          }
          v22 = j;
          v21 = j;
          v20 = 0;
        }
      }
      n = v29 - v34;
      memcpy(n_4, (const void *)(*(_QWORD *)&v30[1] + v34), v29 - v34);
LABEL_72:
      if ( v34 )
      {
        if ( v33 )
        {
          v17 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( v17 >= n )
                goto LABEL_133;
              if ( !HIDWORD(v31) )
                break;
LABEL_109:
              if ( HIDWORD(v31) >= n - v17 )
                v6 = n - v17;
              else
                v6 = HIDWORD(v31);
              LODWORD(v31) = v6;
              if ( v27 + v6 > v28[0] )
              {
                if ( (v32 & 0x80000000) != 0 || v32 < v27 + (unsigned int)v31 )
                  v28[0] = v27 + v31;
                else
                  v28[0] = v32;
                v15 = realloc(*(void **)&v28[1], v28[0]);
                if ( !v15 )
                  goto LABEL_118;
                *(_QWORD *)&v28[1] = v15;
              }
              memcpy((void *)(*(_QWORD *)&v28[1] + v27), &n_4[v17], (unsigned int)v31);
              v27 += v31;
              v17 += v31;
              HIDWORD(v31) -= v31;
            }
            if ( !v25 )
            {
              if ( v17 < n && n_4[v17] == 0xD )
                ++v17;
              if ( v17 < n && n_4[v17] == 0xA )
                ++v17;
            }
            while ( 1 )
            {
              v8 = 0;
              if ( v17 < n )
              {
                v8 = 0;
                if ( ((*_ctype_b_loc())[(unsigned __int8)n_4[v17]] & 0x1000) != 0 )
                  v8 = v25 < 0x1FuLL;
              }
              if ( !v8 )
                break;
              v4 = v25++;
              v26[v4] = n_4[v17];
              v26[v25] = 0;
              ++v17;
            }
            while ( 1 )
            {
              v7 = 0;
              if ( v17 < n )
              {
                v7 = 0;
                if ( n_4[v17] != 0xD )
                  v7 = n_4[v17] != 0xA;
              }
              if ( !v7 )
                break;
              ++v17;
            }
            if ( v17 < n && n_4[v17] == 0xD )
              ++v17;
            if ( v17 < n && n_4[v17] == 0xA )
            {
              for ( m = 0; m < v25; ++m )
              {
                if ( (unsigned __int8)v26[m] < 0x30u || (unsigned __int8)v26[m] > 0x39u )
                  HIDWORD(v31) = ((unsigned __int8)v26[m] | 0x20) - 87 + 16 * HIDWORD(v31);
                else
                  HIDWORD(v31) = (unsigned __int8)v26[m] - 0x30 + 16 * HIDWORD(v31);
              }
              v26[0] = 0;
              v25 = 0;
              ++v17;
              if ( !HIDWORD(v31) )
                goto end_of_stream;
              goto LABEL_109;
            }
          }
        }
        if ( (int)v32 > 0 && v27 + n > v32 )
          n = v32 - v27;
        if ( v27 + n > v28[0] )
        {
          if ( (v32 & 0x80000000) != 0 || v32 < v27 + n )
            v28[0] = v27 + n;
          else
            v28[0] = v32;
          v14 = realloc(*(void **)&v28[1], v28[0]);
          if ( !v14 )
          {
LABEL_118:
            free(*(void **)&v28[1]);
            free(*(void **)&v30[1]);
            *v38 = -1;
            return 0LL;
          }
          *(_QWORD *)&v28[1] = v14;
        }
        memcpy((void *)(*(_QWORD *)&v28[1] + v27), n_4, n);
        v27 += n;
      }
LABEL_133:
      if ( (int)v32 > 0 && v27 >= v32 )
        break;
    }
  }
end_of_stream:
  free(*(void **)&v30[1]);
  *(_QWORD *)&v30[1] = 0LL;
  *v38 = v27;
  if ( !v27 )
  {
    free(*(void **)&v28[1]);
    *(_QWORD *)&v28[1] = 0LL;
  }
  return *(void **)&v28[1];
}
