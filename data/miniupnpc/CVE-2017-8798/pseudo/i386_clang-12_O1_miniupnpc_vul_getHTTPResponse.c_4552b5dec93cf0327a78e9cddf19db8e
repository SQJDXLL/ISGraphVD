void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // eax
  char *v4; // ebp
  void *v5; // eax
  int v6; // ebx
  char *v7; // edi
  int v8; // eax
  int v9; // ebx
  char *v10; // ecx
  bool v11; // dl
  int v12; // edi
  int v13; // ecx
  char v14; // dl
  int v15; // edx
  bool v16; // zf
  int v17; // eax
  int v18; // ecx
  int v19; // edi
  int v20; // esi
  int *v21; // edx
  size_t v22; // eax
  char v23; // cl
  char v24; // al
  char *v25; // edi
  int v26; // ebp
  int v27; // eax
  size_t v28; // ebp
  const char *v29; // edi
  char v30; // al
  int v31; // eax
  int v32; // ecx
  signed int v33; // ebp
  char *v34; // edx
  signed int v35; // ebx
  signed int v36; // eax
  int v37; // edi
  size_t v38; // esi
  int v39; // edi
  char *v40; // eax
  signed int v41; // ecx
  char *v42; // ebx
  char *v43; // ebp
  char *v44; // ebp
  unsigned int v45; // edi
  char *v46; // esi
  const unsigned __int16 *v47; // eax
  int v48; // ecx
  unsigned int v49; // edx
  char v50; // al
  signed int v51; // ebp
  int v52; // eax
  char v53; // cl
  int v54; // ebp
  int v55; // ebp
  size_t v56; // esi
  int v57; // ebp
  size_t v58; // eax
  char *v59; // eax
  char *v60; // ecx
  int v61; // eax
  void *result; // eax
  int v63; // eax
  char *v64; // [esp+0h] [ebp-87Ch]
  void *ptr; // [esp+18h] [ebp-864h]
  void *v66; // [esp+1Ch] [ebp-860h]
  size_t v67; // [esp+20h] [ebp-85Ch]
  char *v68; // [esp+24h] [ebp-858h]
  int v69; // [esp+28h] [ebp-854h]
  int v70; // [esp+2Ch] [ebp-850h]
  int v71; // [esp+30h] [ebp-84Ch]
  char *nptr; // [esp+34h] [ebp-848h]
  size_t v73; // [esp+38h] [ebp-844h]
  unsigned int v74; // [esp+3Ch] [ebp-840h]
  unsigned int v75; // [esp+40h] [ebp-83Ch]
  unsigned int v76; // [esp+44h] [ebp-838h]
  int v77; // [esp+48h] [ebp-834h]
  char v78[32]; // [esp+4Ch] [ebp-830h]
  char src[2064]; // [esp+6Ch] [ebp-810h] BYREF

  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800u);
  if ( !v3 )
  {
    *size = -1;
    return 0;
  }
  v4 = v3;
  v5 = malloc(0x800u);
  if ( !v5 )
  {
    free(v4);
    *size = -1;
    return 0;
  }
  ptr = v5;
  v78[0] = 0;
  v76 = 2048;
  v6 = -1;
  v77 = 0;
  v73 = 0;
  v7 = 0;
  v74 = 2048;
  v68 = 0;
  v75 = 0;
  v8 = 0;
  while ( 2 )
  {
    v70 = v8;
    do
    {
      v67 = receivedata(s, src, 2048, 5000, 0);
      if ( (int)v67 <= 0 )
        goto end_of_stream;
      v8 = v70;
      if ( v70 )
        goto LABEL_79;
      v69 = v6;
      v9 = (int)&v7[v67];
      if ( (unsigned int)&v7[v67] > v76 )
      {
        v10 = (char *)realloc(v4, (size_t)&v7[v67]);
        if ( !v10 )
        {
          free(v4);
          free(ptr);
          *size = -1;
          v70 = 0;
          v17 = 1;
          goto LABEL_8;
        }
        v4 = v10;
        v76 = v9;
      }
      memcpy(&v7[(_DWORD)v4], src, v67);
      v11 = 1;
      v12 = 0;
      if ( v9 >= 2 )
      {
        v13 = 0;
        while ( 1 )
        {
          v14 = v4[v13];
          if ( v14 == 10 )
          {
            v15 = v13 + 1;
            v12 = v13 + 2;
            v16 = v4[v13 + 1] == 10;
LABEL_24:
            if ( !v16 )
              v12 = 0;
            goto LABEL_30;
          }
          if ( v14 != 13 )
            goto LABEL_28;
          if ( v4[v13 + 1] != 10 )
            break;
          v15 = v13 + 2;
          if ( v13 + 2 < v9 )
          {
            v12 = 0;
            if ( v4[v15] != 13 )
              goto LABEL_30;
            v15 = v13 + 3;
            if ( v13 + 3 < v9 )
            {
              v12 = v13 + 4;
              v16 = v4[v13 + 3] == 10;
              goto LABEL_24;
            }
          }
LABEL_29:
          v12 = 0;
LABEL_30:
          v13 = v15 + 1;
          v11 = v12 == 0;
          if ( v13 >= v9 - 1 || v12 )
            goto LABEL_32;
        }
        ++v13;
LABEL_28:
        v15 = v13;
        goto LABEL_29;
      }
LABEL_32:
      v70 = v12;
      v17 = 2;
      if ( v11 )
      {
        v7 = (char *)v9;
        v70 = 0;
      }
      else
      {
        if ( v70 >= 2 )
        {
          v67 = v70 - 1;
          nptr = v4 + 1;
          v71 = 0;
          v18 = 0;
          v19 = 0;
          v20 = 0;
          v21 = status_code;
          v66 = v4;
          do
          {
            if ( v19 > 0 && v18 <= v19 && v4[v20] == 58 )
            {
              v22 = v20;
              if ( v20 < (int)v67 )
              {
                v22 = v20;
                while ( 1 )
                {
                  v23 = v4[v22 + 1];
                  if ( v23 != 32 && v23 != 9 )
                    break;
                  if ( v67 == ++v22 )
                  {
                    v22 = v67;
                    break;
                  }
                }
              }
              v71 = v22 + 1;
            }
            else
            {
              v24 = v4[v20];
              if ( v24 == 13 || v24 == 10 )
              {
                if ( v21 && !v19 )
                {
                  if ( v20 > 0 )
                  {
                    v25 = nptr;
                    v26 = v20;
                    while ( 1 )
                    {
                      if ( *(v25 - 1) == 32 )
                      {
                        if ( *v21 >= 0 )
                          goto LABEL_63;
                        v27 = atoi(v25);
                        v21 = status_code;
                        *status_code = v27;
                      }
                      ++v25;
                      if ( !--v26 )
                        goto LABEL_63;
                    }
                  }
                  goto LABEL_64;
                }
                v28 = v18 - v19;
                if ( v18 <= v19 || v71 <= v18 )
                {
LABEL_63:
                  v4 = (char *)v66;
                }
                else
                {
                  v29 = (char *)v66 + v19;
                  if ( !strncasecmp(v29, "content-length", v28) )
                  {
                    v4 = (char *)v66;
                    v69 = atoi((const char *)v66 + v71);
                  }
                  else
                  {
                    if ( strncasecmp(v29, "transfer-encoding", v28) )
                    {
                      v21 = status_code;
                      goto LABEL_63;
                    }
                    v4 = (char *)v66;
                    v31 = strncasecmp((const char *)v66 + v71, "chunked", 7u);
                    v32 = v77;
                    if ( !v31 )
                      v32 = 1;
                    v77 = v32;
                  }
                  v21 = status_code;
                }
LABEL_64:
                v71 = 0;
                if ( v20 < v9 )
                {
                  while ( 1 )
                  {
                    v30 = v4[v20];
                    if ( v30 != 13 && v30 != 10 )
                      break;
                    if ( v9 == ++v20 )
                    {
                      v22 = v9;
                      v19 = v9;
                      v20 = v9;
                      goto LABEL_37;
                    }
                  }
                }
                v22 = v20;
                v19 = v20;
                goto LABEL_37;
              }
              v22 = v20;
              v20 = v18;
            }
LABEL_37:
            v18 = v20;
            v20 = v22 + 1;
          }
          while ( (int)(v22 + 1) < (int)v67 );
        }
        v67 = v9 - v70;
        memcpy(src, &v4[v70], v9 - v70);
        v17 = 0;
        v7 = (char *)v9;
      }
LABEL_8:
      v6 = v69;
    }
    while ( v17 == 2 );
    v16 = v17 == 0;
    v8 = v70;
    if ( !v16 )
      return 0;
LABEL_79:
    if ( !v8 )
      goto LABEL_140;
    v70 = v8;
    if ( !v77 )
    {
      nptr = v7;
      v38 = v6 - (_DWORD)v68;
      if ( (int)&v68[v67] <= v6 )
        v38 = v67;
      if ( v6 <= 0 )
        v38 = v67;
      v39 = (int)&v68[v38];
      v40 = (char *)ptr;
      if ( (unsigned int)&v68[v38] > v74 )
      {
        v41 = v6;
        v42 = v4;
        v69 = v41;
        if ( v41 < v39 )
          v41 = (signed int)&v68[v38];
        v74 = v41;
        v40 = (char *)realloc(ptr, v41);
        v43 = v40;
        if ( !v40 )
        {
          free(ptr);
          free(v42);
          *size = -1;
          v40 = (char *)ptr;
        }
        v16 = v43 == 0;
        v4 = v42;
        v6 = v69;
        if ( v16 )
          return 0;
      }
      ptr = v40;
      memcpy(&v68[(_DWORD)v40], src, v38);
      v68 = (char *)v39;
      v8 = v70;
      v7 = nptr;
LABEL_140:
      if ( v6 > 0 && (int)v68 >= v6 )
        goto end_of_stream;
      continue;
    }
    break;
  }
  v66 = v4;
  v33 = v67;
  v34 = (char *)ptr;
  if ( (int)v67 <= 0 )
  {
    v57 = (int)v68;
    v61 = 0;
    goto LABEL_138;
  }
  nptr = v7;
  v69 = v6;
  v35 = 0;
  v36 = v73;
  v37 = (int)v68;
  while ( 2 )
  {
    v71 = v37;
    v45 = v75;
    v46 = v34;
    while ( 2 )
    {
      if ( v36 )
      {
        v75 = v45;
        goto LABEL_128;
      }
      if ( !v45 )
      {
        v35 += src[v35] == 13;
        if ( v35 < v33 )
          v35 += src[v35] == 10;
      }
      if ( v35 >= v33 )
        goto LABEL_110;
      v47 = *_ctype_b_loc();
      while ( v45 <= 0x1E )
      {
        v48 = src[v35];
        if ( (v47[v48] & 0x1000) == 0 )
          break;
        v49 = v45 + 1;
        v78[v45] = v48;
        v78[v45 + 1] = 0;
        ++v35;
        ++v45;
        if ( v33 == v35 )
        {
          v45 = v49;
          v35 = v33;
          break;
        }
      }
      v34 = v46;
      if ( v35 >= v33 )
      {
LABEL_110:
        if ( v35 < v33 )
          goto LABEL_118;
LABEL_98:
        v36 = 0;
        if ( v35 < v33 )
          continue;
        v73 = 0;
        v75 = v45;
        v61 = 0;
LABEL_136:
        v6 = v69;
        v7 = nptr;
        v57 = v71;
        goto LABEL_138;
      }
      break;
    }
    while ( 1 )
    {
      v50 = src[v35];
      if ( v50 == 10 || v50 == 13 )
        break;
      if ( v33 == ++v35 )
      {
        v35 = v33;
        goto LABEL_98;
      }
    }
    v35 += v50 == 13;
    if ( v35 >= v33 )
      goto LABEL_98;
LABEL_118:
    if ( src[v35] != 10 )
      goto LABEL_98;
    v75 = 0;
    v51 = 0;
    if ( v45 )
    {
      v52 = 0;
      v51 = 0;
      do
      {
        v53 = v78[v52];
        v55 = 16 * v51;
        if ( (unsigned __int8)(v53 - 48) > 9u )
        {
          v53 |= 0x20u;
          v54 = v55 - 87;
        }
        else
        {
          v54 = v55 - 48;
        }
        v51 = v54 + v53;
        ++v52;
      }
      while ( v45 != v52 );
    }
    v78[0] = 0;
    if ( !v51 )
    {
      v61 = 25;
      v73 = 0;
      v34 = v46;
      goto LABEL_136;
    }
    v36 = v51;
    ++v35;
    v34 = v46;
    v33 = v67;
LABEL_128:
    v56 = v33 - v35;
    v73 = v36;
    if ( v36 < v33 - v35 )
      v56 = v36;
    v57 = v71;
    v37 = v56 + v71;
    if ( v56 + v71 <= v74 )
    {
LABEL_96:
      v64 = &v34[v57];
      v44 = v34;
      memcpy(v64, &src[v35], v56);
      v34 = v44;
      v35 += v56;
      v36 = v73 - v56;
      v33 = v67;
      if ( v35 < (int)v67 )
        continue;
      v73 -= v56;
      v61 = 0;
      v57 = v37;
    }
    else
    {
      v58 = v69;
      if ( v69 < v37 )
        v58 = v56 + v71;
      v74 = v58;
      ptr = v34;
      v59 = (char *)realloc(v34, v58);
      v60 = v59;
      if ( !v59 )
      {
        v68 = 0;
        free(ptr);
        free(v66);
        *size = -1;
        v59 = v68;
        v60 = (char *)ptr;
      }
      if ( v59 )
      {
        v34 = v60;
        goto LABEL_96;
      }
      v61 = 1;
      v34 = v60;
    }
    break;
  }
  v6 = v69;
  v7 = nptr;
LABEL_138:
  ptr = v34;
  if ( !v61 )
  {
    v68 = (char *)v57;
    v4 = (char *)v66;
    v8 = v70;
    goto LABEL_140;
  }
  v68 = (char *)v57;
  v16 = v61 == 25;
  v4 = (char *)v66;
  result = 0;
  if ( v16 )
  {
end_of_stream:
    free(v4);
    v63 = (int)v68;
    *size = (int)v68;
    if ( v63 )
      return ptr;
    free(ptr);
    return 0;
  }
  return result;
}
