void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int *v3; // ebp
  int v4; // eax
  int v5; // esi
  char v6; // dl
  int v7; // ebx
  int v8; // esi
  char *v9; // edi
  int v10; // ecx
  int v11; // eax
  char v12; // dl
  char v13; // dl
  char v14; // al
  int v15; // edx
  const char *v16; // ebp
  const char *v17; // esi
  int *v18; // edi
  bool v19; // zf
  int v20; // eax
  char v21; // al
  int v22; // esi
  int v23; // esi
  const unsigned __int16 *v24; // ebp
  unsigned int v25; // eax
  unsigned int v26; // ebx
  char *v27; // edi
  char v28; // cl
  char v29; // dl
  unsigned int v30; // ebp
  char *v31; // ecx
  char *v32; // edi
  int v33; // edx
  char v34; // al
  int *v35; // ebp
  size_t v36; // edi
  int v37; // eax
  char *v38; // eax
  size_t v39; // edi
  unsigned int v40; // ebp
  char *v41; // eax
  char *v42; // esi
  _DWORD *v43; // ebp
  int v45; // eax
  int v46; // eax
  char *v47; // eax
  char *v48; // edi
  int n; // [esp+0h] [ebp-89Ch]
  int na; // [esp+0h] [ebp-89Ch]
  unsigned int content_buf_used; // [esp+4h] [ebp-898h]
  unsigned int chunksize; // [esp+Ch] [ebp-890h]
  char *content_buf; // [esp+14h] [ebp-888h]
  unsigned int content_buf_len; // [esp+18h] [ebp-884h]
  int header_buf_used_0; // [esp+1Ch] [ebp-880h]
  int endofheaders; // [esp+20h] [ebp-87Ch]
  int content_length; // [esp+24h] [ebp-878h]
  unsigned int chunksize_buf_index; // [esp+28h] [ebp-874h]
  char *header_buf; // [esp+2Ch] [ebp-870h]
  int valuestart; // [esp+30h] [ebp-86Ch]
  int v61; // [esp+34h] [ebp-868h]
  int chunked; // [esp+38h] [ebp-864h]
  unsigned int header_buf_len; // [esp+3Ch] [ebp-860h]
  int v64; // [esp+40h] [ebp-85Ch]
  int i; // [esp+44h] [ebp-858h]
  int *v66; // [esp+48h] [ebp-854h]
  int *v67; // [esp+4Ch] [ebp-850h]
  char chunksize_buf[32]; // [esp+5Ch] [ebp-840h] BYREF
  char buf[2048]; // [esp+7Ch] [ebp-820h] BYREF
  unsigned int v71; // [esp+87Ch] [ebp-20h]

  v66 = status_code;
  v71 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    *size = -1;
    return 0;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  v67 = size;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        na = receivedata(s, buf, 2048, 5000, 0);
        if ( na <= 0 )
        {
          v43 = v67;
          goto end_of_stream;
        }
        if ( endofheaders )
        {
          if ( chunked )
            goto LABEL_79;
LABEL_140:
          if ( content_length <= 0 )
          {
            v39 = na;
            v40 = content_buf_used + na;
            if ( content_buf_len < content_buf_used + na )
            {
              if ( content_length )
              {
                content_buf_len = content_buf_used + na;
                v41 = (char *)realloc(content_buf, content_buf_used + na);
                goto LABEL_147;
              }
LABEL_144:
              v46 = content_length;
              if ( content_length < v40 )
                v46 = v40;
              content_buf_len = v46;
              v41 = (char *)realloc(content_buf, v46);
LABEL_147:
              v42 = v41;
              if ( !v41 )
              {
LABEL_110:
                v35 = v67;
                free(content_buf);
                free(header_buf);
                *v35 = -1;
                return 0;
              }
              goto LABEL_148;
            }
            v42 = content_buf;
          }
          else
          {
            v45 = content_length - content_buf_used;
            if ( content_length >= na + content_buf_used )
              v45 = na;
            v39 = v45;
            v40 = content_buf_used + v45;
            if ( content_buf_len < content_buf_used + v45 )
              goto LABEL_144;
            v42 = content_buf;
          }
LABEL_148:
          memcpy(&v42[content_buf_used], buf, v39);
          content_buf_used = v40;
          content_buf = v42;
          goto LABEL_149;
        }
        header_buf_used_0 = valuestart + na;
        if ( header_buf_len < valuestart + na )
        {
          v47 = (char *)realloc(header_buf, valuestart + na);
          if ( !v47 )
          {
            v3 = v67;
            free(header_buf);
            free(content_buf);
            *v3 = -1;
            return 0;
          }
          header_buf_len = header_buf_used_0;
          header_buf = v47;
        }
        v48 = header_buf;
        memcpy(&header_buf[valuestart], buf, na);
        if ( header_buf_used_0 > 1 )
          break;
        valuestart = header_buf_used_0;
      }
      v4 = 0;
      do
      {
        v6 = v48[v4];
        if ( v6 == 13 )
        {
          if ( v48[v4 + 1] == 10 )
          {
            if ( v4 + 2 >= header_buf_used_0 )
            {
              v4 += 2;
              v5 = 0;
            }
            else if ( v48[v4 + 2] == 13 )
            {
              if ( v4 + 3 >= header_buf_used_0 )
              {
                v4 += 3;
                v5 = 0;
              }
              else if ( v48[v4 + 3] == 10 )
              {
                v5 = v4 + 4;
                v4 += 3;
              }
              else
              {
                v4 += 3;
                v5 = 0;
              }
            }
            else
            {
              v4 += 2;
              v5 = 0;
            }
          }
          else
          {
            ++v4;
            v5 = 0;
          }
        }
        else
        {
          v5 = 0;
          if ( v6 == 10 )
          {
            if ( v48[v4 + 1] == 10 )
              v5 = v4 + 2;
            ++v4;
          }
        }
        ++v4;
      }
      while ( !v5 && v4 < header_buf_used_0 - 1 );
      v61 = v5;
      if ( v5 )
        break;
      valuestart = header_buf_used_0;
      endofheaders = 0;
    }
    n = v5 - 1;
    if ( v5 - 1 > 0 )
    {
      valuestart = 0;
      v7 = 0;
      v8 = 0;
      v64 = 0;
      v9 = header_buf;
      v10 = 0;
      do
      {
        if ( v7 <= 0 || v7 < v10 )
        {
          v13 = v9[v8];
          if ( v13 == 13 || v13 == 10 )
          {
            if ( v7 || !v66 )
            {
              if ( v7 < v10 && v10 < valuestart )
              {
                i = v10 - v7;
                if ( !strncasecmp(&v9[v7], "content-length", v10 - v7) )
                {
                  content_length = strtol(&v9[valuestart], 0, 10);
                }
                else if ( !strncasecmp(&v9[v7], "transfer-encoding", i) )
                {
                  v19 = strncasecmp(&v9[valuestart], "chunked", 7u) == 0;
                  v20 = 1;
                  if ( !v19 )
                    v20 = chunked;
                  chunked = v20;
                }
              }
            }
            else
            {
              if ( v8 <= 0 )
              {
                v15 = header_buf_used_0;
                goto LABEL_68;
              }
              v16 = v9 + 1;
              valuestart = (int)v9;
              i = v8;
              v17 = &v9[v8 + 1];
              v18 = v66;
              do
              {
                if ( *(v16 - 1) == 32 )
                {
                  if ( *v18 >= 0 )
                  {
                    v9 = (char *)valuestart;
                    v8 = i;
                    goto LABEL_47;
                  }
                  *v18 = strtol(v16, 0, 10);
                }
                ++v16;
              }
              while ( v16 != v17 );
              v9 = (char *)valuestart;
              v8 = i;
            }
LABEL_47:
            if ( header_buf_used_0 <= v8 )
            {
              valuestart = 0;
              v10 = v8;
              v7 = v8;
            }
            else
            {
              v15 = header_buf_used_0;
              do
              {
LABEL_68:
                v21 = v9[v8];
                if ( v21 != 13 && v21 != 10 )
                {
                  valuestart = v64;
                  v10 = v8;
                  v7 = v8;
                  goto LABEL_41;
                }
                ++v8;
              }
              while ( v8 != v15 );
              valuestart = v64;
              v8 = header_buf_used_0;
              v10 = header_buf_used_0;
              v7 = header_buf_used_0;
            }
          }
        }
        else
        {
          v14 = v9[v8];
          if ( v14 == 58 )
          {
            if ( n <= v8 )
            {
              v11 = v8;
            }
            else
            {
              v11 = v8;
              while ( 1 )
              {
                v12 = v9[v11 + 1];
                if ( v12 != 32 && v12 != 9 )
                  break;
                if ( ++v11 == v61 - 1 )
                {
                  v11 = v61 - 1;
                  break;
                }
              }
            }
            valuestart = v11 + 1;
            v10 = v8;
            v8 = v11;
            goto LABEL_41;
          }
          if ( v14 == 13 || v14 == 10 )
            goto LABEL_47;
        }
LABEL_41:
        ++v8;
      }
      while ( v8 < n );
    }
    v22 = header_buf_used_0 - v61;
    na = header_buf_used_0 - v61;
    memcpy(buf, &header_buf[v61], header_buf_used_0 - v61);
    if ( !chunked )
    {
      valuestart = header_buf_used_0;
      endofheaders = v61;
      goto LABEL_140;
    }
    if ( v22 > 0 )
    {
      valuestart = header_buf_used_0;
      endofheaders = v61;
LABEL_79:
      v23 = 0;
      while ( 1 )
      {
        if ( chunksize )
          goto LABEL_114;
        if ( !chunksize_buf_index )
        {
          if ( buf[v23] == 13 )
            ++v23;
          if ( v23 >= na )
          {
LABEL_137:
            v25 = chunksize_buf_index;
LABEL_96:
            chunksize_buf_index = v25;
            goto LABEL_149;
          }
          if ( buf[v23] != 10 )
            goto LABEL_87;
          ++v23;
        }
        if ( na <= v23 )
          goto LABEL_137;
LABEL_87:
        v24 = *_ctype_b_loc();
        v25 = chunksize_buf_index;
        v26 = chunksize_buf_index + na - v23;
        v27 = &buf[v23 - chunksize_buf_index];
        while ( 1 )
        {
          v28 = v27[v25];
          if ( (v24[v28] & 0x1000) == 0 || v25 > 0x1E )
            break;
          chunksize_buf[v25++] = v28;
          chunksize_buf[v25] = 0;
          ++v23;
          if ( v25 == v26 )
          {
            v25 = v26;
            break;
          }
        }
        if ( v23 >= na )
          goto LABEL_96;
        while ( 1 )
        {
          v29 = buf[v23];
          if ( v29 == 10 || v29 == 13 )
            break;
          if ( na == ++v23 )
            goto LABEL_96;
        }
        if ( na <= v23 )
          goto LABEL_96;
        if ( buf[v23] == 13 && na <= ++v23 )
          goto LABEL_96;
        if ( buf[v23] != 10 )
        {
          chunksize_buf_index = v25;
          v30 = content_buf_used;
          goto LABEL_112;
        }
        if ( !v25 )
        {
          v43 = v67;
          goto end_of_stream;
        }
        v31 = chunksize_buf;
        v32 = &chunksize_buf[v25];
        v33 = 0;
        do
        {
          v34 = *v31;
          if ( (unsigned __int8)(*v31 - 48) > 9u )
            v33 = 16 * v33 + (v34 | 0x20) - 87;
          else
            v33 = 16 * v33 + v34 - 48;
          ++v31;
        }
        while ( v31 != v32 );
        chunksize_buf[0] = 0;
        ++v23;
        if ( !v33 )
        {
          v43 = v67;
          goto end_of_stream;
        }
        chunksize_buf_index = 0;
        chunksize = v33;
LABEL_114:
        v36 = na - v23;
        if ( na - v23 > chunksize )
          v36 = chunksize;
        v30 = v36 + content_buf_used;
        if ( content_buf_len < v36 + content_buf_used )
        {
          v37 = content_length;
          if ( content_length < v30 )
            v37 = v36 + content_buf_used;
          if ( content_length < 0 )
            v37 = v36 + content_buf_used;
          content_buf_len = v37;
          v38 = (char *)realloc(content_buf, v37);
          if ( !v38 )
            goto LABEL_110;
          content_buf = v38;
        }
        memcpy(&content_buf[content_buf_used], &buf[v23], v36);
        v23 += v36;
        chunksize -= v36;
        if ( na <= v23 )
        {
          content_buf_used += v36;
          goto LABEL_149;
        }
LABEL_112:
        content_buf_used = v30;
      }
    }
    valuestart = header_buf_used_0;
    endofheaders = v61;
LABEL_149:
    ;
  }
  while ( content_length <= 0 || content_buf_used < content_length );
  v43 = v67;
end_of_stream:
  free(header_buf);
  *v43 = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
