void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  __int64 v3; // rbx
  unsigned int v4; // ebp
  int v5; // r12d
  char *v6; // r13
  int v7; // r15d
  unsigned int v8; // r10d
  char *v9; // rax
  signed int v10; // r14d
  int v11; // edx
  char v12; // cl
  signed int v13; // eax
  signed int v14; // ecx
  signed int v15; // r8d
  unsigned int v16; // r8d
  int v17; // r9d
  int v18; // r14d
  char *v19; // rdi
  int v20; // r9d
  int v21; // r8d
  int v22; // r11d
  int v23; // edx
  char *v24; // r12
  __int64 v25; // rsi
  int v26; // ebp
  int v27; // ebx
  int v28; // r15d
  int v29; // r14d
  char *v30; // r13
  char v31; // al
  __int64 v32; // rbp
  const char *v33; // r12
  const char *v34; // rdi
  char *v35; // rcx
  int v36; // r14d
  char *v37; // rsi
  int v38; // r14d
  char *v39; // rax
  unsigned int v40; // r13d
  int v41; // ebp
  char *v42; // r15
  unsigned int v43; // ecx
  int v44; // r9d
  unsigned int v45; // eax
  char *v46; // rax
  char v47; // al
  __int64 v48; // rsi
  const unsigned __int16 *v49; // rdi
  __int64 v50; // rax
  __int64 v51; // rcx
  char *v52; // rcx
  char *v53; // rsi
  int v54; // r8d
  int v55; // eax
  int v56; // r8d
  char *v57; // rax
  bool v58; // zf
  int v59; // eax
  char *v60; // rax
  int v61; // ecx
  char *content_buf; // [rsp+0h] [rbp-8D8h]
  int chunked; // [rsp+8h] [rbp-8D0h]
  int chunkeda; // [rsp+8h] [rbp-8D0h]
  unsigned int chunkedc; // [rsp+8h] [rbp-8D0h]
  unsigned int chunkedb; // [rsp+8h] [rbp-8D0h]
  int chunkedd; // [rsp+8h] [rbp-8D0h]
  signed int header_buf_used_0; // [rsp+14h] [rbp-8C4h]
  unsigned int header_buf_used_0e; // [rsp+14h] [rbp-8C4h]
  signed int header_buf_used_0a; // [rsp+14h] [rbp-8C4h]
  signed int header_buf_used_0b; // [rsp+14h] [rbp-8C4h]
  unsigned int header_buf_used_0c; // [rsp+14h] [rbp-8C4h]
  unsigned int header_buf_used_0d; // [rsp+14h] [rbp-8C4h]
  unsigned int content_buf_len; // [rsp+18h] [rbp-8C0h]
  int content_length; // [rsp+1Ch] [rbp-8BCh]
  char *header_buf; // [rsp+20h] [rbp-8B8h]
  unsigned int content_buf_used; // [rsp+28h] [rbp-8B0h]
  unsigned int content_buf_useda; // [rsp+28h] [rbp-8B0h]
  int endofheaders; // [rsp+2Ch] [rbp-8ACh]
  int endofheadersa; // [rsp+2Ch] [rbp-8ACh]
  unsigned int header_buf_len; // [rsp+34h] [rbp-8A4h]
  unsigned int v84; // [rsp+38h] [rbp-8A0h]
  char *dest; // [rsp+40h] [rbp-898h]
  int n; // [rsp+50h] [rbp-888h]
  size_t na; // [rsp+50h] [rbp-888h]
  char *valuestart; // [rsp+58h] [rbp-880h]
  int valuestarta; // [rsp+58h] [rbp-880h]
  char chunksize_buf[32]; // [rsp+70h] [rbp-868h] BYREF
  char buf[2048]; // [rsp+90h] [rbp-848h] BYREF
  unsigned __int64 v94; // [rsp+898h] [rbp-40h]

  v94 = __readfsqword(0x28u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800uLL);
  if ( !header_buf )
    goto LABEL_139;
  content_buf = (char *)malloc(0x800uLL);
  if ( !content_buf )
  {
    free(header_buf);
    *size = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  v3 = 0LL;
  v4 = 0;
  v5 = 0;
  content_buf_len = 2048;
  v6 = buf;
  content_buf_used = 0;
  header_buf_len = 2048;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
LABEL_6:
  while ( 2 )
  {
    v7 = receivedata((unsigned int)s, v6, 2048LL, 5000LL, 0LL);
    if ( v7 <= 0 )
    {
      v21 = v4;
      goto end_of_stream;
    }
    if ( !endofheaders )
    {
      v8 = v7 + content_buf_used;
      if ( v7 + content_buf_used > header_buf_len )
      {
        v9 = (char *)realloc(header_buf, v8);
        v8 = v7 + content_buf_used;
        if ( !v9 )
        {
          free(header_buf);
          free(content_buf);
          content_buf = 0LL;
          *size = -1;
          return content_buf;
        }
        header_buf_len = v7 + content_buf_used;
        header_buf = v9;
      }
      header_buf_used_0 = v8;
      v10 = 0;
      memcpy(&header_buf[content_buf_used], v6, v7);
      v11 = header_buf_used_0 - 1;
      if ( header_buf_used_0 - 1 <= 0 )
      {
LABEL_21:
        content_buf_used = header_buf_used_0;
        continue;
      }
      while ( 1 )
      {
LABEL_12:
        v12 = header_buf[v10];
        v13 = v10 + 1;
        if ( v12 != 13 )
        {
LABEL_13:
          if ( v12 == 10 )
          {
            v10 += 2;
            if ( header_buf[v13] == 10 )
              goto LABEL_34;
            goto LABEL_20;
          }
          goto LABEL_14;
        }
        while ( 1 )
        {
          v14 = v10 + 2;
          if ( header_buf[v13] != 10 )
            break;
          v13 = v10 + 3;
          if ( header_buf_used_0 > v14 && header_buf[v14] == 13 )
          {
            v10 += 4;
            if ( header_buf_used_0 > v13 && header_buf[v13] == 10 )
            {
LABEL_34:
              content_buf_useda = v4;
              v22 = 0;
              endofheadersa = v5;
              v23 = 0;
              v24 = header_buf;
              v25 = 0LL;
              v84 = v3;
              v26 = v10 - 1;
              v27 = header_buf_used_0;
              v28 = 0;
              header_buf_used_0a = v10;
              dest = v6;
              while ( 2 )
              {
                while ( 1 )
                {
                  v29 = v28 + 1;
                  v30 = &v24[v28];
                  v31 = *v30;
                  if ( (int)v25 <= 0 || v23 > (int)v25 )
                    break;
                  if ( v31 == 58 )
                  {
                    v60 = &v24[v28 + 1];
                    v22 = v28;
                    while ( 1 )
                    {
                      v61 = v22++;
                      if ( *v60 != 32 && *v60 != 9 )
                        break;
                      ++v60;
                      if ( v26 <= v22 )
                      {
                        v22 = v61 + 2;
                        break;
                      }
                    }
                    v23 = v28;
                    v28 = v22;
                    goto LABEL_40;
                  }
                  if ( v31 == 13 || v31 == 10 )
                    goto LABEL_53;
LABEL_39:
                  ++v28;
LABEL_40:
                  if ( v26 <= v28 )
                    goto LABEL_60;
                }
                if ( v31 != 13 && v31 != 10 )
                  goto LABEL_39;
                if ( !(_DWORD)v25 && status_code )
                {
                  if ( v28 > 0 )
                  {
                    n = v26;
                    valuestart = v24;
                    v32 = (__int64)&v24[v28 - 1 + 2];
                    v33 = v24 + 1;
                    do
                    {
                      while ( *(v33 - 1) != 32 )
                      {
                        if ( (const char *)v32 == ++v33 )
                          goto LABEL_52;
                      }
                      if ( *status_code >= 0 )
                        break;
                      v34 = v33++;
                      *status_code = strtol(v34, 0LL, 10);
                    }
                    while ( (const char *)v32 != v33 );
LABEL_52:
                    v26 = n;
                    v24 = valuestart;
                  }
                  break;
                }
                if ( v23 > (int)v25 )
                {
                  valuestarta = v22;
                  if ( v22 > v23 )
                  {
                    na = v23 - (int)v25;
                    if ( !strncasecmp(&v24[v25], "content-length", na) )
                    {
                      content_length = strtol(&v24[valuestarta], 0LL, 10);
                    }
                    else if ( !strncasecmp(&v24[v25], "transfer-encoding", na) )
                    {
                      v58 = strncasecmp(&v24[valuestarta], "chunked", 7uLL) == 0;
                      v59 = 1;
                      if ( !v58 )
                        v59 = chunked;
                      chunked = v59;
                      if ( v27 > v28 )
                      {
LABEL_54:
                        v35 = v30;
                        while ( 1 )
                        {
                          v25 = v28;
                          v28 = v29;
                          if ( *v35 != 13 && *v35 != 10 )
                            break;
                          ++v35;
                          if ( v27 == v29 )
                          {
                            v28 = v25 + 2;
                            v22 = 0;
                            v23 = v27;
                            v25 = v27;
                            goto LABEL_40;
                          }
                          ++v29;
                        }
                        v22 = 0;
                        v23 = v25;
                        if ( v26 > v29 )
                          continue;
LABEL_60:
                        v6 = dest;
                        v4 = content_buf_useda;
                        v5 = endofheadersa;
                        content_buf_used = v27;
                        v36 = header_buf_used_0a;
                        v37 = &header_buf[header_buf_used_0a];
                        header_buf_used_0b = v27 - header_buf_used_0a;
                        v7 = header_buf_used_0b;
                        v3 = v84;
                        memcpy(dest, v37, header_buf_used_0b);
                        endofheaders = v36;
                        v15 = header_buf_used_0b;
                        if ( !chunked )
                          goto LABEL_23;
                        v20 = v4;
                        if ( header_buf_used_0b > 0 )
                          goto LABEL_62;
LABEL_27:
                        if ( content_length > 0 && content_length <= v20 )
                        {
                          v21 = v20;
                          goto end_of_stream;
                        }
                        goto LABEL_6;
                      }
                      goto LABEL_121;
                    }
                  }
                }
                break;
              }
LABEL_53:
              if ( v27 > v28 )
                goto LABEL_54;
LABEL_121:
              v22 = 0;
              v23 = v28;
              v25 = v28;
              goto LABEL_39;
            }
LABEL_20:
            if ( v11 <= v10 )
              goto LABEL_21;
            goto LABEL_12;
          }
LABEL_14:
          if ( v11 <= v13 )
            goto LABEL_21;
          v10 = v13;
          v12 = header_buf[v13++];
          if ( v12 != 13 )
            goto LABEL_13;
        }
        if ( v11 <= v14 )
          goto LABEL_21;
        v10 += 2;
      }
    }
    break;
  }
  v15 = v7;
  if ( chunked )
  {
LABEL_62:
    v38 = 0;
    v39 = v6;
    v40 = v4;
    v41 = v7;
    v42 = v39;
    while ( v5 )
    {
LABEL_63:
      v43 = v41 - v38;
      if ( v41 - v38 > v5 )
        v43 = v5;
      v44 = v43 + v40;
      if ( v43 + v40 > content_buf_len )
      {
        v45 = content_length;
        header_buf_used_0c = v43;
        chunkeda = v43 + v40;
        if ( content_length < v44 )
          v45 = v43 + v40;
        content_buf_len = v45;
        v46 = (char *)realloc(content_buf, v45);
        v44 = chunkeda;
        v43 = header_buf_used_0c;
        if ( !v46 )
          goto LABEL_138;
        content_buf = v46;
      }
      header_buf_used_0d = v44;
      chunkedc = v43;
      memcpy(&content_buf[v40], &v42[v38], v43);
      v20 = header_buf_used_0d;
      v38 += chunkedc;
      v5 -= chunkedc;
      if ( v38 >= v41 )
      {
        chunked = 1;
        v6 = v42;
        v4 = header_buf_used_0d;
        goto LABEL_27;
      }
LABEL_71:
      v40 = v20;
    }
    if ( (_DWORD)v3 )
      goto LABEL_76;
    v47 = buf[v38];
    if ( v47 == 13 )
    {
      if ( ++v38 >= v41 )
      {
        v4 = v40;
        v6 = v42;
        v3 = 0LL;
        goto LABEL_100;
      }
      v48 = v38;
      if ( buf[v38] != 10 )
        goto LABEL_78;
    }
    else if ( v47 != 10 )
    {
LABEL_76:
      if ( v38 < v41 )
      {
        v48 = v38;
LABEL_78:
        v49 = *_ctype_b_loc();
        while ( 1 )
        {
          v50 = (int)v48;
          v51 = v42[v48];
          if ( (v49[v51] & 0x1000) == 0 || (unsigned int)v3 > 0x1E )
            break;
          ++v48;
          chunksize_buf[v3] = v51;
          chunksize_buf[(unsigned int)(v3 + 1)] = 0;
          if ( v41 <= (int)v48 )
          {
            v4 = v40;
            v3 = (unsigned int)(v3 + 1);
            v6 = v42;
            goto LABEL_100;
          }
          v3 = (unsigned int)(v3 + 1);
        }
        if ( (int)v48 < v41 )
        {
          while ( 1 )
          {
            v38 = v50;
            if ( (_BYTE)v51 == 10 || (_BYTE)v51 == 13 )
              break;
            if ( v41 <= (int)++v50 )
              goto LABEL_99;
            LOBYTE(v51) = v42[v50];
          }
          if ( (int)v50 < v41 )
          {
            if ( (_BYTE)v51 != 13 )
              goto LABEL_91;
            v38 = v50 + 1;
            if ( (int)v50 + 1 < v41 )
            {
              LOBYTE(v51) = buf[v38];
LABEL_91:
              v20 = v40;
              if ( (_BYTE)v51 != 10 )
                goto LABEL_71;
              if ( (_DWORD)v3 )
              {
                v52 = chunksize_buf;
                v53 = &chunksize_buf[(unsigned int)(v3 - 1) + 1];
                v54 = 0;
                do
                {
                  while ( 1 )
                  {
                    v55 = *v52;
                    v56 = 16 * v54;
                    if ( (unsigned __int8)(*v52 - 48) > 9u )
                      break;
                    ++v52;
                    v54 = v56 + v55 - 48;
                    if ( v53 == v52 )
                      goto LABEL_97;
                  }
                  ++v52;
                  v54 = v56 + (char)(v55 | 0x20) - 87;
                }
                while ( v53 != v52 );
LABEL_97:
                chunksize_buf[0] = 0;
                ++v38;
                if ( v54 )
                {
                  v3 = 0LL;
                  v5 = v54;
                  goto LABEL_63;
                }
              }
              v4 = v40;
              v21 = v40;
end_of_stream:
              chunkedd = v21;
              free(header_buf);
              *size = chunkedd;
              if ( !v4 )
              {
                free(content_buf);
                return 0LL;
              }
              return content_buf;
            }
          }
        }
LABEL_99:
        v4 = v40;
        v6 = v42;
        goto LABEL_100;
      }
      v4 = v40;
      v6 = v42;
      v3 = (unsigned int)v3;
LABEL_100:
      chunked = 1;
      v20 = v4;
      goto LABEL_27;
    }
    ++v38;
    goto LABEL_76;
  }
LABEL_23:
  v16 = v4 + v15;
  v17 = v16;
  if ( content_length <= 0 )
  {
    if ( content_buf_len < v16 )
    {
      if ( content_length < (int)v16 )
      {
        v18 = v16;
        goto LABEL_109;
      }
      goto LABEL_113;
    }
LABEL_122:
    v18 = v16;
    goto LABEL_26;
  }
  if ( content_length >= (int)v16 )
  {
    if ( content_buf_len < v16 )
    {
LABEL_113:
      v18 = v16;
      v16 = content_length;
      goto LABEL_109;
    }
    goto LABEL_122;
  }
  v18 = content_length;
  v17 = content_length;
  v7 = content_length - v4;
  if ( content_length <= content_buf_len )
  {
LABEL_26:
    v19 = &content_buf[v4];
    header_buf_used_0e = v17;
    v4 = v18;
    memcpy(v19, v6, v7);
    chunked = 0;
    v20 = header_buf_used_0e;
    goto LABEL_27;
  }
  v18 = content_length;
  v16 = content_length;
LABEL_109:
  chunkedb = v16;
  v57 = (char *)realloc(content_buf, v16);
  if ( v57 )
  {
    content_buf = v57;
    v17 = v18;
    content_buf_len = chunkedb;
    goto LABEL_26;
  }
LABEL_138:
  free(content_buf);
  free(header_buf);
LABEL_139:
  content_buf = 0LL;
  *size = -1;
  return content_buf;
}
