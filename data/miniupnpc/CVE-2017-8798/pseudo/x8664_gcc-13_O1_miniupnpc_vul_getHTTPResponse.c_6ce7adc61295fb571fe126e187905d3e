void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // r15
  unsigned int v4; // r13d
  int v5; // eax
  int v6; // eax
  int v7; // ebp
  char v8; // dl
  int v9; // edx
  int v10; // edi
  int v11; // ecx
  int v12; // ebx
  int v13; // ebp
  char *v14; // rdx
  int v15; // eax
  char v16; // al
  char v17; // al
  char *v18; // rax
  const char *v19; // rbp
  size_t v20; // r12
  const char *v21; // rbp
  bool v22; // zf
  int v23; // eax
  int v24; // r12d
  int v25; // ebx
  signed int v26; // r15d
  const unsigned __int16 *v27; // rdi
  char *v28; // rdx
  unsigned int v29; // esi
  char *v30; // rax
  int v31; // r14d
  char *v32; // rcx
  char *v33; // r13
  int v34; // edx
  char v35; // al
  unsigned int v36; // ebp
  unsigned int v37; // eax
  char *v38; // rax
  char *v39; // rbx
  int *v40; // r12
  int v42; // ebp
  int v43; // r14d
  char *v44; // rax
  unsigned int content_buf_used; // [rsp+Ch] [rbp-8BCh]
  char *content_buf; // [rsp+18h] [rbp-8B0h]
  unsigned int content_buf_len; // [rsp+20h] [rbp-8A8h]
  int content_length; // [rsp+24h] [rbp-8A4h]
  int endofheaders; // [rsp+28h] [rbp-8A0h]
  unsigned int valuestart; // [rsp+2Ch] [rbp-89Ch]
  int valuestarta; // [rsp+2Ch] [rbp-89Ch]
  int chunked; // [rsp+34h] [rbp-894h]
  unsigned int header_buf_len; // [rsp+38h] [rbp-890h]
  unsigned int chunksize; // [rsp+3Ch] [rbp-88Ch]
  char *header_buf; // [rsp+40h] [rbp-888h]
  int v57; // [rsp+48h] [rbp-880h]
  char chunksize_buf[32]; // [rsp+60h] [rbp-868h] BYREF
  char buf[2048]; // [rsp+80h] [rbp-848h] BYREF
  unsigned __int64 v62; // [rsp+888h] [rbp-40h]

  v62 = __readfsqword(0x28u);
  if ( status_code )
    *status_code = -1;
  v3 = (char *)malloc(0x800uLL);
  if ( !v3 )
  {
    *size = -1;
    return 0LL;
  }
  content_buf = (char *)malloc(0x800uLL);
  if ( !content_buf )
  {
    free(v3);
    *size = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  v4 = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  v5 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
  while ( 2 )
  {
    v24 = v5;
    if ( v5 <= 0 )
    {
      v40 = size;
      goto end_of_stream;
    }
    if ( endofheaders )
    {
      if ( chunked )
        goto LABEL_77;
LABEL_140:
      if ( content_length > 0 )
      {
        v42 = v24 + content_buf_used;
        if ( (int)(v24 + content_buf_used) <= content_length )
        {
          v39 = content_buf;
          if ( content_buf_len >= v42 )
            goto LABEL_146;
          goto LABEL_138;
        }
        v24 = content_length - content_buf_used;
      }
      v42 = v24 + content_buf_used;
      if ( content_buf_len >= v24 + content_buf_used )
      {
        v39 = content_buf;
        goto LABEL_146;
      }
      content_buf_len = v24 + content_buf_used;
      if ( v42 > content_length )
      {
LABEL_145:
        v39 = (char *)realloc(content_buf, content_buf_len);
        if ( !v39 )
        {
          free(content_buf);
          free(v3);
          *size = -1;
          return 0LL;
        }
LABEL_146:
        memcpy(&v39[content_buf_used], buf, v24);
        content_buf_used = v42;
        content_buf = v39;
        goto LABEL_147;
      }
LABEL_138:
      content_buf_len = content_length;
      goto LABEL_145;
    }
    v43 = v5 + valuestart;
    if ( header_buf_len < v5 + valuestart )
    {
      v44 = (char *)realloc(v3, (unsigned int)v43);
      if ( !v44 )
      {
        free(v3);
        free(content_buf);
        *size = -1;
        return 0LL;
      }
      header_buf_len = v24 + valuestart;
      v3 = v44;
    }
    memcpy(&v3[valuestart], buf, v24);
    if ( v43 <= 1 )
    {
      valuestart += v24;
      goto LABEL_149;
    }
    v6 = 0;
    do
    {
      v8 = v3[v6];
      if ( v8 == 13 )
      {
        if ( v3[v6 + 1] == 10 )
        {
          if ( v6 + 2 >= v43 )
          {
            v6 += 2;
            v7 = 0;
          }
          else if ( v3[v6 + 2] == 13 )
          {
            v9 = v6 + 3;
            if ( v6 + 3 >= v43 )
            {
              v6 += 3;
              v7 = 0;
            }
            else
            {
              v7 = v6 + 4;
              v6 += 3;
              if ( v3[v9] != 10 )
                v7 = 0;
            }
          }
          else
          {
            v6 += 2;
            v7 = 0;
          }
        }
        else
        {
          ++v6;
          v7 = endofheaders;
        }
      }
      else
      {
        v7 = endofheaders;
        if ( v8 == 10 )
        {
          v7 = v6 + 2;
          if ( v3[++v6] != 10 )
            v7 = endofheaders;
        }
      }
      ++v6;
    }
    while ( v6 < v43 - 1 && !v7 );
    if ( !v7 )
    {
      valuestart += v24;
      endofheaders = 0;
      goto LABEL_149;
    }
    v10 = v7 - 1;
    if ( v7 - 1 <= 0 )
      goto LABEL_72;
    valuestarta = 0;
    v11 = 0;
    v12 = 0;
    v57 = v7;
    v13 = 0;
    do
    {
      if ( v13 <= 0 || v13 < v11 )
      {
        v16 = v3[v12];
        if ( v16 != 13 && v16 != 10 )
          goto LABEL_39;
        if ( !v13 && status_code )
        {
          if ( v12 > 0 )
          {
            v19 = v3 + 1;
            while ( 1 )
            {
              if ( *(v19 - 1) == 32 )
              {
                if ( *status_code >= 0 )
                  goto LABEL_45;
                *status_code = strtol(v19, 0LL, 10);
              }
              if ( ++v19 == &v3[v12 + 1] )
                goto LABEL_45;
            }
          }
LABEL_46:
          v18 = &v3[v12];
          do
          {
            if ( *v18 != 13 && *v18 != 10 )
            {
              valuestarta = endofheaders;
              v11 = v12;
              v13 = v12;
              goto LABEL_39;
            }
            ++v12;
            ++v18;
          }
          while ( v12 != v43 );
          valuestarta = endofheaders;
          v11 = v43;
          v13 = v43;
          v12 = v43;
          goto LABEL_39;
        }
        if ( v13 < v11 && v11 < valuestarta )
        {
          v20 = v11 - v13;
          v21 = &v3[v13];
          if ( !strncasecmp(v21, "content-length", v20) )
          {
            content_length = strtol(&v3[valuestarta], 0LL, 10);
          }
          else if ( !strncasecmp(v21, "transfer-encoding", v20) )
          {
            v22 = strncasecmp(&v3[valuestarta], "chunked", 7uLL) == 0;
            v23 = 1;
            if ( !v22 )
              v23 = chunked;
            chunked = v23;
          }
        }
LABEL_45:
        if ( v43 <= v12 )
        {
          valuestarta = 0;
          v11 = v12;
          v13 = v12;
          goto LABEL_39;
        }
        goto LABEL_46;
      }
      v17 = v3[v12];
      if ( v17 != 58 )
      {
        if ( v17 != 10 && v17 != 13 )
          goto LABEL_39;
        goto LABEL_45;
      }
      if ( v10 <= v12 )
      {
        v15 = v12;
      }
      else
      {
        v14 = &v3[v12 + 1];
        v15 = v12;
        while ( *v14 == 32 || *v14 == 9 )
        {
          ++v15;
          ++v14;
          if ( v15 == v57 - 1 )
          {
            v15 = v57 - 1;
            break;
          }
        }
      }
      valuestarta = v15 + 1;
      v11 = v12;
      v12 = v15;
LABEL_39:
      ++v12;
    }
    while ( v12 < v10 );
    v7 = v57;
LABEL_72:
    v24 = v43 - v7;
    memcpy(buf, &v3[v7], v43 - v7);
    if ( !chunked )
    {
      valuestart = v43;
      endofheaders = v7;
      goto LABEL_140;
    }
    if ( v24 > 0 )
    {
      valuestart = v43;
      endofheaders = v7;
LABEL_77:
      v25 = 0;
      header_buf = v3;
      v26 = chunksize;
      while ( 1 )
      {
        if ( v26 )
          goto LABEL_115;
        if ( v4 )
          goto LABEL_84;
        if ( buf[v25] == 13 )
          ++v25;
        if ( v24 <= v25 )
        {
          chunksize = 0;
          v3 = header_buf;
          goto LABEL_147;
        }
        if ( buf[v25] == 10 )
          break;
LABEL_85:
        v27 = *_ctype_b_loc();
        v28 = &buf[v25];
        v29 = v24 + v4 - v25;
        while ( (v27[*v28] & 0x1000) != 0 && v4 <= 0x1E )
        {
          chunksize_buf[v4] = *v28;
          chunksize_buf[v4 + 1] = 0;
          ++v25;
          ++v28;
          if ( v4 + 1 == v29 )
          {
            v4 = v29;
            break;
          }
          ++v4;
        }
        if ( v25 >= v24 )
        {
          chunksize = 0;
          v3 = header_buf;
          goto LABEL_147;
        }
        v30 = &buf[v25];
        while ( *v30 != 10 && *v30 != 13 )
        {
          ++v25;
          ++v30;
          if ( v24 == v25 )
          {
            chunksize = 0;
            v3 = header_buf;
            goto LABEL_147;
          }
        }
        if ( v24 <= v25 )
        {
          chunksize = 0;
          v3 = header_buf;
          goto LABEL_147;
        }
        if ( buf[v25] == 13 && v24 <= ++v25 )
        {
          chunksize = 0;
          v3 = header_buf;
          goto LABEL_147;
        }
        if ( buf[v25] != 10 )
        {
          v31 = content_buf_used;
          goto LABEL_113;
        }
        if ( !v4 )
        {
          v3 = header_buf;
          v40 = size;
          goto end_of_stream;
        }
        v32 = chunksize_buf;
        v33 = &chunksize_buf[v4];
        v34 = 0;
        do
        {
          v35 = *v32;
          if ( (unsigned __int8)(*v32 - 48) > 9u )
            v34 = 16 * v34 + (v35 | 0x20) - 87;
          else
            v34 = 16 * v34 + v35 - 48;
          ++v32;
        }
        while ( v32 != v33 );
        chunksize_buf[0] = 0;
        ++v25;
        if ( !v34 )
        {
          v3 = header_buf;
          v40 = size;
          goto end_of_stream;
        }
        v4 = 0;
        v26 = v34;
LABEL_115:
        v36 = v24 - v25;
        if ( v24 - v25 > v26 )
          v36 = v26;
        v31 = v36 + content_buf_used;
        if ( content_buf_len < v36 + content_buf_used )
        {
          v37 = content_length;
          if ( content_length < v31 )
            v37 = v36 + content_buf_used;
          content_buf_len = v37;
          v38 = (char *)realloc(content_buf, v37);
          if ( !v38 )
          {
            free(content_buf);
            free(header_buf);
            *size = -1;
            return 0LL;
          }
          content_buf = v38;
        }
        memcpy(&content_buf[content_buf_used], &buf[v25], v36);
        v25 += v36;
        v26 -= v36;
        if ( v24 <= v25 )
        {
          chunksize = v26;
          v3 = header_buf;
          content_buf_used += v36;
          goto LABEL_147;
        }
LABEL_113:
        content_buf_used = v31;
      }
      ++v25;
LABEL_84:
      if ( v25 >= v24 )
      {
        chunksize = 0;
        v3 = header_buf;
        goto LABEL_147;
      }
      goto LABEL_85;
    }
    valuestart = v43;
    endofheaders = v7;
LABEL_147:
    if ( content_length <= 0 || (int)content_buf_used < content_length )
    {
LABEL_149:
      v5 = receivedata((unsigned int)s, buf, 2048LL, 5000LL, 0LL);
      continue;
    }
    break;
  }
  v40 = size;
end_of_stream:
  free(v3);
  *v40 = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0LL;
  }
  return content_buf;
}
