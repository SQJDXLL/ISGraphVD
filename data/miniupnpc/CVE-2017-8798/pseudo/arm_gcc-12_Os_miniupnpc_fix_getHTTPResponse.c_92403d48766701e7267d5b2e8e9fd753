void *__fastcall getHTTPResponse(int s, int *size, int *status_code)
{
  void *v3; // r5
  void *v4; // r10
  void *v5; // r0
  unsigned int v6; // r8
  int v7; // r9
  int v8; // r6
  int v9; // r0
  signed int v10; // r7
  int v11; // r11
  void *v12; // r0
  int v13; // r3
  int v14; // r4
  char *v15; // r2
  char *v16; // r0
  char *v17; // r3
  signed int v18; // r4
  int v19; // r1
  int v20; // r2
  bool v21; // cc
  int v22; // r1
  char *v23; // r7
  char *v24; // r1
  int v25; // r2
  bool v26; // zf
  bool v27; // zf
  _BOOL4 v28; // r1
  const char *v29; // r4
  bool v30; // cc
  int v31; // t1
  int v32; // r0
  int v33; // r4
  bool v34; // zf
  int v35; // r0
  int v36; // r3
  unsigned int v37; // r11
  _BYTE *v38; // r11
  const unsigned __int16 **v39; // r0
  int v40; // r1
  int v41; // r3
  bool v42; // zf
  int v43; // r2
  unsigned __int8 *v44; // r1
  _BOOL4 v45; // r3
  int v46; // r3
  int v47; // t1
  int v48; // r11
  int v49; // r11
  char *v50; // r2
  char *v51; // r3
  char *v52; // r1
  void *v53; // r0
  int v54; // r2
  int *v55; // r4
  size_t v56; // r3
  void *v57; // r0
  int v59; // [sp+0h] [bp-890h] BYREF
  size_t v60; // [sp+Ch] [bp-884h]
  int *sizea; // [sp+10h] [bp-880h]
  unsigned int header_buf_used; // [sp+14h] [bp-87Ch]
  int *status_codea; // [sp+18h] [bp-878h]
  int chunked; // [sp+1Ch] [bp-874h]
  unsigned int chunksize; // [sp+20h] [bp-870h]
  unsigned int header_buf_len; // [sp+24h] [bp-86Ch]
  char *v67; // [sp+28h] [bp-868h]
  int sa; // [sp+2Ch] [bp-864h]
  unsigned int content_buf_used_0; // [sp+30h] [bp-860h]
  int v70; // [sp+34h] [bp-85Ch]
  char *s1; // [sp+38h] [bp-858h]
  size_t v72; // [sp+3Ch] [bp-854h]
  char chunksize_buf[32]; // [sp+44h] [bp-84Ch] BYREF
  char buf[2048]; // [sp+64h] [bp-82Ch] BYREF

  status_codea = size;
  v70 = s;
  chunksize = (unsigned int)status_code;
  if ( status_code )
    *status_code = -1;
  v3 = malloc(0x800u);
  if ( !v3 )
  {
LABEL_4:
    *status_codea = -1;
    return 0;
  }
  v4 = malloc(0x800u);
  if ( !v4 )
  {
LABEL_8:
    v5 = v3;
LABEL_9:
    free(v5);
    goto LABEL_4;
  }
  v6 = 0;
  v60 = 2048;
  sa = 2048;
  v7 = -1;
  v8 = 0;
  chunksize_buf[0] = 0;
  sizea = 0;
  chunked = 0;
  v67 = 0;
  header_buf_len = 0;
  content_buf_used_0 = (unsigned int)chunksize_buf;
LABEL_11:
  do
  {
    header_buf_used = (unsigned int)buf;
    v9 = receivedata(v70, buf, 2048, 5000, 0);
    v10 = v9;
    if ( v9 <= 0 )
      break;
    if ( v8 )
      goto LABEL_26;
    v11 = v9 + chunked;
    if ( v9 + chunked > (unsigned int)sa )
    {
      v12 = realloc(v3, v9 + chunked);
      if ( !v12 )
      {
        free(v3);
        v5 = v4;
        goto LABEL_9;
      }
      v3 = v12;
      sa = v11;
    }
    memcpy((char *)v3 + chunked, (const void *)header_buf_used, v10);
    v13 = 0;
    v8 = 0;
    while ( 1 )
    {
      v14 = v11 - 1 > v13;
      if ( v8 )
        v14 = 0;
      if ( !v14 )
        break;
      v19 = *((unsigned __int8 *)v3 + v13);
      v20 = v13 + 1;
      if ( v19 == 13 )
      {
        if ( *((_BYTE *)v3 + v20) == 10 )
        {
          v20 = v13 + 2;
          if ( v11 > v13 + 2 && *((_BYTE *)v3 + v20) == 13 )
          {
            v20 = v13 + 3;
            if ( v11 > v13 + 3 && *((_BYTE *)v3 + v20) == 10 )
            {
              v8 = v13 + 4;
              goto LABEL_41;
            }
          }
        }
        goto LABEL_35;
      }
      if ( v19 != 10 )
      {
        v20 = v13;
LABEL_35:
        v8 = 0;
        goto LABEL_41;
      }
      if ( *((_BYTE *)v3 + v20) != 10 )
        goto LABEL_35;
      v8 = v13 + 2;
LABEL_41:
      v13 = v20 + 1;
    }
    if ( !v8 )
    {
      chunked = v11;
      goto LABEL_11;
    }
    v15 = 0;
    v16 = 0;
    v17 = 0;
    chunked = v8 - 1;
    while ( chunked > (int)v17 )
    {
      v21 = (int)v16 <= (int)v15;
      if ( (int)v16 >= (int)v15 )
        v21 = (int)v16 <= 0;
      v22 = (unsigned __int8)v17[(_DWORD)v3];
      v23 = v17;
      if ( v21 || v22 != 58 )
      {
        v27 = v22 == 10;
        if ( v22 != 10 )
          v27 = v22 == 13;
        if ( v27 )
        {
          v28 = v16 == 0;
          if ( !chunksize )
            v28 = 0;
          if ( v28 )
          {
            v29 = (const char *)v3;
            while ( (int)v17 > v29 - (_BYTE *)v3 )
            {
              v31 = *(unsigned __int8 *)v29++;
              if ( v31 == 32 )
              {
                s1 = v17;
                if ( *(int *)chunksize >= 0 )
                  break;
                v32 = atoi(v29);
                *(_DWORD *)chunksize = v32;
                v17 = s1;
              }
            }
          }
          else
          {
            v30 = (int)v16 < (int)v15;
            if ( (int)v16 < (int)v15 )
              v30 = (int)v15 < v14;
            if ( v30 )
            {
              v72 = v15 - v16;
              s1 = &v16[(_DWORD)v3];
              if ( !strncasecmp(&v16[(_DWORD)v3], "content-length", v15 - v16) )
              {
                v7 = atoi((const char *)v3 + v14);
              }
              else if ( !strncasecmp(s1, "transfer-encoding", v72) )
              {
                v35 = strncasecmp((const char *)v3 + v14, "chunked", 7u);
                v36 = header_buf_len;
                if ( !v35 )
                  v36 = 1;
                header_buf_len = v36;
              }
            }
          }
          while ( 1 )
          {
            v24 = v23;
            if ( v11 <= (int)v23 )
              break;
            v33 = (unsigned __int8)(v23++)[(_DWORD)v3];
            v34 = v33 == 10;
            if ( v33 != 10 )
              v34 = v33 == 13;
            v14 = v34;
            if ( !v34 )
              goto LABEL_77;
          }
          v14 = 0;
LABEL_77:
          v17 = v24;
          v16 = v24;
        }
        else
        {
          v24 = v17;
          v17 = v15;
        }
      }
      else
      {
        v14 = (int)v17;
        do
        {
          v24 = (char *)v14++;
          if ( v8 == v14 )
            break;
          v25 = *((unsigned __int8 *)v3 + v14);
          v26 = v25 == 9;
          if ( v25 != 9 )
            v26 = v25 == 32;
        }
        while ( v26 );
      }
      v15 = v17;
      v17 = v24 + 1;
    }
    v10 = v11 - v8;
    memcpy((void *)header_buf_used, (char *)v3 + v8, v11 - v8);
    chunked = v11;
LABEL_26:
    if ( header_buf_len )
    {
      v18 = 0;
LABEL_102:
      while ( v10 > v18 )
      {
        if ( !v67 )
        {
          if ( !v6 )
          {
            if ( *((_BYTE *)&v59 + v18 + 100) != 13 || (++v18, v10 > v18) )
            {
              if ( *((_BYTE *)&v59 + v18 + 100) == 10 )
                ++v18;
            }
          }
          v38 = (_BYTE *)(content_buf_used_0 + v6);
          while ( v10 > v18 )
          {
            v39 = _ctype_b_loc();
            v40 = *(unsigned __int8 *)(header_buf_used + v18);
            if ( ((v6 <= 0x1E) & ((*v39)[v40] >> 0xC)) == 0 )
            {
              while ( v10 > v18 )
              {
                v41 = *(unsigned __int8 *)(header_buf_used + v18);
                v42 = v41 == 13;
                if ( v41 != 13 )
                  v42 = v41 == 10;
                if ( v42 )
                {
                  if ( *((_BYTE *)&v59 + v18 + 100) == 13 && v10 <= ++v18 )
                    goto LABEL_103;
                  if ( *((_BYTE *)&v59 + v18 + 100) != 10 )
                    goto LABEL_102;
                  v43 = 0;
                  v44 = (unsigned __int8 *)content_buf_used_0;
                  v37 = 0;
                  while ( v6 != v43 )
                  {
                    v47 = *v44++;
                    v46 = v47;
                    v48 = 16 * v37;
                    if ( (unsigned int)(v47 - 0x30) > 9 )
                    {
                      v49 = v48 - 0x57;
                      v46 |= 0x20u;
                    }
                    else
                    {
                      v49 = v48 - 0x30;
                    }
                    v37 = v49 + v46;
                    ++v43;
                  }
                  v6 = 0;
                  ++v18;
                  chunksize_buf[0] = 0;
                  if ( !v37 )
                    goto end_of_stream;
                  goto LABEL_116;
                }
                ++v18;
              }
              goto LABEL_103;
            }
            *v38 = v40;
            ++v6;
            ++v18;
            *++v38 = 0;
          }
          goto LABEL_103;
        }
        v37 = (unsigned int)v67;
LABEL_116:
        v50 = (char *)(v10 - v18);
        if ( v10 - v18 >= v37 )
          v50 = (char *)v37;
        v51 = &v50[(_DWORD)sizea];
        if ( &v50[(int)sizea] > (char *)v60 )
        {
          if ( v7 >= 0 )
          {
            if ( v7 < (unsigned int)v51 )
              v52 = &v50[(_DWORD)sizea];
            else
              v52 = (char *)v7;
            v60 = (size_t)v52;
          }
          else
          {
            v60 = (size_t)&v50[(_DWORD)sizea];
          }
          s1 = v50;
          v67 = &v50[(_DWORD)sizea];
          v53 = realloc(v4, v60);
          v51 = v67;
          v50 = s1;
          if ( !v53 )
            goto LABEL_126;
          v4 = v53;
        }
        s1 = v51;
        v67 = v50;
        memcpy((char *)sizea + (_DWORD)v4, (const void *)(header_buf_used + v18), (size_t)v50);
        v54 = (int)v67;
        v67 = (char *)(v37 - (_DWORD)v67);
        v18 += v54;
        sizea = (int *)s1;
      }
      goto LABEL_103;
    }
    v55 = (int *)((char *)sizea + v10);
    if ( v7 <= 0 )
    {
      if ( v60 >= (unsigned int)v55 )
        goto LABEL_132;
      if ( v7 )
      {
        v60 = (size_t)sizea + v10;
LABEL_142:
        v57 = realloc(v4, v60);
        if ( !v57 )
        {
LABEL_126:
          free(v4);
          goto LABEL_8;
        }
        v4 = v57;
        goto LABEL_132;
      }
LABEL_134:
      if ( v7 < (unsigned int)v55 )
        v56 = (size_t)v55;
      else
        v56 = v7;
      v60 = v56;
      goto LABEL_142;
    }
    if ( v7 < (unsigned int)v55 )
    {
      v55 = (int *)v7;
      v10 = v7 - (_DWORD)sizea;
      if ( v7 <= v60 )
        goto LABEL_132;
      goto LABEL_134;
    }
    if ( v60 < (unsigned int)v55 )
      goto LABEL_134;
LABEL_132:
    memcpy((char *)sizea + (_DWORD)v4, (const void *)header_buf_used, v10);
    sizea = v55;
LABEL_103:
    v45 = v7 > 0;
    if ( v7 > (unsigned int)sizea )
      v45 = 0;
  }
  while ( !v45 );
end_of_stream:
  free(v3);
  v26 = sizea == 0;
  *status_codea = (int)sizea;
  if ( !v26 )
    return v4;
  free(v4);
  return 0;
}
