void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  unsigned int v3; // ebp
  char *v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // esi
  char v8; // al
  int v9; // edx
  signed int v10; // eax
  size_t v11; // edx
  size_t v12; // edi
  unsigned int v13; // ecx
  int v14; // esi
  int v15; // ecx
  int v16; // edx
  char *v17; // ebp
  int v18; // esi
  int v19; // eax
  int v20; // ecx
  char v21; // dl
  size_t v22; // edi
  int v23; // edi
  int v24; // esi
  size_t v25; // edi
  int v26; // ecx
  size_t v27; // eax
  char *v28; // eax
  char *v29; // edx
  char v30; // al
  const unsigned __int16 *v31; // ecx
  unsigned int v32; // edx
  int v33; // edx
  char v34; // al
  signed int v35; // eax
  signed int v36; // ecx
  char v37; // dl
  const char *v38; // edx
  int *v39; // ebp
  const char *v40; // esi
  const char *v41; // edi
  char *v42; // ecx
  int v43; // edx
  char *v44; // ebp
  int v45; // eax
  char *v46; // eax
  bool v47; // zf
  int v48; // eax
  int v49; // edx
  char v50; // cl
  int v51; // edi
  char *v53; // [esp-10h] [ebp-8ACh]
  int n; // [esp+0h] [ebp-89Ch]
  int nc; // [esp+0h] [ebp-89Ch]
  int na; // [esp+0h] [ebp-89Ch]
  int nb; // [esp+0h] [ebp-89Ch]
  int nd; // [esp+0h] [ebp-89Ch]
  unsigned int content_buf_used; // [esp+4h] [ebp-898h]
  signed int chunksize; // [esp+8h] [ebp-894h]
  unsigned int chunksizea; // [esp+8h] [ebp-894h]
  signed int header_buf_used_0; // [esp+Ch] [ebp-890h]
  signed int header_buf_used_0a; // [esp+Ch] [ebp-890h]
  char *content_buf; // [esp+10h] [ebp-88Ch]
  int chunked; // [esp+18h] [ebp-884h]
  int chunkeda; // [esp+18h] [ebp-884h]
  unsigned int content_buf_len; // [esp+1Ch] [ebp-880h]
  int content_length; // [esp+20h] [ebp-87Ch]
  char *header_buf; // [esp+24h] [ebp-878h]
  int valuestart; // [esp+28h] [ebp-874h]
  int endofheaders; // [esp+2Ch] [ebp-870h]
  unsigned int header_buf_len; // [esp+30h] [ebp-86Ch]
  unsigned int chunksize_buf_index; // [esp+34h] [ebp-868h]
  char *v74; // [esp+38h] [ebp-864h]
  int *v75; // [esp+3Ch] [ebp-860h]
  int i; // [esp+40h] [ebp-85Ch]
  size_t v77; // [esp+44h] [ebp-858h]
  char *s2; // [esp+48h] [ebp-854h]
  int *v79; // [esp+4Ch] [ebp-850h]
  char chunksize_buf[32]; // [esp+5Ch] [ebp-840h] BYREF
  char buf[2048]; // [esp+7Ch] [ebp-820h] BYREF
  unsigned int v82; // [esp+87Ch] [ebp-20h]

  v79 = size;
  v75 = status_code;
  v82 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    content_buf = 0;
    *v79 = -1;
    return content_buf;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    free(header_buf);
    *v79 = -1;
    return content_buf;
  }
  chunksize_buf[0] = 0;
  v3 = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  valuestart = 0;
  header_buf_len = 2048;
  chunksize = 0;
  content_length = -1;
  chunked = 0;
  endofheaders = 0;
  s2 = "content-length";
  do
  {
    while ( 1 )
    {
      n = receivedata(s, buf, 2048, 5000, 0);
      if ( n <= 0 )
      {
LABEL_134:
        v16 = content_buf_used;
        goto end_of_stream;
      }
      if ( endofheaders )
      {
        v11 = n;
        if ( chunked )
          goto LABEL_45;
LABEL_24:
        v12 = content_buf_used + v11;
        v13 = content_buf_used + v11;
        if ( content_length <= 0 )
        {
          if ( content_buf_len < v12 )
          {
            if ( content_length < (int)v12 )
            {
              v14 = content_buf_used + v11;
              goto LABEL_109;
            }
LABEL_113:
            v14 = content_buf_used + v11;
            v12 = content_length;
            goto LABEL_109;
          }
        }
        else
        {
          if ( content_length < (int)v12 )
          {
            v14 = content_length;
            v11 = content_length - content_buf_used;
            v13 = content_length;
            if ( content_length <= content_buf_len )
              goto LABEL_27;
            v14 = content_length;
            v12 = content_length;
LABEL_109:
            nb = v11;
            v46 = (char *)realloc(content_buf, v12);
            if ( !v46 )
            {
LABEL_138:
              free(content_buf);
              v53 = header_buf;
LABEL_139:
              free(v53);
              *v79 = -1;
              return 0;
            }
            content_buf_len = v12;
            v11 = nb;
            v13 = v14;
            content_buf = v46;
LABEL_27:
            nc = v13;
            memcpy(&content_buf[content_buf_used], buf, v11);
            v15 = nc;
            content_buf_used = v14;
            chunked = 0;
            goto LABEL_28;
          }
          if ( content_buf_len < v12 )
            goto LABEL_113;
        }
        v14 = content_buf_used + v11;
        goto LABEL_27;
      }
      header_buf_used_0 = valuestart + n;
      if ( valuestart + n <= header_buf_len )
        goto LABEL_11;
      v4 = (char *)realloc(header_buf, valuestart + n);
      if ( !v4 )
      {
        free(header_buf);
        v53 = content_buf;
        goto LABEL_139;
      }
      header_buf = v4;
      header_buf_len = header_buf_used_0;
LABEL_11:
      memcpy(&header_buf[valuestart], buf, n);
      v5 = header_buf_used_0;
      v6 = 0;
      v7 = header_buf_used_0 - 1;
      if ( header_buf_used_0 - 1 <= 0 )
        goto LABEL_22;
LABEL_12:
      v8 = header_buf[v6];
      v9 = v6 + 1;
      if ( v8 == 13 )
        goto LABEL_16;
LABEL_13:
      if ( v8 != 10 )
        break;
      v6 += 2;
      if ( header_buf[v9] == 10 )
        goto LABEL_35;
LABEL_20:
      if ( v7 > v6 )
        goto LABEL_12;
LABEL_21:
      v5 = header_buf_used_0;
LABEL_22:
      valuestart = v5;
    }
    while ( 2 )
    {
      if ( v7 <= v9 )
        goto LABEL_21;
      v6 = v9;
      v8 = header_buf[v9++];
      if ( v8 != 13 )
        goto LABEL_13;
LABEL_16:
      v10 = v6 + 2;
      if ( header_buf[v6 + 1] != 10 )
      {
        if ( v7 <= v10 )
          goto LABEL_21;
        v6 += 2;
        goto LABEL_12;
      }
      v9 = v6 + 3;
      if ( header_buf_used_0 <= v10 || header_buf[v10] != 13 )
        continue;
      break;
    }
    v6 += 4;
    if ( header_buf_used_0 <= v9 || header_buf[v9] != 10 )
      goto LABEL_20;
LABEL_35:
    chunksize_buf_index = v3;
    valuestart = 0;
    v17 = header_buf;
    v18 = 0;
    v74 = "transfer-encoding";
    na = v6 - 1;
    v19 = 0;
    endofheaders = v6;
    v20 = 0;
    while ( 2 )
    {
      v21 = v17[v18];
      v22 = v18 + 1;
      if ( v19 <= 0 || v20 > v19 )
      {
        if ( v21 == 13 || v21 == 10 )
        {
          if ( !v19 && v75 )
          {
            if ( v18 > 0 )
            {
              v38 = v17 + 1;
              valuestart = (int)v17;
              v39 = v75;
              i = v18;
              v77 = v18 + 1;
              v40 = &v38[v18];
              v41 = v38;
              while ( 1 )
              {
                if ( *(v41 - 1) == 32 )
                {
                  if ( *v39 >= 0 )
                  {
LABEL_75:
                    v17 = (char *)valuestart;
                    v18 = i;
                    v22 = v77;
                    goto LABEL_76;
                  }
                  *v39 = strtol(v41, 0, 10);
                }
                if ( v40 == ++v41 )
                  goto LABEL_75;
              }
            }
            goto LABEL_76;
          }
          if ( v20 <= v19 || v20 >= valuestart )
            goto LABEL_76;
          v77 = v20 - v19;
          i = (int)&v17[v19];
          if ( !strncasecmp(&v17[v19], s2, v20 - v19) )
          {
            content_length = strtol(&v17[valuestart], 0, 10);
            goto LABEL_76;
          }
          if ( !strncasecmp((const char *)i, v74, v77) )
          {
            v47 = strncasecmp(&v17[valuestart], "chunked", 7u) == 0;
            v48 = 1;
            if ( !v47 )
              v48 = chunked;
            chunked = v48;
            v35 = header_buf_used_0;
            if ( header_buf_used_0 <= v18 )
            {
LABEL_121:
              valuestart = 0;
              v20 = v18;
              v19 = v18;
              goto LABEL_41;
            }
          }
          else
          {
LABEL_76:
            v35 = header_buf_used_0;
            if ( header_buf_used_0 <= v18 )
              goto LABEL_121;
          }
          v36 = v35;
          while ( 1 )
          {
            v37 = v17[v18];
            v19 = v18;
            v18 = v22;
            if ( v37 != 13 && v37 != 10 )
            {
              valuestart = 0;
              v20 = v19;
              goto LABEL_42;
            }
            if ( v36 == v22 )
              break;
            ++v22;
          }
          v18 = v19 + 2;
          v19 = header_buf_used_0;
          valuestart = 0;
          v20 = header_buf_used_0;
        }
        else
        {
LABEL_41:
          v18 = v22;
        }
      }
      else
      {
        if ( v21 != 58 )
        {
          if ( v21 != 13 && v21 != 10 )
            goto LABEL_41;
          goto LABEL_76;
        }
        valuestart = v19;
        v49 = v18;
        while ( 1 )
        {
          v50 = v17[v49 + 1];
          v51 = v49++;
          if ( v50 != 32 && v50 != 9 )
            break;
          if ( na <= v49 )
          {
            v19 = valuestart;
            goto LABEL_128;
          }
        }
        v19 = valuestart;
        v49 = v51;
LABEL_128:
        v20 = v18;
        valuestart = v49 + 1;
        v18 = v49 + 1;
      }
LABEL_42:
      if ( na > v18 )
        continue;
      break;
    }
    v23 = header_buf_used_0;
    v3 = chunksize_buf_index;
    n = header_buf_used_0 - endofheaders;
    header_buf_used_0a = header_buf_used_0 - endofheaders;
    memcpy(buf, &header_buf[endofheaders], header_buf_used_0a);
    v11 = header_buf_used_0a;
    valuestart = v23;
    if ( !chunked )
      goto LABEL_24;
    v15 = content_buf_used;
    if ( header_buf_used_0a > 0 )
    {
LABEL_45:
      v24 = 0;
LABEL_55:
      if ( chunksize )
        goto LABEL_46;
      if ( v3 )
      {
LABEL_59:
        if ( v24 >= n )
        {
          v32 = v3;
          goto LABEL_104;
        }
      }
      else
      {
        v30 = buf[v24];
        if ( v30 != 13 )
        {
          if ( v30 != 10 )
            goto LABEL_59;
LABEL_130:
          ++v24;
          goto LABEL_59;
        }
        if ( ++v24 >= n )
        {
          v32 = 0;
LABEL_104:
          v3 = v32;
LABEL_105:
          chunked = 1;
          v15 = content_buf_used;
          continue;
        }
        if ( buf[v24] == 10 )
          goto LABEL_130;
      }
      v31 = *_ctype_b_loc();
      while ( 1 )
      {
        v33 = buf[v24];
        v34 = buf[v24];
        if ( (v31[v33] & 0x1000) == 0 || v3 > 0x1E )
          break;
        chunksize_buf[v3] = v33;
        v32 = v3 + 1;
        ++v24;
        chunksize_buf[v3 + 1] = 0;
        if ( v24 >= n )
          goto LABEL_104;
        ++v3;
      }
      if ( v24 >= n )
        goto LABEL_105;
      while ( v34 != 10 && v34 != 13 )
      {
        if ( ++v24 == n )
          goto LABEL_105;
        v34 = buf[v24];
      }
      if ( v24 >= n )
        goto LABEL_105;
      if ( v34 == 13 )
      {
        if ( ++v24 >= n )
          goto LABEL_105;
        if ( buf[v24] != 10 )
        {
          v15 = content_buf_used;
          goto LABEL_54;
        }
      }
      if ( !v3 )
        goto LABEL_134;
      v42 = chunksize_buf;
      v43 = 0;
      v44 = &chunksize_buf[v3];
      do
      {
        while ( 1 )
        {
          v45 = *v42;
          chunksizea = 16 * v43;
          if ( (unsigned __int8)(v45 - 48) > 9u )
            break;
          ++v42;
          v43 = chunksizea + v45 - 48;
          if ( v44 == v42 )
            goto LABEL_100;
        }
        ++v42;
        v43 = chunksizea + (char)(v45 | 0x20) - 87;
      }
      while ( v44 != v42 );
LABEL_100:
      chunksize_buf[0] = 0;
      ++v24;
      if ( !v43 )
        goto LABEL_134;
      chunksize = v43;
      v3 = 0;
LABEL_46:
      v25 = n - v24;
      if ( n - v24 > chunksize )
        v25 = chunksize;
      v26 = v25 + content_buf_used;
      if ( v25 + content_buf_used > content_buf_len )
      {
        v27 = content_length;
        if ( content_length < v26 )
          v27 = v25 + content_buf_used;
        content_buf_len = v27;
        v28 = (char *)realloc(content_buf, v27);
        v26 = v25 + content_buf_used;
        if ( !v28 )
          goto LABEL_138;
        content_buf = v28;
      }
      chunkeda = v26;
      v29 = &buf[v24];
      v24 += v25;
      memcpy(&content_buf[content_buf_used], v29, v25);
      chunksize -= v25;
      v15 = chunkeda;
      if ( v24 >= n )
      {
        content_buf_used = chunkeda;
        chunked = 1;
        continue;
      }
LABEL_54:
      content_buf_used = v15;
      goto LABEL_55;
    }
LABEL_28:
    ;
  }
  while ( content_length <= 0 || content_length > v15 );
  v16 = v15;
end_of_stream:
  nd = v16;
  free(header_buf);
  *v79 = nd;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
