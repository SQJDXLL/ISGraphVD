void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  char *v3; // eax
  char *v4; // ecx
  signed int v5; // edi
  int v6; // esi
  int v7; // eax
  char *v8; // eax
  signed int v9; // eax
  char *v10; // edx
  int v11; // edx
  char v12; // cl
  int v13; // eax
  int v14; // edi
  int v15; // ecx
  int v16; // eax
  int j; // esi
  char v18; // dl
  int v19; // edx
  int v20; // edi
  char v21; // cl
  const char *k; // edi
  size_t v23; // esi
  bool v24; // zf
  int v25; // eax
  char v26; // al
  int v27; // edx
  const unsigned __int16 **v28; // eax
  char v29; // al
  int m; // ecx
  int v31; // edi
  int v32; // eax
  signed int v33; // eax
  size_t v34; // eax
  char *v35; // eax
  char *v36; // esi
  unsigned int v37; // ecx
  int v39; // [esp+0h] [ebp-894h]
  unsigned int header_buf_len; // [esp+Ch] [ebp-888h]
  int chunked; // [esp+10h] [ebp-884h]
  unsigned int bytestocopy; // [esp+14h] [ebp-880h]
  unsigned int bytestocopya; // [esp+14h] [ebp-880h]
  char content_buf_used_0; // [esp+18h] [ebp-87Ch]
  unsigned int content_buf_used_0a; // [esp+18h] [ebp-87Ch]
  unsigned int content_buf_len; // [esp+24h] [ebp-870h]
  unsigned int chunksize_buf_index; // [esp+28h] [ebp-86Ch]
  const char *chunksize_0; // [esp+2Ch] [ebp-868h]
  signed int chunksize_0a; // [esp+2Ch] [ebp-868h]
  unsigned int chunksize_0b; // [esp+2Ch] [ebp-868h]
  char chunksize_0c; // [esp+2Ch] [ebp-868h]
  int endofheaders; // [esp+30h] [ebp-864h]
  signed int header_buf_used; // [esp+34h] [ebp-860h]
  int content_length; // [esp+38h] [ebp-85Ch]
  int content_buf_used; // [esp+3Ch] [ebp-858h]
  int i; // [esp+40h] [ebp-854h]
  int ia; // [esp+40h] [ebp-854h]
  char *content_buf; // [esp+44h] [ebp-850h]
  char *ptr; // [esp+48h] [ebp-84Ch]
  char chunksize_buf[32]; // [esp+58h] [ebp-83Ch]
  char buf[2048]; // [esp+78h] [ebp-81Ch] BYREF
  unsigned int v63; // [esp+878h] [ebp-1Ch]

  v63 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
  {
    *size = -1;
    return content_buf;
  }
  v3 = (char *)malloc(0x800u);
  if ( !v3 )
    goto LABEL_17;
  v4 = content_buf;
  v5 = 0;
  v6 = 0;
  content_buf = v3;
  chunksize_buf[0] = 0;
  ptr = v4;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  content_buf_len = 2048;
  header_buf_len = 2048;
  bytestocopy = 0;
  content_length = -1;
  chunked = 0;
  while ( 2 )
  {
    i = receivedata(s, buf, 2048, 5000, 0);
    if ( i <= 0 )
      break;
    if ( v6 )
    {
      header_buf_used = v5;
      endofheaders = v6;
      goto LABEL_76;
    }
    header_buf_used = v5 + i;
    if ( v5 + i > header_buf_len )
    {
      v8 = (char *)realloc(ptr, v5 + i);
      if ( !v8 )
      {
        free(ptr);
LABEL_17:
        free(content_buf);
LABEL_24:
        *size = -1;
        return 0;
      }
      ptr = v8;
      header_buf_len = v5 + i;
    }
    endofheaders = 0;
    v7 = 0;
    qmemcpy(&ptr[v5], buf, i);
    while ( header_buf_used - 1 > v7 )
    {
      if ( endofheaders )
        goto LABEL_39;
      v11 = v7 + 1;
      v12 = ptr[v7];
      if ( v12 == 13 )
      {
        if ( ptr[v7 + 1] == 10 )
        {
          v11 = v7 + 2;
          if ( header_buf_used > v7 + 2 && ptr[v7 + 2] == 13 )
          {
            v11 = v7 + 3;
            if ( header_buf_used > v7 + 3 && ptr[v7 + 3] == 10 )
            {
              v13 = v7 + 4;
LABEL_36:
              endofheaders = v13;
            }
          }
        }
      }
      else
      {
        if ( v12 == 10 )
        {
          if ( ptr[v11] != 10 )
            goto LABEL_38;
          v13 = v7 + 2;
          goto LABEL_36;
        }
        v11 = v7;
      }
LABEL_38:
      v7 = v11 + 1;
    }
    if ( !endofheaders )
      goto LABEL_11;
LABEL_39:
    v14 = 0;
    v15 = 0;
    v16 = 0;
    for ( j = 0; endofheaders - 1 > j; ++j )
    {
      ia = j;
      v18 = ptr[j];
      if ( v16 > 0 && v16 >= v15 && v18 == 58 )
      {
        v19 = j;
        while ( 1 )
        {
          v20 = v19;
          v21 = ptr[++v19];
          if ( v21 != 32 && v21 != 9 )
            break;
          if ( endofheaders - 1 <= v19 )
            goto LABEL_50;
        }
        v19 = v20;
LABEL_50:
        v15 = j;
        v14 = v19 + 1;
        j = v19;
      }
      else if ( v18 == 13 || v18 == 10 )
      {
        if ( v16 || !status_code )
        {
          if ( v16 < v15 && v15 < v14 )
          {
            v23 = v15 - v16;
            chunksize_0 = &ptr[v16];
            if ( !strncasecmp(&ptr[v16], "content-length", v15 - v16) )
            {
              content_length = atoi(&ptr[v14]);
            }
            else if ( !strncasecmp(chunksize_0, "transfer-encoding", v23) )
            {
              v24 = strncasecmp(&ptr[v14], "chunked", 7u) == 0;
              v25 = 1;
              if ( !v24 )
                v25 = chunked;
              chunked = v25;
            }
          }
        }
        else
        {
          for ( k = ptr + 1; k - ptr - 1 < j; ++k )
          {
            if ( *(k - 1) == 32 )
            {
              if ( *status_code >= 0 )
                goto LABEL_69;
              *status_code = atoi(k);
            }
          }
        }
        do
        {
LABEL_69:
          j = ia;
          if ( header_buf_used <= ia )
            break;
          ++ia;
          v26 = ptr[j];
        }
        while ( v26 == 13 || v26 == 10 );
        v14 = 0;
        v15 = j;
        v16 = j;
      }
    }
    i = header_buf_used - endofheaders;
    qmemcpy(buf, &ptr[endofheaders], header_buf_used - endofheaders);
LABEL_76:
    if ( !chunked )
    {
      if ( content_length > 0 && content_length < content_buf_used + i )
        i = content_length - content_buf_used;
      v9 = content_buf_used + i;
      if ( content_buf_used + i <= content_buf_len )
      {
        v10 = content_buf;
      }
      else
      {
        if ( content_length >= v9 )
          v9 = content_length;
        content_buf_len = v9;
        v10 = (char *)realloc(content_buf, v9);
        if ( !v10 )
        {
LABEL_23:
          free(content_buf);
          free(ptr);
          goto LABEL_24;
        }
      }
      content_buf = v10;
      qmemcpy(&v10[content_buf_used], buf, i);
      content_buf_used += i;
      goto LABEL_117;
    }
    v27 = 0;
LABEL_78:
    while ( i > v27 )
    {
      chunksize_0a = bytestocopy;
      if ( !bytestocopy )
      {
        if ( chunksize_buf_index )
          goto LABEL_85;
        if ( buf[v27] != 13 || (++v27, i > v27) )
        {
          if ( buf[v27] == 10 )
            ++v27;
LABEL_85:
          while ( 1 )
          {
            chunksize_0b = v27;
            if ( i <= v27 )
              break;
            v28 = _ctype_b_loc();
            v27 = chunksize_0b;
            chunksize_0c = buf[chunksize_0b];
            if ( ((*v28)[chunksize_0c] & 0x1000) == 0 || chunksize_buf_index > 0x1E )
            {
              while ( i > v27 )
              {
                v29 = buf[v27];
                if ( v29 == 10 || v29 == 13 )
                {
                  if ( buf[v27] == 13 && i <= ++v27 )
                    goto LABEL_117;
                  if ( buf[v27] != 10 )
                    goto LABEL_78;
                  chunksize_0a = 0;
                  for ( m = 0; chunksize_buf_index != m; ++m )
                  {
                    content_buf_used_0 = chunksize_buf[m];
                    v31 = 16 * chunksize_0a;
                    if ( (unsigned __int8)(content_buf_used_0 - 48) > 9u )
                      v32 = v31 + (content_buf_used_0 | 0x20) - 87;
                    else
                      v32 = v31 + content_buf_used_0 - 48;
                    chunksize_0a = v32;
                  }
                  ++v27;
                  chunksize_buf[0] = 0;
                  if ( chunksize_0a )
                  {
                    chunksize_buf_index = 0;
                    goto LABEL_105;
                  }
                  goto end_of_stream;
                }
                ++v27;
              }
              goto LABEL_117;
            }
            ++chunksize_buf_index;
            ++v27;
            chunksize_buf[chunksize_buf_index - 1] = chunksize_0c;
            chunksize_buf[chunksize_buf_index] = 0;
          }
        }
        break;
      }
LABEL_105:
      v33 = i - v27;
      if ( i - v27 > chunksize_0a )
        v33 = chunksize_0a;
      bytestocopya = v33;
      v34 = v33 + content_buf_used;
      content_buf_used_0a = v34;
      if ( v34 > content_buf_len )
      {
        if ( content_length >= (int)v34 )
          v34 = content_length;
        v39 = v27;
        content_buf_len = v34;
        v35 = (char *)realloc(content_buf, v34);
        v27 = v39;
        if ( !v35 )
          goto LABEL_23;
        content_buf = v35;
      }
      v36 = &buf[v27];
      v37 = bytestocopya;
      v27 += bytestocopya;
      bytestocopy = chunksize_0a - bytestocopya;
      qmemcpy(&content_buf[content_buf_used], v36, v37);
      content_buf_used = content_buf_used_0a;
    }
LABEL_117:
    if ( content_length <= 0 || content_buf_used < content_length )
    {
LABEL_11:
      v5 = header_buf_used;
      v6 = endofheaders;
      continue;
    }
    break;
  }
end_of_stream:
  free(ptr);
  *size = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
