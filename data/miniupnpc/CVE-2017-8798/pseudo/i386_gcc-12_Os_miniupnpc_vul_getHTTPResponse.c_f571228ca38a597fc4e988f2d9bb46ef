void *__cdecl getHTTPResponse(int s, int *size, int *status_code)
{
  int v3; // esi
  char *v4; // eax
  int v5; // eax
  int v6; // edx
  char v7; // cl
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int j; // edi
  char v13; // dl
  int v14; // ebx
  char v15; // dl
  const char *k; // esi
  size_t v17; // edi
  bool v18; // zf
  int v19; // eax
  char v20; // al
  int v21; // edx
  const unsigned __int16 **v22; // eax
  int v23; // ebx
  char v24; // al
  int v25; // ecx
  int v26; // eax
  int v27; // edi
  int v28; // eax
  signed int v29; // eax
  size_t v30; // eax
  char *v31; // eax
  int v32; // edx
  size_t v33; // eax
  char *v34; // eax
  int v35; // eax
  int v37; // [esp-Ch] [ebp-89Ch]
  unsigned int header_buf_len; // [esp+0h] [ebp-890h]
  int chunked; // [esp+4h] [ebp-88Ch]
  unsigned int bytestocopy; // [esp+8h] [ebp-888h]
  unsigned int bytestocopya; // [esp+8h] [ebp-888h]
  const char *content_buf_used_0; // [esp+Ch] [ebp-884h]
  unsigned int content_buf_used_0a; // [esp+Ch] [ebp-884h]
  unsigned int header_buf_used; // [esp+10h] [ebp-880h]
  unsigned int content_buf_len; // [esp+1Ch] [ebp-874h]
  unsigned int chunksize_buf_index; // [esp+20h] [ebp-870h]
  int content_length; // [esp+24h] [ebp-86Ch]
  signed int header_buf_used_0; // [esp+28h] [ebp-868h]
  signed int header_buf_used_0a; // [esp+28h] [ebp-868h]
  unsigned int header_buf_used_0b; // [esp+28h] [ebp-868h]
  int content_buf_used; // [esp+2Ch] [ebp-864h]
  char *content_buf; // [esp+30h] [ebp-860h]
  int endofheaders; // [esp+34h] [ebp-85Ch]
  int i; // [esp+38h] [ebp-858h]
  int ia; // [esp+38h] [ebp-858h]
  char *header_buf; // [esp+3Ch] [ebp-854h]
  char chunksize_buf[32]; // [esp+50h] [ebp-840h]
  char buf[2048]; // [esp+70h] [ebp-820h] BYREF
  unsigned int v60; // [esp+870h] [ebp-20h]

  v60 = __readgsdword(0x14u);
  if ( status_code )
    *status_code = -1;
  header_buf = (char *)malloc(0x800u);
  if ( !header_buf )
  {
    *size = -1;
    return 0;
  }
  content_buf = (char *)malloc(0x800u);
  if ( !content_buf )
    goto LABEL_6;
  chunksize_buf[0] = 0;
  chunksize_buf_index = 0;
  content_buf_used = 0;
  header_buf_used = 0;
  content_buf_len = 2048;
  header_buf_len = 2048;
  content_length = -1;
  chunked = 0;
  bytestocopy = 0;
  v3 = 0;
LABEL_10:
  i = receivedata(s, buf, 2048, 5000, 0);
  if ( i > 0 )
  {
    if ( v3 )
    {
      endofheaders = v3;
      goto LABEL_71;
    }
    header_buf_used_0 = header_buf_used + i;
    if ( header_buf_len < header_buf_used + i )
    {
      v4 = (char *)realloc(header_buf, header_buf_used + i);
      if ( !v4 )
      {
        free(header_buf);
        free(content_buf);
        goto LABEL_7;
      }
      header_buf = v4;
      header_buf_len = header_buf_used + i;
    }
    v5 = 0;
    qmemcpy(&header_buf[header_buf_used], buf, i);
    endofheaders = 0;
    while ( 1 )
    {
      if ( header_buf_used_0 - 1 <= v5 || endofheaders )
      {
        header_buf_used += i;
        if ( !endofheaders )
          goto LABEL_120;
        v9 = 0;
        v10 = 0;
        v11 = 0;
        for ( j = 0; endofheaders - 1 > j; j = v14 + 1 )
        {
          ia = j;
          v13 = header_buf[j];
          if ( v11 > 0 && v11 >= v10 && v13 == 58 )
          {
            v9 = j;
            do
            {
              v14 = v9++;
              if ( endofheaders == v9 )
                break;
              v15 = header_buf[v9];
            }
            while ( v15 == 32 || v15 == 9 );
          }
          else if ( v13 == 13 || v13 == 10 )
          {
            if ( !v11 && status_code )
            {
              for ( k = header_buf + 1; ; ++k )
              {
                if ( k - header_buf - 1 >= j )
                  goto LABEL_61;
                if ( *(k - 1) == 32 )
                {
                  if ( *status_code >= 0 )
                    goto LABEL_61;
                  *status_code = atoi(k);
                }
              }
            }
            if ( v11 < v10 && v10 < v9 )
            {
              v17 = v10 - v11;
              content_buf_used_0 = &header_buf[v11];
              if ( !strncasecmp(&header_buf[v11], "content-length", v10 - v11) )
              {
                content_length = atoi(&header_buf[v9]);
              }
              else if ( !strncasecmp(content_buf_used_0, "transfer-encoding", v17) )
              {
                v18 = strncasecmp(&header_buf[v9], "chunked", 7u) == 0;
                v19 = 1;
                if ( !v18 )
                  v19 = chunked;
                chunked = v19;
              }
            }
LABEL_61:
            while ( 1 )
            {
              v14 = ia;
              if ( header_buf_used_0 <= ia )
                break;
              j = ia++;
              v20 = header_buf[v14];
              if ( v20 != 13 && v20 != 10 )
              {
                v9 = 0;
                goto LABEL_67;
              }
            }
            v9 = 0;
            j = ia;
LABEL_67:
            v11 = v14;
          }
          else
          {
            v14 = j;
            j = v10;
          }
          v10 = j;
        }
        i = header_buf_used_0 - endofheaders;
        qmemcpy(buf, &header_buf[endofheaders], header_buf_used_0 - endofheaders);
        header_buf_used = header_buf_used_0;
LABEL_71:
        if ( chunked )
        {
          v21 = 0;
LABEL_73:
          while ( i > v21 )
          {
            header_buf_used_0a = bytestocopy;
            if ( !bytestocopy )
            {
              if ( !chunksize_buf_index )
              {
                if ( buf[v21] != 13 || (++v21, i > v21) )
                {
                  if ( buf[v21] == 10 )
                    ++v21;
                }
              }
              while ( 1 )
              {
                header_buf_used_0b = v21;
                if ( i <= v21 )
                  goto LABEL_118;
                v22 = _ctype_b_loc();
                v21 = header_buf_used_0b;
                v23 = buf[header_buf_used_0b];
                if ( ((*v22)[v23] & 0x1000) == 0 || chunksize_buf_index > 0x1E )
                {
                  while ( i > v21 )
                  {
                    v24 = buf[v21];
                    if ( v24 == 10 || v24 == 13 )
                    {
                      if ( buf[v21] == 13 && i <= ++v21 )
                        goto LABEL_118;
                      if ( buf[v21] != 10 )
                        goto LABEL_73;
                      v25 = 0;
                      header_buf_used_0a = 0;
                      while ( chunksize_buf_index != v25 )
                      {
                        v26 = chunksize_buf[v25];
                        v27 = 16 * header_buf_used_0a;
                        if ( (unsigned __int8)(v26 - 48) > 9u )
                          v28 = v27 + (char)(v26 | 0x20) - 87;
                        else
                          v28 = v27 + v26 - 48;
                        header_buf_used_0a = v28;
                        ++v25;
                      }
                      ++v21;
                      chunksize_buf[0] = 0;
                      if ( header_buf_used_0a )
                      {
                        chunksize_buf_index = 0;
                        goto LABEL_100;
                      }
                      goto end_of_stream;
                    }
                    ++v21;
                  }
                  goto LABEL_118;
                }
                ++chunksize_buf_index;
                v21 = header_buf_used_0b + 1;
                chunksize_buf[chunksize_buf_index - 1] = v23;
                chunksize_buf[chunksize_buf_index] = 0;
              }
            }
LABEL_100:
            v29 = i - v21;
            if ( i - v21 > header_buf_used_0a )
              v29 = header_buf_used_0a;
            bytestocopya = v29;
            v30 = v29 + content_buf_used;
            content_buf_used_0a = v30;
            if ( content_buf_len < v30 )
            {
              if ( content_length >= (int)v30 )
                v30 = content_length;
              v37 = v21;
              content_buf_len = v30;
              v31 = (char *)realloc(content_buf, v30);
              v21 = v37;
              if ( !v31 )
                goto LABEL_115;
              content_buf = v31;
            }
            qmemcpy(&content_buf[content_buf_used], &buf[v21], bytestocopya);
            v21 += bytestocopya;
            bytestocopy = header_buf_used_0a - bytestocopya;
            content_buf_used = content_buf_used_0a;
          }
LABEL_118:
          if ( content_length > 0 && content_buf_used >= content_length )
            break;
LABEL_120:
          v3 = endofheaders;
          goto LABEL_10;
        }
        if ( content_length > 0 && content_length < content_buf_used + i )
          i = content_length - content_buf_used;
        v32 = i + content_buf_used;
        if ( content_buf_len < i + content_buf_used )
        {
          v33 = content_length;
          if ( content_length < v32 )
            v33 = i + content_buf_used;
          content_buf_len = v33;
          v34 = (char *)realloc(content_buf, v33);
          v32 = i + content_buf_used;
          if ( !v34 )
          {
LABEL_115:
            free(content_buf);
LABEL_6:
            free(header_buf);
LABEL_7:
            *size = -1;
            return 0;
          }
          content_buf = v34;
        }
        v35 = content_buf_used;
        content_buf_used = v32;
        qmemcpy(&content_buf[v35], buf, i);
        goto LABEL_118;
      }
      v6 = v5 + 1;
      v7 = header_buf[v5];
      if ( v7 == 13 )
      {
        endofheaders = 0;
        if ( header_buf[v5 + 1] == 10 )
        {
          v6 = v5 + 2;
          if ( header_buf_used_0 > v5 + 2 && header_buf[v5 + 2] == 13 )
          {
            v6 = v5 + 3;
            if ( header_buf_used_0 > v5 + 3 && header_buf[v5 + 3] == 10 )
            {
              v8 = v5 + 4;
LABEL_29:
              endofheaders = v8;
            }
          }
        }
      }
      else
      {
        if ( v7 == 10 )
        {
          endofheaders = 0;
          if ( header_buf[v6] != 10 )
            goto LABEL_31;
          v8 = v5 + 2;
          goto LABEL_29;
        }
        v6 = v5;
        endofheaders = 0;
      }
LABEL_31:
      v5 = v6 + 1;
    }
  }
end_of_stream:
  free(header_buf);
  *size = content_buf_used;
  if ( !content_buf_used )
  {
    free(content_buf);
    return 0;
  }
  return content_buf;
}
