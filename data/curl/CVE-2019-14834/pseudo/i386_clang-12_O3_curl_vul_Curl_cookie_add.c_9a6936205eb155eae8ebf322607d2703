Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        char *path,
        bool secure)
{
  Cookie *v8; // ebp
  int v9; // eax
  int v10; // esi
  const char *v11; // ecx
  const char *v12; // edi
  char *i; // esi
  size_t v14; // eax
  unsigned int v15; // ebp
  char v16; // dl
  unsigned int v17; // edx
  size_t v18; // eax
  size_t v19; // ebx
  const char *v20; // ecx
  const char *v21; // edx
  char v22; // cl
  const char *v23; // edi
  int j; // ecx
  char v25; // bl
  unsigned int v26; // edi
  int v27; // eax
  unsigned int v28; // ebp
  int v29; // eax
  _DWORD *v30; // ebx
  const char *v31; // eax
  char *v32; // esi
  size_t v33; // ebp
  int v34; // eax
  int v35; // eax
  const char *v36; // esi
  const char *v37; // edi
  size_t v38; // eax
  char v39; // al
  int v40; // eax
  size_t v41; // edi
  unsigned int v42; // esi
  int v43; // eax
  const char *v44; // ebp
  _BYTE *v45; // eax
  const char *v46; // esi
  const char *v47; // eax
  char is_ipnum; // al
  char v49; // cl
  size_t v50; // eax
  char *v51; // ecx
  size_t v52; // esi
  int v53; // eax
  const char *v54; // eax
  int v55; // eax
  size_t v56; // eax
  int v57; // eax
  int v58; // eax
  size_t v59; // edi
  unsigned int v60; // eax
  unsigned int v61; // ecx
  int v62; // eax
  int v63; // edi
  char v64; // cl
  char *v65; // edi
  char *v66; // eax
  char *v67; // eax
  char *v68; // eax
  const char *v69; // ebp
  int v70; // edx
  int v71; // ecx
  int v72; // eax
  int v73; // eax
  int v74; // esi
  int v75; // eax
  const char *v76; // eax
  char *v77; // esi
  char *v78; // edi
  size_t v79; // ebp
  int v80; // ecx
  int v81; // eax
  int v82; // eax
  int v83; // eax
  int v84; // eax
  int v85; // edi
  int v86; // eax
  int v87; // ecx
  CookieInfo *v88; // eax
  char *v89; // eax
  int v90; // eax
  int v91; // eax
  _DWORD *v92; // edi
  char v93; // al
  _DWORD *v94; // esi
  int v95; // eax
  char v96; // cl
  char *v97; // eax
  char *v98; // eax
  int v99; // edi
  void *v100; // eax
  size_t v101; // edi
  const char *v102; // eax
  char *v103; // esi
  char *v104; // edi
  size_t v105; // ebp
  int v106; // eax
  char v107; // cl
  char v108; // al
  bool running; // al
  int v110; // eax
  Cookie *next; // eax
  Cookie *v112; // edi
  Cookie *v113; // esi
  char *v114; // eax
  int v115; // ecx
  const char *spath; // ebp
  char *v117; // eax
  int v118; // ecx
  bool v119; // zf
  int v120; // eax
  char *v121; // eax
  char *v122; // ecx
  int v123; // eax
  const char *v125; // eax
  __int128 v126; // xmm0
  char v127; // al
  CookieInfo *v128; // edi
  int v129; // eax
  CookieInfo *v130; // edi
  Cookie *v131; // esi
  Cookie *v132; // ebx
  Cookie *v133; // ebp
  curl_off_t v134; // rax
  int expires_high; // ecx
  Cookie **p_next; // eax
  const char *v137; // ecx
  Cookie **v138; // eax
  curl_off_t v139; // rax
  int v140; // ecx
  char *reject; // [esp+4h] [ebp-E8h]
  size_t n; // [esp+8h] [ebp-E4h]
  int v143; // [esp+Ch] [ebp-E0h]
  char v144; // [esp+28h] [ebp-C4h]
  const char *v145; // [esp+28h] [ebp-C4h]
  int v146; // [esp+28h] [ebp-C4h]
  int v147; // [esp+28h] [ebp-C4h]
  int v148; // [esp+2Ch] [ebp-C0h]
  char v149; // [esp+30h] [ebp-BCh]
  size_t v150; // [esp+30h] [ebp-BCh]
  size_t v151; // [esp+30h] [ebp-BCh]
  size_t v152; // [esp+30h] [ebp-BCh]
  size_t v153; // [esp+30h] [ebp-BCh]
  Cookie **v154; // [esp+30h] [ebp-BCh]
  time_t delim; // [esp+34h] [ebp-B8h]
  time_t delima; // [esp+34h] [ebp-B8h]
  int delimb; // [esp+34h] [ebp-B8h]
  char delimc; // [esp+34h] [ebp-B8h]
  const char *delim_4; // [esp+38h] [ebp-B4h]
  size_t delim_4a; // [esp+38h] [ebp-B4h]
  char delim_4b; // [esp+38h] [ebp-B4h]
  int delim_4c; // [esp+38h] [ebp-B4h]
  size_t delim_4d; // [esp+38h] [ebp-B4h]
  char *s2a; // [esp+3Ch] [ebp-B0h]
  char v166; // [esp+40h] [ebp-ACh]
  char v167; // [esp+40h] [ebp-ACh]
  size_t v168; // [esp+44h] [ebp-A8h]
  int v169; // [esp+44h] [ebp-A8h]
  unsigned int *v170; // [esp+48h] [ebp-A4h]
  const char *v171; // [esp+4Ch] [ebp-A0h]
  __int64 v172; // [esp+54h] [ebp-98h]
  char *dest[36]; // [esp+5Ch] [ebp-90h] BYREF

  delim = time(0);
  v8 = 0;
  if ( data->req.setcookies > 0x31u )
    return v8;
  v9 = Curl_ccalloc(1, 44);
  if ( !v9 )
    return v8;
  v10 = v9;
  v148 = v9;
  if ( !httpheader )
  {
    dest[0] = 0;
    v65 = lineptr;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v65 = lineptr + 10;
      *(_BYTE *)(v10 + 35) = 1;
      if ( lineptr[10] == 35 )
        goto LABEL_153;
    }
    else if ( *lineptr == 35 )
    {
      goto LABEL_153;
    }
    v66 = strchr(v65, 13);
    if ( v66 )
      *v66 = 0;
    v67 = strchr(v65, 10);
    if ( v67 )
      *v67 = 0;
    v68 = strtok_r(v65, "\t", dest);
    if ( !v68 )
      goto LABEL_225;
    v69 = v68;
    delim_4c = v10 + 24;
    v70 = 0;
    v71 = 0;
    while ( 1 )
    {
      v146 = v71;
      switch ( v70 )
      {
        case 0:
          if ( *v69 == 46 )
            ++v69;
          v72 = Curl_cstrdup(v69);
          *(_DWORD *)(v10 + 20) = v72;
          v119 = v72 == 0;
          v73 = (unsigned __int8)v146;
          if ( v119 )
            v73 = 1;
          v146 = v73;
          v74 = 0;
          goto LABEL_202;
        case 1:
          *(_BYTE *)(v10 + 32) = curl_strequal(v69, "TRUE") != 0;
          v74 = 1;
          goto LABEL_202;
        case 2:
          if ( !strcmp("TRUE", v69) || !strcmp("FALSE", v69) )
          {
            v85 = Curl_cstrdup("/");
            *(_DWORD *)(v148 + 12) = v85;
            v10 = v148;
            v86 = Curl_cstrdup("/");
            v87 = (unsigned __int8)v146;
            if ( !v86 )
              v87 = 1;
            *(_DWORD *)(v148 + 16) = v86;
            if ( !v85 )
              v87 = 1;
            v146 = v87;
            goto LABEL_197;
          }
          v75 = Curl_cstrdup(v69);
          *(_DWORD *)(v148 + 12) = v75;
          if ( v75 )
          {
            v76 = (const char *)Curl_cstrdup(v75);
            v77 = 0;
            if ( v76 )
            {
              v78 = (char *)v76;
              v79 = strlen(v76);
              if ( *v78 == 34 )
                memmove(v78, v78 + 1, v79--);
              if ( v79 )
              {
                if ( v78[v79 - 1] == 34 )
                  v78[--v79] = 0;
                if ( *v78 == 47 )
                {
                  if ( v79 )
                  {
                    LOBYTE(v80) = v146;
                    if ( v78[v79 - 1] == 47 )
                      v78[v79 - 1] = 0;
                    v77 = v78;
                    goto LABEL_216;
                  }
LABEL_213:
                  v77 = v78;
                  LOBYTE(v80) = v146;
LABEL_216:
                  *(_DWORD *)(v148 + 16) = v77;
                  v80 = (unsigned __int8)v80;
                  if ( !v77 )
                    v80 = 1;
                  v146 = v80;
                  v74 = 2;
                  goto LABEL_202;
                }
              }
              else if ( *v78 == 47 )
              {
                goto LABEL_213;
              }
              Curl_cfree(v78);
              v90 = Curl_memdup("/", 2);
              LOBYTE(v80) = v146;
              if ( v90 )
              {
                *(_BYTE *)(v90 + 1) = 0;
                v77 = (char *)v90;
              }
              goto LABEL_216;
            }
            LOBYTE(v80) = v146;
            goto LABEL_216;
          }
          v146 = 1;
          v74 = 2;
LABEL_202:
          v89 = strtok_r(0, "\t", dest);
          v71 = v146;
          v70 = v74 + 1;
          v10 = v148;
          if ( !v89 || (v69 = v89, (v146 & 1) != 0) )
          {
            if ( v70 == 6 )
            {
              v91 = Curl_cstrdup(&L_str_22);
              *(_DWORD *)(v148 + 8) = v91;
              LOBYTE(v71) = 1;
              if ( v91 )
                LOBYTE(v71) = v146;
              v70 = (v91 == 0) ^ 7;
            }
            if ( (v71 & 1) == 0 && v70 == 7 )
              goto LABEL_269;
LABEL_225:
            v92 = (_DWORD *)v10;
            goto LABEL_321;
          }
          break;
        case 3:
LABEL_197:
          *(_BYTE *)(v10 + 33) = 0;
          if ( curl_strequal(v69, "TRUE") )
          {
            if ( secure || (v88 = c, c->running) )
            {
              *(_BYTE *)(v10 + 33) = 1;
            }
            else
            {
              LOBYTE(v88) = 1;
              v146 = (int)v88;
            }
          }
          v74 = 3;
          goto LABEL_202;
        case 4:
          v119 = curlx_strtoofft(v69, 0, 10, delim_4c) == 0;
          v81 = (unsigned __int8)v146;
          if ( !v119 )
            v81 = 1;
          v146 = v81;
          v74 = 4;
          goto LABEL_202;
        case 5:
          v82 = Curl_cstrdup(v69);
          *(_DWORD *)(v10 + 4) = v82;
          if ( v82 )
          {
            if ( curl_strnequal("__Secure-", v82) )
            {
              *(_BYTE *)(v10 + 40) |= 1u;
              v74 = 5;
            }
            else
            {
              if ( curl_strnequal("__Host-", *(_DWORD *)(v10 + 4)) )
                *(_BYTE *)(v10 + 40) |= 2u;
              v74 = 5;
            }
          }
          else
          {
            v146 = 1;
            v74 = 5;
          }
          goto LABEL_202;
        case 6:
          v83 = Curl_cstrdup(v69);
          *(_DWORD *)(v10 + 8) = v83;
          v119 = v83 == 0;
          v84 = (unsigned __int8)v146;
          if ( v119 )
            v84 = 1;
          v146 = v84;
          v74 = 6;
          goto LABEL_202;
        default:
          v74 = v70;
          goto LABEL_202;
      }
    }
  }
  if ( strlen(lineptr) > 0x1388 )
  {
LABEL_153:
    Curl_cfree(v10);
    return v8;
  }
  v170 = (unsigned int *)(v10 + 24);
  HIDWORD(v172) = 0x7FFFFFFF - (delim >> 31);
  v166 = 0;
  v11 = lineptr;
  do
  {
    v12 = v11 + 1;
    for ( i = (char *)v11; *i == 32 || *i == 9; ++i )
      ++v12;
    v144 = *i;
    v14 = strcspn(i, ";\t\r\n=");
    if ( !v14 )
    {
      v11 = i;
      goto LABEL_70;
    }
    v11 = &i[v14];
    v15 = v14;
    while ( 1 )
    {
      v16 = i[v15 - 1];
      if ( v16 != 32 && v16 != 9 )
        break;
      if ( !--v15 )
      {
        v15 = 0;
        break;
      }
    }
    v17 = 0;
    delim_4 = 0;
    v149 = *v11;
    if ( *v11 == 61 )
    {
      delim_4a = v14;
      v171 = &i[v14 + 1];
      v18 = strcspn(v171, ";\r\n");
      v19 = 0;
      v168 = v18 + delim_4a;
      if ( v18 )
      {
        v20 = &v12[v18 + delim_4a];
        while ( 1 )
        {
          v21 = v20;
          v22 = *(v20 - 1);
          if ( v22 != 32 && v22 != 9 )
            break;
          --v18;
          v20 = v21 - 1;
          if ( !v18 )
            goto LABEL_30;
        }
        v23 = &v12[delim_4a];
        for ( j = 0; j != v18; ++j )
        {
          v25 = v23[j];
          if ( v25 != 32 && v25 != 9 )
          {
            v19 = v18 - j;
            v21 = &v23[j];
            goto LABEL_31;
          }
        }
        v19 = 0;
      }
      else
      {
LABEL_30:
        v21 = v171;
      }
LABEL_31:
      delim_4 = v21;
      if ( memchr(v21, 9, v19) )
      {
        Curl_cfree(*(_DWORD *)(v148 + 20));
        Curl_cfree(*(_DWORD *)(v148 + 12));
        Curl_cfree(*(_DWORD *)(v148 + 16));
        Curl_cfree(*(_DWORD *)(v148 + 4));
        Curl_cfree(*(_DWORD *)(v148 + 8));
        Curl_cfree(v148);
        v8 = 0;
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "cookie contains TAB, dropping", n, v143);
        return v8;
      }
      v11 = &i[v168 + 1];
      v17 = v19;
    }
    if ( v15 > 0xFFE || v17 > 0xFFE || v17 + v15 >= 0x1001 )
    {
      v152 = v17;
      Curl_cfree(*(_DWORD *)(v148 + 20));
      Curl_cfree(*(_DWORD *)(v148 + 12));
      Curl_cfree(*(_DWORD *)(v148 + 16));
      Curl_cfree(*(_DWORD *)(v148 + 4));
      Curl_cfree(*(_DWORD *)(v148 + 8));
      Curl_cfree(v148);
      if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v15, v152);
      return 0;
    }
    v119 = v144 == 95;
    v145 = v11;
    if ( v119 && v15 >= 7 && i[1] == 95 )
    {
      v26 = v17;
      n = 9;
      if ( curl_strnequal("__Secure-", i) )
      {
        *(_BYTE *)(v148 + 40) |= 1u;
        v11 = v145;
        v17 = v26;
      }
      else
      {
        n = 7;
        v27 = curl_strnequal("__Host-", i);
        v11 = v145;
        v17 = v26;
        if ( v27 )
          *(_BYTE *)(v148 + 40) |= 2u;
      }
    }
    if ( *(_DWORD *)(v148 + 4) )
    {
      if ( !v17 )
      {
        if ( v15 == 8 )
        {
          n = 8;
          v53 = curl_strnequal("httponly", i);
          v17 = 0;
          if ( v53 )
          {
            *(_BYTE *)(v148 + 35) = 1;
            v11 = v145;
            goto LABEL_70;
          }
        }
        else if ( v15 == 6 )
        {
          n = 6;
          v40 = curl_strnequal("secure", i);
          v17 = 0;
          if ( v40 )
          {
            v30 = (_DWORD *)v148;
            if ( !secure && c->running )
              goto LABEL_320;
            *(_BYTE *)(v148 + 33) = 1;
            v11 = v145;
            goto LABEL_70;
          }
        }
        v11 = v145;
        if ( v149 != 61 )
          goto LABEL_70;
      }
      if ( v15 != 7 )
      {
        if ( v15 != 6 )
        {
          if ( v15 != 4 )
            goto LABEL_70;
          v28 = v17;
          n = 4;
          if ( !curl_strnequal("path", i) )
          {
            v11 = v145;
            goto LABEL_70;
          }
          Curl_cfree(*(_DWORD *)(v148 + 12));
          v29 = Curl_memdup(delim_4, v28 + 1);
          v30 = (_DWORD *)v148;
          *(_DWORD *)(v148 + 12) = v29;
          if ( !v29 )
            goto LABEL_320;
          *(_BYTE *)(v29 + v28) = 0;
          if ( !*(_DWORD *)(v148 + 12) )
            goto LABEL_320;
          Curl_cfree(*(_DWORD *)(v148 + 16));
          v31 = (const char *)Curl_cstrdup(*(_DWORD *)(v148 + 12));
          if ( !v31 )
            goto LABEL_258;
          v32 = (char *)v31;
          v33 = strlen(v31);
          if ( *v32 == 34 )
            memmove(v32, v32 + 1, v33--);
          v11 = v145;
          if ( v33 )
          {
            if ( v32[v33 - 1] == 34 )
              v32[--v33] = 0;
            if ( *v32 == 47 )
            {
              if ( v33 && v32[v33 - 1] == 47 )
                v32[v33 - 1] = 0;
              goto LABEL_119;
            }
          }
          else if ( *v32 == 47 )
          {
LABEL_119:
            *(_DWORD *)(v148 + 16) = v32;
            goto LABEL_70;
          }
          Curl_cfree(v32);
          v57 = Curl_memdup("/", 2);
          if ( !v57 )
          {
LABEL_258:
            v30 = (_DWORD *)v148;
            *(_DWORD *)(v148 + 16) = 0;
            goto LABEL_320;
          }
          v32 = (char *)v57;
          *(_BYTE *)(v57 + 1) = 0;
          v11 = v145;
          goto LABEL_119;
        }
        reject = i;
        n = 6;
        v42 = v17;
        v43 = curl_strnequal("domain", reject);
        if ( !v42 )
        {
          v11 = v145;
          goto LABEL_70;
        }
        if ( !v43 )
        {
          v11 = v145;
          goto LABEL_70;
        }
        v44 = delim_4 + 1;
        if ( *delim_4 != 46 )
          v44 = delim_4;
        v151 = v42 - (*delim_4 == 46);
        if ( v151 == 9 && (n = 9, curl_strnequal(v44, "localhost"))
          || (v45 = memchr(v44, 46, v151)) != 0 && (unsigned int)(&v44[v151] - v45) > 1 )
        {
          v46 = domain;
          v47 = domain;
          if ( !domain )
            v47 = v44;
          is_ipnum = Curl_host_is_ipnum(v47);
          v49 = is_ipnum;
          if ( !domain )
          {
            v46 = 0;
LABEL_139:
            delim_4b = v49;
            domain = v46;
            Curl_cfree(*(_DWORD *)(v148 + 20));
            v62 = Curl_memdup(v44, v151 + 1);
            v30 = (_DWORD *)v148;
            *(_DWORD *)(v148 + 20) = v62;
            if ( !v62 )
              goto LABEL_320;
            *(_BYTE *)(v62 + v151) = 0;
            v63 = *(_DWORD *)(v148 + 20);
            v64 = v166;
            if ( !v63 )
              v64 = 1;
            if ( (v63 == 0) | (unsigned __int8)delim_4b )
            {
              v166 = v64;
              v11 = v145;
              if ( !v63 )
                break;
            }
            else
            {
              *(_BYTE *)(v148 + 32) = 1;
              v11 = v145;
            }
            goto LABEL_70;
          }
          if ( !is_ipnum )
          {
LABEL_94:
            v50 = strlen(v46);
            v51 = (char *)v46;
            v52 = v50;
            if ( v50 < v151 )
            {
              v46 = v51;
LABEL_146:
              domain = v46;
              v166 = 1;
              if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
                Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v44, v143);
              v11 = v145;
              goto LABEL_70;
            }
            s2a = v51;
            v59 = (size_t)&v51[v50 - v151];
            n = v151;
            if ( !curl_strnequal(v44, v59) )
            {
              v46 = s2a;
              goto LABEL_146;
            }
            if ( v52 == v151 )
            {
              v49 = 0;
              v46 = s2a;
            }
            else
            {
              v46 = s2a;
              if ( *(_BYTE *)(v59 - 1) != 46 )
                goto LABEL_146;
              v49 = 0;
            }
            goto LABEL_139;
          }
        }
        else
        {
          v46 = ":";
          if ( !(unsigned __int8)Curl_host_is_ipnum(":") )
            goto LABEL_94;
        }
        if ( strncmp(v44, v46, v151) )
          goto LABEL_146;
        v56 = strlen(v46);
        v49 = 1;
        if ( v151 != v56 )
          goto LABEL_146;
        goto LABEL_139;
      }
      v41 = v17;
      n = 7;
      if ( curl_strnequal("version", i) )
      {
        v11 = v145;
        goto LABEL_70;
      }
      if ( curl_strnequal("max-age", i) )
      {
        v54 = delim_4 + 1;
        if ( *delim_4 != 34 )
          v54 = delim_4;
        v55 = curlx_strtoofft(v54, 0, 10, v170);
        if ( v55 )
        {
          if ( v55 == 2 )
            goto LABEL_134;
          v11 = v145;
          if ( v55 == 1 )
          {
            *v170 = -1;
            v170[1] = 0x7FFFFFFF;
          }
        }
        else
        {
          v60 = *v170;
          v61 = v170[1];
          if ( !*(_QWORD *)v170 )
          {
LABEL_134:
            v170[1] = 0;
            *v170 = 1;
            v11 = v145;
            goto LABEL_70;
          }
          LODWORD(v172) = ~delim;
          if ( v172 >= __SPAIR64__(v61, v60) )
          {
            *(_QWORD *)v170 = delim + __PAIR64__(v61, v60);
          }
          else
          {
            *v170 = -1;
            v170[1] = 0x7FFFFFFF;
          }
          v11 = v145;
        }
      }
      else
      {
        n = 7;
        if ( curl_strnequal("expires", i) )
        {
          v11 = v145;
          if ( v41 <= 0x7F && !*(_QWORD *)v170 )
          {
            memcpy(dest, delim_4, v41);
            *((_BYTE *)dest + v41) = 0;
            v58 = Curl_getdate_capped(dest);
            *(_QWORD *)v170 = v58;
            if ( v58 )
            {
              v11 = v145;
              if ( v58 < 0 )
              {
                v170[1] = 0;
                *v170 = 0;
              }
            }
            else
            {
              v170[1] = 0;
              *v170 = 1;
              v11 = v145;
            }
          }
        }
        else
        {
          v11 = v145;
        }
      }
    }
    else
    {
      v30 = (_DWORD *)v148;
      if ( v149 != 61 )
        goto LABEL_320;
      v150 = v17;
      Curl_cfree(0);
      v34 = Curl_memdup(i, v15 + 1);
      *(_DWORD *)(v148 + 4) = v34;
      if ( v34 )
        *(_BYTE *)(v34 + v15) = 0;
      Curl_cfree(*(_DWORD *)(v148 + 8));
      v35 = Curl_memdup(delim_4, v150 + 1);
      *(_DWORD *)(v148 + 8) = v35;
      if ( v35 )
        *(_BYTE *)(v35 + v150) = 0;
      v30 = (_DWORD *)v148;
      v36 = *(const char **)(v148 + 4);
      if ( !v36 )
        goto LABEL_320;
      v37 = *(const char **)(v148 + 8);
      if ( !v37 )
        goto LABEL_320;
      if ( v37[strcspn(v37, invalid_octets_badoctets)]
        || (v38 = strcspn(v36, invalid_octets_badoctets), v11 = v145, v36[v38]) )
      {
        v30 = (_DWORD *)v148;
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
        {
          Curl_infof(data, "invalid octets in name/value, cookie dropped", n, v143);
          v30 = (_DWORD *)v148;
        }
LABEL_320:
        v92 = v30;
LABEL_321:
        Curl_cfree(v92[5]);
        Curl_cfree(v92[3]);
        Curl_cfree(v92[4]);
        Curl_cfree(v92[1]);
        Curl_cfree(v92[2]);
        Curl_cfree(v92);
        return 0;
      }
    }
    do
    {
      do
LABEL_70:
        v39 = *v11++;
      while ( v39 == 32 );
    }
    while ( v39 == 9 );
  }
  while ( v39 == 59 );
  v93 = v166;
  if ( (v166 & 1) != 0 )
  {
    v94 = (_DWORD *)v148;
  }
  else
  {
    v94 = (_DWORD *)v148;
    if ( domain && !*(_DWORD *)(v148 + 20) )
    {
      v95 = Curl_cstrdup(domain);
      *(_DWORD *)(v148 + 20) = v95;
      v96 = 1;
      if ( v95 )
        v96 = v166;
      v93 = v96;
    }
  }
  if ( (v93 & 1) != 0 || !path || v94[3] )
    goto LABEL_266;
  v167 = v93;
  v97 = strchr(path, 63);
  if ( v97 )
    v98 = (char *)Curl_memrchr(path, 47, v97 - path);
  else
    v98 = strrchr(path, 47);
  if ( !v98 )
  {
    v93 = v167;
    goto LABEL_266;
  }
  v99 = v98 - path;
  v100 = (void *)Curl_cmalloc(v98 - path + 2);
  v94[3] = v100;
  v30 = v94;
  if ( !v100 )
    goto LABEL_320;
  v101 = v99 + 1;
  memcpy(v100, path, v101);
  *(_BYTE *)(v94[3] + v101) = 0;
  v102 = (const char *)Curl_cstrdup(v94[3]);
  v103 = 0;
  if ( !v102 )
    goto LABEL_263;
  v104 = (char *)v102;
  v105 = strlen(v102);
  if ( *v104 == 34 )
    memmove(v104, v104 + 1, v105--);
  if ( !v105 )
  {
    if ( *v104 == 47 )
      goto LABEL_260;
    goto LABEL_261;
  }
  if ( v104[v105 - 1] == 34 )
    v104[--v105] = 0;
  if ( *v104 != 47 )
  {
LABEL_261:
    Curl_cfree(v104);
    v106 = Curl_memdup("/", 2);
    if ( v106 )
    {
      *(_BYTE *)(v106 + 1) = 0;
      v103 = (char *)v106;
    }
    goto LABEL_263;
  }
  if ( v105 && v104[v105 - 1] == 47 )
    v104[v105 - 1] = 0;
LABEL_260:
  v103 = v104;
LABEL_263:
  *(_DWORD *)(v148 + 16) = v103;
  v107 = 1;
  if ( v103 )
    v107 = v167;
  v93 = v107;
LABEL_266:
  v30 = (_DWORD *)v148;
  if ( (v93 & 1) != 0 || !*(_DWORD *)(v148 + 4) )
    goto LABEL_320;
  ++data->req.setcookies;
  v10 = v148;
LABEL_269:
  v8 = 0;
  v108 = *(_BYTE *)(v10 + 40);
  if ( (v108 & 1) != 0 && !*(_BYTE *)(v10 + 33)
    || (v108 & 2) != 0
    && (!*(_BYTE *)(v10 + 33) || (v125 = *(const char **)(v10 + 12)) == 0 || strcmp(v125, "/") || *(_BYTE *)(v10 + 32))
    || !(running = c->running) && c->newsession && !*(_QWORD *)(v10 + 24) )
  {
    Curl_cfree(*(_DWORD *)(v10 + 20));
    Curl_cfree(*(_DWORD *)(v10 + 12));
    Curl_cfree(*(_DWORD *)(v10 + 16));
    Curl_cfree(*(_DWORD *)(v10 + 4));
    Curl_cfree(*(_DWORD *)(v10 + 8));
    Curl_cfree(v10);
    return v8;
  }
  *(_BYTE *)(v10 + 34) = running;
  v110 = c->lastct + 1;
  c->lastct = v110;
  *(_DWORD *)(v10 + 36) = v110;
  if ( !noexpire )
  {
    delima = time(0);
    if ( delima >= c->next_expiration || !(~LODWORD(c->next_expiration) | HIDWORD(c->next_expiration) ^ 0x7FFFFFFF) )
    {
      c->next_expiration = 0x7FFFFFFFFFFFFFFFLL;
      v129 = 0;
      do
      {
        v130 = c;
        v169 = v129;
        v131 = c->cookies[v129];
        if ( v131 )
        {
          v154 = &c->cookies[v129];
          v132 = 0;
          do
          {
            while ( 1 )
            {
              v133 = v131;
              v131 = v131->next;
              LODWORD(v134) = v133->expires;
              expires_high = HIDWORD(v133->expires);
              if ( !v133->expires )
                break;
              HIDWORD(v134) = HIDWORD(v133->expires);
              if ( v134 >= delima )
                break;
              p_next = &v132->next;
              if ( !v132 )
                p_next = v154;
              *p_next = v131;
              --v130->numcookies;
              Curl_cfree(v133->domain);
              Curl_cfree(v133->path);
              Curl_cfree(v133->spath);
              Curl_cfree(v133->name);
              Curl_cfree(v133->value);
              Curl_cfree(v133);
              v130 = c;
              if ( !v131 )
                goto LABEL_336;
            }
            if ( expires_high | (unsigned int)v134 )
            {
              HIDWORD(v134) = HIDWORD(v133->expires);
              if ( v134 < v130->next_expiration )
              {
                LODWORD(v130->next_expiration) = v134;
                HIDWORD(v130->next_expiration) = expires_high;
              }
            }
            v132 = v133;
          }
          while ( v131 );
        }
LABEL_336:
        v129 = v169 + 1;
      }
      while ( v169 != 62 );
    }
  }
  v8 = (Cookie *)v148;
  delim_4d = cookiehash(*(const char *const *)(v148 + 20));
  next = c->cookies[delim_4d];
  if ( !next )
  {
    v113 = 0;
    v127 = 0;
    v128 = c;
    goto LABEL_351;
  }
  v147 = 0;
  v112 = 0;
  delimb = 0;
  while ( 2 )
  {
    v113 = next;
    if ( curl_strequal(next->name, *(_DWORD *)(v148 + 4)) )
    {
      v114 = v113->domain;
      v115 = *(_DWORD *)(v148 + 20);
      if ( v114 )
      {
        if ( v115 && curl_strequal(v114, *(_DWORD *)(v148 + 20)) )
        {
LABEL_285:
          spath = v113->spath;
          if ( spath && *(_DWORD *)(v148 + 16) && v113->secure && !*(_BYTE *)(v148 + 33) && !secure )
          {
            v153 = *(_DWORD *)(v148 + 16);
            if ( !strchr(spath + 1, 47) )
              strlen(spath);
            if ( curl_strnequal(spath, v153) )
            {
              if ( data && (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
                Curl_infof(
                  data,
                  "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                  *(_DWORD *)(v148 + 4),
                  *(_DWORD *)(v148 + 20));
LABEL_364:
              v92 = (_DWORD *)v148;
              goto LABEL_321;
            }
          }
        }
      }
      else if ( !v115 )
      {
        goto LABEL_285;
      }
    }
    if ( !v147 )
    {
      v147 = 0;
      if ( curl_strequal(v113->name, *(_DWORD *)(v148 + 4)) )
      {
        v117 = v113->domain;
        v118 = *(_DWORD *)(v148 + 20);
        if ( !v117 )
        {
          v119 = v118 == 0;
          goto LABEL_299;
        }
        if ( v118 && curl_strequal(v117, *(_DWORD *)(v148 + 20)) )
        {
          v119 = v113->tailmatch == *(_BYTE *)(v148 + 32);
LABEL_299:
          v120 = (unsigned __int8)delimb;
          if ( v119 )
            v120 = 1;
        }
        else
        {
          v120 = delimb;
        }
        delimb = v120;
        if ( (v120 & 1) != 0 )
        {
          v121 = v113->spath;
          v147 = 0;
          v122 = 0;
          if ( v121 )
          {
            if ( !*(_DWORD *)(v148 + 16) )
            {
              v122 = v113->spath;
              goto LABEL_307;
            }
            if ( curl_strequal(v121, *(_DWORD *)(v148 + 16)) )
            {
              v122 = v113->spath;
              goto LABEL_307;
            }
            delimb = 0;
            v147 = 0;
          }
          else
          {
LABEL_307:
            v123 = (unsigned __int8)delimb;
            if ( (v122 != 0) == (*(_DWORD *)(v148 + 16) == 0) )
              v123 = 0;
            delimb = v123;
            if ( (v123 & 1) != 0 )
            {
              if ( *(_BYTE *)(v148 + 34) )
              {
                v112 = v113;
                v147 = v148;
              }
              else
              {
                v112 = v113;
                v147 = v148;
                if ( v113->livecookie )
                  goto LABEL_364;
              }
            }
          }
        }
      }
    }
    next = v113->next;
    if ( v113->next )
      continue;
    break;
  }
  if ( v147 )
  {
    *(_DWORD *)v147 = v112->next;
    *(_DWORD *)(v147 + 36) = v112->creationtime;
    Curl_cfree(v112->name);
    Curl_cfree(v112->value);
    Curl_cfree(v112->domain);
    Curl_cfree(v112->path);
    Curl_cfree(v112->spath);
    *(_OWORD *)((char *)&v112->expires + 4) = *(_OWORD *)(v147 + 28);
    v126 = *(_OWORD *)v147;
    *(_OWORD *)&v112->spath = *(_OWORD *)(v147 + 16);
    *(_OWORD *)&v112->next = v126;
    Curl_cfree(v147);
    v8 = v112;
  }
  else
  {
    v8 = (Cookie *)v148;
  }
  v128 = c;
  v127 = delimb;
LABEL_351:
  if ( data && v128->running && (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
  {
    delimc = v127;
    v137 = "Replaced";
    if ( (v127 & 1) == 0 )
      v137 = "Added";
    v128 = c;
    Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v137, v8->name);
    v127 = delimc;
  }
  if ( (v127 & 1) == 0 )
  {
    v138 = &v128->cookies[delim_4d];
    if ( v113 )
      v138 = &v113->next;
    *v138 = v8;
    ++v128->numcookies;
  }
  LODWORD(v139) = v8->expires;
  v140 = HIDWORD(v8->expires);
  if ( v8->expires )
  {
    HIDWORD(v139) = HIDWORD(v8->expires);
    if ( v139 < v128->next_expiration )
    {
      LODWORD(v128->next_expiration) = v139;
      HIDWORD(v128->next_expiration) = v140;
    }
  }
  return v8;
}
