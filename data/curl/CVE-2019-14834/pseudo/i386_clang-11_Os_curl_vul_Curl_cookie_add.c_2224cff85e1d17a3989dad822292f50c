Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  time_t v8; // eax
  Cookie *v9; // esi
  int v10; // ebp
  int v11; // eax
  int v12; // edi
  const char *v13; // esi
  const char *v14; // edi
  const char *i; // ebp
  size_t v16; // eax
  unsigned int v17; // ecx
  char v18; // dl
  size_t v19; // esi
  size_t v20; // eax
  size_t v21; // ecx
  const char *v22; // edx
  size_t v23; // esi
  const char *v24; // edi
  char v25; // cl
  int v26; // edi
  unsigned int v27; // edx
  unsigned int v28; // edi
  int v29; // eax
  int v30; // eax
  char *v31; // eax
  unsigned int v32; // esi
  int v33; // eax
  int v34; // eax
  const char *v35; // esi
  const char *v36; // edi
  size_t v37; // eax
  const char *v38; // ecx
  int v39; // eax
  size_t v40; // edi
  const char *v41; // eax
  int v42; // eax
  unsigned int v43; // esi
  int v44; // eax
  unsigned int v45; // ecx
  const char *v46; // esi
  _BOOL4 v47; // eax
  _BYTE *v48; // eax
  const char *v49; // ebp
  Curl_easy *v50; // esi
  int v51; // eax
  const char *v52; // eax
  char is_ipnum; // al
  char v54; // cl
  int v55; // eax
  size_t v56; // eax
  int v57; // eax
  char v58; // cl
  int v59; // ebp
  unsigned int v60; // eax
  unsigned int v61; // ecx
  char v62; // al
  char *v63; // ebp
  char *v64; // eax
  char *v65; // eax
  char *v66; // eax
  const char *v67; // edi
  int v68; // ebp
  int v69; // edx
  int v70; // eax
  int v71; // eax
  const char *v72; // eax
  char *v73; // eax
  int v74; // eax
  int v75; // eax
  int v76; // eax
  int v77; // ebp
  int v78; // eax
  int v79; // ecx
  CookieInfo *v80; // eax
  char *v81; // eax
  int v82; // eax
  char v83; // al
  int v84; // esi
  int v85; // eax
  char v86; // bp
  char *v87; // eax
  char *v88; // eax
  int v89; // edi
  void *v90; // eax
  size_t v91; // edi
  char *v92; // eax
  char v93; // al
  bool running; // al
  int v95; // eax
  Cookie *v96; // esi
  Cookie *next; // eax
  Cookie **v98; // edi
  Cookie *v99; // ebp
  char *v100; // eax
  int v101; // ecx
  const char *spath; // esi
  char *v103; // eax
  size_t v104; // eax
  char *v105; // eax
  int v106; // ecx
  bool v107; // zf
  int v108; // eax
  char *v109; // eax
  char *v110; // ecx
  int v111; // eax
  const char *v112; // eax
  Cookie **p_next; // eax
  curl_off_t v115; // rax
  int expires_high; // ecx
  size_t v117; // [esp-Ch] [ebp-D8h]
  const char *v118; // [esp-8h] [ebp-D4h]
  Cookie *v119; // [esp+0h] [ebp-CCh]
  char v120; // [esp+8h] [ebp-C4h]
  const char *v121; // [esp+8h] [ebp-C4h]
  int v122; // [esp+8h] [ebp-C4h]
  int v123; // [esp+8h] [ebp-C4h]
  int v124; // [esp+Ch] [ebp-C0h]
  const char *s; // [esp+10h] [ebp-BCh]
  const char *sa; // [esp+10h] [ebp-BCh]
  const char *sb; // [esp+10h] [ebp-BCh]
  Cookie *sc; // [esp+10h] [ebp-BCh]
  size_t n; // [esp+14h] [ebp-B8h]
  size_t na; // [esp+14h] [ebp-B8h]
  size_t nb; // [esp+14h] [ebp-B8h]
  size_t nc; // [esp+14h] [ebp-B8h]
  size_t nd; // [esp+14h] [ebp-B8h]
  char v134; // [esp+18h] [ebp-B4h]
  char v135; // [esp+18h] [ebp-B4h]
  int v136; // [esp+18h] [ebp-B4h]
  char v137; // [esp+1Ch] [ebp-B0h]
  unsigned int v139; // [esp+24h] [ebp-A8h]
  unsigned int v140; // [esp+24h] [ebp-A8h]
  unsigned int *v141; // [esp+28h] [ebp-A4h]
  int v142; // [esp+2Ch] [ebp-A0h]
  __int64 v143; // [esp+34h] [ebp-98h]
  char *dest[36]; // [esp+3Ch] [ebp-90h] BYREF

  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return v9;
  v10 = v8;
  v11 = Curl_ccalloc(1, 44);
  if ( !v11 )
    return v9;
  v12 = v11;
  v142 = v10;
  v124 = v11;
  if ( !httpheader )
  {
    dest[0] = 0;
    v63 = lineptr;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v63 = lineptr + 10;
      *(_BYTE *)(v12 + 35) = 1;
    }
    if ( *v63 != 35 )
    {
      v64 = strchr(v63, 13);
      if ( v64 )
        *v64 = 0;
      v65 = strchr(v63, 10);
      if ( v65 )
        *v65 = 0;
      v66 = strtok_r(v63, "\t", dest);
      if ( v66 )
      {
        v67 = v66;
        v68 = 0;
        v69 = 0;
        do
        {
          v122 = v69;
          switch ( v68 )
          {
            case 0:
              if ( *v67 == 46 )
                ++v67;
              v70 = Curl_cstrdup(v67);
              v107 = v70 == 0;
              *(_DWORD *)(v124 + 20) = v70;
              v71 = (unsigned __int8)v122;
              if ( v107 )
                v71 = 1;
              v68 = 0;
              goto LABEL_157;
            case 1:
              *(_BYTE *)(v124 + 32) = curl_strequal(v67, "TRUE") != 0;
              v68 = 1;
              break;
            case 2:
              if ( !strcmp("TRUE", v67) || !strcmp("FALSE", v67) )
              {
                v77 = Curl_cstrdup("/");
                *(_DWORD *)(v124 + 12) = v77;
                v78 = Curl_cstrdup("/");
                v9 = 0;
                v79 = (unsigned __int8)v122;
                if ( !v78 )
                  v79 = 1;
                if ( !v77 )
                  v79 = 1;
                v122 = v79;
                *(_DWORD *)(v124 + 16) = v78;
LABEL_163:
                *(_BYTE *)(v124 + 33) = 0;
                if ( curl_strequal(v67, "TRUE") )
                {
                  if ( secure || (v80 = c, c->running) )
                  {
                    *(_BYTE *)(v124 + 33) = 1;
                  }
                  else
                  {
                    LOBYTE(v80) = 1;
                    v122 = (int)v80;
                  }
                }
                v68 = 3;
              }
              else
              {
                v72 = (const char *)Curl_cstrdup(v67);
                *(_DWORD *)(v124 + 12) = v72;
                if ( v72 )
                {
                  v73 = sanitize_cookie_path(v72);
                  *(_DWORD *)(v124 + 16) = v73;
                  v107 = v73 == 0;
                  v74 = (unsigned __int8)v122;
                  if ( v107 )
                    v74 = 1;
                }
                else
                {
                  v74 = 1;
                }
                v122 = v74;
                v68 = 2;
              }
              break;
            case 3:
              goto LABEL_163;
            case 4:
              v107 = curlx_strtoofft(v67, 0, 10, v124 + 24) == 0;
              v68 = 4;
              v71 = (unsigned __int8)v122;
              if ( !v107 )
                v71 = 1;
              goto LABEL_157;
            case 5:
              v75 = Curl_cstrdup(v67);
              *(_DWORD *)(v124 + 4) = v75;
              if ( v75 )
              {
                if ( curl_strnequal("__Secure-", v75, 9) )
                {
                  *(_BYTE *)(v124 + 40) |= 1u;
                }
                else if ( curl_strnequal("__Host-", *(_DWORD *)(v124 + 4), 7) )
                {
                  *(_BYTE *)(v124 + 40) |= 2u;
                }
              }
              else
              {
                v122 = 1;
              }
              v68 = 5;
              break;
            case 6:
              v76 = Curl_cstrdup(v67);
              v107 = v76 == 0;
              v68 = 6;
              *(_DWORD *)(v124 + 8) = v76;
              v71 = (unsigned __int8)v122;
              if ( v107 )
                v71 = 1;
LABEL_157:
              v122 = v71;
              break;
            default:
              break;
          }
          v81 = strtok_r(0, "\t", dest);
          v69 = v122;
          ++v68;
          if ( !v81 )
            break;
          v67 = v81;
        }
        while ( (v122 & 1) == 0 );
        if ( v68 == 6 )
        {
          v82 = Curl_cstrdup(&L_str_22);
          LOBYTE(v69) = v122;
          *(_DWORD *)(v124 + 8) = v82;
          if ( !v82 )
            LOBYTE(v69) = 1;
          v68 = (v82 == 0) ^ 7;
        }
        if ( (v69 & 1) == 0 && v68 == 7 )
          goto LABEL_212;
      }
      goto LABEL_268;
    }
LABEL_129:
    Curl_cfree(v12);
    return v9;
  }
  if ( strlen(lineptr) > 0x1388 )
    goto LABEL_129;
  v137 = 0;
  v141 = (unsigned int *)(v12 + 24);
  LODWORD(v143) = ~v10;
  v13 = lineptr;
  HIDWORD(v143) = 0x7FFFFFFF - (v10 >> 31);
  do
  {
    v14 = v13 + 1;
    for ( i = v13; *i == 32 || *i == 9; ++i )
      ++v14;
    v120 = *i;
    v16 = strcspn(i, ";\t\r\n=");
    if ( !v16 )
    {
      v13 = i;
      goto LABEL_120;
    }
    v13 = &i[v16];
    v17 = v16;
    while ( 1 )
    {
      v18 = i[v17 - 1];
      if ( v18 != 32 && v18 != 9 )
        break;
      if ( !--v17 )
      {
        v17 = 0;
        break;
      }
    }
    if ( *v13 == 61 )
    {
      v139 = v17;
      s = &i[v16 + 1];
      v19 = v16;
      v20 = strcspn(s, ";\r\n");
      v21 = v20 + v19;
      if ( v20 )
      {
        v22 = s;
        v23 = v20 + v19;
        v24 = &v14[v21];
        while ( 1 )
        {
          v25 = *(v24 - 1);
          if ( v25 != 32 && v25 != 9 )
            break;
          --v20;
          --v24;
          if ( !v20 )
            goto LABEL_30;
        }
        while ( *v22 == 32 || *v22 == 9 )
        {
          ++v22;
          if ( !--v20 )
          {
            v20 = 0;
            v22 = v24;
            break;
          }
        }
      }
      else
      {
        v22 = s;
        v23 = v20 + v19;
LABEL_30:
        v20 = 0;
      }
      v28 = v20;
      sa = v22;
      if ( memchr(v22, 9, v20) )
      {
        freecookie(v119);
        v9 = 0;
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "cookie contains TAB, dropping");
        return v9;
      }
      v27 = v28;
      v26 = v124;
      v17 = v139;
      v13 = &i[v23 + 1];
      v134 = 1;
    }
    else
    {
      v26 = v124;
      v27 = 0;
      v134 = 0;
      sa = 0;
    }
    if ( v17 > 0xFFE || v27 > 0xFFE || v27 + v17 >= 0x1001 )
    {
      freecookie(v119);
      if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes");
      return 0;
    }
    v107 = v120 == 95;
    v121 = v13;
    if ( v107 && v17 >= 7 && i[1] == 95 )
    {
      v140 = v17;
      n = v27;
      if ( curl_strnequal("__Secure-", i, 9) )
      {
        *(_BYTE *)(v26 + 40) |= 1u;
        v27 = n;
        v17 = v140;
      }
      else
      {
        v29 = curl_strnequal("__Host-", i, 7);
        v27 = n;
        v17 = v140;
        if ( v29 )
          *(_BYTE *)(v26 + 40) |= 2u;
      }
    }
    if ( !*(_DWORD *)(v26 + 4) )
    {
      if ( !v134 )
        goto LABEL_262;
      nb = v27;
      v32 = v17;
      Curl_cfree(0);
      v33 = Curl_memdup(i, v32 + 1);
      *(_DWORD *)(v124 + 4) = v33;
      if ( v33 )
        *(_BYTE *)(v33 + v32) = 0;
      Curl_cfree(*(_DWORD *)(v124 + 8));
      v34 = Curl_memdup(sa, nb + 1);
      *(_DWORD *)(v124 + 8) = v34;
      if ( v34 )
        *(_BYTE *)(v34 + nb) = 0;
      v35 = *(const char **)(v124 + 4);
      if ( !v35 )
        goto LABEL_262;
      v36 = *(const char **)(v124 + 8);
      if ( !v36 )
        goto LABEL_262;
      if ( v36[strcspn(v36, invalid_octets_badoctets)]
        || (v37 = strcspn(v35, invalid_octets_badoctets), v38 = v35, v13 = v121, v38[v37]) )
      {
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "invalid octets in name/value, cookie dropped");
        goto LABEL_262;
      }
      goto LABEL_120;
    }
    if ( !v27 )
    {
      if ( v17 == 8 )
      {
        v51 = curl_strnequal("httponly", i, 8);
        v17 = 8;
        v27 = 0;
        v26 = v124;
        if ( v51 )
        {
          *(_BYTE *)(v124 + 35) = 1;
          goto LABEL_120;
        }
      }
      else if ( v17 == 6 )
      {
        v39 = curl_strnequal("secure", i, 6);
        v17 = 6;
        v27 = 0;
        v26 = v124;
        if ( v39 )
        {
          if ( !secure && c->running )
            goto LABEL_262;
          *(_BYTE *)(v124 + 33) = 1;
          goto LABEL_120;
        }
      }
      if ( !v134 )
        goto LABEL_120;
    }
    if ( v17 != 7 )
    {
      if ( v17 != 6 )
      {
        if ( v17 != 4 )
          goto LABEL_120;
        na = v27;
        if ( !curl_strnequal("path", i, 4) )
          goto LABEL_119;
        Curl_cfree(*(_DWORD *)(v26 + 12));
        v30 = Curl_memdup(sa, na + 1);
        *(_DWORD *)(v26 + 12) = v30;
        if ( !v30 )
          goto LABEL_262;
        *(_BYTE *)(v30 + na) = 0;
        if ( !*(_DWORD *)(v124 + 12) )
          goto LABEL_262;
        Curl_cfree(*(_DWORD *)(v124 + 16));
        v31 = sanitize_cookie_path(*(const char **)(v124 + 12));
        *(_DWORD *)(v124 + 16) = v31;
        if ( !v31 )
          goto LABEL_262;
        goto LABEL_120;
      }
      v43 = v27;
      v44 = curl_strnequal("domain", i, 6);
      if ( !v43 || !v44 )
        goto LABEL_119;
      v45 = v43;
      v46 = sa + 1;
      v47 = *sa == 46;
      if ( *sa != 46 )
        v46 = sa;
      sb = v46;
      nc = v45 - v47;
      if ( v45 - v47 == 9 && curl_strnequal(v46, "localhost", 9)
        || (v48 = memchr(v46, 46, nc)) != 0 && (unsigned int)(&v46[nc] - v48) > 1 )
      {
        v49 = domain;
        v52 = domain;
        if ( !domain )
          v52 = v46;
        is_ipnum = Curl_host_is_ipnum(v52);
        v50 = data;
        v54 = is_ipnum;
        if ( !domain )
        {
          v49 = 0;
LABEL_106:
          v135 = v54;
          domain = v49;
          Curl_cfree(*(_DWORD *)(v26 + 20));
          v57 = Curl_memdup(sb, nc + 1);
          *(_DWORD *)(v26 + 20) = v57;
          if ( !v57 )
            goto LABEL_262;
          *(_BYTE *)(v57 + nc) = 0;
          v58 = v137;
          v59 = *(_DWORD *)(v124 + 20);
          if ( !v59 )
            v58 = 1;
          if ( !((v59 == 0) | (unsigned __int8)v135) )
          {
            *(_BYTE *)(v124 + 32) = 1;
            goto LABEL_119;
          }
          v13 = v121;
          v137 = v58;
          if ( !v59 )
            break;
          goto LABEL_120;
        }
        if ( is_ipnum )
          goto LABEL_86;
      }
      else
      {
        v49 = ":";
        v50 = data;
        if ( (unsigned __int8)Curl_host_is_ipnum(":") )
        {
LABEL_86:
          if ( strncmp(sb, v49, nc) )
          {
            v50 = data;
LABEL_112:
            domain = v49;
            v137 = 1;
            if ( (*((_BYTE *)&v50->set + 1326) & 0x10) != 0 )
              Curl_infof(v50, "skipped cookie with bad tailmatch domain: %s");
LABEL_119:
            v13 = v121;
            goto LABEL_120;
          }
          v56 = strlen(v49);
          v50 = data;
          v54 = 1;
          if ( nc != v56 )
            goto LABEL_112;
          goto LABEL_106;
        }
      }
      if ( !cookie_tailmatch(v49, v117, v118) )
        goto LABEL_112;
      v54 = 0;
      goto LABEL_106;
    }
    v40 = v27;
    if ( curl_strnequal("version", i, 7) )
      goto LABEL_119;
    if ( curl_strnequal("max-age", i, 7) )
    {
      v41 = sa + 1;
      if ( *sa != 34 )
        v41 = sa;
      v42 = curlx_strtoofft(v41, 0, 10, v141);
      switch ( v42 )
      {
        case 0:
          v60 = *v141;
          v61 = v141[1];
          if ( *(_QWORD *)v141 )
          {
            if ( v143 >= __SPAIR64__(v61, v60) )
            {
              *(_QWORD *)v141 = v142 + __PAIR64__(v61, v60);
            }
            else
            {
              v141[1] = 0x7FFFFFFF;
              *v141 = -1;
            }
          }
          else
          {
LABEL_118:
            v141[1] = 0;
            *v141 = 1;
          }
          goto LABEL_119;
        case 2:
          goto LABEL_118;
        case 1:
          v141[1] = 0x7FFFFFFF;
          *v141 = -1;
          break;
      }
    }
    else
    {
      if ( !curl_strnequal("expires", i, 7) )
        goto LABEL_119;
      if ( v40 > 0x7F || *(_QWORD *)v141 )
        goto LABEL_120;
      memcpy(dest, sa, v40);
      *((_BYTE *)dest + v40) = 0;
      v55 = Curl_getdate_capped(dest);
      *(_QWORD *)v141 = v55;
      if ( !v55 )
      {
        v141[1] = 0;
        *v141 = 1;
        goto LABEL_119;
      }
      if ( v55 < 0 )
      {
        v141[1] = 0;
        *v141 = 0;
      }
    }
    do
    {
      do
LABEL_120:
        v62 = *v13++;
      while ( v62 == 32 );
    }
    while ( v62 == 9 );
  }
  while ( v62 == 59 );
  v83 = v137;
  if ( (v137 & 1) != 0 )
  {
    v84 = v124;
  }
  else
  {
    v84 = v124;
    if ( domain )
    {
      if ( !*(_DWORD *)(v124 + 20) )
      {
        v85 = Curl_cstrdup(domain);
        *(_DWORD *)(v124 + 20) = v85;
        v107 = v85 == 0;
        v83 = v137;
        if ( v107 )
          v83 = 1;
      }
    }
  }
  if ( (v83 & 1) == 0 && path && !*(_DWORD *)(v84 + 12) )
  {
    v86 = v83;
    v87 = strchr(path, 63);
    if ( v87 )
      v88 = (char *)Curl_memrchr(path, 47, v87 - path);
    else
      v88 = strrchr(path, 47);
    if ( v88 )
    {
      v89 = v88 - path;
      v90 = (void *)Curl_cmalloc(v88 - path + 2);
      *(_DWORD *)(v124 + 12) = v90;
      if ( !v90 )
        goto LABEL_262;
      v91 = v89 + 1;
      memcpy(v90, path, v91);
      *(_BYTE *)(*(_DWORD *)(v124 + 12) + v91) = 0;
      v92 = sanitize_cookie_path(*(const char **)(v124 + 12));
      *(_DWORD *)(v124 + 16) = v92;
      v107 = v92 == 0;
      v83 = v86;
      if ( v107 )
        v83 = 1;
    }
    else
    {
      v83 = v86;
    }
  }
  if ( (v83 & 1) != 0 || !*(_DWORD *)(v124 + 4) )
  {
LABEL_262:
    freecookie(v119);
    return 0;
  }
  v9 = 0;
  ++data->req.setcookies;
LABEL_212:
  v93 = *(_BYTE *)(v124 + 40);
  if ( (v93 & 1) != 0 && !*(_BYTE *)(v124 + 33)
    || (v93 & 2) != 0
    && (!*(_BYTE *)(v124 + 33) || (v112 = *(const char **)(v124 + 12)) == 0
                               || strcmp(v112, "/")
                               || *(_BYTE *)(v124 + 32))
    || !(running = c->running) && c->newsession && !*(_QWORD *)(v124 + 24) )
  {
LABEL_268:
    freecookie(v119);
    return v9;
  }
  *(_BYTE *)(v124 + 34) = running;
  v95 = c->lastct + 1;
  c->lastct = v95;
  *(_DWORD *)(v124 + 36) = v95;
  if ( !noexpire )
    remove_expired((CookieInfo *)v119);
  v96 = (Cookie *)v124;
  nd = cookiehash(*(const char *const *)(v124 + 20));
  next = c->cookies[nd];
  if ( next )
  {
    v98 = 0;
    sc = 0;
    v123 = 0;
    while ( 1 )
    {
      v99 = next;
      if ( !curl_strequal(next->name, v96->name) )
        goto LABEL_235;
      v100 = v99->domain;
      v101 = *(_DWORD *)(v124 + 20);
      if ( v100 )
      {
        if ( !v101 || !curl_strequal(v100, *(_DWORD *)(v124 + 20)) )
          goto LABEL_235;
      }
      else if ( v101 )
      {
        goto LABEL_235;
      }
      spath = v99->spath;
      if ( spath && *(_DWORD *)(v124 + 16) && v99->secure && !*(_BYTE *)(v124 + 33) && !secure )
      {
        v136 = *(_DWORD *)(v124 + 16);
        v103 = strchr(spath + 1, 47);
        v104 = v103 ? v103 - spath : strlen(spath);
        if ( curl_strnequal(spath, v136, v104) )
        {
          if ( data && (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
            Curl_infof(data, "cookie '%s' for domain '%s' dropped, would overlay an existing cookie");
          goto LABEL_262;
        }
      }
LABEL_235:
      if ( v98 )
      {
        v96 = (Cookie *)v124;
        goto LABEL_237;
      }
      v96 = (Cookie *)v124;
      v98 = 0;
      if ( !curl_strequal(v99->name, *(_DWORD *)(v124 + 4)) )
        goto LABEL_237;
      v105 = v99->domain;
      v106 = *(_DWORD *)(v124 + 20);
      if ( v105 )
      {
        if ( !v106 || !curl_strequal(v105, *(_DWORD *)(v124 + 20)) )
        {
          v108 = v123;
          goto LABEL_248;
        }
        v107 = v99->tailmatch == *(_BYTE *)(v124 + 32);
      }
      else
      {
        v107 = v106 == 0;
      }
      v108 = (unsigned __int8)v123;
      if ( v107 )
        v108 = 1;
LABEL_248:
      v123 = v108;
      if ( (v108 & 1) != 0 )
      {
        v109 = v99->spath;
        v98 = 0;
        v110 = 0;
        if ( !v109 )
          goto LABEL_254;
        if ( !*(_DWORD *)(v124 + 16) )
        {
          v110 = v99->spath;
LABEL_254:
          v111 = (unsigned __int8)v123;
          if ( (v110 != 0) == (*(_DWORD *)(v124 + 16) == 0) )
            v111 = 0;
          v123 = v111;
          if ( (v111 & 1) != 0 )
          {
            if ( *(_BYTE *)(v124 + 34) )
            {
              sc = v99;
              v98 = (Cookie **)v124;
            }
            else
            {
              v98 = (Cookie **)v124;
              sc = v99;
              if ( v99->livecookie )
                goto LABEL_262;
            }
          }
          goto LABEL_237;
        }
        if ( curl_strequal(v109, *(_DWORD *)(v124 + 16)) )
        {
          v110 = v99->spath;
          goto LABEL_254;
        }
        v123 = 0;
        v98 = 0;
      }
LABEL_237:
      next = v99->next;
      if ( !v99->next )
      {
        if ( !v98 )
          goto LABEL_276;
        *v98 = sc->next;
        v98[9] = (Cookie *)sc->creationtime;
        Curl_cfree(sc->name);
        Curl_cfree(sc->value);
        Curl_cfree(sc->domain);
        Curl_cfree(sc->path);
        Curl_cfree(sc->spath);
        qmemcpy(sc, v98, sizeof(Cookie));
        Curl_cfree(v98);
        goto LABEL_277;
      }
    }
  }
  v99 = 0;
  LOBYTE(v123) = 0;
LABEL_276:
  sc = v96;
LABEL_277:
  if ( data && c->running && (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
    Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld");
  if ( (v123 & 1) == 0 )
  {
    p_next = &c->cookies[nd];
    if ( v99 )
      p_next = &v99->next;
    *p_next = sc;
    ++c->numcookies;
  }
  v9 = sc;
  LODWORD(v115) = sc->expires;
  expires_high = HIDWORD(sc->expires);
  if ( sc->expires )
  {
    HIDWORD(v115) = HIDWORD(sc->expires);
    if ( v115 < c->next_expiration )
    {
      LODWORD(c->next_expiration) = v115;
      HIDWORD(c->next_expiration) = expires_high;
    }
  }
  return v9;
}
