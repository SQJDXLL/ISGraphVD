Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  time_t v8; // eax
  char **v9; // esi
  int v10; // eax
  int v11; // ebp
  int *v12; // edi
  int v13; // edi
  char *v14; // ebp
  const char *v15; // ecx
  const char *i; // esi
  size_t v17; // eax
  char **v18; // ebp
  char v19; // dl
  int *v20; // ebx
  const char *v21; // edi
  size_t v22; // eax
  size_t v23; // edx
  size_t v24; // ecx
  char v25; // dl
  size_t v26; // edx
  unsigned int v27; // edx
  char v28; // bl
  size_t v29; // eax
  int v30; // ebx
  int v31; // edx
  int *v32; // ebx
  unsigned int v33; // edi
  unsigned int v34; // esi
  int v35; // eax
  int *v36; // ebx
  char **v37; // edi
  char *v38; // eax
  _DWORD *v39; // ebp
  unsigned int v40; // edi
  int v41; // eax
  const char *v42; // esi
  char **v43; // edi
  const char *v44; // ebp
  const char *v45; // eax
  char v46; // al
  int v47; // esi
  int *v48; // ebx
  size_t v49; // edi
  char *v50; // eax
  int v51; // eax
  int v52; // eax
  int v53; // eax
  unsigned int v54; // eax
  unsigned int v55; // ecx
  char v56; // al
  int v57; // eax
  char v58; // cl
  char *v59; // eax
  char *v60; // eax
  char *v61; // eax
  char *v62; // eax
  char *v63; // eax
  const char *v64; // esi
  int v65; // ebp
  int v66; // edx
  char *v67; // eax
  bool v68; // zf
  int v69; // ecx
  const char *v70; // eax
  unsigned __int8 v71; // si
  int v72; // eax
  char v73; // si
  int v74; // eax
  int v75; // eax
  char *v76; // eax
  char v77; // si
  int v78; // eax
  int v79; // esi
  void *v80; // eax
  size_t v81; // esi
  char *v82; // eax
  char v83; // cl
  char v84; // al
  bool running; // al
  int v86; // eax
  Cookie *v87; // esi
  int v88; // eax
  void *v89; // edx
  char *v90; // eax
  int v91; // eax
  const char *v92; // esi
  int v93; // ebp
  char *v94; // eax
  size_t v95; // eax
  int v96; // eax
  void *v97; // esi
  int v98; // eax
  bool v99; // zf
  int v100; // eax
  int v101; // eax
  void *v102; // esi
  int v103; // eax
  char **v104; // eax
  const char *v105; // eax
  __int64 v107; // xmm0_8
  const char *v108; // ecx
  void *v109; // edi
  Cookie **v110; // eax
  curl_off_t v111; // rax
  char *v112; // ecx
  char *v113; // [esp-10h] [ebp-ECh]
  const char *v114; // [esp-10h] [ebp-ECh]
  const char *v115; // [esp-10h] [ebp-ECh]
  const char *v116; // [esp-Ch] [ebp-E8h]
  const char *v117; // [esp-Ch] [ebp-E8h]
  const char *v118; // [esp-Ch] [ebp-E8h]
  const char *v119; // [esp-Ch] [ebp-E8h]
  const char *v120; // [esp-8h] [ebp-E4h]
  size_t v121; // [esp-8h] [ebp-E4h]
  int v122; // [esp-4h] [ebp-E0h]
  Cookie *v123; // [esp+0h] [ebp-DCh]
  size_t v124; // [esp+4h] [ebp-D8h]
  size_t v125; // [esp+8h] [ebp-D4h]
  int v126; // [esp+8h] [ebp-D4h]
  unsigned __int8 v127; // [esp+8h] [ebp-D4h]
  const char *v128; // [esp+8h] [ebp-D4h]
  int v129; // [esp+8h] [ebp-D4h]
  int v130; // [esp+Ch] [ebp-D0h]
  char v131; // [esp+14h] [ebp-C8h]
  char delim; // [esp+18h] [ebp-C4h]
  unsigned __int8 delima; // [esp+18h] [ebp-C4h]
  char *delimb; // [esp+18h] [ebp-C4h]
  unsigned __int8 delimc; // [esp+18h] [ebp-C4h]
  char **str; // [esp+1Ch] [ebp-C0h]
  char stra; // [esp+1Ch] [ebp-C0h]
  char **strd; // [esp+1Ch] [ebp-C0h]
  char **strb; // [esp+1Ch] [ebp-C0h]
  char **strc; // [esp+1Ch] [ebp-C0h]
  char *s1; // [esp+20h] [ebp-BCh]
  char *s1a; // [esp+20h] [ebp-BCh]
  char *s1b; // [esp+20h] [ebp-BCh]
  char *s1c; // [esp+20h] [ebp-BCh]
  _DWORD *v145; // [esp+24h] [ebp-B8h]
  size_t v146; // [esp+24h] [ebp-B8h]
  int v148; // [esp+2Ch] [ebp-B0h]
  __int64 v149; // [esp+34h] [ebp-A8h]
  unsigned int *v150; // [esp+3Ch] [ebp-A0h]
  _DWORD *v151; // [esp+40h] [ebp-9Ch]
  _DWORD *v152; // [esp+44h] [ebp-98h]
  _DWORD *v153; // [esp+48h] [ebp-94h]
  char *dest[36]; // [esp+4Ch] [ebp-90h] BYREF

  v122 = 134218511;
  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return (Cookie *)v9;
  v148 = v8;
  v10 = Curl_ccalloc(1, 44);
  if ( !v10 )
    return (Cookie *)v9;
  v11 = v10;
  v12 = &GLOBAL_OFFSET_TABLE_;
  v130 = v10;
  if ( !httpheader )
  {
    v13 = v10;
    dest[0] = 0;
    v14 = lineptr;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v14 = lineptr + 10;
      *(_BYTE *)(v13 + 35) = 1;
      if ( lineptr[10] == 35 )
        goto LABEL_8;
    }
    else if ( *lineptr == 35 )
    {
LABEL_8:
      Curl_cfree(v13);
      return (Cookie *)v9;
    }
    v61 = strchr(v14, 13);
    if ( v61 )
      *v61 = 0;
    v62 = strchr(v14, 10);
    if ( v62 )
      *v62 = 0;
    v63 = strtok_r(v14, "\t", dest);
    if ( v63 )
    {
      v64 = v63;
      strb = (char **)(v13 + 24);
      v65 = 0;
      v66 = 0;
      v12 = &GLOBAL_OFFSET_TABLE_;
      while ( 2 )
      {
        switch ( v65 )
        {
          case 0:
            v127 = v66;
            if ( *v64 == 46 )
              ++v64;
            v67 = (char *)Curl_cstrdup(v64);
            *(_DWORD *)(v130 + 20) = v67;
            goto LABEL_180;
          case 1:
            v128 = (const char *)v66;
            *(_BYTE *)(v130 + 32) = curl_strequal(v64, "TRUE") != 0;
            goto LABEL_207;
          case 2:
            v127 = v66;
            if ( !strcmp("TRUE", v64) || !strcmp("FALSE", v64) )
            {
              s1a = (char *)Curl_cstrdup("/");
              *(_DWORD *)(v130 + 12) = s1a;
              v12 = &GLOBAL_OFFSET_TABLE_;
              v75 = Curl_cstrdup("/");
              v66 = v127;
              if ( !v75 )
                v66 = 1;
              *(_DWORD *)(v130 + 16) = v75;
              if ( !s1a )
                v66 = 1;
              ++v65;
LABEL_202:
              v128 = (const char *)v66;
              *(_BYTE *)(v130 + 33) = 0;
              if ( curl_strequal(v64, "TRUE") )
              {
                if ( secure || (v70 = (const char *)c, c->running) )
                {
                  *(_BYTE *)(v130 + 33) = 1;
                  goto LABEL_207;
                }
LABEL_206:
                LOBYTE(v70) = 1;
                v128 = v70;
              }
            }
            else
            {
              v70 = (const char *)Curl_cstrdup(v64);
              *(_DWORD *)(v130 + 12) = v70;
              if ( !v70 )
                goto LABEL_206;
              v67 = sanitize_cookie_path(v70);
              *(_DWORD *)(v130 + 16) = v67;
LABEL_180:
              v68 = v67 == 0;
              LOBYTE(v69) = v127;
LABEL_194:
              v69 = (unsigned __int8)v69;
              if ( v68 )
                v69 = 1;
LABEL_196:
              v128 = (const char *)v69;
            }
LABEL_207:
            v76 = strtok_r(0, "\t", dest);
            ++v65;
            v66 = (int)v128;
            if ( ((unsigned __int8)v128 & 1) != 0 )
              goto LABEL_214;
            v64 = v76;
            if ( !v76 )
              goto LABEL_214;
            continue;
          case 3:
            goto LABEL_202;
          case 4:
            v114 = v64;
            v71 = v66;
            v72 = curlx_strtoofft(v114, 0, 10, strb);
            v69 = v71;
            if ( v72 )
              v69 = 1;
            goto LABEL_196;
          case 5:
            v128 = (const char *)v66;
            v70 = (const char *)Curl_cstrdup(v64);
            *(_DWORD *)(v130 + 4) = v70;
            if ( !v70 )
              goto LABEL_206;
            if ( curl_strnequal("__Secure-", v70, 9) )
            {
              *(_BYTE *)(v130 + 40) |= 1u;
            }
            else if ( curl_strnequal("__Host-", *(_DWORD *)(v130 + 4), 7) )
            {
              *(_BYTE *)(v130 + 40) |= 2u;
            }
            goto LABEL_207;
          case 6:
            v115 = v64;
            v73 = v66;
            v74 = Curl_cstrdup(v115);
            *(_DWORD *)(v130 + 8) = v74;
            v68 = v74 == 0;
            LOBYTE(v69) = v73;
            goto LABEL_194;
          default:
            v128 = (const char *)v66;
            goto LABEL_207;
        }
      }
    }
    LOBYTE(v66) = 0;
    v65 = 0;
    v12 = &GLOBAL_OFFSET_TABLE_;
LABEL_214:
    if ( v65 == 6 )
    {
      v77 = v66;
      v78 = Curl_cstrdup(&L_str_22);
      *(_DWORD *)(v130 + 8) = v78;
      LOBYTE(v66) = 1;
      if ( v78 )
        LOBYTE(v66) = v77;
      v65 = (v78 != 0) + 6;
    }
    v9 = 0;
    if ( (v66 & 1) == 0 && v65 == 7 )
    {
      v11 = v130;
      goto LABEL_236;
    }
LABEL_221:
    freecookie(v123);
    return 0;
  }
  if ( strlen(lineptr) > 0x1388 )
  {
    Curl_cfree(v11);
    goto LABEL_234;
  }
  v153 = (_DWORD *)(v11 + 8);
  v145 = (_DWORD *)(v11 + 4);
  v152 = (_DWORD *)(v11 + 12);
  v150 = (unsigned int *)(v11 + 24);
  v151 = (_DWORD *)(v11 + 20);
  v131 = 0;
  v15 = lineptr;
  while ( 2 )
  {
    for ( i = v15; *i == 32 || *i == 9; ++i )
      ;
    delim = *i;
    v17 = strcspn(i, &L_str_1[(_DWORD)v12 - 134228864]);
    if ( !v17 )
      goto LABEL_152;
    v15 = &i[v17];
    v18 = (char **)v17;
    do
    {
      v19 = *((_BYTE *)v18 + (_DWORD)i - 1);
      if ( v19 != 32 && v19 != 9 )
      {
        if ( *v15 != 61 )
          goto LABEL_28;
LABEL_21:
        v20 = v12;
        v21 = &i[v17 + 1];
        v125 = v17;
        v22 = strcspn(v21, &L_str_2[(_DWORD)v20 - 134228864]);
        if ( v22 )
        {
          v23 = v22;
          do
          {
            v24 = v23;
            v25 = i[v125 + v23];
            if ( v25 != 32 && v25 != 9 )
            {
              v26 = v24;
              goto LABEL_31;
            }
            v23 = v24 - 1;
          }
          while ( v24 != 1 );
          v26 = 0;
        }
        else
        {
          v26 = 0;
        }
LABEL_31:
        v29 = v125 + v22;
        if ( v26 )
        {
          v30 = (int)&i[v26 + 1 + v125];
          while ( *v21 == 32 || *v21 == 9 )
          {
            ++v21;
            if ( !--v26 )
            {
              v26 = 0;
              v21 = (const char *)v30;
              break;
            }
          }
        }
        str = (char **)v26;
        v126 = (int)&i[v29 + 1];
        if ( !memchr(v21, 9, v26) )
        {
          s1 = (char *)v21;
          v15 = (const char *)v126;
          v27 = (unsigned int)str;
          v12 = &GLOBAL_OFFSET_TABLE_;
          v28 = 1;
          goto LABEL_43;
        }
        v11 = v130;
        freecookie(v123);
        v31 = 1;
        v12 = &GLOBAL_OFFSET_TABLE_;
        if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
        {
          Curl_infof(data, "cookie contains TAB, dropping", v120, v122);
          v31 = 1;
          v15 = (const char *)v126;
          goto LABEL_149;
        }
LABEL_55:
        v15 = (const char *)v126;
        goto LABEL_149;
      }
      v18 = (char **)((char *)v18 - 1);
    }
    while ( v18 );
    v18 = 0;
    if ( *v15 == 61 )
      goto LABEL_21;
LABEL_28:
    v27 = 0;
    v28 = 0;
    s1 = 0;
LABEL_43:
    v126 = (int)v15;
    if ( (unsigned int)v18 > 0xFFE || v27 > 0xFFE || (unsigned int)v18 + v27 >= 0x1001 )
    {
      v34 = v27;
      freecookie(v123);
      v31 = 1;
      if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      {
        Curl_infof(data, &L_str_4[(_DWORD)v12 - 134228864], v18, v34);
        v31 = 1;
      }
      v11 = v130;
      goto LABEL_55;
    }
    if ( delim == 95 && (unsigned int)v18 >= 7 && i[1] == 95 )
    {
      stra = v28;
      v32 = v12;
      v33 = v27;
      if ( curl_strnequal(&L_str_5[(_DWORD)v32 - 134228864], i, 9) )
      {
        *(_BYTE *)(v130 + 40) |= 1u;
        v15 = (const char *)v126;
        v27 = v33;
        v12 = v32;
        v28 = stra;
      }
      else
      {
        v35 = curl_strnequal(&L_str_6[(_DWORD)v32 - 134228864], i, 7);
        v15 = (const char *)v126;
        v27 = v33;
        v12 = v32;
        v28 = stra;
        if ( v35 )
          *(_BYTE *)(v130 + 40) |= 2u;
      }
    }
    if ( !*v145 )
    {
      if ( !v28 )
      {
        v131 = 1;
        v11 = v130;
        v31 = 6;
        goto LABEL_149;
      }
      strd = (char **)v27;
      strstore(v18, v116, (size_t)v120);
      v39 = v153;
      strstore(strd, v118, v121);
      if ( *v145 )
      {
        v68 = *v39 == 0;
        v11 = v130;
        if ( !v68 )
        {
          v12 = &GLOBAL_OFFSET_TABLE_;
          if ( !invalid_octets((const char *)v123) && !invalid_octets((const char *)v123) )
          {
            v15 = (const char *)v126;
            goto LABEL_148;
          }
          v15 = (const char *)v126;
          v31 = 6;
          if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
          {
            Curl_infof(data, "invalid octets in name/value, cookie dropped", v120, v122);
            v31 = 6;
            v15 = (const char *)v126;
          }
          goto LABEL_75;
        }
        v131 = 1;
      }
      else
      {
        v131 = 1;
        v11 = v130;
      }
      v15 = (const char *)v126;
      v12 = &GLOBAL_OFFSET_TABLE_;
      v31 = 6;
      goto LABEL_149;
    }
    if ( v27 )
      goto LABEL_60;
    if ( v18 == (char **)8 )
    {
      v52 = curl_strnequal(&L_str_9[(_DWORD)v12 - 134228864], i, 8);
      v27 = 0;
      v12 = &GLOBAL_OFFSET_TABLE_;
      v15 = (const char *)v126;
      if ( v52 )
      {
        v11 = v130;
        *(_BYTE *)(v130 + 35) = 1;
        goto LABEL_148;
      }
LABEL_121:
      if ( !v28 )
      {
LABEL_122:
        v11 = v130;
        goto LABEL_148;
      }
LABEL_60:
      if ( v18 == (char **)7 )
      {
        v48 = v12;
        v49 = v27;
        if ( curl_strnequal(&L_str_14[(_DWORD)v48 - 134228864], i, 7) )
        {
          v11 = v130;
          v15 = (const char *)v126;
          v12 = v48;
          goto LABEL_148;
        }
        v11 = v130;
        if ( !curl_strnequal(&L_str_15[(_DWORD)v48 - 134228864], i, 7) )
        {
          if ( curl_strnequal(&L_str_16[(_DWORD)v48 - 134228864], i, 7) )
          {
            v15 = (const char *)v126;
            if ( v49 > 0x7F || *(_QWORD *)(v130 + 24) )
              goto LABEL_147;
            memcpy(dest, s1, v49);
            *((_BYTE *)dest + v49) = 0;
            v53 = Curl_getdate_capped(dest);
            *(_QWORD *)(v130 + 24) = v53;
            if ( v53 )
            {
              v15 = (const char *)v126;
              if ( v53 < 0 )
              {
                *(_DWORD *)(v130 + 28) = 0;
                *(_DWORD *)(v130 + 24) = 0;
              }
              goto LABEL_147;
            }
            *(_DWORD *)(v130 + 28) = 0;
            *(_DWORD *)(v130 + 24) = 1;
          }
          v15 = (const char *)v126;
          goto LABEL_147;
        }
        v50 = s1 + 1;
        if ( *s1 != 34 )
          v50 = s1;
        v51 = curlx_strtoofft(v50, 0, 10, v150);
        v12 = v48;
        if ( v51 )
        {
          if ( v51 != 2 )
          {
            v15 = (const char *)v126;
            if ( v51 == 1 )
            {
              *v150 = -1;
              v150[1] = 0x7FFFFFFF;
            }
            goto LABEL_148;
          }
        }
        else
        {
          v54 = *v150;
          v55 = v150[1];
          if ( *(_QWORD *)v150 )
          {
            LODWORD(v149) = ~v148;
            HIDWORD(v149) = 0x7FFFFFFF - (v148 >> 31);
            if ( v149 >= __SPAIR64__(v55, v54) )
            {
              *(_QWORD *)v150 = v148 + __PAIR64__(v55, v54);
            }
            else
            {
              *v150 = -1;
              v150[1] = 0x7FFFFFFF;
            }
            v15 = (const char *)v126;
            goto LABEL_148;
          }
        }
        v150[1] = 0;
        *v150 = 1;
        v15 = (const char *)v126;
        goto LABEL_148;
      }
      if ( v18 != (char **)6 )
      {
        if ( v18 != (char **)4 )
          goto LABEL_122;
        v36 = v12;
        v37 = (char **)v27;
        if ( !curl_strnequal(&L_str_10[(_DWORD)v36 - 134228864], i, 4) )
        {
          v15 = (const char *)v126;
          v12 = v36;
          goto LABEL_122;
        }
        strstore(v37, v117, (size_t)v120);
        v31 = 6;
        if ( !*v152 )
        {
          v131 = 1;
          v11 = v130;
          v15 = (const char *)v126;
          v12 = v36;
          goto LABEL_149;
        }
        v11 = v130;
        (**(void (__cdecl ***)(_DWORD))((char *)v36 + (_DWORD)(&Curl_cfree_ptr - 33557216)))(*(_DWORD *)(v130 + 16));
        v38 = sanitize_cookie_path(*(const char **)(v130 + 12));
        v31 = 6;
        *(_DWORD *)(v130 + 16) = v38;
        v15 = (const char *)v126;
        v12 = v36;
        if ( v38 )
          goto LABEL_148;
LABEL_75:
        v131 = 1;
        goto LABEL_149;
      }
      v113 = &L_str_11[(_DWORD)v12 - 134228864];
      v40 = v27;
      v41 = curl_strnequal(v113, i, 6);
      if ( !v40 || !v41 )
      {
        v15 = (const char *)v126;
        v12 = &GLOBAL_OFFSET_TABLE_;
        goto LABEL_122;
      }
      v42 = s1 + 1;
      if ( *s1 != 46 )
        v42 = s1;
      v43 = (char **)(v40 - (*s1 == 46));
      v44 = domain;
      if ( bad_domain((const char *)v123, v124) )
        v44 = ":";
      v45 = v42;
      if ( v44 )
        v45 = v44;
      delima = Curl_host_is_ipnum(v45);
      domain = v44;
      if ( v44 )
      {
        if ( delima )
        {
          if ( strncmp(v42, v44, (size_t)v43) || v43 != (char **)strlen(v44) )
          {
LABEL_130:
            v31 = 0;
            v131 = 1;
            v11 = v130;
            v15 = (const char *)v126;
            if ( data )
            {
              v12 = &GLOBAL_OFFSET_TABLE_;
              if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
              {
                Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v42, v122);
                v31 = 0;
                v15 = (const char *)v126;
              }
LABEL_136:
              if ( !v31 )
                goto LABEL_148;
              goto LABEL_149;
            }
LABEL_135:
            v12 = &GLOBAL_OFFSET_TABLE_;
            goto LABEL_136;
          }
        }
        else if ( !cookie_tailmatch(v44, (size_t)v119, v120) )
        {
          goto LABEL_130;
        }
      }
      strstore(v43, v119, (size_t)v120);
      v46 = v131;
      if ( !*v151 )
        v46 = 1;
      v47 = 0;
      if ( !*v151 )
        v47 = 6;
      v11 = v130;
      if ( (*v151 == 0) | delima )
      {
        v31 = v47;
        v131 = v46;
      }
      else
      {
        *(_BYTE *)(v130 + 32) = 1;
        v31 = 0;
      }
      v15 = (const char *)v126;
      goto LABEL_135;
    }
    if ( v18 != (char **)6 )
      goto LABEL_121;
    if ( !curl_strnequal(&L_str_8[(_DWORD)v12 - 134228864], i, 6) )
    {
      v15 = (const char *)v126;
      v27 = 0;
      v12 = &GLOBAL_OFFSET_TABLE_;
      goto LABEL_121;
    }
    v15 = (const char *)v126;
    if ( !secure && c->running )
    {
      v31 = 6;
      v131 = 1;
      v11 = v130;
      v12 = &GLOBAL_OFFSET_TABLE_;
      goto LABEL_149;
    }
    v11 = v130;
    *(_BYTE *)(v130 + 33) = 1;
LABEL_147:
    v12 = &GLOBAL_OFFSET_TABLE_;
LABEL_148:
    v31 = 0;
LABEL_149:
    i = v15;
    if ( !v31 )
    {
LABEL_152:
      while ( 1 )
      {
        v56 = *i;
        if ( *i != 32 && v56 != 9 )
          break;
        ++i;
      }
      v15 = i + 1;
      v31 = 6;
      if ( v56 == 59 )
        v31 = 0;
      else
        v15 = i;
    }
    if ( !v31 )
      continue;
    break;
  }
  if ( v31 != 6 )
  {
    v9 = 0;
    goto LABEL_235;
  }
  v9 = 0;
  if ( (v131 & 1) == 0 && domain && !*(_DWORD *)(v11 + 20) )
  {
    v57 = (**(int (__cdecl ***)(const char *))((char *)v12 + (_DWORD)(&Curl_cstrdup_ptr - 33557216)))(domain);
    *(_DWORD *)(v11 + 20) = v57;
    v58 = 1;
    if ( v57 )
      v58 = v131;
    v131 = v58;
  }
  if ( (v131 & 1) == 0 && path && !*(_DWORD *)(v11 + 12) )
  {
    v59 = strchr(path, 63);
    if ( v59 )
      v60 = (char *)Curl_memrchr(path, 47, v59 - path);
    else
      v60 = strrchr(path, 47);
    if ( v60 )
    {
      v79 = v60 - path;
      v80 = (void *)(**(int (__cdecl ***)(int))((char *)v12 + (_DWORD)(&Curl_cmalloc_ptr - 33557216)))(v60 - path + 2);
      *(_DWORD *)(v11 + 12) = v80;
      if ( v80 )
      {
        v81 = v79 + 1;
        memcpy(v80, path, v81);
        *(_BYTE *)(*(_DWORD *)(v11 + 12) + v81) = 0;
        v82 = sanitize_cookie_path(*(const char **)(v11 + 12));
        *(_DWORD *)(v11 + 16) = v82;
        v83 = 1;
        if ( v82 )
          v83 = v131;
        v131 = v83;
      }
      else
      {
        v131 = 1;
      }
    }
    v9 = 0;
  }
  if ( (v131 & 1) == 0 && *(_DWORD *)(v11 + 4) )
  {
    ++data->req.setcookies;
    v31 = 0;
    goto LABEL_235;
  }
  freecookie(v123);
LABEL_234:
  v31 = 1;
LABEL_235:
  if ( !v31 )
  {
LABEL_236:
    v84 = *(_BYTE *)(v11 + 40);
    if ( (v84 & 1) != 0 && !*(_BYTE *)(v11 + 33)
      || (v84 & 2) != 0
      && (!*(_BYTE *)(v11 + 33)
       || (v105 = *(const char **)(v11 + 12)) == 0
       || strcmp(v105, &L_str_21[(_DWORD)v12 - 134228864])
       || *(_BYTE *)(v11 + 32))
      || !(running = c->running) && c->newsession && !*(_QWORD *)(v11 + 24) )
    {
      freecookie(v123);
      return (Cookie *)v9;
    }
    *(_BYTE *)(v11 + 34) = running;
    v86 = c->lastct + 1;
    c->lastct = v86;
    *(_DWORD *)(v11 + 36) = v86;
    if ( !noexpire )
      remove_expired((CookieInfo *)v123);
    v146 = cookiehash(*(const char *const *)(v11 + 20));
    v87 = c->cookies[v146];
    if ( v87 )
    {
      v129 = 0;
      strc = 0;
      delimb = 0;
      while ( 1 )
      {
        v88 = curl_strequal(v87->name, *(_DWORD *)(v11 + 4));
        v89 = v87;
        if ( !v88 )
          goto LABEL_270;
        v90 = v87->domain;
        if ( v90 )
        {
          if ( !*(_DWORD *)(v130 + 20) )
            goto LABEL_268;
          v91 = curl_strequal(v90, *(_DWORD *)(v130 + 20));
          v89 = v87;
          if ( !v91 )
            goto LABEL_268;
        }
        else if ( *(_DWORD *)(v130 + 20) )
        {
          goto LABEL_268;
        }
        v92 = (const char *)*((_DWORD *)v89 + 4);
        if ( !v92 )
          goto LABEL_268;
        v93 = *(_DWORD *)(v130 + 16);
        if ( !v93 || !*((_BYTE *)v89 + 33) || *(_BYTE *)(v130 + 33) || secure )
          goto LABEL_268;
        s1b = (char *)v89;
        v94 = strchr(v92 + 1, 47);
        v95 = v94 ? v94 - v92 : strlen(v92);
        if ( curl_strnequal(v92, v93, v95) )
        {
          if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
            Curl_infof(
              data,
              "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
              *(_DWORD *)(v130 + 4),
              *(_DWORD *)(v130 + 20));
          freecookie(v123);
          v96 = 1;
        }
        else
        {
          v96 = 0;
        }
        v89 = s1b;
        if ( !v96 )
LABEL_268:
          v96 = 0;
        v11 = v130;
        if ( v96 )
          return 0;
LABEL_270:
        if ( v129 )
          goto LABEL_245;
        v97 = v89;
        if ( !curl_strequal(*((_DWORD *)v89 + 1), *(_DWORD *)(v11 + 4)) )
        {
          v129 = 0;
          v89 = v97;
          goto LABEL_245;
        }
        v98 = *((_DWORD *)v97 + 5);
        v89 = v97;
        if ( !v98 )
        {
          v99 = *(_DWORD *)(v11 + 20) == 0;
LABEL_280:
          v100 = (unsigned __int8)delimb;
          if ( v99 )
            v100 = 1;
          if ( (v100 & 1) == 0 )
            goto LABEL_288;
LABEL_283:
          delimc = v100;
          v101 = *((_DWORD *)v89 + 4);
          if ( v101
            && *(_DWORD *)(v11 + 16)
            && (v102 = v89, v103 = curl_strequal(v101, *(_DWORD *)(v11 + 16)), v89 = v102, !v103) )
          {
            v100 = 0;
          }
          else
          {
            v100 = delimc;
            if ( (*((_DWORD *)v89 + 4) == 0) != (*(_DWORD *)(v11 + 16) == 0) )
              v100 = 0;
          }
          goto LABEL_288;
        }
        if ( *(_DWORD *)(v11 + 20) )
        {
          if ( curl_strequal(v98, *(_DWORD *)(v11 + 20)) )
          {
            v89 = v97;
            v99 = *((_BYTE *)v97 + 32) == *(_BYTE *)(v11 + 32);
            goto LABEL_280;
          }
          v100 = (int)delimb;
          v89 = v97;
          if ( ((unsigned __int8)delimb & 1) != 0 )
            goto LABEL_283;
        }
        else
        {
          v100 = (int)delimb;
          if ( ((unsigned __int8)delimb & 1) != 0 )
            goto LABEL_283;
        }
LABEL_288:
        if ( (v100 & 1) != 0 && !*(_BYTE *)(v11 + 34) && *((_BYTE *)v89 + 34) )
          goto LABEL_221;
        delimb = (char *)v100;
        v68 = (v100 & 1) == 0;
        v104 = (char **)v89;
        v129 = v11;
        if ( v68 )
        {
          v129 = 0;
          v104 = strc;
        }
        strc = v104;
LABEL_245:
        v87 = *(Cookie **)v89;
        if ( !*(_DWORD *)v89 )
          goto LABEL_306;
      }
    }
    LOBYTE(delimb) = 0;
    strc = 0;
    v129 = 0;
    v89 = 0;
LABEL_306:
    if ( v129 )
    {
      *(_DWORD *)v129 = *strc;
      *(_DWORD *)(v129 + 36) = strc[9];
      s1c = (char *)v89;
      Curl_cfree(strc[1]);
      Curl_cfree(strc[2]);
      Curl_cfree(strc[5]);
      Curl_cfree(strc[3]);
      Curl_cfree(strc[4]);
      strc[10] = *(char **)(v129 + 40);
      *((_QWORD *)strc + 4) = *(_QWORD *)(v129 + 32);
      *((_QWORD *)strc + 3) = *(_QWORD *)(v129 + 24);
      *((_QWORD *)strc + 2) = *(_QWORD *)(v129 + 16);
      v107 = *(_QWORD *)v129;
      *((_QWORD *)strc + 1) = *(_QWORD *)(v129 + 8);
      *(_QWORD *)strc = v107;
      Curl_cfree(v129);
      v89 = s1c;
      v9 = strc;
    }
    else
    {
      v9 = (char **)v11;
    }
    if ( data && c->running && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
    {
      v108 = "Replaced";
      if ( ((unsigned __int8)delimb & 1) == 0 )
        v108 = "Added";
      v109 = v89;
      Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v108, v9[1]);
      v89 = v109;
    }
    if ( ((unsigned __int8)delimb & 1) == 0 )
    {
      v110 = &c->cookies[v146];
      if ( v89 )
        v110 = (Cookie **)v89;
      *v110 = (Cookie *)v9;
      ++c->numcookies;
    }
    LODWORD(v111) = v9[6];
    v112 = v9[7];
    if ( *((_QWORD *)v9 + 3) )
    {
      HIDWORD(v111) = v9[7];
      if ( v111 < c->next_expiration )
      {
        LODWORD(c->next_expiration) = v111;
        HIDWORD(c->next_expiration) = v112;
      }
    }
  }
  return (Cookie *)v9;
}
