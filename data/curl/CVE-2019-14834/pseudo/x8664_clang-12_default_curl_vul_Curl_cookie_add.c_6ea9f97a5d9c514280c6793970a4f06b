Cookie *__fastcall Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  __int64 v10; // r12
  time_t v11; // rax
  __int64 v12; // r14
  __int64 v13; // rax
  __int64 v14; // rbx
  const char *v15; // r12
  char *i; // rbx
  char v17; // r15
  size_t v18; // rax
  size_t v19; // rdx
  unsigned __int64 v20; // rbp
  char v21; // al
  size_t v22; // r14
  size_t v23; // r14
  size_t v24; // rax
  size_t v25; // rdx
  size_t v26; // r13
  size_t v27; // r14
  const char *v28; // rax
  char v29; // cl
  const char *v30; // r12
  __int64 j; // rcx
  char v32; // dl
  _QWORD *v33; // r15
  __int64 v34; // rax
  const char *v35; // rax
  _BYTE *v36; // rbx
  size_t v37; // rax
  size_t v38; // rbp
  __int64 v39; // rax
  __int64 v40; // rax
  const char *v41; // rbx
  __int64 v42; // rbp
  char v43; // al
  __int64 v44; // rdi
  int v45; // eax
  int v46; // eax
  const char *v47; // rbx
  size_t v48; // r14
  _BYTE *v49; // rax
  const char *v50; // rdi
  char is_ipnum; // r12
  const char *v52; // rbp
  size_t v53; // rax
  size_t v54; // r12
  const char *v55; // r15
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // rax
  __int64 v59; // rax
  char v60; // cl
  __int64 v61; // rax
  char *v62; // rax
  char *v63; // rax
  char *v64; // rax
  const char *v65; // rbp
  int v66; // r15d
  char v67; // r14
  __int64 v68; // rax
  __int64 v69; // rax
  const char *v70; // rax
  _BYTE *v71; // rbp
  size_t v72; // rax
  size_t v73; // rbx
  __int64 v74; // rax
  __int64 v75; // rax
  __int64 v76; // rbx
  __int64 v77; // rax
  __int64 v78; // rax
  char v79; // al
  char *v80; // rax
  __int64 v81; // rax
  _BOOL4 v82; // r15d
  char v83; // al
  char v84; // r14
  __int64 v85; // rbx
  const char *v86; // rbp
  __int64 v87; // rax
  char *v88; // rax
  char *v89; // rax
  signed __int64 v90; // rbx
  void *v91; // rax
  size_t v92; // rbx
  const char *v93; // rax
  _BYTE *v94; // rbx
  size_t v95; // rax
  size_t v96; // rbp
  __int64 v97; // rax
  char v98; // al
  char v99; // al
  bool running; // al
  int v101; // eax
  time_t v102; // rax
  CookieInfo *v103; // rcx
  time_t v104; // r15
  curl_off_t next_expiration; // rax
  size_t v106; // rax
  CookieInfo *v107; // rcx
  size_t v108; // rbp
  Cookie *next; // rax
  __int64 v110; // r13
  Cookie *v111; // r14
  char *v112; // rdi
  __int64 v113; // rsi
  const char *spath; // r15
  __int64 v115; // rbx
  char *v116; // rax
  size_t v117; // rax
  char *v118; // rdi
  __int64 v119; // rsi
  __int64 v120; // rbx
  bool v121; // zf
  char *v122; // rdi
  __int64 v123; // rsi
  _QWORD *v124; // rdi
  const char *v125; // rdi
  __int128 v126; // xmm0
  __int128 v127; // xmm1
  __int128 v128; // xmm2
  char v130; // r15
  char *v131; // rax
  Cookie *v132; // rbx
  Cookie **v133; // r13
  Cookie *v134; // r14
  Cookie *v135; // rbp
  curl_off_t expires; // rax
  Cookie **p_next; // rax
  const char *v138; // rdx
  Cookie **v139; // rax
  curl_off_t v140; // rax
  __int64 v141; // [rsp+8h] [rbp-110h]
  _BYTE v142[9]; // [rsp+17h] [rbp-101h]
  void *s; // [rsp+18h] [rbp-100h]
  void *sa; // [rsp+18h] [rbp-100h]
  char *sb; // [rsp+18h] [rbp-100h]
  char v148; // [rsp+34h] [rbp-E4h]
  __int64 *v151; // [rsp+48h] [rbp-D0h]
  __int64 v152; // [rsp+50h] [rbp-C8h]
  __int64 v153; // [rsp+58h] [rbp-C0h]
  char *dest[23]; // [rsp+60h] [rbp-B8h] BYREF

  v10 = 0LL;
  v11 = time(0LL);
  if ( data->req.setcookies > 0x31u )
    return (Cookie *)v10;
  v12 = v11;
  v13 = Curl_ccalloc(1LL, 72LL);
  if ( !v13 )
    return 0LL;
  v14 = v13;
  v141 = v13;
  if ( httpheader )
  {
    if ( strlen(lineptr) <= 0x1388 )
    {
      v151 = (__int64 *)(v14 + 48);
      v152 = 0x7FFFFFFFFFFFFFFFLL - v12;
      v148 = 0;
      v153 = v12;
      while ( 1 )
      {
        v15 = lineptr + 1;
        for ( i = lineptr; ; ++i )
        {
          v17 = *i;
          if ( *i != 32 && v17 != 9 )
            break;
          ++v15;
        }
        v18 = strcspn(i, ";\t\r\n=");
        if ( v18 )
        {
          v19 = v18;
          lineptr = &i[v18];
          v20 = v18;
          while ( 1 )
          {
            v21 = i[v20 - 1];
            if ( v21 != 32 && v21 != 9 )
              break;
            if ( !--v20 )
            {
              v20 = 0LL;
              break;
            }
          }
          v22 = 0LL;
          v142[8] = 0;
          *(_QWORD *)v142 = (unsigned __int8)*lineptr;
          if ( v142[0] == 61 )
          {
            *(_QWORD *)&v142[1] = &i[v19 + 1];
            v23 = v19;
            v24 = strcspn(*(const char **)&v142[1], ";\r\n");
            v25 = v23;
            v26 = v23 + v24;
            if ( v24 )
            {
              v27 = v24;
              v28 = &v15[v26];
              while ( 1 )
              {
                v29 = *(v28 - 1);
                if ( v29 != 32 && v29 != 9 )
                  break;
                --v27;
                --v28;
                if ( !v27 )
                  goto LABEL_29;
              }
              v30 = &v15[v25];
              for ( j = 0LL; j != v27; ++j )
              {
                v32 = v30[j];
                if ( v32 != 32 && v32 != 9 )
                {
                  v22 = v27 - j;
                  *(_QWORD *)&v142[1] = &v30[j];
                  goto LABEL_30;
                }
              }
              v22 = 0LL;
              *(_QWORD *)&v142[1] = v28;
            }
            else
            {
LABEL_29:
              v22 = 0LL;
            }
LABEL_30:
            if ( memchr(*(const void **)&v142[1], 9, v22) )
            {
              Curl_cfree(*(_QWORD *)(v141 + 40));
              Curl_cfree(*(_QWORD *)(v141 + 24));
              Curl_cfree(*(_QWORD *)(v141 + 32));
              Curl_cfree(*(_QWORD *)(v141 + 8));
              Curl_cfree(*(_QWORD *)(v141 + 16));
              Curl_cfree(v141);
              if ( (*((_BYTE *)&data->set + 2238) & 0x10) != 0 )
              {
                v10 = 0LL;
                Curl_infof(data, "cookie contains TAB, dropping");
                return (Cookie *)v10;
              }
              return 0LL;
            }
            lineptr = &i[v26 + 1];
          }
          if ( v20 > 0xFFE || v22 > 0xFFE || v22 + v20 >= 0x1001 )
          {
            Curl_cfree(*(_QWORD *)(v141 + 40));
            Curl_cfree(*(_QWORD *)(v141 + 24));
            Curl_cfree(*(_QWORD *)(v141 + 32));
            Curl_cfree(*(_QWORD *)(v141 + 8));
            Curl_cfree(*(_QWORD *)(v141 + 16));
            Curl_cfree(v141);
            if ( (*((_BYTE *)&data->set + 2238) & 0x10) != 0 )
            {
              v10 = 0LL;
              Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v20, v22);
              return (Cookie *)v10;
            }
            return 0LL;
          }
          if ( v17 == 95 && v20 >= 7 && i[1] == 95 )
          {
            if ( (unsigned int)curl_strnequal("__Secure-", i, 9LL) )
            {
              *(_BYTE *)(v141 + 64) |= 1u;
            }
            else if ( (unsigned int)curl_strnequal("__Host-", i, 7LL) )
            {
              *(_BYTE *)(v141 + 64) |= 2u;
            }
          }
          if ( !*(_QWORD *)(v141 + 8) )
          {
            v33 = (_QWORD *)v141;
            if ( v142[0] != 61 )
              goto LABEL_301;
            Curl_cfree(0LL);
            v39 = Curl_memdup(i, v20 + 1);
            *(_QWORD *)(v141 + 8) = v39;
            if ( v39 )
              *(_BYTE *)(v39 + v20) = 0;
            Curl_cfree(*(_QWORD *)(v141 + 16));
            v40 = Curl_memdup(*(_QWORD *)&v142[1], v22 + 1);
            *(_QWORD *)(v141 + 16) = v40;
            if ( v40 )
              *(_BYTE *)(v40 + v22) = 0;
            v41 = *(const char **)(v141 + 8);
            if ( !v41 )
              goto LABEL_301;
            v42 = *(_QWORD *)(v141 + 16);
            if ( !v42 )
              goto LABEL_301;
            if ( *(_BYTE *)(v42 + strcspn(*(const char **)(v141 + 16), &invalid_octets_badoctets))
              || v41[strcspn(v41, &invalid_octets_badoctets)] )
            {
              v33 = (_QWORD *)v141;
              if ( (*((_BYTE *)&data->set + 2238) & 0x10) != 0 )
                Curl_infof(data, "invalid octets in name/value, cookie dropped");
              goto LABEL_301;
            }
            goto LABEL_69;
          }
          if ( !v22 )
          {
            if ( v20 == 8 )
            {
              if ( (unsigned int)curl_strnequal("httponly", i, 8LL) )
              {
                *(_BYTE *)(v141 + 59) = 1;
                goto LABEL_69;
              }
            }
            else if ( v20 == 6 && (unsigned int)curl_strnequal("secure", i, 6LL) )
            {
              v33 = (_QWORD *)v141;
              if ( !secure && c->running )
                goto LABEL_301;
              *(_BYTE *)(v141 + 57) = 1;
              goto LABEL_69;
            }
            if ( v142[0] != 61 )
              goto LABEL_69;
          }
          if ( v20 == 7 )
          {
            if ( !(unsigned int)curl_strnequal("version", i, 7LL) )
            {
              if ( !(unsigned int)curl_strnequal("max-age", i, 7LL) )
              {
                if ( (unsigned int)curl_strnequal("expires", i, 7LL) && v22 <= 0x7F && !*v151 )
                {
                  memcpy(dest, *(const void **)&v142[1], v22);
                  *((_BYTE *)dest + v22) = 0;
                  v57 = Curl_getdate_capped(dest);
                  *v151 = v57;
                  if ( v57 )
                  {
                    if ( v57 < 0 )
                      *v151 = 0LL;
                  }
                  else
                  {
                    *v151 = 1LL;
                  }
                }
                goto LABEL_69;
              }
              v44 = *(_QWORD *)&v142[1] + 1LL;
              if ( **(_BYTE **)&v142[1] != 34 )
                v44 = *(_QWORD *)&v142[1];
              v45 = curlx_strtoofft(v44, 0LL, 10LL, v151);
              switch ( v45 )
              {
                case 0:
                  v61 = *v151;
                  if ( !*v151 )
                  {
                    *v151 = 1LL;
                    goto LABEL_69;
                  }
                  if ( v152 >= v61 )
                  {
                    *v151 = v153 + v61;
                    goto LABEL_69;
                  }
LABEL_134:
                  *v151 = 0x7FFFFFFFFFFFFFFFLL;
                  goto LABEL_69;
                case 2:
                  *v151 = 1LL;
                  goto LABEL_69;
                case 1:
                  goto LABEL_134;
              }
            }
          }
          else if ( v20 == 6 )
          {
            v46 = curl_strnequal("domain", i, 6LL);
            if ( v22 && v46 )
            {
              v47 = (const char *)(*(_QWORD *)&v142[1] + 1LL);
              if ( **(_BYTE **)&v142[1] != 46 )
                v47 = *(const char **)&v142[1];
              v48 = v22 - (**(_BYTE **)&v142[1] == 46);
              if ( v48 == 9 && (unsigned int)curl_strnequal(v47, "localhost", 9LL)
                || (v49 = memchr(v47, 46, v48)) != 0LL && (unsigned __int64)(&v47[v48] - v49) > 1 )
              {
                v50 = domain;
                if ( !domain )
                  v50 = v47;
                is_ipnum = Curl_host_is_ipnum(v50);
                if ( !domain )
                {
                  domain = 0LL;
LABEL_125:
                  v33 = (_QWORD *)v141;
                  Curl_cfree(*(_QWORD *)(v141 + 40));
                  v58 = Curl_memdup(v47, v48 + 1);
                  *(_QWORD *)(v141 + 40) = v58;
                  if ( !v58 )
                    goto LABEL_301;
                  *(_BYTE *)(v58 + v48) = 0;
                  v59 = *(_QWORD *)(v141 + 40);
                  v60 = v148;
                  if ( !v59 )
                    v60 = 1;
                  if ( (v59 == 0) | (unsigned __int8)is_ipnum )
                  {
                    v148 = v60;
                    if ( !v59 )
                      goto LABEL_207;
                  }
                  else
                  {
                    *(_BYTE *)(v141 + 56) = 1;
                  }
                  goto LABEL_69;
                }
                v52 = domain;
                if ( !is_ipnum )
                {
LABEL_99:
                  v53 = strlen(v52);
                  domain = v52;
                  if ( v53 >= v48 )
                  {
                    v54 = v53;
                    v55 = &v52[v53 - v48];
                    if ( (unsigned int)curl_strnequal(v47, v55, v48) )
                    {
                      if ( v54 == v48 || *(v55 - 1) == 46 )
                      {
                        is_ipnum = 0;
                        goto LABEL_125;
                      }
                    }
                  }
                  goto LABEL_112;
                }
              }
              else
              {
                v52 = ":";
                if ( !(unsigned __int8)Curl_host_is_ipnum(":") )
                  goto LABEL_99;
              }
              domain = v52;
              if ( !strncmp(v47, v52, v48) )
              {
                is_ipnum = 1;
                if ( v48 == strlen(v52) )
                  goto LABEL_125;
              }
LABEL_112:
              v148 = 1;
              if ( (*((_BYTE *)&data->set + 2238) & 0x10) != 0 )
                Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v47);
              goto LABEL_69;
            }
          }
          else if ( v20 == 4 && (unsigned int)curl_strnequal("path", i, 4LL) )
          {
            v33 = (_QWORD *)v141;
            Curl_cfree(*(_QWORD *)(v141 + 24));
            v34 = Curl_memdup(*(_QWORD *)&v142[1], v22 + 1);
            *(_QWORD *)(v141 + 24) = v34;
            if ( !v34 )
              goto LABEL_301;
            *(_BYTE *)(v34 + v22) = 0;
            if ( !*(_QWORD *)(v141 + 24) )
              goto LABEL_301;
            Curl_cfree(*(_QWORD *)(v141 + 32));
            v35 = (const char *)Curl_cstrdup(*(_QWORD *)(v141 + 24));
            if ( !v35 )
              goto LABEL_238;
            v36 = v35;
            v37 = strlen(v35);
            v38 = v37;
            if ( *v36 == 34 )
            {
              memmove(v36, v36 + 1, v37);
              --v38;
            }
            if ( v38 )
            {
              if ( v36[v38 - 1] == 34 )
                v36[--v38] = 0;
              if ( *v36 == 47 )
              {
                if ( v38 && v36[v38 - 1] == 47 )
                  v36[v38 - 1] = 0;
                goto LABEL_117;
              }
            }
            else if ( *v36 == 47 )
            {
LABEL_117:
              *(_QWORD *)(v141 + 32) = v36;
              goto LABEL_69;
            }
            Curl_cfree(v36);
            v56 = Curl_memdup("/", 2LL);
            if ( !v56 )
            {
LABEL_238:
              v33 = (_QWORD *)v141;
              *(_QWORD *)(v141 + 32) = 0LL;
              goto LABEL_301;
            }
            v36 = (_BYTE *)v56;
            *(_BYTE *)(v56 + 1) = 0;
            goto LABEL_117;
          }
        }
        else
        {
          lineptr = i;
        }
        do
        {
          do
LABEL_69:
            v43 = *lineptr++;
          while ( v43 == 32 );
        }
        while ( v43 == 9 );
        if ( v43 != 59 )
        {
LABEL_207:
          v84 = v148;
          if ( (v148 & 1) != 0 )
          {
            v85 = v141;
            v86 = path;
          }
          else
          {
            v85 = v141;
            v86 = path;
            if ( domain )
            {
              if ( !*(_QWORD *)(v141 + 40) )
              {
                v87 = Curl_cstrdup(domain);
                *(_QWORD *)(v141 + 40) = v87;
                v84 = 1;
                if ( v87 )
                  v84 = v148;
              }
            }
          }
          if ( (v84 & 1) != 0 || !v86 || *(_QWORD *)(v85 + 24) )
            goto LABEL_245;
          v88 = strchr(v86, 63);
          v89 = v88 ? (char *)Curl_memrchr(v86, 47LL, v88 - v86) : strrchr(v86, 47);
          if ( !v89 )
            goto LABEL_245;
          v90 = v89 - v86;
          v91 = (void *)Curl_cmalloc(v89 - v86 + 2);
          v33 = (_QWORD *)v141;
          *(_QWORD *)(v141 + 24) = v91;
          if ( !v91 )
            goto LABEL_301;
          v92 = v90 + 1;
          memcpy(v91, path, v92);
          *(_BYTE *)(*(_QWORD *)(v141 + 24) + v92) = 0;
          v93 = (const char *)Curl_cstrdup(*(_QWORD *)(v141 + 24));
          if ( v93 )
          {
            v94 = v93;
            v95 = strlen(v93);
            v96 = v95;
            if ( *v94 == 34 )
            {
              memmove(v94, v94 + 1, v95);
              --v96;
            }
            if ( v96 )
            {
              if ( v94[v96 - 1] == 34 )
                v94[--v96] = 0;
              if ( *v94 == 47 )
              {
                if ( v96 && v94[v96 - 1] == 47 )
                  v94[v96 - 1] = 0;
LABEL_243:
                *(_QWORD *)(v141 + 32) = v94;
                v98 = v84;
                v84 = 1;
                if ( v94 )
                  v84 = v98;
LABEL_245:
                v33 = (_QWORD *)v141;
                if ( (v84 & 1) == 0 && *(_QWORD *)(v141 + 8) )
                {
                  ++data->req.setcookies;
                  v14 = v141;
                  goto LABEL_248;
                }
LABEL_301:
                Curl_cfree(v33[5]);
                Curl_cfree(v33[3]);
                Curl_cfree(v33[4]);
                Curl_cfree(v33[1]);
                Curl_cfree(v33[2]);
                v124 = v33;
LABEL_302:
                Curl_cfree(v124);
                return 0LL;
              }
            }
            else if ( *v94 == 47 )
            {
              goto LABEL_243;
            }
            Curl_cfree(v94);
            v97 = Curl_memdup("/", 2LL);
            if ( v97 )
            {
              v94 = (_BYTE *)v97;
              *(_BYTE *)(v97 + 1) = 0;
              goto LABEL_243;
            }
          }
          v94 = 0LL;
          goto LABEL_243;
        }
      }
    }
LABEL_141:
    Curl_cfree(v14);
    return 0LL;
  }
  dest[0] = 0LL;
  if ( !strncmp(lineptr, "#HttpOnly_", 0xAuLL) )
  {
    lineptr += 10;
    *(_BYTE *)(v14 + 59) = 1;
    if ( *lineptr == 35 )
      goto LABEL_141;
  }
  else if ( *lineptr == 35 )
  {
    goto LABEL_141;
  }
  v62 = strchr(lineptr, 13);
  if ( v62 )
    *v62 = 0;
  v63 = strchr(lineptr, 10);
  if ( v63 )
    *v63 = 0;
  v64 = strtok_r(lineptr, "\t", dest);
  if ( !v64 )
    goto LABEL_312;
  v65 = v64;
  s = (void *)(v14 + 48);
  v66 = 0;
  v67 = 0;
  while ( 2 )
  {
    switch ( v66 )
    {
      case 0:
        if ( *v65 == 46 )
          ++v65;
        v68 = Curl_cstrdup(v65);
        *(_QWORD *)(v14 + 40) = v68;
        if ( !v68 )
          v67 = 1;
        v66 = 0;
        goto LABEL_198;
      case 1:
        *(_BYTE *)(v14 + 56) = (unsigned int)curl_strequal(v65, "TRUE") != 0;
        v66 = 1;
        goto LABEL_198;
      case 2:
        if ( !strcmp("TRUE", v65) || !strcmp("FALSE", v65) )
        {
          v76 = Curl_cstrdup("/");
          *(_QWORD *)(v141 + 24) = v76;
          v77 = Curl_cstrdup("/");
          if ( !v77 )
            v67 = 1;
          v121 = v76 == 0;
          v14 = v141;
          *(_QWORD *)(v141 + 32) = v77;
          if ( v121 )
            v67 = 1;
          goto LABEL_182;
        }
        v69 = Curl_cstrdup(v65);
        *(_QWORD *)(v14 + 24) = v69;
        v66 = 2;
        if ( !v69 )
          goto LABEL_186;
        v70 = (const char *)Curl_cstrdup(v69);
        if ( !v70 )
        {
          v71 = 0LL;
          goto LABEL_195;
        }
        v71 = v70;
        v72 = strlen(v70);
        v73 = v72;
        if ( *v71 == 34 )
        {
          memmove(v71, v71 + 1, v72);
          --v73;
        }
        if ( !v73 )
        {
          if ( *v71 == 47 )
            goto LABEL_194;
LABEL_191:
          Curl_cfree(v71);
          v78 = Curl_memdup("/", 2LL);
          if ( v78 )
          {
            v71 = (_BYTE *)v78;
            *(_BYTE *)(v78 + 1) = 0;
          }
          else
          {
            v71 = 0LL;
          }
          goto LABEL_194;
        }
        if ( v71[v73 - 1] == 34 )
          v71[--v73] = 0;
        if ( *v71 != 47 )
          goto LABEL_191;
        if ( v73 && v71[v73 - 1] == 47 )
          v71[v73 - 1] = 0;
LABEL_194:
        v14 = v141;
LABEL_195:
        *(_QWORD *)(v14 + 32) = v71;
        v79 = 1;
        if ( v71 )
          v79 = v67;
        v67 = v79;
LABEL_198:
        v80 = strtok_r(0LL, "\t", dest);
        ++v66;
        if ( v80 )
        {
          v65 = v80;
          if ( (v67 & 1) == 0 )
            continue;
        }
        if ( v66 == 6 )
        {
          v81 = Curl_cstrdup(&L_str_22);
          *(_QWORD *)(v14 + 16) = v81;
          v121 = v81 == 0;
          v82 = v81 == 0;
          v83 = v67;
          v67 = 1;
          if ( !v121 )
            v67 = v83;
          v66 = v82 ^ 7;
        }
        if ( (v67 & 1) != 0 || v66 != 7 )
          goto LABEL_312;
LABEL_248:
        v99 = *(_BYTE *)(v14 + 64);
        if ( (v99 & 1) != 0 && !*(_BYTE *)(v14 + 57)
          || (v99 & 2) != 0
          && (!*(_BYTE *)(v14 + 57)
           || (v125 = *(const char **)(v14 + 24)) == 0LL
           || strcmp(v125, "/")
           || *(_BYTE *)(v14 + 56))
          || !(running = c->running) && c->newsession && !*(_QWORD *)(v14 + 48) )
        {
LABEL_312:
          Curl_cfree(*(_QWORD *)(v14 + 40));
          Curl_cfree(*(_QWORD *)(v14 + 24));
          Curl_cfree(*(_QWORD *)(v14 + 32));
          Curl_cfree(*(_QWORD *)(v14 + 8));
          Curl_cfree(*(_QWORD *)(v14 + 16));
          Curl_cfree(v14);
          return 0LL;
        }
        *(_BYTE *)(v14 + 58) = running;
        v101 = c->lastct + 1;
        c->lastct = v101;
        *(_DWORD *)(v14 + 60) = v101;
        if ( !noexpire )
        {
          v102 = time(0LL);
          v103 = c;
          v104 = v102;
          next_expiration = c->next_expiration;
          if ( v104 >= next_expiration || next_expiration == 0x7FFFFFFFFFFFFFFFLL )
          {
            c->next_expiration = 0x7FFFFFFFFFFFFFFFLL;
            v131 = 0LL;
            do
            {
              sb = v131;
              v132 = v103->cookies[(_QWORD)v131];
              if ( v132 )
              {
                v133 = &v103->cookies[(_QWORD)v131];
                v134 = 0LL;
                do
                {
                  while ( 1 )
                  {
                    v135 = v132;
                    v132 = v132->next;
                    expires = v135->expires;
                    if ( !expires || expires >= v104 )
                      break;
                    p_next = &v134->next;
                    if ( !v134 )
                      p_next = v133;
                    *p_next = v132;
                    --v103->numcookies;
                    Curl_cfree(v135->domain);
                    Curl_cfree(v135->path);
                    Curl_cfree(v135->spath);
                    Curl_cfree(v135->name);
                    Curl_cfree(v135->value);
                    Curl_cfree(v135);
                    v103 = c;
                    if ( !v132 )
                      goto LABEL_317;
                  }
                  if ( expires && expires < v103->next_expiration )
                    v103->next_expiration = expires;
                  v134 = v135;
                }
                while ( v132 );
              }
LABEL_317:
              v131 = sb + 1;
            }
            while ( sb != (char *)&loc_3E );
          }
        }
        v10 = v141;
        v106 = cookiehash(*(const char *const *)(v141 + 40));
        v107 = c;
        v108 = v106;
        next = c->cookies[v106];
        if ( !next )
        {
          v111 = 0LL;
          v130 = 0;
          goto LABEL_332;
        }
        v110 = 0LL;
        v10 = 0LL;
        sa = 0LL;
        while ( 2 )
        {
          v111 = next;
          if ( (unsigned int)curl_strequal(next->name, *(_QWORD *)(v141 + 8)) )
          {
            v112 = v111->domain;
            v113 = *(_QWORD *)(v141 + 40);
            if ( v112 )
            {
              if ( v113 && (unsigned int)curl_strequal(v112, v113) )
              {
LABEL_264:
                spath = v111->spath;
                if ( spath )
                {
                  v115 = *(_QWORD *)(v141 + 32);
                  if ( v115 )
                  {
                    if ( v111->secure && !*(_BYTE *)(v141 + 57) && !secure )
                    {
                      v116 = strchr(spath + 1, 47);
                      v117 = v116 ? v116 - spath : strlen(spath);
                      if ( (unsigned int)curl_strnequal(spath, v115, v117) )
                      {
                        if ( data && (*((_BYTE *)&data->set + 2238) & 0x10) != 0 )
                          Curl_infof(
                            data,
                            "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                            *(const char **)(v141 + 8),
                            *(const char **)(v141 + 40));
LABEL_300:
                        Curl_cfree(*(_QWORD *)(v141 + 40));
                        Curl_cfree(*(_QWORD *)(v141 + 24));
                        Curl_cfree(*(_QWORD *)(v141 + 32));
                        Curl_cfree(*(_QWORD *)(v141 + 8));
                        Curl_cfree(*(_QWORD *)(v141 + 16));
                        v124 = (_QWORD *)v141;
                        goto LABEL_302;
                      }
                    }
                  }
                }
              }
            }
            else if ( !v113 )
            {
              goto LABEL_264;
            }
          }
          if ( !v110 )
          {
            if ( !(unsigned int)curl_strequal(v111->name, *(_QWORD *)(v141 + 8)) )
              goto LABEL_289;
            v118 = v111->domain;
            v119 = *(_QWORD *)(v141 + 40);
            if ( v118 )
            {
              v120 = (__int64)sa;
              if ( !v119 || !(unsigned int)curl_strequal(v118, v119) )
                goto LABEL_279;
              v121 = v111->tailmatch == *(_BYTE *)(v141 + 56);
            }
            else
            {
              v121 = v119 == 0;
              LOBYTE(v120) = (_BYTE)sa;
            }
            v120 = (unsigned __int8)v120;
            if ( v121 )
              v120 = 1LL;
LABEL_279:
            if ( (v120 & 1) == 0 )
            {
              sa = (void *)v120;
              v110 = 0LL;
              goto LABEL_259;
            }
            v122 = v111->spath;
            if ( v122 )
            {
              v123 = *(_QWORD *)(v141 + 32);
              if ( v123 )
              {
                if ( !(unsigned int)curl_strequal(v122, v123) )
                {
                  sa = 0LL;
                  v110 = 0LL;
                  goto LABEL_259;
                }
                v122 = v111->spath;
              }
            }
            else
            {
              v122 = 0LL;
            }
            v110 = v141;
            v120 = (unsigned __int8)v120;
            if ( (v122 != 0LL) == (*(_QWORD *)(v141 + 32) == 0LL) )
              v120 = 0LL;
            sa = (void *)v120;
            if ( (v120 & 1) != 0 )
            {
              if ( *(_BYTE *)(v141 + 58) )
              {
                v10 = (__int64)v111;
              }
              else
              {
                v10 = (__int64)v111;
                if ( v111->livecookie )
                  goto LABEL_300;
              }
              goto LABEL_259;
            }
LABEL_289:
            v110 = 0LL;
          }
LABEL_259:
          next = v111->next;
          if ( v111->next )
            continue;
          break;
        }
        if ( v110 )
        {
          *(_QWORD *)v110 = *(_QWORD *)v10;
          *(_DWORD *)(v110 + 60) = *(_DWORD *)(v10 + 60);
          Curl_cfree(*(_QWORD *)(v10 + 8));
          Curl_cfree(*(_QWORD *)(v10 + 16));
          Curl_cfree(*(_QWORD *)(v10 + 40));
          Curl_cfree(*(_QWORD *)(v10 + 24));
          Curl_cfree(*(_QWORD *)(v10 + 32));
          *(_QWORD *)(v10 + 64) = *(_QWORD *)(v110 + 64);
          v126 = *(_OWORD *)v110;
          v127 = *(_OWORD *)(v110 + 16);
          v128 = *(_OWORD *)(v110 + 32);
          *(_OWORD *)(v10 + 48) = *(_OWORD *)(v110 + 48);
          *(_OWORD *)(v10 + 32) = v128;
          *(_OWORD *)(v10 + 16) = v127;
          *(_OWORD *)v10 = v126;
          Curl_cfree(v110);
        }
        else
        {
          v10 = v141;
        }
        v107 = c;
        v130 = (char)sa;
LABEL_332:
        if ( data && v107->running && (*((_BYTE *)&data->set + 2238) & 0x10) != 0 )
        {
          v138 = "Replaced";
          if ( (v130 & 1) == 0 )
            v138 = "Added";
          Curl_infof(
            data,
            "%s cookie %s=\"%s\" for domain %s, path %s, expire %ld",
            v138,
            *(const char **)(v10 + 8),
            *(const char **)(v10 + 16),
            *(const char **)(v10 + 40),
            *(const char **)(v10 + 24),
            *(_QWORD *)(v10 + 48));
          v107 = c;
        }
        if ( (v130 & 1) == 0 )
        {
          v139 = &v107->cookies[v108];
          if ( v111 )
            v139 = &v111->next;
          *v139 = (Cookie *)v10;
          ++v107->numcookies;
        }
        v140 = *(_QWORD *)(v10 + 48);
        if ( v140 && v140 < v107->next_expiration )
          v107->next_expiration = v140;
        return (Cookie *)v10;
      case 3:
LABEL_182:
        *(_BYTE *)(v14 + 57) = 0;
        v66 = 3;
        if ( (unsigned int)curl_strequal(v65, "TRUE") )
        {
          if ( !secure && !c->running )
            goto LABEL_186;
          *(_BYTE *)(v14 + 57) = 1;
        }
        goto LABEL_198;
      case 4:
        if ( (unsigned int)curlx_strtoofft(v65, 0LL, 10LL, s) )
          v67 = 1;
        v66 = 4;
        goto LABEL_198;
      case 5:
        v74 = Curl_cstrdup(v65);
        *(_QWORD *)(v14 + 8) = v74;
        v66 = 5;
        if ( v74 )
        {
          if ( (unsigned int)curl_strnequal("__Secure-", v74, 9LL) )
          {
            *(_BYTE *)(v14 + 64) |= 1u;
          }
          else if ( (unsigned int)curl_strnequal("__Host-", *(_QWORD *)(v14 + 8), 7LL) )
          {
            *(_BYTE *)(v14 + 64) |= 2u;
          }
        }
        else
        {
LABEL_186:
          v67 = 1;
        }
        goto LABEL_198;
      case 6:
        v75 = Curl_cstrdup(v65);
        *(_QWORD *)(v14 + 16) = v75;
        if ( !v75 )
          v67 = 1;
        v66 = 6;
        goto LABEL_198;
      default:
        goto LABEL_198;
    }
  }
}
