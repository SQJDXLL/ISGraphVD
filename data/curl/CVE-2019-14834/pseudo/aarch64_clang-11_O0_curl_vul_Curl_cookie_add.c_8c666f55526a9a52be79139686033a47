// local variable allocation has failed, the output may be wrong!
Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  char *v8; // x0
  int v9; // w0
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x0
  char *v13; // x0
  __int64 v14; // x0
  _BOOL4 v15; // w8
  __int64 v16; // x0
  char *v17; // x0
  __int64 v18; // x0
  __int64 v19; // x0
  __int64 v20; // x0
  __int64 v21; // x0
  __int64 v22; // x0
  int v23; // w9
  int v24; // w0
  const char *v25; // x2
  char *v26; // x9
  char v28; // [xsp+14h] [xbp-1FCh]
  bool v29; // [xsp+18h] [xbp-1F8h]
  bool v30; // [xsp+1Ch] [xbp-1F4h]
  Cookie *v31; // [xsp+40h] [xbp-1D0h]
  bool v32; // [xsp+48h] [xbp-1C8h]
  bool v33; // [xsp+4Ch] [xbp-1C4h]
  bool v34; // [xsp+50h] [xbp-1C0h]
  bool v35; // [xsp+54h] [xbp-1BCh]
  bool v36; // [xsp+58h] [xbp-1B8h]
  bool v37; // [xsp+5Ch] [xbp-1B4h]
  bool v38; // [xsp+60h] [xbp-1B0h]
  bool v39; // [xsp+64h] [xbp-1ACh]
  char *v40; // [xsp+80h] [xbp-190h]
  size_t v41; // [xsp+88h] [xbp-188h]
  char v42; // [xsp+93h] [xbp-17Dh]
  int i; // [xsp+94h] [xbp-17Ch]
  char *save_ptr; // [xsp+98h] [xbp-178h] BYREF
  char *v45; // [xsp+A0h] [xbp-170h]
  char *s2; // [xsp+A8h] [xbp-168h]
  size_t n; // [xsp+B0h] [xbp-160h]
  char *v48; // [xsp+B8h] [xbp-158h]
  char *v49; // [xsp+C0h] [xbp-150h]
  _BYTE dest[128]; // [xsp+C8h] [xbp-148h] BYREF
  __int64 v51; // [xsp+148h] [xbp-C8h]
  int v52; // [xsp+150h] [xbp-C0h]
  char v53; // [xsp+157h] [xbp-B9h]
  __int64 v54; // [xsp+158h] [xbp-B8h]
  const char *v55; // [xsp+160h] [xbp-B0h]
  const char *maxage; // [xsp+168h] [xbp-A8h]
  size_t offt; // [xsp+170h] [xbp-A0h]
  const char *valuep; // [xsp+178h] [xbp-98h]
  const char *namep; // [xsp+180h] [xbp-90h]
  const char *j; // [xsp+188h] [xbp-88h] OVERLAPPED
  size_t nlen; // [xsp+190h] [xbp-80h]
  size_t vlen; // [xsp+198h] [xbp-78h]
  size_t linelength; // [xsp+1A0h] [xbp-70h]
  const char *ptr; // [xsp+1A8h] [xbp-68h]
  size_t myhash; // [xsp+1B0h] [xbp-60h]
  Cookie *v66; // [xsp+1B8h] [xbp-58h] OVERLAPPED
  time_t now; // [xsp+1C0h] [xbp-50h]
  Cookie *replace_clist; // [xsp+1C8h] [xbp-48h]
  Cookie *replace_co; // [xsp+1D0h] [xbp-40h]
  Cookie *lastc; // [xsp+1D8h] [xbp-38h]
  Cookie *co; // [xsp+1E0h] [xbp-30h]
  Cookie *clist; // [xsp+1E8h] [xbp-28h]
  bool v73; // [xsp+1F6h] [xbp-1Ah]
  bool securea; // [xsp+1F7h] [xbp-19h]
  const char *patha; // [xsp+1F8h] [xbp-18h]
  const char *domaina; // [xsp+200h] [xbp-10h]

  domaina = (const char *)data;
  patha = (const char *)c;
  securea = httpheader;
  v73 = noexpire;
  clist = (Cookie *)lineptr;
  co = (Cookie *)domain;
  lastc = (Cookie *)path;
  HIBYTE(replace_co) = secure;
  v66 = 0LL;
  myhash = 0LL;
  ptr = 0LL;
  linelength = time(0uLL);
  HIWORD(vlen) = 0;
  if ( *((unsigned __int8 *)domaina + 416) >= 0x32u )
    return 0LL;
  now = Curl_ccalloc(1LL, 72LL);
  if ( !now )
    return 0LL;
  if ( !securea )
  {
    save_ptr = 0LL;
    if ( !strncmp((const char *)clist, "#HttpOnly_", 0xAuLL) )
    {
      clist = (Cookie *)((char *)clist + 0xA);
      *(_BYTE *)(now + 59) = 1;
    }
    if ( LOBYTE(clist->next) != 35 )
    {
      s2 = strchr((const char *)clist, 13);
      if ( s2 )
        *s2 = 0;
      s2 = strchr((const char *)clist, 10);
      if ( s2 )
        *s2 = 0;
      v45 = strtok_r((char *)clist, "\t", &save_ptr);
      s2 = v45;
      for ( i = 0; ; ++i )
      {
        v28 = 0;
        if ( s2 )
          v28 = BYTE6(vlen) ^ 1;
        if ( (v28 & 1) == 0 )
          break;
        switch ( i )
        {
          case 0:
            if ( *s2 == 46 )
              ++s2;
            v14 = Curl_cstrdup(s2);
            *(_QWORD *)(now + 40) = v14;
            if ( !*(_QWORD *)(now + 40) )
              BYTE6(vlen) = 1;
            break;
          case 1:
            v15 = curl_strequal(s2, "TRUE") != 0;
            *(_BYTE *)(now + 56) = v15;
            break;
          case 2:
            if ( !strcmp("TRUE", s2) || !strcmp("FALSE", s2) )
            {
              v18 = Curl_cstrdup("/");
              *(_QWORD *)(now + 24) = v18;
              if ( !*(_QWORD *)(now + 24) )
                BYTE6(vlen) = 1;
              v19 = Curl_cstrdup("/");
              *(_QWORD *)(now + 32) = v19;
              if ( !*(_QWORD *)(now + 32) )
                BYTE6(vlen) = 1;
              ++i;
              goto LABEL_202;
            }
            v16 = Curl_cstrdup(s2);
            *(_QWORD *)(now + 24) = v16;
            if ( *(_QWORD *)(now + 24) )
            {
              v17 = sanitize_cookie_path(*(const char **)(now + 24));
              *(_QWORD *)(now + 32) = v17;
              if ( !*(_QWORD *)(now + 32) )
                BYTE6(vlen) = 1;
            }
            else
            {
              BYTE6(vlen) = 1;
            }
            break;
          case 3:
LABEL_202:
            *(_BYTE *)(now + 57) = 0;
            if ( (unsigned int)curl_strequal(s2, "TRUE") )
            {
              if ( (HIBYTE(replace_co) & 1) != 0 || (patha[520] & 1) != 0 )
                *(_BYTE *)(now + 57) = 1;
              else
                BYTE6(vlen) = 1;
            }
            break;
          case 4:
            if ( (unsigned int)curlx_strtoofft(s2, 0LL, 10LL, now + 0x30) )
              BYTE6(vlen) = 1;
            break;
          case 5:
            v20 = Curl_cstrdup(s2);
            *(_QWORD *)(now + 8) = v20;
            if ( *(_QWORD *)(now + 8) )
            {
              if ( (unsigned int)curl_strnequal("__Secure-", *(_QWORD *)(now + 8), 9LL) )
              {
                *(_BYTE *)(now + 64) |= 1u;
              }
              else if ( (unsigned int)curl_strnequal("__Host-", *(_QWORD *)(now + 8), 7LL) )
              {
                *(_BYTE *)(now + 64) |= 2u;
              }
            }
            else
            {
              BYTE6(vlen) = 1;
            }
            break;
          case 6:
            v21 = Curl_cstrdup(s2);
            *(_QWORD *)(now + 16) = v21;
            if ( !*(_QWORD *)(now + 16) )
              BYTE6(vlen) = 1;
            break;
          default:
            break;
        }
        s2 = strtok_r(0uLL, "\t", &save_ptr);
      }
      if ( i == 6 )
      {
        v22 = Curl_cstrdup(&unk_366A);
        *(_QWORD *)(now + 16) = v22;
        if ( *(_QWORD *)(now + 16) )
          i = 7;
        else
          BYTE6(vlen) = 1;
      }
      if ( (vlen & 0x1000000000000LL) == 0 && i != 7 )
        BYTE6(vlen) = 1;
      if ( (vlen & 0x1000000000000LL) == 0 )
        goto LABEL_230;
LABEL_289:
      freecookie((Cookie *)now);
      return 0LL;
    }
LABEL_174:
    Curl_cfree(now);
    return 0LL;
  }
  namep = (const char *)strlen((const char *)clist);
  if ( (unsigned __int64)namep > 0x1388 )
    goto LABEL_174;
  for ( j = (const char *)clist; ; ++j )
  {
    while ( 1 )
    {
      v39 = 0;
      if ( *j )
      {
        v38 = 1;
        if ( *j != 32 )
          v38 = *j == 9;
        v39 = v38;
      }
      if ( !v39 )
        break;
      ++j;
    }
    offt = strcspn(j, ";\t\r\n=");
    if ( !offt )
      goto LABEL_142;
    HIWORD(maxage) = 0;
    v55 = j;
    j += offt;
    while ( 1 )
    {
      v37 = 0;
      if ( offt )
      {
        v36 = 1;
        if ( v55[offt - 1] != 32 )
          v36 = v55[offt - 1] == 9;
        v37 = v36;
      }
      if ( !v37 )
        break;
      --offt;
    }
    if ( *j == 61 )
    {
      valuep = (const char *)strcspn(++j, ";\r\n");
      v54 = (__int64)j;
      BYTE6(maxage) = 1;
      j = &valuep[(_QWORD)j];
      while ( 1 )
      {
        v35 = 0;
        if ( valuep )
        {
          v34 = 1;
          if ( valuep[v54 + 0xFFFFFFFFLL] != 32 )
            v34 = valuep[v54 + 0xFFFFFFFFLL] == 9;
          v35 = v34;
        }
        if ( !v35 )
          break;
        --valuep;
      }
      while ( 1 )
      {
        v33 = 0;
        if ( valuep )
        {
          v32 = 1;
          if ( *(_BYTE *)v54 != 32 )
            v32 = *(_BYTE *)v54 == 9;
          v33 = v32;
        }
        if ( !v33 )
          break;
        ++v54;
        --valuep;
      }
      if ( memchr((const void *)v54, 9, (size_t)valuep) )
      {
        freecookie((Cookie *)now);
        if ( domaina && ((*(_QWORD *)(domaina + 0xA63) >> 0x1C) & 1) != 0 )
          Curl_infof(domaina, "cookie contains TAB, dropping");
        return 0LL;
      }
    }
    else
    {
      v54 = 0LL;
      valuep = 0LL;
    }
    if ( offt >= 0xFFF || (unsigned __int64)valuep >= 0xFFF || (unsigned __int64)&valuep[offt] > 0x1000 )
    {
      freecookie((Cookie *)now);
      if ( domaina && ((*(_QWORD *)(domaina + 0xA63) >> 0x1C) & 1) != 0 )
        Curl_infof(domaina, "oversized cookie dropped, name/val %zu + %zu bytes", offt, (size_t)valuep);
      return 0LL;
    }
    if ( offt >= 7 && *v55 == 95 && v55[1] == 95 )
    {
      if ( (unsigned int)curl_strnequal("__Secure-", v55, 9LL) )
      {
        *(_BYTE *)(now + 64) |= 1u;
      }
      else if ( (unsigned int)curl_strnequal("__Host-", v55, 7LL) )
      {
        *(_BYTE *)(now + 64) |= 2u;
      }
    }
    if ( !*(_QWORD *)(now + 8) )
      break;
    if ( !valuep )
    {
      HIBYTE(maxage) = 1;
      if ( offt == 6 && (unsigned int)curl_strnequal("secure", v55, 6LL) )
      {
        if ( (HIBYTE(replace_co) & 1) == 0 && (patha[520] & 1) != 0 )
        {
          BYTE6(vlen) = 1;
          goto LABEL_150;
        }
        *(_BYTE *)(now + 57) = 1;
      }
      else if ( offt == 8 && (unsigned int)curl_strnequal("httponly", v55, 8LL) )
      {
        *(_BYTE *)(now + 59) = 1;
      }
      else if ( (BYTE6(maxage) & 1) != 0 )
      {
        HIBYTE(maxage) = 0;
      }
    }
LABEL_83:
    if ( (HIBYTE(maxage) & 1) == 0 )
    {
      if ( offt == 4 && (unsigned int)curl_strnequal("path", v55, 4LL) )
      {
        strstore((char **)(now + 0x18), (const char *)v54, (size_t)valuep);
        if ( !*(_QWORD *)(now + 24) )
        {
          BYTE6(vlen) = 1;
          goto LABEL_150;
        }
        Curl_cfree(*(_QWORD *)(now + 32));
        v8 = sanitize_cookie_path(*(const char **)(now + 24));
        *(_QWORD *)(now + 32) = v8;
        if ( !*(_QWORD *)(now + 32) )
        {
          BYTE6(vlen) = 1;
          goto LABEL_150;
        }
      }
      else if ( offt == 6 && (unsigned int)curl_strnequal("domain", v55, 6LL) && valuep )
      {
        if ( 46 == *(_BYTE *)v54 )
        {
          ++v54;
          --valuep;
        }
        if ( bad_domain((const char *)v54, (size_t)valuep) )
          co = (Cookie *)":";
        if ( co )
          v31 = co;
        else
          v31 = (Cookie *)v54;
        v53 = Curl_host_is_ipnum(v31) & 1;
        if ( !co
          || (v53 & 1) != 0
          && !strncmp((const char *)v54, (const char *)co, (size_t)valuep)
          && valuep == (const char *)strlen((const char *)co)
          || (v53 & 1) == 0 && cookie_tailmatch((const char *)v54, (size_t)valuep, (const char *)co) )
        {
          strstore((char **)(now + 0x28), (const char *)v54, (size_t)valuep);
          if ( !*(_QWORD *)(now + 40) )
          {
            BYTE6(vlen) = 1;
            goto LABEL_150;
          }
          if ( (v53 & 1) == 0 )
            *(_BYTE *)(now + 56) = 1;
        }
        else
        {
          BYTE6(vlen) = 1;
          if ( domaina && ((*(_QWORD *)(domaina + 0xA63) >> 0x1C) & 1) != 0 )
            Curl_infof(domaina, "skipped cookie with bad tailmatch domain: %s", (const char *)v54);
        }
      }
      else if ( offt != 7 || !(unsigned int)curl_strnequal("version", v55, 7LL) )
      {
        if ( offt == 7 && (unsigned int)curl_strnequal("max-age", v55, 7LL) )
        {
          v51 = v54;
          if ( *(_BYTE *)v54 == 34 )
            v9 = curlx_strtoofft(v51 + 1, 0LL, 10LL, now + 0x30);
          else
            v9 = curlx_strtoofft(v51, 0LL, 10LL, now + 0x30);
          v52 = v9;
          if ( v9 )
          {
            if ( v9 == 1 )
            {
              *(_QWORD *)(now + 48) = 0x7FFFFFFFFFFFFFFFLL;
            }
            else if ( v9 == 2 )
            {
              *(_QWORD *)(now + 48) = 1LL;
            }
          }
          else if ( *(_QWORD *)(now + 48) )
          {
            if ( (signed __int64)(0x7FFFFFFFFFFFFFFFLL - linelength) < *(_QWORD *)(now + 48) )
              *(_QWORD *)(now + 48) = 0x7FFFFFFFFFFFFFFFLL;
            else
              *(_QWORD *)(now + 48) += linelength;
          }
          else
          {
            *(_QWORD *)(now + 48) = 1LL;
          }
        }
        else if ( offt == 7
               && (unsigned int)curl_strnequal("expires", v55, 7LL)
               && !*(_QWORD *)(now + 48)
               && (unsigned __int64)valuep < 0x80 )
        {
          memcpy(dest, (const void *)v54, (size_t)valuep);
          dest[(_QWORD)valuep] = 0;
          v10 = Curl_getdate_capped(dest);
          *(_QWORD *)(now + 48) = v10;
          if ( *(_QWORD *)(now + 48) )
          {
            if ( *(__int64 *)(now + 48) < 0 )
              *(_QWORD *)(now + 48) = 0LL;
          }
          else
          {
            *(_QWORD *)(now + 48) = 1LL;
          }
        }
      }
    }
    while ( 1 )
    {
LABEL_142:
      v30 = 0;
      if ( *j )
      {
        v29 = 1;
        if ( *j != 32 )
          v29 = *j == 9;
        v30 = v29;
      }
      if ( !v30 )
        break;
      ++j;
    }
    if ( *j != 59 )
      goto LABEL_150;
  }
  if ( (BYTE6(maxage) & 1) == 0 )
  {
    BYTE6(vlen) = 1;
    goto LABEL_150;
  }
  strstore((char **)(now + 8), v55, offt);
  strstore((char **)(now + 0x10), (const char *)v54, (size_t)valuep);
  HIBYTE(maxage) = 1;
  if ( !*(_QWORD *)(now + 8) || !*(_QWORD *)(now + 16) )
  {
    BYTE6(vlen) = 1;
    goto LABEL_150;
  }
  if ( !invalid_octets(*(const char **)(now + 16)) && !invalid_octets(*(const char **)(now + 8)) )
    goto LABEL_83;
  if ( domaina && ((*(_QWORD *)(domaina + 0xA63) >> 0x1C) & 1) != 0 )
    Curl_infof(domaina, "invalid octets in name/value, cookie dropped");
  BYTE6(vlen) = 1;
LABEL_150:
  if ( (vlen & 0x1000000000000LL) == 0 && !*(_QWORD *)(now + 40) )
  {
    if ( co )
    {
      v11 = Curl_cstrdup(co);
      *(_QWORD *)(now + 40) = v11;
      if ( !*(_QWORD *)(now + 40) )
        BYTE6(vlen) = 1;
    }
  }
  if ( (vlen & 0x1000000000000LL) == 0 && !*(_QWORD *)(now + 24) && lastc )
  {
    v49 = strchr((const char *)lastc, 63);
    v48 = v49 ? (char *)Curl_memrchr(lastc, 47LL, v49 - (char *)lastc) : strrchr((const char *)lastc, 47);
    if ( v48 )
    {
      n = v48 - (char *)lastc + 1;
      v12 = Curl_cmalloc(v48 - (char *)lastc + 2);
      *(_QWORD *)(now + 24) = v12;
      if ( *(_QWORD *)(now + 24) )
      {
        memcpy(*(void **)(now + 24), lastc, n);
        *(_BYTE *)(*(_QWORD *)(now + 24) + n) = 0;
        v13 = sanitize_cookie_path(*(const char **)(now + 24));
        *(_QWORD *)(now + 32) = v13;
        if ( !*(_QWORD *)(now + 32) )
          BYTE6(vlen) = 1;
      }
      else
      {
        BYTE6(vlen) = 1;
      }
    }
  }
  if ( (vlen & 0x1000000000000LL) != 0 || !*(_QWORD *)(now + 8) )
  {
    freecookie((Cookie *)now);
    return 0LL;
  }
  ++domaina[416];
LABEL_230:
  if ( (*(_BYTE *)(now + 64) & 1) != 0 && (*(_BYTE *)(now + 57) & 1) == 0
    || (*(_BYTE *)(now + 64) & 2) != 0
    && ((*(_BYTE *)(now + 57) & 1) == 0
     || !*(_QWORD *)(now + 24)
     || strcmp(*(const char **)(now + 24), "/")
     || (*(_BYTE *)(now + 56) & 1) != 0)
    || (patha[520] & 1) == 0 && (patha[521] & 1) != 0 && !*(_QWORD *)(now + 48) )
  {
    goto LABEL_289;
  }
  *(_BYTE *)(now + 58) = patha[520] & 1;
  v23 = *((_DWORD *)patha + 129) + 1;
  *((_DWORD *)patha + 129) = v23;
  *(_DWORD *)(now + 60) = v23;
  if ( !v73 )
    remove_expired((CookieInfo *)patha);
  nlen = cookiehash(*(const char *const *)(now + 40));
  for ( replace_clist = *(Cookie **)&patha[8 * nlen]; replace_clist; replace_clist = replace_clist->next )
  {
    if ( (unsigned int)curl_strequal(replace_clist->name, *(_QWORD *)(now + 8)) )
    {
      v42 = 0;
      if ( replace_clist->domain && *(_QWORD *)(now + 40) )
      {
        if ( (unsigned int)curl_strequal(replace_clist->domain, *(_QWORD *)(now + 40)) )
          v42 = 1;
      }
      else if ( !replace_clist->domain && !*(_QWORD *)(now + 40) )
      {
        v42 = 1;
      }
      if ( (v42 & 1) != 0
        && replace_clist->spath
        && *(_QWORD *)(now + 32)
        && replace_clist->secure
        && (*(_BYTE *)(now + 57) & 1) == 0
        && (HIBYTE(replace_co) & 1) == 0 )
      {
        v40 = strchr((const char *)replace_clist->spath + 1, 47);
        if ( v40 )
        {
          v24 = curl_strnequal(replace_clist->spath, *(_QWORD *)(now + 32), v40 - replace_clist->spath);
        }
        else
        {
          v41 = strlen(replace_clist->spath);
          v24 = curl_strnequal(replace_clist->spath, *(_QWORD *)(now + 32), v41);
        }
        if ( v24 )
        {
          if ( domaina && ((*(_QWORD *)(domaina + 0xA63) >> 0x1C) & 1) != 0 )
            Curl_infof(
              domaina,
              "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
              *(const char **)(now + 8),
              *(const char **)(now + 40));
          goto LABEL_289;
        }
      }
    }
    if ( !myhash && (unsigned int)curl_strequal(replace_clist->name, *(_QWORD *)(now + 8)) )
    {
      if ( replace_clist->domain && *(_QWORD *)(now + 40) )
      {
        if ( (unsigned int)curl_strequal(replace_clist->domain, *(_QWORD *)(now + 40))
          && replace_clist->tailmatch == (*(_BYTE *)(now + 56) & 1) )
        {
          HIBYTE(vlen) = 1;
        }
      }
      else if ( !replace_clist->domain && !*(_QWORD *)(now + 40) )
      {
        HIBYTE(vlen) = 1;
      }
      if ( (vlen & 0x100000000000000LL) != 0 )
      {
        if ( replace_clist->spath
          && *(_QWORD *)(now + 32)
          && !(unsigned int)curl_strequal(replace_clist->spath, *(_QWORD *)(now + 32)) )
        {
          HIBYTE(vlen) = 0;
        }
        else if ( (replace_clist->spath == 0LL) != (*(_QWORD *)(now + 32) == 0LL) )
        {
          HIBYTE(vlen) = 0;
        }
      }
      if ( (vlen & 0x100000000000000LL) != 0 && (*(_BYTE *)(now + 58) & 1) == 0 && replace_clist->livecookie )
        goto LABEL_289;
      if ( (vlen & 0x100000000000000LL) != 0 )
      {
        myhash = now;
        ptr = (const char *)replace_clist;
      }
    }
    v66 = replace_clist;
  }
  if ( myhash )
  {
    now = myhash;
    replace_clist = (Cookie *)ptr;
    *(_QWORD *)myhash = *(_QWORD *)ptr;
    *(_DWORD *)(now + 60) = replace_clist->creationtime;
    Curl_cfree(replace_clist->name);
    Curl_cfree(replace_clist->value);
    Curl_cfree(replace_clist->domain);
    Curl_cfree(replace_clist->path);
    Curl_cfree(replace_clist->spath);
    memcpy(replace_clist, (const void *)now, sizeof(Cookie));
    Curl_cfree(now);
    now = (time_t)replace_clist;
  }
  if ( (patha[520] & 1) != 0 && domaina && ((*(_QWORD *)(domaina + 0xA63) >> 0x1C) & 1) != 0 )
  {
    if ( (vlen & 0x100000000000000LL) != 0 )
      v25 = "Replaced";
    else
      v25 = "Added";
    Curl_infof(
      domaina,
      "%s cookie %s=\"%s\" for domain %s, path %s, expire %ld",
      v25,
      *(const char **)(now + 8),
      *(const char **)(now + 16),
      *(const char **)(now + 40),
      *(const char **)(now + 24),
      *(_QWORD *)(now + 48));
  }
  if ( (vlen & 0x100000000000000LL) == 0 )
  {
    if ( v66 )
      v26 = (char *)v66;
    else
      v26 = (char *)&patha[8 * nlen];
    *(_QWORD *)v26 = now;
    ++*((_DWORD *)patha + 128);
  }
  if ( *(_QWORD *)(now + 48) && *(_QWORD *)(now + 48) < *((_QWORD *)patha + 63) )
    *((_QWORD *)patha + 63) = *(_QWORD *)(now + 48);
  return (Cookie *)now;
}
