Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        char *path,
        bool secure)
{
  time_t v8; // eax
  Cookie *v9; // ebp
  int v10; // eax
  int v11; // esi
  const char *j; // edx
  const char *v13; // ebp
  const char *i; // esi
  size_t v15; // eax
  const char *v16; // edx
  unsigned int v17; // edi
  char v18; // cl
  size_t v19; // eax
  size_t v20; // ecx
  const char *v21; // edx
  const char *v22; // ebp
  char v23; // cl
  size_t v24; // ebp
  char v25; // cl
  int v26; // eax
  int v27; // eax
  const char *v28; // eax
  char *v29; // edi
  size_t v30; // eax
  size_t v31; // esi
  const char *v32; // eax
  const char *v33; // esi
  size_t v34; // eax
  int v35; // eax
  _DWORD *v36; // esi
  const char *v37; // eax
  int v38; // eax
  int v39; // eax
  const char *v40; // esi
  size_t v41; // ebp
  _BYTE *v42; // eax
  const char *v43; // eax
  const char *v44; // edi
  size_t v45; // eax
  char is_ipnum; // cl
  int v47; // eax
  const char *v48; // eax
  size_t v49; // edi
  const char *v50; // ebp
  size_t v51; // eax
  const char *v52; // ebp
  int v53; // eax
  int v54; // eax
  int v55; // esi
  int v56; // eax
  unsigned int v57; // eax
  unsigned int v58; // ecx
  char v59; // cl
  char *v60; // edi
  char *v61; // eax
  char *v62; // eax
  char *v63; // eax
  const char *v64; // ebp
  int v65; // edx
  int v66; // ecx
  unsigned __int8 v67; // di
  int v68; // edi
  int v69; // eax
  const char *v70; // eax
  char *v71; // edi
  size_t v72; // eax
  size_t v73; // ebp
  char v74; // di
  int v75; // eax
  int v76; // ecx
  int v77; // edi
  int v78; // eax
  char v79; // di
  int v80; // eax
  int v81; // ecx
  int v82; // edi
  int v83; // eax
  int v84; // edi
  CookieInfo *v85; // eax
  int v86; // eax
  int v87; // ecx
  int v88; // eax
  char *v89; // eax
  int v90; // edi
  int v91; // eax
  _DWORD *v92; // edi
  char v93; // al
  const char *v94; // ebp
  int v95; // eax
  char v96; // cl
  char *v97; // eax
  char *v98; // eax
  int v99; // edi
  void *v100; // eax
  size_t v101; // edi
  const char *v102; // eax
  char *v103; // edi
  size_t v104; // eax
  size_t v105; // ebp
  char v106; // al
  char v107; // cl
  char v108; // al
  bool running; // al
  int v110; // eax
  unsigned int next_expiration; // eax
  unsigned int next_expiration_high; // ecx
  Cookie *next; // eax
  Cookie *v114; // edi
  Cookie *v115; // esi
  char *v116; // eax
  int v117; // ecx
  const char *spath; // ebp
  char *v119; // eax
  size_t v120; // eax
  char *v121; // eax
  int v122; // ecx
  bool v123; // zf
  int v124; // eax
  char *v125; // eax
  char *v126; // ecx
  int v127; // eax
  __int64 v129; // xmm0_8
  CookieInfo *v130; // edi
  char v131; // al
  int v132; // eax
  CookieInfo *v133; // edi
  Cookie *v134; // esi
  Cookie *v135; // ebp
  curl_off_t v136; // rax
  int expires_high; // ecx
  Cookie **p_next; // eax
  const char *v139; // ecx
  Cookie **v140; // eax
  curl_off_t v141; // rax
  int v142; // ecx
  time_t *timer; // [esp+0h] [ebp-ECh]
  size_t n; // [esp+8h] [ebp-E4h]
  char v145; // [esp+30h] [ebp-BCh]
  const char *v146; // [esp+30h] [ebp-BCh]
  int v147; // [esp+30h] [ebp-BCh]
  unsigned __int8 v148; // [esp+30h] [ebp-BCh]
  int v149; // [esp+30h] [ebp-BCh]
  Cookie *v150; // [esp+30h] [ebp-BCh]
  int v151; // [esp+34h] [ebp-B8h]
  const char *s; // [esp+38h] [ebp-B4h]
  const char *sa; // [esp+38h] [ebp-B4h]
  size_t sb; // [esp+38h] [ebp-B4h]
  char sf; // [esp+38h] [ebp-B4h]
  time_t sc; // [esp+38h] [ebp-B4h]
  int sd; // [esp+38h] [ebp-B4h]
  char se; // [esp+38h] [ebp-B4h]
  size_t s_4d; // [esp+3Ch] [ebp-B0h]
  size_t s_4; // [esp+3Ch] [ebp-B0h]
  char s_4a; // [esp+3Ch] [ebp-B0h]
  char s_4e; // [esp+3Ch] [ebp-B0h]
  char s_4f; // [esp+3Ch] [ebp-B0h]
  int s_4b; // [esp+3Ch] [ebp-B0h]
  size_t s_4c; // [esp+3Ch] [ebp-B0h]
  char v166; // [esp+40h] [ebp-ACh]
  char v167; // [esp+40h] [ebp-ACh]
  int v168; // [esp+40h] [ebp-ACh]
  int v169; // [esp+44h] [ebp-A8h]
  int v170; // [esp+44h] [ebp-A8h]
  Cookie **v171; // [esp+44h] [ebp-A8h]
  _DWORD *v173; // [esp+4Ch] [ebp-A0h]
  __int64 v174; // [esp+54h] [ebp-98h]
  char *dest[36]; // [esp+5Ch] [ebp-90h] BYREF

  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return v9;
  v169 = v8;
  v10 = Curl_ccalloc(1, 44);
  if ( !v10 )
    return v9;
  v11 = v10;
  v151 = v10;
  if ( !httpheader )
  {
    dest[0] = 0;
    v60 = lineptr;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v60 = lineptr + 10;
      *(_BYTE *)(v11 + 35) = 1;
      if ( lineptr[10] == 35 )
        goto LABEL_139;
    }
    else if ( *lineptr == 35 )
    {
      goto LABEL_139;
    }
    v61 = strchr(v60, 13);
    if ( v61 )
      *v61 = 0;
    v62 = strchr(v60, 10);
    if ( v62 )
      *v62 = 0;
    v63 = strtok_r(v60, "\t", dest);
    if ( !v63 )
      goto LABEL_209;
    v64 = v63;
    v65 = 0;
    v66 = 0;
    s_4b = v11 + 24;
    while ( 1 )
    {
      switch ( v65 )
      {
        case 0:
          v67 = v66;
          if ( *v64 == 46 )
            ++v64;
          v86 = Curl_cstrdup(v64);
          *(_DWORD *)(v11 + 20) = v86;
          v87 = v67;
          if ( !v86 )
            v87 = 1;
          v68 = 0;
          v147 = v87;
          goto LABEL_201;
        case 1:
          v147 = v66;
          v68 = 1;
          *(_BYTE *)(v11 + 32) = curl_strequal(v64, "TRUE") != 0;
          goto LABEL_201;
        case 2:
          v148 = v66;
          if ( !strcmp("TRUE", v64) || !strcmp("FALSE", v64) )
          {
            v82 = Curl_cstrdup("/");
            *(_DWORD *)(v151 + 12) = v82;
            v11 = v151;
            v83 = Curl_cstrdup("/");
            *(_DWORD *)(v151 + 16) = v83;
            v66 = v148;
            if ( !v83 )
              v66 = 1;
            if ( !v82 )
              v66 = 1;
            goto LABEL_174;
          }
          v69 = Curl_cstrdup(v64);
          *(_DWORD *)(v11 + 12) = v69;
          if ( !v69 )
          {
            v88 = 1;
            goto LABEL_200;
          }
          v70 = (const char *)Curl_cstrdup(v69);
          if ( v70 )
          {
            v71 = (char *)v70;
            v72 = strlen(v70);
            v73 = v72;
            if ( *v71 == 34 )
            {
              memmove(v71, v71 + 1, v72);
              --v73;
            }
            if ( v73 )
            {
              if ( v71[v73 - 1] == 34 )
                v71[--v73] = 0;
            }
            else
            {
              v73 = 0;
            }
            if ( *v71 == 47 )
            {
              if ( v73 )
              {
                LOBYTE(v88) = v148;
                if ( v71[v73 - 1] == 47 )
                  v71[v73 - 1] = 0;
                goto LABEL_198;
              }
            }
            else
            {
              Curl_cfree(v71);
              v71 = (char *)Curl_strndup("/", 1);
            }
            LOBYTE(v88) = v148;
          }
          else
          {
            LOBYTE(v88) = v148;
            v71 = 0;
          }
LABEL_198:
          v88 = (unsigned __int8)v88;
          *(_DWORD *)(v11 + 16) = v71;
          if ( !v71 )
            v88 = 1;
LABEL_200:
          v147 = v88;
          v68 = 2;
LABEL_201:
          v89 = strtok_r(0, "\t", dest);
          v66 = v147;
          v90 = v68 + 1;
          v65 = v90;
          if ( (v147 & 1) != 0 || (v64 = v89) == 0 )
          {
            if ( v90 == 6 )
            {
              v91 = Curl_cstrdup(&L_str_22);
              *(_DWORD *)(v11 + 8) = v91;
              LOBYTE(v66) = 1;
              if ( v91 )
                LOBYTE(v66) = v147;
              v65 = (v91 == 0) ^ 7;
            }
            if ( (v66 & 1) == 0 && v65 == 7 )
              goto LABEL_256;
LABEL_209:
            v92 = (_DWORD *)v11;
            goto LABEL_308;
          }
          break;
        case 3:
LABEL_174:
          *(_BYTE *)(v11 + 33) = 0;
          v84 = v66;
          if ( !curl_strequal(v64, "TRUE") )
            goto LABEL_178;
          if ( secure || (v85 = c, c->running) )
          {
            *(_BYTE *)(v11 + 33) = 1;
LABEL_178:
            v147 = v84;
            v68 = 3;
          }
          else
          {
            LOBYTE(v85) = 1;
            v68 = 3;
            v147 = (int)v85;
          }
          goto LABEL_201;
        case 4:
          v74 = v66;
          v75 = curlx_strtoofft(v64, 0, 10, s_4b);
          LOBYTE(v76) = v74;
          v68 = 4;
          v76 = (unsigned __int8)v76;
          if ( v75 )
            v76 = 1;
          v147 = v76;
          goto LABEL_201;
        case 5:
          v77 = v66;
          v78 = Curl_cstrdup(v64);
          *(_DWORD *)(v11 + 4) = v78;
          if ( v78 )
          {
            v147 = v77;
            if ( curl_strnequal("__Secure-", v78, 9) )
            {
              *(_BYTE *)(v11 + 40) |= 1u;
              v68 = 5;
            }
            else
            {
              if ( curl_strnequal("__Host-", *(_DWORD *)(v11 + 4), 7) )
                *(_BYTE *)(v11 + 40) |= 2u;
              v68 = 5;
            }
          }
          else
          {
            v68 = 5;
            v147 = 1;
          }
          goto LABEL_201;
        case 6:
          v79 = v66;
          v80 = Curl_cstrdup(v64);
          LOBYTE(v81) = v79;
          *(_DWORD *)(v11 + 8) = v80;
          v68 = 6;
          v81 = (unsigned __int8)v81;
          if ( !v80 )
            v81 = 1;
          v147 = v81;
          goto LABEL_201;
        default:
          v147 = v66;
          v68 = v65;
          goto LABEL_201;
      }
    }
  }
  if ( strlen(lineptr) > 0x1388 )
  {
LABEL_139:
    Curl_cfree(v11);
    return v9;
  }
  v166 = 0;
  v173 = (_DWORD *)(v11 + 24);
  LODWORD(v174) = ~v169;
  HIDWORD(v174) = 0x7FFFFFFF - (v169 >> 31);
  j = lineptr;
  while ( 1 )
  {
    v13 = j + 1;
    for ( i = j; *i == 32 || *i == 9; ++i )
      ++v13;
    v145 = *i;
    v15 = strcspn(i, ";\t\r\n=");
    if ( !v15 )
    {
      v16 = i;
      goto LABEL_130;
    }
    v16 = &i[v15];
    v17 = v15;
    while ( 1 )
    {
      v18 = i[v17 - 1];
      if ( v18 != 32 && v18 != 9 )
        break;
      if ( !--v17 )
      {
        v17 = 0;
        if ( *v16 != 61 )
          goto LABEL_28;
        goto LABEL_16;
      }
    }
    if ( *v16 != 61 )
    {
LABEL_28:
      v24 = 0;
      v25 = 0;
      sa = 0;
      goto LABEL_34;
    }
LABEL_16:
    s_4d = v15;
    s = &i[v15 + 1];
    v19 = strcspn(s, ";\r\n");
    v20 = v19 + s_4d;
    s_4 = v19 + s_4d;
    if ( v19 )
    {
      v21 = s;
      v22 = &v13[v20];
      while ( 1 )
      {
        v23 = *(v22 - 1);
        if ( v23 != 32 && v23 != 9 )
          break;
        --v19;
        --v22;
        if ( !v19 )
          goto LABEL_31;
      }
      do
      {
        if ( *v21 != 32 && *v21 != 9 )
        {
          v24 = v19;
          goto LABEL_32;
        }
        ++v21;
        --v19;
      }
      while ( v19 );
      v21 = v22;
    }
    else
    {
      v21 = s;
    }
LABEL_31:
    v24 = 0;
LABEL_32:
    sa = v21;
    if ( memchr(v21, 9, v24) )
    {
      Curl_cfree(*(_DWORD *)(v151 + 20));
      Curl_cfree(*(_DWORD *)(v151 + 12));
      Curl_cfree(*(_DWORD *)(v151 + 16));
      Curl_cfree(*(_DWORD *)(v151 + 4));
      Curl_cfree(*(_DWORD *)(v151 + 8));
      Curl_cfree(v151);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
        Curl_infof(data, "cookie contains TAB, dropping", n);
      return v9;
    }
    v25 = 1;
    v16 = &i[s_4 + 1];
LABEL_34:
    if ( v17 > 0xFFE || v24 > 0xFFE || v24 + v17 >= 0x1001 )
    {
      Curl_cfree(*(_DWORD *)(v151 + 20));
      Curl_cfree(*(_DWORD *)(v151 + 12));
      Curl_cfree(*(_DWORD *)(v151 + 16));
      Curl_cfree(*(_DWORD *)(v151 + 4));
      Curl_cfree(*(_DWORD *)(v151 + 8));
      Curl_cfree(v151);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v17);
      return v9;
    }
    v123 = v145 == 95;
    v146 = v16;
    if ( v123 && v17 >= 7 && i[1] == 95 )
    {
      s_4a = v25;
      if ( curl_strnequal("__Secure-", i, 9) )
      {
        *(_BYTE *)(v151 + 40) |= 1u;
        v16 = v146;
        v25 = s_4a;
      }
      else
      {
        v26 = curl_strnequal("__Host-", i, 7);
        v16 = v146;
        v25 = s_4a;
        if ( v26 )
          *(_BYTE *)(v151 + 40) |= 2u;
      }
    }
    if ( !*(_DWORD *)(v151 + 4) )
    {
      if ( !v25 )
        goto LABEL_307;
      Curl_cfree(0);
      *(_DWORD *)(v151 + 4) = Curl_strndup(i, v17);
      Curl_cfree(*(_DWORD *)(v151 + 8));
      v32 = (const char *)Curl_strndup(sa, v24);
      *(_DWORD *)(v151 + 8) = v32;
      if ( !v32 )
        goto LABEL_307;
      v33 = *(const char **)(v151 + 4);
      if ( !v33 )
        goto LABEL_307;
      if ( v32[strcspn(v32, invalid_octets_badoctets)]
        || (v34 = strcspn(v33, invalid_octets_badoctets), v16 = v146, v33[v34]) )
      {
        if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
          Curl_infof(data, "invalid octets in name/value, cookie dropped", n);
LABEL_307:
        v92 = (_DWORD *)v151;
LABEL_308:
        Curl_cfree(v92[5]);
        Curl_cfree(v92[3]);
        Curl_cfree(v92[4]);
        Curl_cfree(v92[1]);
        Curl_cfree(v92[2]);
        Curl_cfree(v92);
        return 0;
      }
      goto LABEL_130;
    }
    if ( v24 )
      break;
    if ( v17 == 8 )
    {
      s_4f = v25;
      v47 = curl_strnequal("httponly", i, 8);
      v25 = s_4f;
      v16 = v146;
      if ( v47 )
      {
        *(_BYTE *)(v151 + 35) = 1;
        goto LABEL_130;
      }
    }
    else if ( v17 == 6 )
    {
      s_4e = v25;
      v35 = curl_strnequal("secure", i, 6);
      v25 = s_4e;
      v16 = v146;
      if ( v35 )
      {
        if ( !secure && c->running )
          goto LABEL_307;
        *(_BYTE *)(v151 + 33) = 1;
        goto LABEL_130;
      }
    }
    if ( v25 )
      break;
LABEL_130:
    v55 = v151;
    for ( j = v16 + 1; ; ++j )
    {
      v59 = *(j - 1);
      if ( v59 != 32 && v59 != 9 )
        break;
    }
    if ( v59 != 59 )
      goto LABEL_210;
  }
  if ( v17 == 7 )
  {
    if ( curl_strnequal("version", i, 7) )
      goto LABEL_129;
    if ( curl_strnequal("max-age", i, 7) )
    {
      v36 = v173;
      v37 = sa + 1;
      if ( *sa != 34 )
        v37 = sa;
      v38 = curlx_strtoofft(v37, 0, 10, v173);
      if ( v38 )
      {
        if ( v38 != 2 )
        {
          v16 = v146;
          if ( v38 == 1 )
          {
            *v173 = -1;
            v173[1] = 0x7FFFFFFF;
          }
          goto LABEL_130;
        }
        goto LABEL_128;
      }
      v57 = *v173;
      v58 = v173[1];
      if ( !*(_QWORD *)v173 )
        goto LABEL_128;
      v16 = v146;
      if ( v174 >= __SPAIR64__(v58, v57) )
      {
        *v173 = v169 + v57;
        v173[1] = (v169 >> 31) + __CFADD__(v169, v57) + v58;
      }
      else
      {
        *v173 = -1;
        v173[1] = 0x7FFFFFFF;
      }
    }
    else
    {
      if ( !curl_strnequal("expires", i, 7) )
        goto LABEL_129;
      v36 = v173;
      v16 = v146;
      if ( v24 <= 0x7F && !*(_QWORD *)v173 )
      {
        memcpy(dest, sa, v24);
        *((_BYTE *)dest + v24) = 0;
        v54 = Curl_getdate_capped(dest);
        *(_QWORD *)v173 = v54;
        if ( v54 )
        {
          v16 = v146;
          if ( v54 < 0 )
          {
            v173[1] = 0;
            *v173 = 0;
          }
          goto LABEL_130;
        }
LABEL_128:
        v36[1] = 0;
        *v36 = 1;
LABEL_129:
        v16 = v146;
        goto LABEL_130;
      }
    }
    goto LABEL_130;
  }
  if ( v17 != 6 )
  {
    if ( v17 != 4 )
      goto LABEL_130;
    if ( !curl_strnequal("path", i, 4) )
      goto LABEL_129;
    Curl_cfree(*(_DWORD *)(v151 + 12));
    v27 = Curl_strndup(sa, v24);
    *(_DWORD *)(v151 + 12) = v27;
    if ( !v27 )
      goto LABEL_307;
    Curl_cfree(*(_DWORD *)(v151 + 16));
    v28 = (const char *)Curl_cstrdup(*(_DWORD *)(v151 + 12));
    if ( !v28 )
    {
      *(_DWORD *)(v151 + 16) = 0;
      goto LABEL_307;
    }
    v29 = (char *)v28;
    v30 = strlen(v28);
    v31 = v30;
    if ( *v29 == 34 )
    {
      memmove(v29, v29 + 1, v30);
      --v31;
    }
    if ( v31 )
    {
      if ( v29[v31 - 1] == 34 )
        v29[--v31] = 0;
    }
    else
    {
      v31 = 0;
    }
    if ( *v29 == 47 )
    {
      if ( v31 && v29[v31 - 1] == 47 )
        v29[v31 - 1] = 0;
      v16 = v146;
      *(_DWORD *)(v151 + 16) = v29;
    }
    else
    {
      Curl_cfree(v29);
      v53 = Curl_strndup("/", 1);
      v16 = v146;
      *(_DWORD *)(v151 + 16) = v53;
      if ( !v53 )
        goto LABEL_307;
    }
    goto LABEL_130;
  }
  v39 = curl_strnequal("domain", i, 6);
  if ( !v24 || !v39 )
    goto LABEL_129;
  v40 = sa + 1;
  if ( *sa != 46 )
    v40 = sa;
  v41 = v24 - (*sa == 46);
  if ( v41 == 9 && curl_strnequal(v40, "localhost", 9)
    || (v42 = memchr(v40, 46, v41)) != 0 && (unsigned int)(&v40[v41] - v42) > 1 )
  {
    v48 = v40;
    if ( domain )
      v48 = domain;
    is_ipnum = Curl_host_is_ipnum(v48);
    if ( domain )
    {
      v43 = domain;
      if ( !is_ipnum )
        goto LABEL_97;
LABEL_86:
      v44 = v43;
      domain = v43;
      if ( strncmp(v40, v43, v41) )
        goto LABEL_102;
      v45 = strlen(v44);
      is_ipnum = 1;
      if ( v41 != v45 )
        goto LABEL_102;
    }
    else
    {
      domain = 0;
    }
  }
  else
  {
    v123 = (unsigned __int8)Curl_host_is_ipnum(":") == 0;
    v43 = ":";
    if ( !v123 )
      goto LABEL_86;
LABEL_97:
    v49 = v41;
    v50 = v43;
    v51 = strlen(v43);
    domain = v50;
    if ( v51 < v49 || (sb = v51, v52 = &v50[v51 - v49], !curl_strnequal(v40, v52, v49)) || sb != v49 && *(v52 - 1) != 46 )
    {
LABEL_102:
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      {
        v166 = 1;
        Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v40);
        v16 = v146;
      }
      else
      {
        v16 = v146;
        v166 = 1;
      }
      goto LABEL_130;
    }
    is_ipnum = 0;
    v41 = v49;
  }
  sf = is_ipnum;
  Curl_cfree(*(_DWORD *)(v151 + 20));
  timer = (time_t *)v40;
  v55 = v151;
  v56 = Curl_strndup(timer, v41);
  *(_DWORD *)(v151 + 20) = v56;
  if ( !sf && v56 )
  {
    v16 = v146;
    *(_BYTE *)(v151 + 32) = 1;
    goto LABEL_130;
  }
  v16 = v146;
  if ( v56 )
    goto LABEL_130;
  v166 = 1;
LABEL_210:
  v93 = v166;
  if ( (v166 & 1) != 0 )
  {
    v94 = path;
    goto LABEL_218;
  }
  if ( !domain )
  {
    v94 = path;
    if ( (v166 & 1) != 0 )
      goto LABEL_253;
    goto LABEL_219;
  }
  v94 = path;
  if ( *(_DWORD *)(v55 + 20) )
  {
LABEL_218:
    if ( (v166 & 1) != 0 )
      goto LABEL_253;
LABEL_219:
    if ( !v94 || *(_DWORD *)(v55 + 12) )
      goto LABEL_253;
    v167 = v93;
    v97 = strchr(v94, 63);
    if ( v97 )
      v98 = (char *)Curl_memrchr(v94, 47, v97 - v94);
    else
      v98 = strrchr(v94, 47);
    if ( !v98 )
    {
      v93 = v167;
      goto LABEL_253;
    }
    v99 = v98 - v94;
    v100 = (void *)Curl_cmalloc(v98 - v94 + 2);
    *(_DWORD *)(v55 + 12) = v100;
    if ( !v100 )
      goto LABEL_307;
    v101 = v99 + 1;
    memcpy(v100, path, v101);
    *(_BYTE *)(*(_DWORD *)(v151 + 12) + v101) = 0;
    v102 = (const char *)Curl_cstrdup(*(_DWORD *)(v151 + 12));
    if ( v102 )
    {
      v103 = (char *)v102;
      v104 = strlen(v102);
      v105 = v104;
      if ( *v103 == 34 )
      {
        memmove(v103, v103 + 1, v104);
        --v105;
      }
      if ( v105 )
      {
        if ( v103[v105 - 1] == 34 )
          v103[--v105] = 0;
      }
      else
      {
        v105 = 0;
      }
      if ( *v103 == 47 )
      {
        if ( v105 )
        {
          v106 = v167;
          if ( v103[v105 - 1] == 47 )
            v103[v105 - 1] = 0;
          goto LABEL_250;
        }
      }
      else
      {
        Curl_cfree(v103);
        v103 = (char *)Curl_strndup("/", 1);
      }
      v106 = v167;
    }
    else
    {
      v106 = v167;
      v103 = 0;
    }
LABEL_250:
    v107 = 1;
    *(_DWORD *)(v151 + 16) = v103;
    if ( v103 )
      v107 = v106;
    v93 = v107;
    goto LABEL_253;
  }
  v95 = Curl_cstrdup(domain);
  *(_DWORD *)(v55 + 20) = v95;
  v96 = 1;
  if ( v95 )
    v96 = v166;
  v93 = v96;
  if ( (v96 & 1) == 0 )
    goto LABEL_219;
LABEL_253:
  if ( (v93 & 1) != 0 || !*(_DWORD *)(v151 + 4) )
    goto LABEL_307;
  ++data->req.setcookies;
  v11 = v151;
LABEL_256:
  v108 = *(_BYTE *)(v11 + 40);
  v9 = 0;
  if ( (v108 & 1) != 0 && !*(_BYTE *)(v11 + 33)
    || (v108 & 2) != 0
    && (!*(_BYTE *)(v11 + 33)
     || !*(_DWORD *)(v11 + 12)
     || strcmp(*(const char **)(v11 + 12), "/")
     || *(_BYTE *)(v11 + 32))
    || !(running = c->running) && c->newsession && !*(_QWORD *)(v11 + 24) )
  {
    Curl_cfree(*(_DWORD *)(v11 + 20));
    Curl_cfree(*(_DWORD *)(v11 + 12));
    Curl_cfree(*(_DWORD *)(v11 + 16));
    Curl_cfree(*(_DWORD *)(v11 + 4));
    Curl_cfree(*(_DWORD *)(v11 + 8));
    Curl_cfree(v11);
    return v9;
  }
  *(_BYTE *)(v11 + 34) = running;
  v110 = c->lastct + 1;
  c->lastct = v110;
  *(_DWORD *)(v11 + 36) = v110;
  if ( !noexpire )
  {
    sc = time(0);
    next_expiration = c->next_expiration;
    next_expiration_high = HIDWORD(c->next_expiration);
    if ( sc >= __SPAIR64__(next_expiration_high, next_expiration)
      || !(~next_expiration | next_expiration_high ^ 0x7FFFFFFF) )
    {
      c->next_expiration = 0x7FFFFFFFFFFFFFFFLL;
      v132 = 0;
      do
      {
        v133 = c;
        v168 = v132;
        v134 = c->cookies[v132];
        if ( v134 )
        {
          v150 = 0;
          v171 = &c->cookies[v132];
          do
          {
            while ( 1 )
            {
              v135 = v134;
              v134 = v134->next;
              LODWORD(v136) = v135->expires;
              expires_high = HIDWORD(v135->expires);
              if ( !v135->expires )
                break;
              HIDWORD(v136) = HIDWORD(v135->expires);
              if ( v136 >= sc )
                break;
              p_next = &v150->next;
              if ( !v150 )
                p_next = v171;
              *p_next = v134;
              --v133->numcookies;
              Curl_cfree(v135->domain);
              Curl_cfree(v135->path);
              Curl_cfree(v135->spath);
              Curl_cfree(v135->name);
              Curl_cfree(v135->value);
              Curl_cfree(v135);
              v133 = c;
              if ( !v134 )
                goto LABEL_322;
            }
            if ( expires_high | (unsigned int)v136 )
            {
              HIDWORD(v136) = HIDWORD(v135->expires);
              if ( v136 < v133->next_expiration )
              {
                LODWORD(v133->next_expiration) = v136;
                HIDWORD(v133->next_expiration) = expires_high;
              }
            }
            v150 = v135;
          }
          while ( v134 );
        }
LABEL_322:
        v132 = v168 + 1;
      }
      while ( v168 != 62 );
    }
  }
  v9 = (Cookie *)v151;
  s_4c = cookiehash(*(const char *const *)(v151 + 20));
  next = c->cookies[s_4c];
  if ( !next )
  {
    v130 = c;
    v115 = 0;
    v131 = 0;
    goto LABEL_337;
  }
  v114 = 0;
  v149 = 0;
  sd = 0;
  while ( 2 )
  {
    v115 = next;
    if ( curl_strequal(next->name, *(_DWORD *)(v151 + 4)) )
    {
      v116 = v115->domain;
      v117 = *(_DWORD *)(v151 + 20);
      if ( v116 )
      {
        if ( v117 && curl_strequal(v116, *(_DWORD *)(v151 + 20)) )
        {
LABEL_272:
          spath = v115->spath;
          if ( spath && *(_DWORD *)(v151 + 16) && v115->secure && !*(_BYTE *)(v151 + 33) && !secure )
          {
            v170 = *(_DWORD *)(v151 + 16);
            v119 = strchr(spath + 1, 47);
            v120 = v119 ? v119 - spath : strlen(spath);
            if ( curl_strnequal(spath, v170, v120) )
            {
              if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
                Curl_infof(
                  data,
                  "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                  *(_DWORD *)(v151 + 4));
              goto LABEL_307;
            }
          }
        }
      }
      else if ( !v117 )
      {
        goto LABEL_272;
      }
    }
    if ( !v149 )
    {
      v149 = 0;
      if ( curl_strequal(v115->name, *(_DWORD *)(v151 + 4)) )
      {
        v121 = v115->domain;
        v122 = *(_DWORD *)(v151 + 20);
        if ( !v121 )
        {
          v123 = v122 == 0;
          goto LABEL_286;
        }
        if ( v122 && curl_strequal(v121, *(_DWORD *)(v151 + 20)) )
        {
          v123 = v115->tailmatch == *(_BYTE *)(v151 + 32);
LABEL_286:
          v124 = (unsigned __int8)sd;
          if ( v123 )
            v124 = 1;
        }
        else
        {
          v124 = sd;
        }
        sd = v124;
        if ( (v124 & 1) != 0 )
        {
          v125 = v115->spath;
          v126 = 0;
          v149 = 0;
          if ( v125 )
          {
            if ( !*(_DWORD *)(v151 + 16) )
            {
              v126 = v115->spath;
              goto LABEL_294;
            }
            if ( curl_strequal(v125, *(_DWORD *)(v151 + 16)) )
            {
              v126 = v115->spath;
              goto LABEL_294;
            }
            sd = 0;
            v149 = 0;
          }
          else
          {
LABEL_294:
            v127 = (unsigned __int8)sd;
            if ( (v126 == 0) != (*(_DWORD *)(v151 + 16) == 0) )
              v127 = 0;
            sd = v127;
            if ( (v127 & 1) != 0 )
            {
              if ( *(_BYTE *)(v151 + 34) )
              {
                v114 = v115;
                v149 = v151;
              }
              else
              {
                v114 = v115;
                v149 = v151;
                if ( v115->livecookie )
                  goto LABEL_307;
              }
            }
          }
        }
      }
    }
    next = v115->next;
    if ( v115->next )
      continue;
    break;
  }
  if ( v149 )
  {
    *(_DWORD *)v149 = v114->next;
    *(_DWORD *)(v149 + 36) = v114->creationtime;
    Curl_cfree(v114->name);
    Curl_cfree(v114->value);
    Curl_cfree(v114->domain);
    Curl_cfree(v114->path);
    Curl_cfree(v114->spath);
    *(_DWORD *)&v114->prefix = *(_DWORD *)(v149 + 40);
    *(_QWORD *)&v114->tailmatch = *(_QWORD *)(v149 + 32);
    v114->expires = *(_QWORD *)(v149 + 24);
    *(_QWORD *)&v114->spath = *(_QWORD *)(v149 + 16);
    v129 = *(_QWORD *)v149;
    *(_QWORD *)&v114->value = *(_QWORD *)(v149 + 8);
    *(_QWORD *)&v114->next = v129;
    Curl_cfree(v149);
    v9 = v114;
  }
  else
  {
    v9 = (Cookie *)v151;
  }
  v130 = c;
  v131 = sd;
LABEL_337:
  if ( data )
  {
    if ( v130->running )
    {
      se = v131;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      {
        v139 = "Replaced";
        if ( (v131 & 1) == 0 )
          v139 = "Added";
        v130 = c;
        Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v139);
        v131 = se;
      }
    }
  }
  if ( (v131 & 1) == 0 )
  {
    v140 = &v130->cookies[s_4c];
    if ( v115 )
      v140 = &v115->next;
    *v140 = v9;
    ++v130->numcookies;
  }
  LODWORD(v141) = v9->expires;
  v142 = HIDWORD(v9->expires);
  if ( v9->expires )
  {
    HIDWORD(v141) = HIDWORD(v9->expires);
    if ( v141 < v130->next_expiration )
    {
      LODWORD(v130->next_expiration) = v141;
      HIDWORD(v130->next_expiration) = v142;
    }
  }
  return v9;
}
