Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  int name; // esi
  char v9; // al
  size_t v10; // edi
  char *v11; // edx
  size_t v12; // ecx
  char v13; // al
  char v14; // al
  int v15; // eax
  int v16; // eax
  const char *value; // edi
  const char *v18; // eax
  char *v19; // eax
  bool v20; // di
  _BYTE *v21; // eax
  _BYTE *v22; // eax
  const char *v23; // eax
  int is_ipnum; // eax
  char v25; // al
  int v26; // eax
  char *v27; // eax
  char *v28; // eax
  char *v29; // eax
  _BOOL4 v30; // ecx
  int v31; // edi
  const char *v32; // esi
  char *v33; // eax
  char *v34; // eax
  int v35; // eax
  int (__cdecl *v36)(const char *); // edx
  int v37; // eax
  const char *v38; // eax
  int v39; // eax
  bool v40; // dl
  int v41; // eax
  int v42; // edx
  int v43; // eax
  char *v44; // eax
  char *v45; // eax
  unsigned __int8 prefix; // al
  Cookie *v47; // edi
  const char *v48; // eax
  bool running; // al
  Cookie *v50; // eax
  int v51; // eax
  CookieInfo *v52; // eax
  const char *spath; // edi
  Cookie *v54; // esi
  char *v55; // edx
  char *v56; // eax
  int v57; // edx
  size_t v58; // eax
  char *v59; // eax
  char *v60; // edx
  bool v61; // zf
  char *v62; // edx
  const char *v63; // eax
  unsigned int v64; // edx
  unsigned int expires_high; // eax
  char *v66; // eax
  int v68; // edx
  int v69; // eax
  curl_off_t expires; // rax
  Cookie *v71; // eax
  Curl_easy *v73; // [esp-Ch] [ebp-F0h]
  Curl_easy *v74; // [esp-8h] [ebp-ECh]
  char *v75; // [esp+0h] [ebp-E4h]
  __int64 v76; // [esp+Ch] [ebp-D8h]
  bool badcookie; // [esp+15h] [ebp-CFh]
  char sep; // [esp+17h] [ebp-CDh]
  bool sepa; // [esp+17h] [ebp-CDh]
  bool sepb; // [esp+17h] [ebp-CDh]
  char *v81; // [esp+18h] [ebp-CCh]
  size_t myhash; // [esp+1Ch] [ebp-C8h]
  Cookie *lastc; // [esp+20h] [ebp-C4h]
  Cookie *lastca; // [esp+20h] [ebp-C4h]
  int (__cdecl *replace_olda)(const char *); // [esp+24h] [ebp-C0h]
  int replace_oldb; // [esp+24h] [ebp-C0h]
  bool replace_oldc; // [esp+24h] [ebp-C0h]
  char replace_oldd; // [esp+24h] [ebp-C0h]
  _BYTE *pathlen; // [esp+30h] [ebp-B4h]
  Cookie *pathlena; // [esp+30h] [ebp-B4h]
  unsigned int pathlenb; // [esp+30h] [ebp-B4h]
  signed int vlen; // [esp+34h] [ebp-B0h]
  size_t vlena; // [esp+34h] [ebp-B0h]
  bool vlenb; // [esp+34h] [ebp-B0h]
  bool vlene; // [esp+34h] [ebp-B0h]
  Cookie *vlenc; // [esp+34h] [ebp-B0h]
  size_t vlend; // [esp+34h] [ebp-B0h]
  Cookie *co; // [esp+38h] [ebp-ACh]
  char *tok_buf; // [esp+44h] [ebp-A0h] BYREF
  char date[128]; // [esp+48h] [ebp-9Ch] BYREF
  unsigned int v102; // [esp+C8h] [ebp-1Ch]

  name = (int)lineptr;
  v102 = __readgsdword(0x14u);
  vlen = time(0);
  if ( data->req.setcookies > 0x31u )
    return 0;
  co = (Cookie *)Curl_ccalloc(1, 44, data, data);
  if ( !co )
    return 0;
  if ( !httpheader )
  {
    tok_buf = 0;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      name = (int)(lineptr + 10);
      co->httponly = 1;
    }
    if ( *(_BYTE *)name != 35 )
    {
      v27 = strchr((const char *)name, 13);
      if ( v27 )
        *v27 = 0;
      v28 = strchr((const char *)name, 10);
      if ( v28 )
        *v28 = 0;
      v29 = strtok_r((char *)name, "\t", &tok_buf);
      v30 = httpheader;
      v31 = 0;
      v32 = v29;
      v33 = (char *)&Curl_cstrdup;
      while ( 1 )
      {
        vlenb = !v30 && v32 != 0;
        if ( !vlenb )
        {
          if ( v31 == 6 )
          {
            vlene = v30;
            v43 = Curl_cstrdup(&LC1);
            LOBYTE(v30) = vlene;
            co->value = (char *)v43;
            v31 = 7;
            if ( !v43 )
              goto LABEL_191;
          }
          if ( v31 != 7 || v30 )
            goto LABEL_191;
          goto LABEL_157;
        }
        switch ( v31 )
        {
          case 0:
            if ( *v32 == 46 )
              ++v32;
            v34 = (char *)Curl_cstrdup(v32);
            co->domain = v34;
            goto LABEL_127;
          case 1:
            LOBYTE(v33) = !v30 && v32 != 0;
            co->tailmatch = curl_strequal(v32, "TRUE", v33, v33) != 0;
            goto LABEL_142;
          case 2:
            v35 = strcmp("TRUE", v32);
            v36 = (int (__cdecl *)(const char *))Curl_cstrdup;
            if ( v35
              && (replace_olda = (int (__cdecl *)(const char *))Curl_cstrdup,
                  v37 = strcmp("FALSE", v32),
                  v36 = replace_olda,
                  v37) )
            {
              v38 = (const char *)replace_olda(v32);
              co->path = (char *)v38;
              if ( v38 )
              {
                v34 = sanitize_cookie_path(v38);
                co->spath = v34;
LABEL_127:
                vlenb = v34 == 0;
              }
            }
            else
            {
              replace_oldb = v36("/");
              co->path = (char *)replace_oldb;
              v39 = Curl_cstrdup("/");
              v40 = vlenb;
              co->spath = (char *)v39;
              if ( v39 )
              {
                v30 = replace_oldb;
                v40 = replace_oldb == 0;
              }
LABEL_131:
              replace_oldc = v40;
              co->secure = 0;
              if ( !curl_strequal(v32, "TRUE", v30, v30) )
                goto LABEL_143;
              if ( secure || (v31 = 3, c->running) )
              {
                co->secure = 1;
LABEL_143:
                vlenb = replace_oldc;
                v31 = 3;
              }
            }
LABEL_144:
            ++v31;
            v33 = strtok_r(0, "\t", &tok_buf);
            LOBYTE(v30) = vlenb;
            v32 = v33;
            break;
          case 3:
            v40 = httpheader;
            goto LABEL_131;
          case 4:
            vlenb = curlx_strtoofft(v32, 0, 10, &co->expires) != 0;
            goto LABEL_144;
          case 5:
            v41 = Curl_cstrdup(v32);
            co->name = (char *)v41;
            if ( !v41 )
              goto LABEL_144;
            if ( curl_strnequal("__Secure-", v41, 9, v42) )
            {
              co->prefix |= 1u;
LABEL_142:
              vlenb = httpheader;
            }
            else
            {
              vlenb = httpheader;
              if ( curl_strnequal("__Host-", co->name, 7, v32) )
                co->prefix |= 2u;
            }
            goto LABEL_144;
          case 6:
            v34 = (char *)Curl_cstrdup(v32);
            co->value = v34;
            goto LABEL_127;
          default:
            goto LABEL_142;
        }
      }
    }
LABEL_111:
    Curl_cfree(co);
    return 0;
  }
  badcookie = 0;
  if ( strlen(lineptr) > 0x1388 )
    goto LABEL_111;
  v76 = vlen;
  while ( 1 )
  {
    v9 = *(_BYTE *)name;
    sep = *(_BYTE *)name;
    if ( !*(_BYTE *)name || v9 != 32 && v9 != 9 )
      break;
LABEL_8:
    ++name;
  }
  v10 = strcspn((const char *)name, ";\t\r\n=");
  v11 = (char *)(name + v10);
  if ( !v10 )
  {
    v81 = (char *)name;
    goto LABEL_97;
  }
  while ( 1 )
  {
    v12 = v10--;
    v13 = *(_BYTE *)(name + v10);
    if ( v13 != 32 && v13 != 9 )
      break;
    if ( !v10 )
      goto LABEL_16;
  }
  v10 = v12;
LABEL_16:
  if ( *v11 == 61 )
  {
    v75 = v11;
    pathlen = v11 + 1;
    vlena = strcspn(v11 + 1, ";\r\n");
    v81 = &pathlen[vlena];
    while ( vlena )
    {
      v12 = vlena - 1;
      v14 = v75[vlena];
      if ( v14 != 32 && v14 != 9 )
      {
        while ( 1 )
        {
          LOBYTE(v11) = *pathlen == 32 || *pathlen == 9;
          if ( !(_BYTE)v11 )
            break;
          ++pathlen;
          if ( !--vlena )
            goto LABEL_30;
        }
        if ( memchr(pathlen, 9, vlena) )
        {
          freecookie(co);
          if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
            Curl_infof(data, "cookie contains TAB, dropping", name, name);
          return 0;
        }
        break;
      }
      --vlena;
    }
    LOBYTE(v11) = httpheader;
  }
  else
  {
    v81 = v11;
    LOBYTE(v11) = 0;
    pathlen = 0;
    vlena = 0;
  }
LABEL_30:
  if ( v10 > 0xFFE || vlena > 0xFFE || v10 + vlena > 0x1000 )
  {
    freecookie(co);
    if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
      Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v10, vlena);
    return 0;
  }
  if ( v10 > 6 && sep == 95 && *(_BYTE *)(name + 1) == 95 )
  {
    sepa = (char)v11;
    v15 = curl_strnequal("__Secure-", name, 9, v12);
    LOBYTE(v11) = sepa;
    if ( v15 )
    {
      co->prefix |= 1u;
    }
    else
    {
      v16 = curl_strnequal("__Host-", name, 7, v11);
      LOBYTE(v11) = sepa;
      if ( v16 )
        co->prefix |= 2u;
    }
  }
  if ( co->name )
  {
    if ( vlena )
      goto LABEL_51;
    if ( v10 == 6 )
    {
      sepb = (char)v11;
      if ( curl_strnequal("secure", name, 6, co) )
      {
        if ( !secure && c->running )
          goto LABEL_191;
        co->secure = 1;
        goto LABEL_97;
      }
      if ( !sepb )
        goto LABEL_97;
      goto LABEL_68;
    }
    if ( v10 == 8 )
    {
      if ( curl_strnequal("httponly", name, 8, co) )
        co->httponly = 1;
      goto LABEL_97;
    }
    if ( !(_BYTE)v11 )
      goto LABEL_97;
LABEL_51:
    if ( v10 == 4 )
    {
      if ( curl_strnequal("path", name, 4, 4) )
      {
        strstore(&co->path, pathlen, vlena);
        if ( !co->path )
          goto LABEL_191;
        Curl_cfree(co->spath);
        v19 = sanitize_cookie_path(co->path);
        co->spath = v19;
        if ( !v19 )
          goto LABEL_191;
      }
      goto LABEL_97;
    }
    if ( v10 == 6 )
    {
LABEL_68:
      v20 = (vlena != 0) & (curl_strnequal("domain", name, 6, v12) != 0);
      if ( !v20 )
        goto LABEL_97;
      v21 = pathlen;
      if ( *pathlen == 46 )
      {
        ++pathlen;
        --vlena;
      }
      if ( vlena == 9 && curl_strnequal(pathlen, "localhost", 9, v21)
        || (v22 = memchr(pathlen, 46, vlena)) != 0 && vlena - (v22 - pathlen) > 1 )
      {
        v23 = pathlen;
        if ( domain )
          v23 = domain;
      }
      else
      {
        v23 = ":";
        domain = ":";
      }
      is_ipnum = Curl_host_is_ipnum(v23);
      name = is_ipnum;
      if ( !domain )
        goto LABEL_81;
      if ( (_BYTE)is_ipnum )
      {
        if ( !strncmp(pathlen, domain, vlena) && strlen(domain) == vlena )
          goto LABEL_81;
      }
      else if ( cookie_tailmatch(pathlen, vlena, domain) )
      {
LABEL_81:
        strstore(&co->domain, pathlen, vlena);
        if ( !co->domain )
          goto LABEL_191;
        if ( !(_BYTE)name )
          co->tailmatch = 1;
        goto LABEL_97;
      }
      badcookie = v20;
      if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
        Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", pathlen, data);
      goto LABEL_97;
    }
    if ( v10 != 7 || curl_strnequal("version", name, 7, co) )
      goto LABEL_97;
    if ( curl_strnequal("max-age", name, 7, 0) )
    {
      if ( *pathlen == 34 )
        ++pathlen;
      v69 = curlx_strtoofft(pathlen, 0, 10, &co->expires);
      if ( v69 != 1 )
      {
        if ( v69 == 2 )
          goto LABEL_240;
        if ( v69 )
          goto LABEL_97;
        expires = co->expires;
        if ( !expires )
        {
LABEL_240:
          v71 = co;
          goto LABEL_248;
        }
        name = -1 - v76;
        if ( 0x7FFFFFFFFFFFFFFFLL - v76 >= expires )
        {
          co->expires = v76 + expires;
          goto LABEL_97;
        }
      }
      LODWORD(co->expires) = -1;
      HIDWORD(co->expires) = 0x7FFFFFFF;
      goto LABEL_97;
    }
    if ( !curl_strnequal("expires", name, 7, v68) || co->expires || vlena > 0x7F )
      goto LABEL_97;
    qmemcpy(date, pathlen, vlena);
    date[vlena] = 0;
    name = Curl_getdate_capped(date);
    v71 = co;
    if ( name )
    {
      if ( name >> 31 != -1 )
      {
        co->expires = name;
        goto LABEL_97;
      }
      LODWORD(co->expires) = 0;
    }
    else
    {
LABEL_248:
      LODWORD(v71->expires) = 1;
    }
    HIDWORD(v71->expires) = 0;
    goto LABEL_97;
  }
  if ( !(_BYTE)v11 )
    goto LABEL_191;
  strstore(&co->name, (const char *)name, v10);
  strstore(&co->value, pathlen, vlena);
  name = (int)co->name;
  if ( !name )
    goto LABEL_191;
  value = co->value;
  if ( !value )
    goto LABEL_191;
  if ( value[strcspn(value, badoctets_0)] || *(_BYTE *)(name + strcspn((const char *)name, badoctets_0)) )
  {
    if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
    {
      v74 = data;
      v73 = data;
      v18 = "invalid octets in name/value, cookie dropped";
      goto LABEL_189;
    }
    goto LABEL_191;
  }
  while ( 1 )
  {
LABEL_97:
    v25 = *v81;
    if ( !*v81 )
      goto LABEL_103;
    if ( v25 != 32 && v25 != 9 )
      break;
    ++v81;
  }
  if ( v25 == 59 )
  {
    name = (int)v81;
    goto LABEL_8;
  }
LABEL_103:
  if ( badcookie )
    goto LABEL_191;
  if ( !co->domain )
  {
    if ( domain )
    {
      v26 = Curl_cstrdup(domain);
      co->domain = (char *)v26;
      if ( !v26 )
        goto LABEL_191;
    }
  }
  if ( !co->path && path )
  {
    v44 = strchr(path, 63);
    v45 = v44 ? (char *)Curl_memrchr(path, 47, v44 - path, name) : strrchr(path, 47);
    if ( v45 )
    {
      pathlenb = v45 - path + 1;
      vlend = v45 - path;
      v59 = (char *)Curl_cmalloc(v45 - path + 2);
      co->path = v59;
      if ( !v59 )
        goto LABEL_191;
      qmemcpy(v59, path, pathlenb);
      co->path[vlend + 1] = 0;
      v66 = sanitize_cookie_path(co->path);
      co->spath = v66;
      if ( !v66 )
        goto LABEL_191;
    }
  }
  if ( !co->name )
    goto LABEL_191;
  ++data->req.setcookies;
LABEL_157:
  prefix = co->prefix;
  if ( (prefix & 1) != 0 )
  {
    v47 = co;
    if ( !co->secure )
      goto LABEL_167;
  }
  if ( (prefix & 2) != 0 )
  {
    if ( !co->secure )
      goto LABEL_191;
    v48 = co->path;
    if ( !v48 || strcmp(v48, "/") || co->tailmatch )
      goto LABEL_191;
  }
  running = c->running;
  if ( !running && c->newsession )
  {
    v47 = co;
    if ( !co->expires )
    {
LABEL_167:
      v50 = v47;
      goto LABEL_192;
    }
  }
  co->livecookie = running;
  v51 = c->lastct + 1;
  c->lastct = v51;
  co->creationtime = v51;
  if ( !noexpire )
    remove_expired(c);
  replace_oldd = 0;
  myhash = cookiehash(co->domain);
  v52 = c;
  vlenc = 0;
  spath = (const char *)myhash;
  pathlena = 0;
  lastc = 0;
  v54 = c->cookies[myhash];
  while ( 2 )
  {
    if ( !v54 )
    {
      if ( pathlena )
      {
        pathlena->next = vlenc->next;
        pathlena->creationtime = vlenc->creationtime;
        Curl_cfree(vlenc->name);
        Curl_cfree(vlenc->value);
        Curl_cfree(vlenc->domain);
        Curl_cfree(vlenc->path);
        Curl_cfree(vlenc->spath);
        qmemcpy(vlenc, pathlena, sizeof(Cookie));
        Curl_cfree(pathlena);
        co = vlenc;
      }
      if ( c->running && (*(&data->set.connect_only + 4) & 0x20) != 0 )
      {
        v63 = "Replaced";
        if ( !replace_oldd )
          v63 = "Added";
        Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v63, co->name);
      }
      if ( !replace_oldd )
      {
        if ( lastc )
          lastc->next = co;
        else
          c->cookies[myhash] = co;
        ++c->numcookies;
      }
      v64 = co->expires;
      expires_high = HIDWORD(co->expires);
      if ( co->expires && __SPAIR64__(expires_high, v64) < c->next_expiration )
      {
        LODWORD(c->next_expiration) = v64;
        HIDWORD(c->next_expiration) = expires_high;
      }
      return co;
    }
    v52 = (CookieInfo *)curl_strequal(v54->name, co->name, v52, v52);
    if ( !v52 )
      goto LABEL_172;
    v55 = v54->domain;
    v52 = (CookieInfo *)co->domain;
    if ( v55 )
    {
      if ( v52 )
      {
        v52 = (CookieInfo *)curl_strequal(v55, v52, spath, spath);
        if ( v52 )
          goto LABEL_179;
      }
      goto LABEL_172;
    }
    if ( v52 )
      goto LABEL_172;
LABEL_179:
    spath = v54->spath;
    if ( !spath
      || (v52 = (CookieInfo *)co->spath, (lastca = (Cookie *)v52) == 0)
      || !v54->secure
      || (v52 = (CookieInfo *)co, co->secure)
      || secure
      || ((v56 = strchr(spath + 1, 47)) == 0 ? (v58 = strlen(spath)) : (v58 = v56 - spath),
          (v52 = (CookieInfo *)curl_strnequal(spath, lastca, v58, v57)) == 0) )
    {
LABEL_172:
      if ( pathlena )
        goto LABEL_173;
      v52 = (CookieInfo *)curl_strequal(v54->name, co->name, v52, v52);
      if ( !v52 )
        goto LABEL_173;
      v60 = v54->domain;
      v52 = (CookieInfo *)co->domain;
      if ( v60 )
      {
        if ( !v52 || (v52 = (CookieInfo *)curl_strequal(v60, v52, spath, spath)) == 0 )
        {
LABEL_198:
          if ( !replace_oldd )
            goto LABEL_173;
LABEL_203:
          v52 = (CookieInfo *)v54->spath;
          v62 = co->spath;
          if ( !v52 )
          {
LABEL_208:
            v52 = (CookieInfo *)co;
            LOBYTE(v52) = co->spath == 0;
            if ( (v54->spath == 0) == (_BYTE)v52 )
            {
              replace_oldd = co->livecookie;
              if ( replace_oldd )
              {
                v52 = (CookieInfo *)co;
                vlenc = v54;
                pathlena = co;
              }
              else
              {
                if ( v54->livecookie )
                  goto LABEL_191;
                v52 = (CookieInfo *)co;
                vlenc = v54;
                replace_oldd = 1;
                pathlena = co;
              }
              goto LABEL_173;
            }
            goto LABEL_213;
          }
          if ( v62 )
          {
            v52 = (CookieInfo *)curl_strequal(v52, v62, co, co);
            if ( v52 )
              goto LABEL_208;
          }
          else
          {
            pathlena = 0;
          }
LABEL_213:
          replace_oldd = 0;
LABEL_173:
          lastc = v54;
          v54 = v54->next;
          continue;
        }
        v52 = (CookieInfo *)co;
        LOBYTE(v52) = co->tailmatch;
        v61 = v54->tailmatch == (unsigned __int8)v52;
      }
      else
      {
        v61 = v52 == 0;
      }
      if ( v61 )
        goto LABEL_203;
      goto LABEL_198;
    }
    break;
  }
  if ( (*(&data->set.connect_only + 4) & 0x20) == 0 )
    goto LABEL_191;
  v74 = (Curl_easy *)co->domain;
  v73 = (Curl_easy *)co->name;
  v18 = "cookie '%s' for domain '%s' dropped, would overlay an existing cookie";
LABEL_189:
  Curl_infof(data, v18, v73, v74);
LABEL_191:
  v50 = co;
LABEL_192:
  freecookie(v50);
  return 0;
}
