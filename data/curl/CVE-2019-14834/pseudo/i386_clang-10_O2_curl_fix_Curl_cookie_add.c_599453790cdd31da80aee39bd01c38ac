Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        char *path,
        bool secure)
{
  time_t v8; // eax
  Cookie *v9; // ebp
  int v10; // eax
  int v11; // esi
  const char *j; // edx
  const char *v13; // ebp
  const char *i; // esi
  size_t v15; // eax
  const char *v16; // edx
  unsigned int v17; // edi
  char v18; // cl
  size_t v19; // eax
  size_t v20; // ecx
  const char *v21; // edx
  const char *v22; // ebp
  char v23; // cl
  size_t v24; // ebp
  char v25; // cl
  int v26; // eax
  int v27; // eax
  const char *v28; // eax
  char *v29; // edi
  size_t v30; // eax
  size_t v31; // esi
  const char *v32; // eax
  const char *v33; // esi
  size_t v34; // eax
  int v35; // eax
  int *v36; // esi
  const char *v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // ecx
  int v41; // eax
  const char *v42; // esi
  size_t v43; // ebp
  _BYTE *v44; // eax
  const char *v45; // eax
  const char *v46; // edi
  size_t v47; // eax
  char is_ipnum; // cl
  int v49; // eax
  const char *v50; // eax
  size_t v51; // edi
  const char *v52; // ebp
  size_t v53; // eax
  const char *v54; // ebp
  int v55; // eax
  int v56; // eax
  int v57; // esi
  int v58; // eax
  int v59; // eax
  int v60; // ecx
  char v61; // cl
  char *v62; // edi
  char *v63; // eax
  char *v64; // eax
  char *v65; // eax
  const char *v66; // ebp
  int v67; // edx
  int v68; // ecx
  unsigned __int8 v69; // di
  int v70; // edi
  int v71; // eax
  const char *v72; // eax
  char *v73; // edi
  size_t v74; // eax
  size_t v75; // ebp
  char v76; // di
  int v77; // eax
  int v78; // ecx
  int v79; // edi
  int v80; // eax
  char v81; // di
  int v82; // eax
  int v83; // ecx
  int v84; // edi
  int v85; // eax
  int v86; // edi
  CookieInfo *v87; // eax
  int v88; // eax
  int v89; // ecx
  int v90; // eax
  char *v91; // eax
  int v92; // edi
  int v93; // eax
  _DWORD *v94; // edi
  char v95; // al
  const char *v96; // ebp
  int v97; // eax
  char v98; // cl
  char *v99; // eax
  char *v100; // eax
  int v101; // edi
  void *v102; // eax
  size_t v103; // edi
  const char *v104; // eax
  char *v105; // edi
  size_t v106; // eax
  size_t v107; // ebp
  char v108; // al
  char v109; // cl
  char v110; // al
  bool running; // al
  int v112; // eax
  unsigned int next_expiration; // eax
  unsigned int next_expiration_high; // ecx
  Cookie *next; // eax
  Cookie *v116; // edi
  Cookie *v117; // esi
  char *v118; // eax
  int v119; // ecx
  const char *spath; // ebp
  char *v121; // eax
  size_t v122; // eax
  char *v123; // eax
  int v124; // ecx
  bool v125; // zf
  int v126; // eax
  char *v127; // eax
  char *v128; // ecx
  int v129; // eax
  __int64 v131; // xmm0_8
  CookieInfo *v132; // edi
  char v133; // al
  int v134; // eax
  CookieInfo *v135; // edi
  Cookie *v136; // esi
  Cookie *v137; // ebp
  curl_off_t v138; // rax
  int expires_high; // ecx
  Cookie **p_next; // eax
  const char *v141; // ecx
  Cookie **v142; // eax
  curl_off_t v143; // rax
  int v144; // ecx
  time_t *timer; // [esp+0h] [ebp-ECh]
  size_t n; // [esp+8h] [ebp-E4h]
  char v147; // [esp+30h] [ebp-BCh]
  const char *v148; // [esp+30h] [ebp-BCh]
  int v149; // [esp+30h] [ebp-BCh]
  unsigned __int8 v150; // [esp+30h] [ebp-BCh]
  int v151; // [esp+30h] [ebp-BCh]
  Cookie *v152; // [esp+30h] [ebp-BCh]
  int v153; // [esp+34h] [ebp-B8h]
  const char *s; // [esp+38h] [ebp-B4h]
  const char *sa; // [esp+38h] [ebp-B4h]
  size_t sb; // [esp+38h] [ebp-B4h]
  char sf; // [esp+38h] [ebp-B4h]
  time_t sc; // [esp+38h] [ebp-B4h]
  int sd; // [esp+38h] [ebp-B4h]
  char se; // [esp+38h] [ebp-B4h]
  size_t s_4d; // [esp+3Ch] [ebp-B0h]
  size_t s_4; // [esp+3Ch] [ebp-B0h]
  char s_4a; // [esp+3Ch] [ebp-B0h]
  char s_4e; // [esp+3Ch] [ebp-B0h]
  char s_4f; // [esp+3Ch] [ebp-B0h]
  int s_4b; // [esp+3Ch] [ebp-B0h]
  size_t s_4c; // [esp+3Ch] [ebp-B0h]
  char v168; // [esp+40h] [ebp-ACh]
  char v169; // [esp+40h] [ebp-ACh]
  int v170; // [esp+40h] [ebp-ACh]
  int v171; // [esp+44h] [ebp-A8h]
  int v172; // [esp+44h] [ebp-A8h]
  Cookie **v173; // [esp+44h] [ebp-A8h]
  int *v175; // [esp+4Ch] [ebp-A0h]
  __int64 v176; // [esp+54h] [ebp-98h]
  char *dest[36]; // [esp+5Ch] [ebp-90h] BYREF

  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return v9;
  v171 = v8;
  v10 = Curl_ccalloc(1, 44);
  if ( !v10 )
    return v9;
  v11 = v10;
  v153 = v10;
  if ( !httpheader )
  {
    dest[0] = 0;
    v62 = lineptr;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v62 = lineptr + 10;
      *(_BYTE *)(v11 + 35) = 1;
      if ( lineptr[10] == 35 )
        goto LABEL_140;
    }
    else if ( *lineptr == 35 )
    {
      goto LABEL_140;
    }
    v63 = strchr(v62, 13);
    if ( v63 )
      *v63 = 0;
    v64 = strchr(v62, 10);
    if ( v64 )
      *v64 = 0;
    v65 = strtok_r(v62, "\t", dest);
    if ( !v65 )
      goto LABEL_210;
    v66 = v65;
    v67 = 0;
    v68 = 0;
    s_4b = v11 + 24;
    while ( 1 )
    {
      switch ( v67 )
      {
        case 0:
          v69 = v68;
          if ( *v66 == 46 )
            ++v66;
          v88 = Curl_cstrdup(v66);
          *(_DWORD *)(v11 + 20) = v88;
          v89 = v69;
          if ( !v88 )
            v89 = 1;
          v70 = 0;
          v149 = v89;
          goto LABEL_202;
        case 1:
          v149 = v68;
          v70 = 1;
          *(_BYTE *)(v11 + 32) = curl_strequal(v66, "TRUE") != 0;
          goto LABEL_202;
        case 2:
          v150 = v68;
          if ( !strcmp("TRUE", v66) || !strcmp("FALSE", v66) )
          {
            v84 = Curl_cstrdup("/");
            *(_DWORD *)(v153 + 12) = v84;
            v11 = v153;
            v85 = Curl_cstrdup("/");
            *(_DWORD *)(v153 + 16) = v85;
            v68 = v150;
            if ( !v85 )
              v68 = 1;
            if ( !v84 )
              v68 = 1;
            goto LABEL_175;
          }
          v71 = Curl_cstrdup(v66);
          *(_DWORD *)(v11 + 12) = v71;
          if ( !v71 )
          {
            v90 = 1;
            goto LABEL_201;
          }
          v72 = (const char *)Curl_cstrdup(v71);
          if ( v72 )
          {
            v73 = (char *)v72;
            v74 = strlen(v72);
            v75 = v74;
            if ( *v73 == 34 )
            {
              memmove(v73, v73 + 1, v74);
              --v75;
            }
            if ( v75 )
            {
              if ( v73[v75 - 1] == 34 )
                v73[--v75] = 0;
            }
            else
            {
              v75 = 0;
            }
            if ( *v73 == 47 )
            {
              if ( v75 )
              {
                LOBYTE(v90) = v150;
                if ( v73[v75 - 1] == 47 )
                  v73[v75 - 1] = 0;
                goto LABEL_199;
              }
            }
            else
            {
              Curl_cfree(v73);
              v73 = (char *)Curl_strndup("/", 1);
            }
            LOBYTE(v90) = v150;
          }
          else
          {
            LOBYTE(v90) = v150;
            v73 = 0;
          }
LABEL_199:
          v90 = (unsigned __int8)v90;
          *(_DWORD *)(v11 + 16) = v73;
          if ( !v73 )
            v90 = 1;
LABEL_201:
          v149 = v90;
          v70 = 2;
LABEL_202:
          v91 = strtok_r(0, "\t", dest);
          v68 = v149;
          v92 = v70 + 1;
          v67 = v92;
          if ( (v149 & 1) != 0 || (v66 = v91) == 0 )
          {
            if ( v92 == 6 )
            {
              v93 = Curl_cstrdup(&L_str_22);
              *(_DWORD *)(v11 + 8) = v93;
              LOBYTE(v68) = 1;
              if ( v93 )
                LOBYTE(v68) = v149;
              v67 = (v93 == 0) ^ 7;
            }
            if ( (v68 & 1) == 0 && v67 == 7 )
              goto LABEL_257;
LABEL_210:
            v94 = (_DWORD *)v11;
            goto LABEL_309;
          }
          break;
        case 3:
LABEL_175:
          *(_BYTE *)(v11 + 33) = 0;
          v86 = v68;
          if ( !curl_strequal(v66, "TRUE") )
            goto LABEL_179;
          if ( secure || (v87 = c, c->running) )
          {
            *(_BYTE *)(v11 + 33) = 1;
LABEL_179:
            v149 = v86;
            v70 = 3;
          }
          else
          {
            LOBYTE(v87) = 1;
            v70 = 3;
            v149 = (int)v87;
          }
          goto LABEL_202;
        case 4:
          v76 = v68;
          v77 = curlx_strtoofft(v66, 0, 10, s_4b);
          LOBYTE(v78) = v76;
          v70 = 4;
          v78 = (unsigned __int8)v78;
          if ( v77 )
            v78 = 1;
          v149 = v78;
          goto LABEL_202;
        case 5:
          v79 = v68;
          v80 = Curl_cstrdup(v66);
          *(_DWORD *)(v11 + 4) = v80;
          if ( v80 )
          {
            v149 = v79;
            if ( curl_strnequal("__Secure-", v80, 9) )
            {
              *(_BYTE *)(v11 + 40) |= 1u;
              v70 = 5;
            }
            else
            {
              if ( curl_strnequal("__Host-", *(_DWORD *)(v11 + 4), 7) )
                *(_BYTE *)(v11 + 40) |= 2u;
              v70 = 5;
            }
          }
          else
          {
            v70 = 5;
            v149 = 1;
          }
          goto LABEL_202;
        case 6:
          v81 = v68;
          v82 = Curl_cstrdup(v66);
          LOBYTE(v83) = v81;
          *(_DWORD *)(v11 + 8) = v82;
          v70 = 6;
          v83 = (unsigned __int8)v83;
          if ( !v82 )
            v83 = 1;
          v149 = v83;
          goto LABEL_202;
        default:
          v149 = v68;
          v70 = v67;
          goto LABEL_202;
      }
    }
  }
  if ( strlen(lineptr) > 0x1388 )
  {
LABEL_140:
    Curl_cfree(v11);
    return v9;
  }
  v168 = 0;
  v175 = (int *)(v11 + 24);
  LODWORD(v176) = ~v171;
  HIDWORD(v176) = 0x7FFFFFFF - (v171 >> 31);
  j = lineptr;
  while ( 1 )
  {
    v13 = j + 1;
    for ( i = j; *i == 32 || *i == 9; ++i )
      ++v13;
    v147 = *i;
    v15 = strcspn(i, ";\t\r\n=");
    if ( !v15 )
    {
      v16 = i;
      goto LABEL_130;
    }
    v16 = &i[v15];
    v17 = v15;
    while ( 1 )
    {
      v18 = i[v17 - 1];
      if ( v18 != 32 && v18 != 9 )
        break;
      if ( !--v17 )
      {
        v17 = 0;
        if ( *v16 != 61 )
          goto LABEL_28;
        goto LABEL_16;
      }
    }
    if ( *v16 != 61 )
    {
LABEL_28:
      v24 = 0;
      v25 = 0;
      sa = 0;
      goto LABEL_34;
    }
LABEL_16:
    s_4d = v15;
    s = &i[v15 + 1];
    v19 = strcspn(s, ";\r\n");
    v20 = v19 + s_4d;
    s_4 = v19 + s_4d;
    if ( v19 )
    {
      v21 = s;
      v22 = &v13[v20];
      while ( 1 )
      {
        v23 = *(v22 - 1);
        if ( v23 != 32 && v23 != 9 )
          break;
        --v19;
        --v22;
        if ( !v19 )
          goto LABEL_31;
      }
      do
      {
        if ( *v21 != 32 && *v21 != 9 )
        {
          v24 = v19;
          goto LABEL_32;
        }
        ++v21;
        --v19;
      }
      while ( v19 );
      v21 = v22;
    }
    else
    {
      v21 = s;
    }
LABEL_31:
    v24 = 0;
LABEL_32:
    sa = v21;
    if ( memchr(v21, 9, v24) )
    {
      Curl_cfree(*(_DWORD *)(v153 + 20));
      Curl_cfree(*(_DWORD *)(v153 + 12));
      Curl_cfree(*(_DWORD *)(v153 + 16));
      Curl_cfree(*(_DWORD *)(v153 + 4));
      Curl_cfree(*(_DWORD *)(v153 + 8));
      Curl_cfree(v153);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
        Curl_infof(data, "cookie contains TAB, dropping", n);
      return v9;
    }
    v25 = 1;
    v16 = &i[s_4 + 1];
LABEL_34:
    if ( v17 > 0xFFE || v24 > 0xFFE || v24 + v17 >= 0x1001 )
    {
      Curl_cfree(*(_DWORD *)(v153 + 20));
      Curl_cfree(*(_DWORD *)(v153 + 12));
      Curl_cfree(*(_DWORD *)(v153 + 16));
      Curl_cfree(*(_DWORD *)(v153 + 4));
      Curl_cfree(*(_DWORD *)(v153 + 8));
      Curl_cfree(v153);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v17);
      return v9;
    }
    v125 = v147 == 95;
    v148 = v16;
    if ( v125 && v17 >= 7 && i[1] == 95 )
    {
      s_4a = v25;
      if ( curl_strnequal("__Secure-", i, 9) )
      {
        *(_BYTE *)(v153 + 40) |= 1u;
        v16 = v148;
        v25 = s_4a;
      }
      else
      {
        v26 = curl_strnequal("__Host-", i, 7);
        v16 = v148;
        v25 = s_4a;
        if ( v26 )
          *(_BYTE *)(v153 + 40) |= 2u;
      }
    }
    if ( !*(_DWORD *)(v153 + 4) )
    {
      if ( !v25 )
        goto LABEL_308;
      Curl_cfree(0);
      *(_DWORD *)(v153 + 4) = Curl_strndup(i, v17);
      Curl_cfree(*(_DWORD *)(v153 + 8));
      v32 = (const char *)Curl_strndup(sa, v24);
      *(_DWORD *)(v153 + 8) = v32;
      if ( !v32 )
        goto LABEL_308;
      v33 = *(const char **)(v153 + 4);
      if ( !v33 )
        goto LABEL_308;
      if ( v32[strcspn(v32, invalid_octets_badoctets)]
        || (v34 = strcspn(v33, invalid_octets_badoctets), v16 = v148, v33[v34]) )
      {
        if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
          Curl_infof(data, "invalid octets in name/value, cookie dropped", n);
LABEL_308:
        v94 = (_DWORD *)v153;
LABEL_309:
        Curl_cfree(v94[5]);
        Curl_cfree(v94[3]);
        Curl_cfree(v94[4]);
        Curl_cfree(v94[1]);
        Curl_cfree(v94[2]);
        Curl_cfree(v94);
        return 0;
      }
      goto LABEL_130;
    }
    if ( v24 )
      break;
    if ( v17 == 8 )
    {
      s_4f = v25;
      v49 = curl_strnequal("httponly", i, 8);
      v25 = s_4f;
      v16 = v148;
      if ( v49 )
      {
        *(_BYTE *)(v153 + 35) = 1;
        goto LABEL_130;
      }
    }
    else if ( v17 == 6 )
    {
      s_4e = v25;
      v35 = curl_strnequal("secure", i, 6);
      v25 = s_4e;
      v16 = v148;
      if ( v35 )
      {
        if ( !secure && c->running )
          goto LABEL_308;
        *(_BYTE *)(v153 + 33) = 1;
        goto LABEL_130;
      }
    }
    if ( v25 )
      break;
LABEL_130:
    v57 = v153;
    for ( j = v16 + 1; ; ++j )
    {
      v61 = *(j - 1);
      if ( v61 != 32 && v61 != 9 )
        break;
    }
    if ( v61 != 59 )
      goto LABEL_211;
  }
  if ( v17 == 7 )
  {
    if ( curl_strnequal("version", i, 7) )
      goto LABEL_129;
    if ( curl_strnequal("max-age", i, 7) )
    {
      v36 = v175;
      v37 = sa + 1;
      if ( *sa != 34 )
        v37 = sa;
      v38 = curlx_strtoofft(v37, 0, 10, v175);
      if ( v38 )
      {
        if ( v38 == 2 )
          goto LABEL_128;
        v16 = v148;
        if ( v38 != 1 )
          goto LABEL_130;
        v39 = -1;
        v40 = 0x7FFFFFFF;
      }
      else
      {
        v59 = *v175;
        v60 = v175[1];
        if ( !*(_QWORD *)v175 )
          goto LABEL_128;
        if ( v176 < __SPAIR64__(v60, v59) )
        {
          v16 = v148;
          *v175 = -1;
          v175[1] = 0x7FFFFFFF;
          goto LABEL_130;
        }
        v16 = v148;
        v40 = (v171 + __PAIR64__(v60, v59)) >> 32;
        v39 = v171 + v59;
      }
      *v175 = v39;
      v175[1] = v40;
    }
    else
    {
      if ( !curl_strnequal("expires", i, 7) )
        goto LABEL_129;
      v36 = v175;
      v16 = v148;
      if ( v24 <= 0x7F && !*(_QWORD *)v175 )
      {
        memcpy(dest, sa, v24);
        *((_BYTE *)dest + v24) = 0;
        v56 = Curl_getdate_capped(dest);
        *(_QWORD *)v175 = v56;
        if ( v56 )
        {
          v16 = v148;
          if ( v56 < 0 )
          {
            v175[1] = 0;
            *v175 = 0;
          }
          goto LABEL_130;
        }
LABEL_128:
        v36[1] = 0;
        *v36 = 1;
LABEL_129:
        v16 = v148;
        goto LABEL_130;
      }
    }
    goto LABEL_130;
  }
  if ( v17 != 6 )
  {
    if ( v17 != 4 )
      goto LABEL_130;
    if ( !curl_strnequal("path", i, 4) )
      goto LABEL_129;
    Curl_cfree(*(_DWORD *)(v153 + 12));
    v27 = Curl_strndup(sa, v24);
    *(_DWORD *)(v153 + 12) = v27;
    if ( !v27 )
      goto LABEL_308;
    Curl_cfree(*(_DWORD *)(v153 + 16));
    v28 = (const char *)Curl_cstrdup(*(_DWORD *)(v153 + 12));
    if ( !v28 )
    {
      *(_DWORD *)(v153 + 16) = 0;
      goto LABEL_308;
    }
    v29 = (char *)v28;
    v30 = strlen(v28);
    v31 = v30;
    if ( *v29 == 34 )
    {
      memmove(v29, v29 + 1, v30);
      --v31;
    }
    if ( v31 )
    {
      if ( v29[v31 - 1] == 34 )
        v29[--v31] = 0;
    }
    else
    {
      v31 = 0;
    }
    if ( *v29 == 47 )
    {
      if ( v31 && v29[v31 - 1] == 47 )
        v29[v31 - 1] = 0;
      v16 = v148;
      *(_DWORD *)(v153 + 16) = v29;
    }
    else
    {
      Curl_cfree(v29);
      v55 = Curl_strndup("/", 1);
      v16 = v148;
      *(_DWORD *)(v153 + 16) = v55;
      if ( !v55 )
        goto LABEL_308;
    }
    goto LABEL_130;
  }
  v41 = curl_strnequal("domain", i, 6);
  if ( !v24 || !v41 )
    goto LABEL_129;
  v42 = sa + 1;
  if ( *sa != 46 )
    v42 = sa;
  v43 = v24 - (*sa == 46);
  if ( v43 == 9 && curl_strnequal(v42, "localhost", 9)
    || (v44 = memchr(v42, 46, v43)) != 0 && (unsigned int)(&v42[v43] - v44) > 1 )
  {
    v50 = v42;
    if ( domain )
      v50 = domain;
    is_ipnum = Curl_host_is_ipnum(v50);
    if ( domain )
    {
      v45 = domain;
      if ( !is_ipnum )
        goto LABEL_97;
LABEL_86:
      v46 = v45;
      domain = v45;
      if ( strncmp(v42, v45, v43) )
        goto LABEL_102;
      v47 = strlen(v46);
      is_ipnum = 1;
      if ( v43 != v47 )
        goto LABEL_102;
    }
    else
    {
      domain = 0;
    }
  }
  else
  {
    v125 = (unsigned __int8)Curl_host_is_ipnum(":") == 0;
    v45 = ":";
    if ( !v125 )
      goto LABEL_86;
LABEL_97:
    v51 = v43;
    v52 = v45;
    v53 = strlen(v45);
    domain = v52;
    if ( v53 < v51 || (sb = v53, v54 = &v52[v53 - v51], !curl_strnequal(v42, v54, v51)) || sb != v51 && *(v54 - 1) != 46 )
    {
LABEL_102:
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      {
        v168 = 1;
        Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v42);
        v16 = v148;
      }
      else
      {
        v16 = v148;
        v168 = 1;
      }
      goto LABEL_130;
    }
    is_ipnum = 0;
    v43 = v51;
  }
  sf = is_ipnum;
  Curl_cfree(*(_DWORD *)(v153 + 20));
  timer = (time_t *)v42;
  v57 = v153;
  v58 = Curl_strndup(timer, v43);
  *(_DWORD *)(v153 + 20) = v58;
  if ( !sf && v58 )
  {
    v16 = v148;
    *(_BYTE *)(v153 + 32) = 1;
    goto LABEL_130;
  }
  v16 = v148;
  if ( v58 )
    goto LABEL_130;
  v168 = 1;
LABEL_211:
  v95 = v168;
  if ( (v168 & 1) != 0 )
  {
    v96 = path;
    goto LABEL_219;
  }
  if ( !domain )
  {
    v96 = path;
    if ( (v168 & 1) != 0 )
      goto LABEL_254;
    goto LABEL_220;
  }
  v96 = path;
  if ( *(_DWORD *)(v57 + 20) )
  {
LABEL_219:
    if ( (v168 & 1) != 0 )
      goto LABEL_254;
LABEL_220:
    if ( !v96 || *(_DWORD *)(v57 + 12) )
      goto LABEL_254;
    v169 = v95;
    v99 = strchr(v96, 63);
    if ( v99 )
      v100 = (char *)Curl_memrchr(v96, 47, v99 - v96);
    else
      v100 = strrchr(v96, 47);
    if ( !v100 )
    {
      v95 = v169;
      goto LABEL_254;
    }
    v101 = v100 - v96;
    v102 = (void *)Curl_cmalloc(v100 - v96 + 2);
    *(_DWORD *)(v57 + 12) = v102;
    if ( !v102 )
      goto LABEL_308;
    v103 = v101 + 1;
    memcpy(v102, path, v103);
    *(_BYTE *)(*(_DWORD *)(v153 + 12) + v103) = 0;
    v104 = (const char *)Curl_cstrdup(*(_DWORD *)(v153 + 12));
    if ( v104 )
    {
      v105 = (char *)v104;
      v106 = strlen(v104);
      v107 = v106;
      if ( *v105 == 34 )
      {
        memmove(v105, v105 + 1, v106);
        --v107;
      }
      if ( v107 )
      {
        if ( v105[v107 - 1] == 34 )
          v105[--v107] = 0;
      }
      else
      {
        v107 = 0;
      }
      if ( *v105 == 47 )
      {
        if ( v107 )
        {
          v108 = v169;
          if ( v105[v107 - 1] == 47 )
            v105[v107 - 1] = 0;
          goto LABEL_251;
        }
      }
      else
      {
        Curl_cfree(v105);
        v105 = (char *)Curl_strndup("/", 1);
      }
      v108 = v169;
    }
    else
    {
      v108 = v169;
      v105 = 0;
    }
LABEL_251:
    v109 = 1;
    *(_DWORD *)(v153 + 16) = v105;
    if ( v105 )
      v109 = v108;
    v95 = v109;
    goto LABEL_254;
  }
  v97 = Curl_cstrdup(domain);
  *(_DWORD *)(v57 + 20) = v97;
  v98 = 1;
  if ( v97 )
    v98 = v168;
  v95 = v98;
  if ( (v98 & 1) == 0 )
    goto LABEL_220;
LABEL_254:
  if ( (v95 & 1) != 0 || !*(_DWORD *)(v153 + 4) )
    goto LABEL_308;
  ++data->req.setcookies;
  v11 = v153;
LABEL_257:
  v110 = *(_BYTE *)(v11 + 40);
  v9 = 0;
  if ( (v110 & 1) != 0 && !*(_BYTE *)(v11 + 33)
    || (v110 & 2) != 0
    && (!*(_BYTE *)(v11 + 33)
     || !*(_DWORD *)(v11 + 12)
     || strcmp(*(const char **)(v11 + 12), "/")
     || *(_BYTE *)(v11 + 32))
    || !(running = c->running) && c->newsession && !*(_QWORD *)(v11 + 24) )
  {
    Curl_cfree(*(_DWORD *)(v11 + 20));
    Curl_cfree(*(_DWORD *)(v11 + 12));
    Curl_cfree(*(_DWORD *)(v11 + 16));
    Curl_cfree(*(_DWORD *)(v11 + 4));
    Curl_cfree(*(_DWORD *)(v11 + 8));
    Curl_cfree(v11);
    return v9;
  }
  *(_BYTE *)(v11 + 34) = running;
  v112 = c->lastct + 1;
  c->lastct = v112;
  *(_DWORD *)(v11 + 36) = v112;
  if ( !noexpire )
  {
    sc = time(0);
    next_expiration = c->next_expiration;
    next_expiration_high = HIDWORD(c->next_expiration);
    if ( sc >= __SPAIR64__(next_expiration_high, next_expiration)
      || !(~next_expiration | next_expiration_high ^ 0x7FFFFFFF) )
    {
      c->next_expiration = 0x7FFFFFFFFFFFFFFFLL;
      v134 = 0;
      do
      {
        v135 = c;
        v170 = v134;
        v136 = c->cookies[v134];
        if ( v136 )
        {
          v152 = 0;
          v173 = &c->cookies[v134];
          do
          {
            while ( 1 )
            {
              v137 = v136;
              v136 = v136->next;
              LODWORD(v138) = v137->expires;
              expires_high = HIDWORD(v137->expires);
              if ( !v137->expires )
                break;
              HIDWORD(v138) = HIDWORD(v137->expires);
              if ( v138 >= sc )
                break;
              p_next = &v152->next;
              if ( !v152 )
                p_next = v173;
              *p_next = v136;
              --v135->numcookies;
              Curl_cfree(v137->domain);
              Curl_cfree(v137->path);
              Curl_cfree(v137->spath);
              Curl_cfree(v137->name);
              Curl_cfree(v137->value);
              Curl_cfree(v137);
              v135 = c;
              if ( !v136 )
                goto LABEL_323;
            }
            if ( expires_high | (unsigned int)v138 )
            {
              HIDWORD(v138) = HIDWORD(v137->expires);
              if ( v138 < v135->next_expiration )
              {
                LODWORD(v135->next_expiration) = v138;
                HIDWORD(v135->next_expiration) = expires_high;
              }
            }
            v152 = v137;
          }
          while ( v136 );
        }
LABEL_323:
        v134 = v170 + 1;
      }
      while ( v170 != 62 );
    }
  }
  v9 = (Cookie *)v153;
  s_4c = cookiehash(*(const char *const *)(v153 + 20));
  next = c->cookies[s_4c];
  if ( !next )
  {
    v132 = c;
    v117 = 0;
    v133 = 0;
    goto LABEL_338;
  }
  v116 = 0;
  v151 = 0;
  sd = 0;
  while ( 2 )
  {
    v117 = next;
    if ( curl_strequal(next->name, *(_DWORD *)(v153 + 4)) )
    {
      v118 = v117->domain;
      v119 = *(_DWORD *)(v153 + 20);
      if ( v118 )
      {
        if ( v119 && curl_strequal(v118, *(_DWORD *)(v153 + 20)) )
        {
LABEL_273:
          spath = v117->spath;
          if ( spath && *(_DWORD *)(v153 + 16) && v117->secure && !*(_BYTE *)(v153 + 33) && !secure )
          {
            v172 = *(_DWORD *)(v153 + 16);
            v121 = strchr(spath + 1, 47);
            v122 = v121 ? v121 - spath : strlen(spath);
            if ( curl_strnequal(spath, v172, v122) )
            {
              if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
                Curl_infof(
                  data,
                  "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                  *(_DWORD *)(v153 + 4));
              goto LABEL_308;
            }
          }
        }
      }
      else if ( !v119 )
      {
        goto LABEL_273;
      }
    }
    if ( !v151 )
    {
      v151 = 0;
      if ( curl_strequal(v117->name, *(_DWORD *)(v153 + 4)) )
      {
        v123 = v117->domain;
        v124 = *(_DWORD *)(v153 + 20);
        if ( !v123 )
        {
          v125 = v124 == 0;
          goto LABEL_287;
        }
        if ( v124 && curl_strequal(v123, *(_DWORD *)(v153 + 20)) )
        {
          v125 = v117->tailmatch == *(_BYTE *)(v153 + 32);
LABEL_287:
          v126 = (unsigned __int8)sd;
          if ( v125 )
            v126 = 1;
        }
        else
        {
          v126 = sd;
        }
        sd = v126;
        if ( (v126 & 1) != 0 )
        {
          v127 = v117->spath;
          v128 = 0;
          v151 = 0;
          if ( v127 )
          {
            if ( !*(_DWORD *)(v153 + 16) )
            {
              v128 = v117->spath;
              goto LABEL_295;
            }
            if ( curl_strequal(v127, *(_DWORD *)(v153 + 16)) )
            {
              v128 = v117->spath;
              goto LABEL_295;
            }
            sd = 0;
            v151 = 0;
          }
          else
          {
LABEL_295:
            v129 = (unsigned __int8)sd;
            if ( (v128 == 0) != (*(_DWORD *)(v153 + 16) == 0) )
              v129 = 0;
            sd = v129;
            if ( (v129 & 1) != 0 )
            {
              if ( *(_BYTE *)(v153 + 34) )
              {
                v116 = v117;
                v151 = v153;
              }
              else
              {
                v116 = v117;
                v151 = v153;
                if ( v117->livecookie )
                  goto LABEL_308;
              }
            }
          }
        }
      }
    }
    next = v117->next;
    if ( v117->next )
      continue;
    break;
  }
  if ( v151 )
  {
    *(_DWORD *)v151 = v116->next;
    *(_DWORD *)(v151 + 36) = v116->creationtime;
    Curl_cfree(v116->name);
    Curl_cfree(v116->value);
    Curl_cfree(v116->domain);
    Curl_cfree(v116->path);
    Curl_cfree(v116->spath);
    *(_DWORD *)&v116->prefix = *(_DWORD *)(v151 + 40);
    *(_QWORD *)&v116->tailmatch = *(_QWORD *)(v151 + 32);
    v116->expires = *(_QWORD *)(v151 + 24);
    *(_QWORD *)&v116->spath = *(_QWORD *)(v151 + 16);
    v131 = *(_QWORD *)v151;
    *(_QWORD *)&v116->value = *(_QWORD *)(v151 + 8);
    *(_QWORD *)&v116->next = v131;
    Curl_cfree(v151);
    v9 = v116;
  }
  else
  {
    v9 = (Cookie *)v153;
  }
  v132 = c;
  v133 = sd;
LABEL_338:
  if ( data )
  {
    if ( v132->running )
    {
      se = v133;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      {
        v141 = "Replaced";
        if ( (v133 & 1) == 0 )
          v141 = "Added";
        v132 = c;
        Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v141);
        v133 = se;
      }
    }
  }
  if ( (v133 & 1) == 0 )
  {
    v142 = &v132->cookies[s_4c];
    if ( v117 )
      v142 = &v117->next;
    *v142 = v9;
    ++v132->numcookies;
  }
  LODWORD(v143) = v9->expires;
  v144 = HIDWORD(v9->expires);
  if ( v9->expires )
  {
    HIDWORD(v143) = HIDWORD(v9->expires);
    if ( v143 < v132->next_expiration )
    {
      LODWORD(v132->next_expiration) = v143;
      HIDWORD(v132->next_expiration) = v144;
    }
  }
  return v9;
}
