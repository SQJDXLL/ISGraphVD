Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        char *path,
        bool secure)
{
  time_t v8; // eax
  Cookie *v9; // ebp
  int v10; // eax
  int v11; // edi
  const char *v12; // edx
  const char *v13; // esi
  const char *i; // ebp
  size_t v15; // eax
  const char *v16; // edx
  unsigned int v17; // edi
  char v18; // al
  unsigned int v19; // ecx
  size_t v20; // eax
  size_t v21; // ecx
  const char *v22; // edx
  char v23; // cl
  const char *v24; // esi
  int j; // ecx
  char v26; // dl
  const char *v27; // esi
  const char *v28; // eax
  unsigned int v29; // esi
  bool v30; // zf
  unsigned int v31; // esi
  int v32; // eax
  unsigned int v33; // esi
  int v34; // eax
  const char *v35; // eax
  char *v36; // edi
  size_t v37; // esi
  const char *v38; // eax
  const char *v39; // esi
  size_t v40; // eax
  int v41; // eax
  unsigned int v42; // esi
  const char *v43; // eax
  _DWORD *v44; // esi
  int v45; // eax
  unsigned int v46; // esi
  int v47; // eax
  const char *v48; // ebp
  _BYTE *v49; // eax
  const char *v50; // eax
  char is_ipnum; // cl
  const char *v52; // eax
  int v53; // esi
  const char *v54; // esi
  size_t v55; // edi
  const char *v56; // esi
  int v57; // eax
  const char *v58; // edi
  size_t v59; // eax
  int v60; // eax
  size_t v61; // ecx
  bool v62; // cc
  size_t v63; // ebp
  int v64; // eax
  char v65; // di
  int v66; // eax
  unsigned int v67; // eax
  unsigned int v68; // ecx
  char v69; // cl
  const char *v70; // eax
  char *v71; // esi
  char *v72; // eax
  char *v73; // eax
  char *v74; // eax
  const char *v75; // ebp
  int v76; // edx
  int v77; // ecx
  int v78; // eax
  int v79; // eax
  int v80; // esi
  int v81; // eax
  const char *v82; // eax
  char *v83; // ebp
  size_t v84; // edi
  int v85; // eax
  int v86; // eax
  int v87; // eax
  int v88; // eax
  int v89; // eax
  int v90; // edi
  int v91; // eax
  int v92; // ecx
  CookieInfo *v93; // eax
  char *v94; // eax
  int v95; // esi
  int v96; // eax
  char v97; // al
  int v98; // eax
  char v99; // cl
  char *v100; // eax
  char *v101; // eax
  int v102; // edi
  void *v103; // eax
  size_t v104; // edi
  int v105; // esi
  const char *v106; // eax
  char *v107; // ebp
  size_t v108; // edi
  char v109; // al
  char v110; // cl
  char v111; // al
  bool running; // al
  int v113; // eax
  Cookie *next; // eax
  Cookie *v115; // edi
  Cookie *v116; // esi
  char *v117; // eax
  int v118; // ecx
  const char *spath; // ebp
  char *v120; // eax
  size_t v121; // eax
  char *v122; // eax
  int v123; // ecx
  int v124; // eax
  char *v125; // eax
  char *v126; // ecx
  int v127; // eax
  const char *v129; // eax
  __int128 v130; // xmm0
  char v131; // al
  CookieInfo *v132; // edi
  int v133; // eax
  CookieInfo *v134; // edi
  Cookie *v135; // esi
  Cookie *v136; // ebp
  curl_off_t v137; // rax
  int expires_high; // ecx
  Cookie **p_next; // eax
  const char *v140; // ecx
  Cookie **v141; // eax
  curl_off_t v142; // rax
  int v143; // ecx
  size_t n; // [esp+8h] [ebp-E4h]
  char v145; // [esp+28h] [ebp-C4h]
  const char *v146; // [esp+28h] [ebp-C4h]
  int v147; // [esp+28h] [ebp-C4h]
  int v148; // [esp+28h] [ebp-C4h]
  Cookie *v149; // [esp+28h] [ebp-C4h]
  int v150; // [esp+2Ch] [ebp-C0h]
  const char *s; // [esp+30h] [ebp-BCh]
  const char *sa; // [esp+30h] [ebp-BCh]
  time_t sb; // [esp+30h] [ebp-BCh]
  int sc; // [esp+30h] [ebp-BCh]
  char sd; // [esp+30h] [ebp-BCh]
  size_t s_4; // [esp+34h] [ebp-B8h]
  unsigned int s_4d; // [esp+34h] [ebp-B8h]
  size_t s_4a; // [esp+34h] [ebp-B8h]
  int s_4b; // [esp+34h] [ebp-B8h]
  size_t s_4c; // [esp+34h] [ebp-B8h]
  char v161; // [esp+38h] [ebp-B4h]
  char v162; // [esp+38h] [ebp-B4h]
  int v163; // [esp+3Ch] [ebp-B0h]
  int v164; // [esp+3Ch] [ebp-B0h]
  Cookie **v165; // [esp+3Ch] [ebp-B0h]
  char v167; // [esp+44h] [ebp-A8h]
  int v168; // [esp+44h] [ebp-A8h]
  _DWORD *v169; // [esp+48h] [ebp-A4h]
  __int64 v170; // [esp+50h] [ebp-9Ch]
  size_t v171; // [esp+58h] [ebp-94h]
  char *dest[36]; // [esp+5Ch] [ebp-90h] BYREF

  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return v9;
  v163 = v8;
  v10 = Curl_ccalloc(1, 44);
  if ( !v10 )
    return v9;
  v11 = v10;
  v150 = v10;
  if ( !httpheader )
  {
    dest[0] = 0;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      *(_BYTE *)(v11 + 35) = 1;
      v70 = lineptr + 10;
      if ( lineptr[10] == 35 )
        goto LABEL_141;
    }
    else
    {
      v70 = lineptr;
      if ( *lineptr == 35 )
        goto LABEL_141;
    }
    v71 = (char *)v70;
    v72 = strchr(v70, 13);
    if ( v72 )
      *v72 = 0;
    v73 = strchr(v71, 10);
    if ( v73 )
      *v73 = 0;
    v74 = strtok_r(v71, "\t", dest);
    if ( !v74 )
      goto LABEL_314;
    v75 = v74;
    s_4b = v11 + 24;
    v76 = 0;
    v77 = 0;
    while ( 1 )
    {
      v147 = v77;
      switch ( v76 )
      {
        case 0:
          if ( *v75 == 46 )
            ++v75;
          v78 = Curl_cstrdup(v75);
          *(_DWORD *)(v11 + 20) = v78;
          v30 = v78 == 0;
          v79 = (unsigned __int8)v147;
          if ( v30 )
            v79 = 1;
          v147 = v79;
          v80 = 0;
          goto LABEL_205;
        case 1:
          *(_BYTE *)(v11 + 32) = curl_strequal(v75, "TRUE") != 0;
          v80 = 1;
          goto LABEL_205;
        case 2:
          if ( !strcmp("TRUE", v75) || !strcmp("FALSE", v75) )
          {
            v90 = Curl_cstrdup("/");
            *(_DWORD *)(v150 + 12) = v90;
            v91 = Curl_cstrdup("/");
            v92 = (unsigned __int8)v147;
            if ( !v91 )
              v92 = 1;
            v30 = v90 == 0;
            v11 = v150;
            *(_DWORD *)(v150 + 16) = v91;
            if ( v30 )
              v92 = 1;
            v147 = v92;
            goto LABEL_185;
          }
          v81 = Curl_cstrdup(v75);
          *(_DWORD *)(v11 + 12) = v81;
          if ( v81 )
          {
            v82 = (const char *)Curl_cstrdup(v81);
            if ( v82 )
            {
              v83 = (char *)v82;
              v84 = strlen(v82);
              if ( *v83 == 34 )
                memmove(v83, v83 + 1, v84--);
              if ( v84 )
              {
                if ( v83[v84 - 1] == 34 )
                  v83[--v84] = 0;
                if ( *v83 == 47 )
                {
                  if ( v84 )
                  {
                    LOBYTE(v85) = v147;
                    if ( v83[v84 - 1] == 47 )
                      v83[v84 - 1] = 0;
                    v11 = v150;
                    goto LABEL_202;
                  }
LABEL_200:
                  v11 = v150;
LABEL_201:
                  LOBYTE(v85) = v147;
LABEL_202:
                  *(_DWORD *)(v11 + 16) = v83;
                  v85 = (unsigned __int8)v85;
                  if ( !v83 )
                    v85 = 1;
                  goto LABEL_204;
                }
              }
              else if ( *v83 == 47 )
              {
                goto LABEL_200;
              }
              Curl_cfree(v83);
              v83 = (char *)Curl_strndup("/", 1);
              goto LABEL_200;
            }
            v83 = 0;
            goto LABEL_201;
          }
          v85 = 1;
LABEL_204:
          v147 = v85;
          v80 = 2;
LABEL_205:
          v94 = strtok_r(0, "\t", dest);
          v95 = v80 + 1;
          v77 = v147;
          v76 = v95;
          if ( !v94 || (v75 = v94, (v147 & 1) != 0) )
          {
            if ( v95 == 6 )
            {
              v96 = Curl_cstrdup(&L_str_22);
              *(_DWORD *)(v11 + 8) = v96;
              LOBYTE(v77) = 1;
              if ( v96 )
                LOBYTE(v77) = v147;
              v76 = (v96 == 0) ^ 7;
            }
            if ( (v77 & 1) != 0 || v76 != 7 )
              goto LABEL_314;
            goto LABEL_258;
          }
          break;
        case 3:
LABEL_185:
          *(_BYTE *)(v11 + 33) = 0;
          if ( !curl_strequal(v75, "TRUE") )
            goto LABEL_189;
          if ( secure || (v93 = c, c->running) )
          {
            *(_BYTE *)(v11 + 33) = 1;
LABEL_189:
            v80 = 3;
          }
          else
          {
            LOBYTE(v93) = 1;
            v147 = (int)v93;
            v80 = 3;
          }
          goto LABEL_205;
        case 4:
          v30 = curlx_strtoofft(v75, 0, 10, s_4b) == 0;
          v86 = (unsigned __int8)v147;
          if ( !v30 )
            v86 = 1;
          v147 = v86;
          v80 = 4;
          goto LABEL_205;
        case 5:
          v87 = Curl_cstrdup(v75);
          *(_DWORD *)(v11 + 4) = v87;
          if ( v87 )
          {
            if ( curl_strnequal("__Secure-", v87, 9) )
            {
              *(_BYTE *)(v11 + 40) |= 1u;
              v80 = 5;
            }
            else
            {
              if ( curl_strnequal("__Host-", *(_DWORD *)(v11 + 4), 7) )
                *(_BYTE *)(v11 + 40) |= 2u;
              v80 = 5;
            }
          }
          else
          {
            v147 = 1;
            v80 = 5;
          }
          goto LABEL_205;
        case 6:
          v88 = Curl_cstrdup(v75);
          *(_DWORD *)(v11 + 8) = v88;
          v30 = v88 == 0;
          v89 = (unsigned __int8)v147;
          if ( v30 )
            v89 = 1;
          v147 = v89;
          v80 = 6;
          goto LABEL_205;
        default:
          v80 = v76;
          goto LABEL_205;
      }
    }
  }
  if ( strlen(lineptr) > 0x1388 )
  {
LABEL_141:
    Curl_cfree(v11);
    return v9;
  }
  v169 = (_DWORD *)(v11 + 24);
  v161 = 0;
  v12 = lineptr;
  while ( 1 )
  {
    v13 = v12 + 1;
    for ( i = v12; *i == 32 || *i == 9; ++i )
      ++v13;
    v145 = *i;
    v15 = strcspn(i, ";\t\r\n=");
    if ( !v15 )
    {
      v16 = i;
      goto LABEL_127;
    }
    v16 = &i[v15];
    s_4 = v15;
    v17 = v15;
    while ( 1 )
    {
      v18 = i[v17 - 1];
      if ( v18 != 32 && v18 != 9 )
        break;
      if ( !--v17 )
      {
        v17 = 0;
        break;
      }
    }
    v19 = 0;
    s = 0;
    v167 = *v16;
    if ( *v16 == 61 )
    {
      sa = &i[s_4 + 1];
      v20 = strcspn(sa, ";\r\n");
      v21 = 0;
      v171 = s_4 + v20;
      if ( v20 )
      {
        v22 = &v13[s_4 + v20];
        while ( 1 )
        {
          v23 = *(v22 - 1);
          if ( v23 != 32 && v23 != 9 )
            break;
          --v20;
          --v22;
          if ( !v20 )
          {
            v28 = &i[s_4 + 1];
            v21 = 0;
            goto LABEL_32;
          }
        }
        sa = v22;
        v24 = &v13[s_4];
        for ( j = 0; j != v20; ++j )
        {
          v26 = v24[j];
          if ( v26 != 32 && v26 != 9 )
          {
            v27 = &v24[j];
            v21 = v20 - j;
            v28 = v27;
            goto LABEL_32;
          }
        }
        v21 = 0;
      }
      v28 = sa;
LABEL_32:
      v29 = v21;
      s = v28;
      if ( memchr(v28, 9, v21) )
      {
        Curl_cfree(*(_DWORD *)(v150 + 20));
        Curl_cfree(*(_DWORD *)(v150 + 12));
        Curl_cfree(*(_DWORD *)(v150 + 16));
        Curl_cfree(*(_DWORD *)(v150 + 4));
        Curl_cfree(*(_DWORD *)(v150 + 8));
        Curl_cfree(v150);
        v9 = 0;
        if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
          Curl_infof(data, "cookie contains TAB, dropping", n);
        return v9;
      }
      v16 = &i[v171 + 1];
      v19 = v29;
    }
    if ( v17 > 0xFFE || v19 > 0xFFE || v19 + v17 >= 0x1001 )
    {
      Curl_cfree(*(_DWORD *)(v150 + 20));
      Curl_cfree(*(_DWORD *)(v150 + 12));
      Curl_cfree(*(_DWORD *)(v150 + 16));
      Curl_cfree(*(_DWORD *)(v150 + 4));
      Curl_cfree(*(_DWORD *)(v150 + 8));
      Curl_cfree(v150);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v17);
      return v9;
    }
    v30 = v145 == 95;
    v146 = v16;
    if ( v30 && v17 >= 7 && i[1] == 95 )
    {
      v31 = v19;
      if ( curl_strnequal("__Secure-", i, 9) )
      {
        *(_BYTE *)(v150 + 40) |= 1u;
        v16 = v146;
        v19 = v31;
      }
      else
      {
        v32 = curl_strnequal("__Host-", i, 7);
        v16 = v146;
        v19 = v31;
        if ( v32 )
          *(_BYTE *)(v150 + 40) |= 2u;
      }
    }
    if ( !*(_DWORD *)(v150 + 4) )
    {
      if ( v167 != 61 )
        goto LABEL_313;
      s_4d = v19;
      Curl_cfree(0);
      *(_DWORD *)(v150 + 4) = Curl_strndup(i, v17);
      Curl_cfree(*(_DWORD *)(v150 + 8));
      v38 = (const char *)Curl_strndup(s, s_4d);
      *(_DWORD *)(v150 + 8) = v38;
      if ( !v38 )
        goto LABEL_313;
      v39 = *(const char **)(v150 + 4);
      if ( !v39 )
        goto LABEL_313;
      if ( v38[strcspn(v38, invalid_octets_badoctets)]
        || (v40 = strcspn(v39, invalid_octets_badoctets), v16 = v146, v39[v40]) )
      {
        if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
          Curl_infof(data, "invalid octets in name/value, cookie dropped", n);
LABEL_313:
        v11 = v150;
LABEL_314:
        Curl_cfree(*(_DWORD *)(v11 + 20));
        Curl_cfree(*(_DWORD *)(v11 + 12));
        Curl_cfree(*(_DWORD *)(v11 + 16));
        Curl_cfree(*(_DWORD *)(v11 + 4));
        Curl_cfree(*(_DWORD *)(v11 + 8));
        Curl_cfree(v11);
        return 0;
      }
      goto LABEL_127;
    }
    if ( v19 )
      break;
    if ( v17 == 8 )
    {
      v57 = curl_strnequal("httponly", i, 8);
      v19 = 0;
      v16 = v146;
      if ( v57 )
      {
        *(_BYTE *)(v150 + 35) = 1;
        goto LABEL_127;
      }
    }
    else if ( v17 == 6 )
    {
      v41 = curl_strnequal("secure", i, 6);
      v19 = 0;
      v16 = v146;
      if ( v41 )
      {
        if ( !secure && c->running )
          goto LABEL_313;
        *(_BYTE *)(v150 + 33) = 1;
        goto LABEL_127;
      }
    }
    if ( v167 == 61 )
      break;
LABEL_127:
    v12 = v16 + 1;
    v53 = v150;
    while ( 1 )
    {
      v69 = *(v12 - 1);
      if ( v69 != 32 && v69 != 9 )
        break;
      ++v12;
    }
    if ( v69 != 59 )
      goto LABEL_214;
  }
  if ( v17 == 7 )
  {
    v42 = v19;
    if ( curl_strnequal("version", i, 7) )
      goto LABEL_126;
    if ( curl_strnequal("max-age", i, 7) )
    {
      v43 = s + 1;
      if ( *s != 34 )
        v43 = s;
      v44 = v169;
      v45 = curlx_strtoofft(v43, 0, 10, v169);
      if ( v45 )
      {
        if ( v45 != 2 )
        {
          v16 = v146;
          if ( v45 == 1 )
          {
            *v169 = -1;
            v169[1] = 0x7FFFFFFF;
          }
          goto LABEL_127;
        }
      }
      else
      {
        v67 = *v169;
        v68 = v169[1];
        if ( *(_QWORD *)v169 )
        {
          LODWORD(v170) = ~v163;
          HIDWORD(v170) = 0x7FFFFFFF - (v163 >> 31);
          if ( v170 >= __SPAIR64__(v68, v67) )
          {
            *(_QWORD *)v169 = v163 + __PAIR64__(v68, v67);
          }
          else
          {
            *v169 = -1;
            v169[1] = 0x7FFFFFFF;
          }
          v16 = v146;
          goto LABEL_127;
        }
      }
      goto LABEL_125;
    }
    if ( !curl_strnequal("expires", i, 7) )
      goto LABEL_126;
    v61 = v42;
    v62 = v42 <= 0x7F;
    v44 = v169;
    v16 = v146;
    if ( v62 && !*(_QWORD *)v169 )
    {
      v63 = v61;
      memcpy(dest, s, v61);
      *((_BYTE *)dest + v63) = 0;
      v64 = Curl_getdate_capped(dest);
      *(_QWORD *)v169 = v64;
      if ( v64 )
      {
        v16 = v146;
        if ( v64 < 0 )
        {
          v169[1] = 0;
          *v169 = 0;
        }
        goto LABEL_127;
      }
LABEL_125:
      v44[1] = 0;
      *v44 = 1;
LABEL_126:
      v16 = v146;
      goto LABEL_127;
    }
    goto LABEL_127;
  }
  if ( v17 != 6 )
  {
    if ( v17 != 4 )
      goto LABEL_127;
    v33 = v19;
    if ( !curl_strnequal("path", i, 4) )
      goto LABEL_126;
    Curl_cfree(*(_DWORD *)(v150 + 12));
    v34 = Curl_strndup(s, v33);
    *(_DWORD *)(v150 + 12) = v34;
    if ( !v34 )
      goto LABEL_313;
    Curl_cfree(*(_DWORD *)(v150 + 16));
    v35 = (const char *)Curl_cstrdup(*(_DWORD *)(v150 + 12));
    if ( !v35 )
    {
      *(_DWORD *)(v150 + 16) = 0;
      goto LABEL_313;
    }
    v36 = (char *)v35;
    v37 = strlen(v35);
    if ( *v36 == 34 )
      memmove(v36, v36 + 1, v37--);
    if ( v37 )
    {
      if ( v36[v37 - 1] == 34 )
        v36[--v37] = 0;
      if ( *v36 != 47 )
      {
LABEL_107:
        Curl_cfree(v36);
        v60 = Curl_strndup("/", 1);
        *(_DWORD *)(v150 + 16) = v60;
        v16 = v146;
        if ( !v60 )
          goto LABEL_313;
        goto LABEL_127;
      }
      if ( v37 && v36[v37 - 1] == 47 )
        v36[v37 - 1] = 0;
    }
    else if ( *v36 != 47 )
    {
      goto LABEL_107;
    }
    *(_DWORD *)(v150 + 16) = v36;
    v16 = v146;
    goto LABEL_127;
  }
  v46 = v19;
  v47 = curl_strnequal("domain", i, 6);
  if ( !v46 || !v47 )
    goto LABEL_126;
  v48 = s + 1;
  if ( *s != 46 )
    v48 = s;
  s_4a = v46 - (*s == 46);
  if ( s_4a == 9 && curl_strnequal(v48, "localhost", 9)
    || (v49 = memchr(v48, 46, s_4a)) != 0 && (unsigned int)(&v48[s_4a] - v49) > 1 )
  {
    v50 = domain;
    if ( !domain )
      v50 = v48;
    is_ipnum = Curl_host_is_ipnum(v50);
    v52 = domain;
    v53 = v150;
    if ( !domain )
    {
      domain = 0;
      goto LABEL_116;
    }
    if ( !is_ipnum )
    {
LABEL_93:
      v54 = v52;
      v55 = strlen(v52);
      domain = v54;
      if ( v55 < s_4a )
        goto LABEL_135;
      v56 = &v54[v55 - s_4a];
      if ( !curl_strnequal(v48, v56, s_4a) )
        goto LABEL_135;
      if ( v55 == s_4a )
      {
        is_ipnum = 0;
        v53 = v150;
      }
      else
      {
        v30 = *(v56 - 1) == 46;
        v53 = v150;
        if ( !v30 )
          goto LABEL_135;
        is_ipnum = 0;
      }
      goto LABEL_116;
    }
  }
  else
  {
    v30 = (unsigned __int8)Curl_host_is_ipnum(":") == 0;
    v52 = ":";
    v53 = v150;
    if ( v30 )
      goto LABEL_93;
  }
  v58 = v52;
  domain = v52;
  if ( strncmp(v48, v52, s_4a) || (v59 = strlen(v58), is_ipnum = 1, s_4a != v59) )
  {
LABEL_135:
    v161 = 1;
    if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v48);
    v16 = v146;
    goto LABEL_127;
  }
LABEL_116:
  v65 = is_ipnum;
  Curl_cfree(*(_DWORD *)(v53 + 20));
  v66 = Curl_strndup(v48, s_4a);
  *(_DWORD *)(v53 + 20) = v66;
  if ( !v65 && v66 )
  {
    *(_BYTE *)(v53 + 32) = 1;
    v16 = v146;
    goto LABEL_127;
  }
  v16 = v146;
  if ( v66 )
    goto LABEL_127;
  v161 = 1;
LABEL_214:
  v97 = v161;
  if ( (v161 & 1) == 0 && domain && !*(_DWORD *)(v53 + 20) )
  {
    v98 = Curl_cstrdup(domain);
    *(_DWORD *)(v53 + 20) = v98;
    v99 = 1;
    if ( v98 )
      v99 = v161;
    v97 = v99;
  }
  if ( (v97 & 1) != 0 || !path || *(_DWORD *)(v53 + 12) )
    goto LABEL_255;
  v162 = v97;
  v100 = strchr(path, 63);
  if ( v100 )
    v101 = (char *)Curl_memrchr(path, 47, v100 - path);
  else
    v101 = strrchr(path, 47);
  if ( !v101 )
  {
    v97 = v162;
    goto LABEL_255;
  }
  v102 = v101 - path;
  v103 = (void *)Curl_cmalloc(v101 - path + 2);
  *(_DWORD *)(v150 + 12) = v103;
  if ( !v103 )
    goto LABEL_313;
  v104 = v102 + 1;
  memcpy(v103, path, v104);
  v105 = v150;
  *(_BYTE *)(*(_DWORD *)(v150 + 12) + v104) = 0;
  v106 = (const char *)Curl_cstrdup(*(_DWORD *)(v150 + 12));
  if ( !v106 )
  {
    v107 = 0;
LABEL_251:
    v109 = v162;
    goto LABEL_252;
  }
  v107 = (char *)v106;
  v108 = strlen(v106);
  if ( *v107 == 34 )
    memmove(v107, v107 + 1, v108--);
  if ( !v108 )
  {
    if ( *v107 == 47 )
      goto LABEL_250;
LABEL_249:
    Curl_cfree(v107);
    v107 = (char *)Curl_strndup("/", 1);
    goto LABEL_250;
  }
  if ( v107[v108 - 1] == 34 )
    v107[--v108] = 0;
  if ( *v107 != 47 )
    goto LABEL_249;
  if ( !v108 )
  {
LABEL_250:
    v105 = v150;
    goto LABEL_251;
  }
  v109 = v162;
  if ( v107[v108 - 1] == 47 )
    v107[v108 - 1] = 0;
  v105 = v150;
LABEL_252:
  *(_DWORD *)(v105 + 16) = v107;
  v110 = 1;
  if ( v107 )
    v110 = v109;
  v97 = v110;
LABEL_255:
  if ( (v97 & 1) != 0 || !*(_DWORD *)(v150 + 4) )
    goto LABEL_313;
  ++data->req.setcookies;
  v11 = v150;
LABEL_258:
  v111 = *(_BYTE *)(v11 + 40);
  v9 = 0;
  if ( (v111 & 1) != 0 && !*(_BYTE *)(v11 + 33)
    || (v111 & 2) != 0
    && (!*(_BYTE *)(v11 + 33) || (v129 = *(const char **)(v11 + 12)) == 0 || strcmp(v129, "/") || *(_BYTE *)(v11 + 32))
    || !(running = c->running) && c->newsession && !*(_QWORD *)(v11 + 24) )
  {
    Curl_cfree(*(_DWORD *)(v11 + 20));
    Curl_cfree(*(_DWORD *)(v11 + 12));
    Curl_cfree(*(_DWORD *)(v11 + 16));
    Curl_cfree(*(_DWORD *)(v11 + 4));
    Curl_cfree(*(_DWORD *)(v11 + 8));
    Curl_cfree(v11);
    return v9;
  }
  *(_BYTE *)(v11 + 34) = running;
  v113 = c->lastct + 1;
  c->lastct = v113;
  *(_DWORD *)(v11 + 36) = v113;
  if ( !noexpire )
  {
    sb = time(0);
    if ( sb >= c->next_expiration || !(~LODWORD(c->next_expiration) | HIDWORD(c->next_expiration) ^ 0x7FFFFFFF) )
    {
      c->next_expiration = 0x7FFFFFFFFFFFFFFFLL;
      v133 = 0;
      do
      {
        v134 = c;
        v168 = v133;
        v135 = c->cookies[v133];
        if ( v135 )
        {
          v165 = &c->cookies[v133];
          v149 = 0;
          do
          {
            while ( 1 )
            {
              v136 = v135;
              v135 = v135->next;
              LODWORD(v137) = v136->expires;
              expires_high = HIDWORD(v136->expires);
              if ( !v136->expires )
                break;
              HIDWORD(v137) = HIDWORD(v136->expires);
              if ( v137 >= sb )
                break;
              p_next = &v149->next;
              if ( !v149 )
                p_next = v165;
              *p_next = v135;
              --v134->numcookies;
              Curl_cfree(v136->domain);
              Curl_cfree(v136->path);
              Curl_cfree(v136->spath);
              Curl_cfree(v136->name);
              Curl_cfree(v136->value);
              Curl_cfree(v136);
              v134 = c;
              if ( !v135 )
                goto LABEL_328;
            }
            if ( expires_high | (unsigned int)v137 )
            {
              HIDWORD(v137) = HIDWORD(v136->expires);
              if ( v137 < v134->next_expiration )
              {
                LODWORD(v134->next_expiration) = v137;
                HIDWORD(v134->next_expiration) = expires_high;
              }
            }
            v149 = v136;
          }
          while ( v135 );
        }
LABEL_328:
        v133 = v168 + 1;
      }
      while ( v168 != 62 );
    }
  }
  v9 = (Cookie *)v150;
  s_4c = cookiehash(*(const char *const *)(v150 + 20));
  next = c->cookies[s_4c];
  if ( !next )
  {
    v116 = 0;
    v131 = 0;
    v132 = c;
    goto LABEL_343;
  }
  v148 = 0;
  v9 = 0;
  sc = 0;
  while ( 2 )
  {
    v115 = v9;
    v116 = next;
    if ( curl_strequal(next->name, *(_DWORD *)(v150 + 4)) )
    {
      v117 = v116->domain;
      v118 = *(_DWORD *)(v150 + 20);
      if ( v117 )
      {
        if ( v118 && curl_strequal(v117, *(_DWORD *)(v150 + 20)) )
        {
LABEL_275:
          spath = v116->spath;
          if ( spath && *(_DWORD *)(v150 + 16) && v116->secure && !*(_BYTE *)(v150 + 33) && !secure )
          {
            v164 = *(_DWORD *)(v150 + 16);
            v120 = strchr(spath + 1, 47);
            v121 = v120 ? v120 - spath : strlen(spath);
            if ( curl_strnequal(spath, v164, v121) )
            {
              v11 = v150;
              if ( data && (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
                Curl_infof(
                  data,
                  "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                  *(_DWORD *)(v150 + 4));
              goto LABEL_314;
            }
          }
        }
      }
      else if ( !v118 )
      {
        goto LABEL_275;
      }
    }
    if ( v148 || (v148 = 0, !curl_strequal(v116->name, *(_DWORD *)(v150 + 4))) )
    {
      v9 = v115;
    }
    else
    {
      v122 = v116->domain;
      v123 = *(_DWORD *)(v150 + 20);
      if ( v122 )
      {
        if ( v123 )
        {
          v9 = v115;
          if ( curl_strequal(v122, *(_DWORD *)(v150 + 20)) )
          {
            v124 = (unsigned __int8)sc;
            if ( v116->tailmatch == *(_BYTE *)(v150 + 32) )
              v124 = 1;
            goto LABEL_294;
          }
        }
        else
        {
          v9 = v115;
        }
        v124 = sc;
        goto LABEL_294;
      }
      v124 = (unsigned __int8)sc;
      if ( !v123 )
        v124 = 1;
      v9 = v115;
LABEL_294:
      sc = v124;
      if ( (v124 & 1) != 0 )
      {
        v125 = v116->spath;
        v148 = 0;
        v126 = 0;
        if ( v125 )
        {
          if ( !*(_DWORD *)(v150 + 16) )
          {
            v126 = v116->spath;
            goto LABEL_300;
          }
          if ( curl_strequal(v125, *(_DWORD *)(v150 + 16)) )
          {
            v126 = v116->spath;
            goto LABEL_300;
          }
          sc = 0;
          v148 = 0;
        }
        else
        {
LABEL_300:
          v127 = (unsigned __int8)sc;
          if ( (v126 != 0) == (*(_DWORD *)(v150 + 16) == 0) )
            v127 = 0;
          sc = v127;
          if ( (v127 & 1) != 0 )
          {
            if ( *(_BYTE *)(v150 + 34) )
            {
              v9 = v116;
              v148 = v150;
            }
            else
            {
              v9 = v116;
              v148 = v150;
              if ( v116->livecookie )
                goto LABEL_313;
            }
          }
        }
      }
    }
    next = v116->next;
    if ( v116->next )
      continue;
    break;
  }
  if ( v148 )
  {
    *(_DWORD *)v148 = v9->next;
    *(_DWORD *)(v148 + 36) = v9->creationtime;
    Curl_cfree(v9->name);
    Curl_cfree(v9->value);
    Curl_cfree(v9->domain);
    Curl_cfree(v9->path);
    Curl_cfree(v9->spath);
    *(_OWORD *)((char *)&v9->expires + 4) = *(_OWORD *)(v148 + 28);
    v130 = *(_OWORD *)v148;
    *(_OWORD *)&v9->spath = *(_OWORD *)(v148 + 16);
    *(_OWORD *)&v9->next = v130;
    Curl_cfree(v148);
  }
  else
  {
    v9 = (Cookie *)v150;
  }
  v132 = c;
  v131 = sc;
LABEL_343:
  if ( data )
  {
    if ( v132->running )
    {
      sd = v131;
      if ( (*((_BYTE *)&data->set + 1321) & 0x20) != 0 )
      {
        v140 = "Replaced";
        if ( (v131 & 1) == 0 )
          v140 = "Added";
        v132 = c;
        Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v140);
        v131 = sd;
      }
    }
  }
  if ( (v131 & 1) == 0 )
  {
    v141 = &v132->cookies[s_4c];
    if ( v116 )
      v141 = &v116->next;
    *v141 = v9;
    ++v132->numcookies;
  }
  LODWORD(v142) = v9->expires;
  v143 = HIDWORD(v9->expires);
  if ( v9->expires )
  {
    HIDWORD(v142) = HIDWORD(v9->expires);
    if ( v142 < v132->next_expiration )
    {
      LODWORD(v132->next_expiration) = v142;
      HIDWORD(v132->next_expiration) = v143;
    }
  }
  return v9;
}
