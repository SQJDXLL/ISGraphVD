Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  char *value; // edi
  char v9; // al
  char *v10; // edx
  unsigned int v11; // esi
  char v12; // al
  _BYTE *v13; // esi
  char v14; // cl
  const char *v15; // eax
  Cookie *v16; // eax
  int v17; // eax
  const char *name; // esi
  const char *v19; // eax
  _BOOL4 v20; // edx
  char *v21; // eax
  bool v22; // zf
  _BYTE *v23; // eax
  char is_ipnum; // al
  int v25; // eax
  Cookie *v26; // eax
  int v27; // esi
  char v28; // al
  int v29; // eax
  char *v30; // eax
  char *v31; // eax
  size_t v32; // eax
  char *v33; // eax
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  char *v37; // eax
  int v38; // ecx
  char *v39; // esi
  char *v40; // eax
  char v41; // dl
  int v42; // edi
  int v43; // eax
  int (__cdecl *v44)(const char *); // edx
  int v45; // eax
  const char *v46; // eax
  char *v47; // edi
  char *v48; // eax
  int v49; // eax
  int v50; // edi
  char *v51; // eax
  int v52; // eax
  int v53; // edx
  int v54; // eax
  int v55; // eax
  unsigned __int8 prefix; // al
  Cookie *v57; // ecx
  const char *v58; // eax
  bool running; // al
  Cookie *v60; // eax
  int v61; // eax
  Cookie *v62; // esi
  int spath; // eax
  char *v64; // edx
  char *v65; // eax
  int v66; // edx
  size_t v67; // eax
  char *v68; // edx
  bool v69; // zf
  char *v70; // edx
  const char *v71; // eax
  unsigned int expires; // edx
  unsigned int expires_high; // eax
  Curl_easy *v75; // [esp-Ch] [ebp-F0h]
  Curl_easy *v76; // [esp-Ch] [ebp-F0h]
  Curl_easy *v77; // [esp-8h] [ebp-ECh]
  Curl_easy *v78; // [esp-8h] [ebp-ECh]
  int now; // [esp+8h] [ebp-DCh]
  bool badcookie; // [esp+10h] [ebp-D4h]
  char v81; // [esp+12h] [ebp-D2h]
  const char *ptr; // [esp+14h] [ebp-D0h]
  size_t myhash; // [esp+18h] [ebp-CCh]
  char *sep; // [esp+1Ch] [ebp-C8h]
  bool sepa; // [esp+1Ch] [ebp-C8h]
  int (__cdecl *sepb)(char *); // [esp+1Ch] [ebp-C8h]
  int sepc; // [esp+1Ch] [ebp-C8h]
  Cookie *sepd; // [esp+1Ch] [ebp-C8h]
  int sepe; // [esp+1Ch] [ebp-C8h]
  char replace_olda; // [esp+20h] [ebp-C4h]
  size_t vlen; // [esp+2Ch] [ebp-B8h]
  __int64 vlena; // [esp+2Ch] [ebp-B8h]
  size_t vlenb; // [esp+2Ch] [ebp-B8h]
  Cookie *vlenc; // [esp+2Ch] [ebp-B8h]
  int fields; // [esp+34h] [ebp-B0h]
  unsigned int fieldsa; // [esp+34h] [ebp-B0h]
  bool fieldsb; // [esp+34h] [ebp-B0h]
  int fieldsc; // [esp+34h] [ebp-B0h]
  Cookie *fieldsd; // [esp+34h] [ebp-B0h]
  Cookie *co; // [esp+38h] [ebp-ACh]
  char *tok_buf; // [esp+44h] [ebp-A0h] BYREF
  char date[128]; // [esp+48h] [ebp-9Ch] BYREF
  unsigned int v104; // [esp+C8h] [ebp-1Ch]

  value = (char *)lineptr;
  v104 = __readgsdword(0x14u);
  now = time(0);
  if ( data->req.setcookies > 0x31u )
    return 0;
  co = (Cookie *)((int (__cdecl *)(int, int))Curl_ccalloc)(1, 44);
  if ( !co )
    return 0;
  if ( !httpheader )
  {
    tok_buf = 0;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      value = (char *)(lineptr + 10);
      co->httponly = 1;
    }
    if ( *value != 35 )
    {
      v35 = strchr(value, 13);
      if ( v35 )
        *v35 = 0;
      v36 = strchr(value, 10);
      if ( v36 )
        *v36 = 0;
      v37 = strtok_r(value, "\t", &tok_buf);
      value = (char *)httpheader;
      v38 = 0;
      v39 = v37;
      v40 = (char *)&Curl_cstrdup;
      while ( 1 )
      {
        v41 = (unsigned __int8)value ^ 1;
        LOBYTE(v40) = ((unsigned __int8)value ^ 1) & (v39 != 0);
        LOBYTE(fields) = (_BYTE)v40;
        if ( !(_BYTE)v40 )
          goto LABEL_205;
        switch ( v38 )
        {
          case 0:
            if ( *v39 == 46 )
              ++v39;
            v42 = Curl_cstrdup(v39);
            co->domain = (char *)v42;
            v40 = strtok_r(0, "\t", &tok_buf);
            v39 = v40;
            v41 = v42 != 0;
            if ( v40 && v42 )
              goto _L222;
            v38 = 1;
            LOBYTE(v40) = v42 == 0;
            value = v40;
            goto LABEL_205;
          case 1:
_L222:
            co->tailmatch = curl_strequal(v39, "TRUE", v40) != 0;
            v39 = strtok_r(0, "\t", &tok_buf);
            if ( v39 )
              goto _L221;
            value = (char *)httpheader;
            v41 = fields;
            v38 = 2;
            goto LABEL_205;
          case 2:
_L221:
            v43 = strcmp("TRUE", v39);
            v44 = (int (__cdecl *)(const char *))Curl_cstrdup;
            if ( v43
              && (sepb = (int (__cdecl *)(char *))Curl_cstrdup,
                  v45 = strcmp("FALSE", v39),
                  v44 = (int (__cdecl *)(const char *))sepb,
                  v45) )
            {
              v46 = (const char *)sepb(v39);
              co->path = (char *)v46;
              if ( !v46 )
              {
                strtok_r(0, "\t", &tok_buf);
                value = (char *)fields;
                v41 = 0;
                goto LABEL_175;
              }
              v47 = sanitize_cookie_path(v46);
              co->spath = v47;
              v48 = strtok_r(0, "\t", &tok_buf);
              v39 = v48;
              v41 = v47 != 0;
              if ( !v48 || !v47 )
              {
                LOBYTE(v48) = v47 == 0;
                value = v48;
LABEL_175:
                v38 = 3;
LABEL_205:
                if ( v38 != 7 && v41 )
                  goto LABEL_241;
LABEL_202:
                if ( (_BYTE)value )
                  goto LABEL_241;
                goto LABEL_208;
              }
_L287:
              value = (char *)httpheader;
            }
            else
            {
              sepc = v44("/");
              co->path = (char *)sepc;
              v49 = Curl_cstrdup("/");
              v38 = (int)co;
              value = (char *)fields;
              co->spath = (char *)v49;
              if ( v49 )
              {
                LOBYTE(v49) = sepc == 0;
                value = (char *)v49;
              }
            }
            co->secure = 0;
            if ( curl_strequal(v39, "TRUE", v38) )
            {
              if ( !secure && !c->running )
              {
                strtok_r(0, "\t", &tok_buf);
                value = (char *)fields;
                v41 = 0;
                v38 = 4;
                goto LABEL_205;
              }
              co->secure = 1;
            }
            v39 = strtok_r(0, "\t", &tok_buf);
            v41 = (unsigned __int8)value ^ 1;
            if ( !v39 || !v41 )
            {
              v38 = 4;
              goto LABEL_205;
            }
_L219:
            v50 = curlx_strtoofft(v39, 0, 10);
            v51 = strtok_r(0, "\t", &tok_buf);
            v39 = v51;
            v41 = v50 == 0;
            if ( !v51 || v50 )
            {
              v38 = 5;
              LOBYTE(v51) = v50 != 0;
              value = v51;
              goto LABEL_205;
            }
_L218:
            v52 = Curl_cstrdup(v39);
            co->name = (char *)v52;
            if ( !v52 )
            {
              strtok_r(0, "\t", &tok_buf);
              value = (char *)fields;
LABEL_201:
              v55 = Curl_cstrdup(&LC1);
              co->value = (char *)v55;
              if ( !v55 )
                goto LABEL_241;
              goto LABEL_202;
            }
            if ( curl_strnequal("__Secure-", v52, 9, v53) )
            {
              co->prefix |= 1u;
            }
            else if ( curl_strnequal("__Host-", co->name, 7, v39) )
            {
              co->prefix |= 2u;
            }
            v39 = strtok_r(0, "\t", &tok_buf);
            if ( !v39 )
            {
              value = (char *)httpheader;
              goto LABEL_201;
            }
_L216:
            v54 = Curl_cstrdup(v39);
            co->value = (char *)v54;
            v38 = 6;
            LOBYTE(v54) = v54 == 0;
            value = (char *)v54;
LABEL_200:
            fields = v38;
            v40 = strtok_r(0, "\t", &tok_buf);
            v39 = v40;
            v38 = fields + 1;
            break;
          case 3:
            goto _L287;
          case 4:
            goto _L219;
          case 5:
            goto _L218;
          case 6:
            goto _L216;
          default:
            value = (char *)httpheader;
            goto LABEL_200;
        }
      }
    }
LABEL_9:
    Curl_cfree(co);
    return 0;
  }
  badcookie = 0;
  if ( strlen(lineptr) > 0x1388 )
    goto LABEL_9;
  while ( 1 )
  {
    v9 = *value;
    v81 = *value;
    if ( *value && (v9 == 32 || v9 == 9) )
      goto LABEL_12;
    fieldsa = strcspn(value, ";\t\r\n=");
    v10 = &value[fieldsa];
    if ( !fieldsa )
    {
      ptr = value;
      goto LABEL_133;
    }
    while ( 1 )
    {
      v11 = fieldsa--;
      v12 = value[fieldsa];
      if ( v12 != 32 && v12 != 9 )
        break;
      if ( !fieldsa )
        goto LABEL_22;
    }
    fieldsa = v11;
LABEL_22:
    if ( *v10 == 61 )
    {
      v13 = v10 + 1;
      sep = v10;
      vlen = strcspn(v10 + 1, ";\r\n");
      ptr = &v13[vlen];
      while ( 1 )
      {
        if ( !vlen )
          goto LABEL_36;
        v14 = sep[vlen];
        if ( v14 != 32 && v14 != 9 )
          break;
        --vlen;
      }
      while ( 1 )
      {
        if ( !vlen )
          goto LABEL_36;
        if ( *v13 != 32 && *v13 != 9 )
          break;
        --vlen;
        ++v13;
      }
      if ( memchr(v13, 9, vlen) )
      {
        freecookie(co);
        if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
        {
          v77 = data;
          v75 = data;
          v15 = "cookie contains TAB, dropping";
          goto LABEL_42;
        }
        return 0;
      }
LABEL_36:
      sepa = httpheader;
    }
    else
    {
      ptr = v10;
      v13 = 0;
      sepa = 0;
      vlen = 0;
    }
    if ( fieldsa > 0xFFE || vlen > 0xFFE || fieldsa + vlen > 0x1000 )
      break;
    if ( fieldsa > 6 )
    {
      if ( v81 == 95 && value[1] == 95 )
      {
        if ( curl_strnequal("__Secure-", value, 9, fieldsa + vlen) )
        {
          v16 = co;
          co->prefix |= 1u;
        }
        else
        {
          v22 = curl_strnequal("__Host-", value, 7, 0) == 0;
          v16 = co;
          if ( !v22 )
            co->prefix |= 2u;
        }
      }
      else
      {
        v16 = co;
      }
      if ( !v16->name )
      {
LABEL_58:
        if ( !sepa )
          goto LABEL_241;
        strstore(&co->name, value, fieldsa);
        strstore(&co->value, v13, vlen);
        name = co->name;
        if ( !name )
          goto LABEL_241;
        value = co->value;
        if ( !value )
          goto LABEL_241;
        if ( !value[strcspn(value, badoctets_0)] && !name[strcspn(name, badoctets_0)] )
          goto LABEL_133;
        if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
        {
          v78 = data;
          v76 = data;
          v19 = "invalid octets in name/value, cookie dropped";
          goto LABEL_240;
        }
LABEL_241:
        v60 = co;
LABEL_242:
        freecookie(v60);
        return 0;
      }
      if ( !vlen )
      {
        if ( fieldsa == 8 )
        {
          if ( curl_strnequal("httponly", value, 8, v16) )
            co->httponly = 1;
          goto LABEL_133;
        }
        if ( !sepa )
          goto LABEL_133;
      }
      if ( fieldsa != 7 || curl_strnequal("version", value, 7, v16) )
        goto LABEL_133;
      if ( curl_strnequal("max-age", value, 7, 0) )
      {
        if ( *v13 == 34 )
          ++v13;
        v25 = curlx_strtoofft(v13, 0, 10);
        if ( v25 != 1 )
        {
          if ( v25 == 2 )
            goto LABEL_119;
          if ( v25 )
            goto LABEL_133;
          vlena = co->expires;
          if ( !vlena )
          {
LABEL_119:
            v26 = co;
            goto LABEL_127;
          }
          value = (char *)(now >> 31);
          if ( 0x7FFFFFFFFFFFFFFFLL - now >= vlena )
          {
            co->expires = now + vlena;
            goto LABEL_133;
          }
        }
        LODWORD(co->expires) = -1;
        HIDWORD(co->expires) = 0x7FFFFFFF;
        goto LABEL_133;
      }
      if ( !curl_strnequal("expires", value, 7, 0) || co->expires || vlen > 0x7F )
        goto LABEL_133;
      qmemcpy(date, v13, vlen);
      date[vlen] = 0;
      v27 = Curl_getdate_capped(date);
      value = (char *)(v27 >> 31);
      v26 = co;
      if ( v27 )
      {
        if ( v27 >> 31 != -1 )
        {
          LODWORD(co->expires) = v27;
          HIDWORD(co->expires) = value;
          goto LABEL_133;
        }
        LODWORD(co->expires) = 0;
        goto LABEL_131;
      }
LABEL_127:
      LODWORD(v26->expires) = 1;
LABEL_131:
      HIDWORD(v26->expires) = 0;
      goto LABEL_133;
    }
    v17 = (int)co;
    if ( !co->name )
      goto LABEL_58;
    if ( vlen )
    {
      if ( fieldsa == 4 )
        goto LABEL_79;
      if ( fieldsa != 6 )
        goto LABEL_133;
LABEL_76:
      LOBYTE(v20) = (vlen != 0) & (curl_strnequal("domain", value, 6, v17) != 0);
      fieldsb = v20;
      if ( !v20 )
        goto LABEL_133;
      if ( *v13 == 46 )
      {
        --vlen;
        ++v13;
      }
      if ( vlen != 9 || !curl_strnequal(v13, "localhost", 9, v20) )
      {
        v23 = memchr(v13, 46, vlen);
        if ( !v23 || vlen - (v23 - v13) <= 1 )
        {
          value = ":";
          is_ipnum = Curl_host_is_ipnum(":");
          domain = ":";
          goto LABEL_95;
        }
      }
      if ( !domain )
      {
        value = (char *)Curl_host_is_ipnum(v13);
        strstore(&co->domain, v13, vlen);
        if ( !co->domain )
          goto LABEL_241;
        if ( (_BYTE)value )
          goto LABEL_133;
LABEL_105:
        co->tailmatch = 1;
        goto LABEL_133;
      }
      is_ipnum = Curl_host_is_ipnum(domain);
LABEL_95:
      if ( !is_ipnum )
      {
        if ( cookie_tailmatch(v13, vlen, domain) )
        {
          strstore(&co->domain, v13, vlen);
          if ( !co->domain )
            goto LABEL_241;
          goto LABEL_105;
        }
LABEL_106:
        if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
          Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v13, data);
        badcookie = fieldsb;
        goto LABEL_133;
      }
      if ( strncmp(v13, domain, vlen) || strlen(domain) != vlen )
        goto LABEL_106;
      strstore(&co->domain, v13, vlen);
      v22 = co->domain == 0;
LABEL_102:
      if ( v22 )
        goto LABEL_241;
      goto LABEL_133;
    }
    if ( fieldsa != 6 )
    {
      if ( !sepa || fieldsa != 4 )
        goto LABEL_133;
LABEL_79:
      if ( !curl_strnequal("path", value, 4, co) )
        goto LABEL_133;
      strstore(&co->path, v13, vlen);
      if ( !co->path )
        goto LABEL_241;
      Curl_cfree(co->spath);
      v21 = sanitize_cookie_path(co->path);
      v22 = v21 == 0;
      co->spath = v21;
      goto LABEL_102;
    }
    v17 = curl_strnequal("secure", value, 6, co);
    if ( !v17 )
    {
      if ( !sepa )
        goto LABEL_133;
      goto LABEL_76;
    }
    if ( !secure && c->running )
      goto LABEL_241;
    co->secure = 1;
    while ( 1 )
    {
LABEL_133:
      v28 = *ptr;
      if ( !*ptr )
        goto LABEL_139;
      if ( v28 != 32 && v28 != 9 )
        break;
      ++ptr;
    }
    if ( v28 != 59 )
    {
LABEL_139:
      if ( badcookie )
        goto LABEL_241;
      if ( !co->domain )
      {
        if ( domain )
        {
          v29 = Curl_cstrdup(domain);
          co->domain = (char *)v29;
          if ( !v29 )
            goto LABEL_241;
        }
      }
      if ( !co->path )
      {
        if ( path )
        {
          v30 = strchr(path, 63);
          v31 = v30 ? (char *)Curl_memrchr(path, 47, v30 - path, value) : strrchr(path, 47);
          if ( v31 )
          {
            v32 = v31 - path;
            fieldsc = v32 + 1;
            vlenb = v32;
            v33 = (char *)Curl_cmalloc(v32 + 2);
            co->path = v33;
            if ( !v33 )
              goto LABEL_241;
            qmemcpy(v33, path, fieldsc);
            value = &v33[fieldsc];
            co->path[vlenb + 1] = 0;
            v34 = sanitize_cookie_path(co->path);
            co->spath = v34;
            if ( !v34 )
              goto LABEL_241;
          }
        }
      }
      if ( !co->name )
        goto LABEL_241;
      ++data->req.setcookies;
LABEL_208:
      prefix = co->prefix;
      if ( (prefix & 1) != 0 )
      {
        v57 = co;
        if ( !co->secure )
          goto LABEL_218;
      }
      if ( (prefix & 2) != 0 )
      {
        if ( !co->secure )
          goto LABEL_241;
        v58 = co->path;
        if ( !v58 || strcmp(v58, "/") || co->tailmatch )
          goto LABEL_241;
      }
      running = c->running;
      if ( !running && c->newsession )
      {
        v57 = co;
        if ( !co->expires )
        {
LABEL_218:
          v60 = v57;
          goto LABEL_242;
        }
      }
      co->livecookie = running;
      v61 = c->lastct + 1;
      c->lastct = v61;
      co->creationtime = v61;
      if ( !noexpire )
        remove_expired(c);
      replace_olda = 0;
      myhash = cookiehash(co->domain);
      v62 = c->cookies[myhash];
      spath = 0;
      vlenc = 0;
      fieldsd = 0;
      sepd = 0;
      while ( 2 )
      {
        if ( !v62 )
        {
          if ( fieldsd )
          {
            fieldsd->next = vlenc->next;
            fieldsd->creationtime = vlenc->creationtime;
            Curl_cfree(vlenc->name);
            Curl_cfree(vlenc->value);
            Curl_cfree(vlenc->domain);
            Curl_cfree(vlenc->path);
            Curl_cfree(vlenc->spath);
            qmemcpy(vlenc, fieldsd, sizeof(Cookie));
            Curl_cfree(fieldsd);
            co = vlenc;
          }
          if ( c->running && (*(&data->set.connect_only + 4) & 0x20) != 0 )
          {
            v71 = "Replaced";
            if ( !replace_olda )
              v71 = "Added";
            Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v71, co->name);
          }
          if ( !replace_olda )
          {
            if ( sepd )
              sepd->next = co;
            else
              c->cookies[myhash] = co;
            ++c->numcookies;
          }
          expires = co->expires;
          expires_high = HIDWORD(co->expires);
          if ( co->expires && __SPAIR64__(expires_high, expires) < c->next_expiration )
          {
            LODWORD(c->next_expiration) = expires;
            HIDWORD(c->next_expiration) = expires_high;
          }
          return co;
        }
        spath = curl_strequal(v62->name, co->name, spath);
        if ( spath )
        {
          v64 = v62->domain;
          spath = (int)co->domain;
          if ( v64 )
          {
            if ( spath )
            {
              spath = curl_strequal(v64, spath, value);
              if ( spath )
              {
LABEL_230:
                value = v62->spath;
                if ( value )
                {
                  spath = (int)co->spath;
                  sepe = spath;
                  if ( spath )
                  {
                    if ( v62->secure )
                    {
                      spath = (int)co;
                      if ( !co->secure && !secure )
                      {
                        v65 = strchr(value + 1, 47);
                        v67 = v65 ? v65 - value : strlen(value);
                        spath = curl_strnequal(value, sepe, v67, v66);
                        if ( spath )
                        {
                          if ( (*(&data->set.connect_only + 4) & 0x20) == 0 )
                            goto LABEL_241;
                          v78 = (Curl_easy *)co->domain;
                          v76 = (Curl_easy *)co->name;
                          v19 = "cookie '%s' for domain '%s' dropped, would overlay an existing cookie";
LABEL_240:
                          Curl_infof(data, v19, v76, v78);
                          goto LABEL_241;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else if ( !spath )
          {
            goto LABEL_230;
          }
        }
        if ( !fieldsd )
        {
          spath = curl_strequal(v62->name, co->name, spath);
          if ( spath )
          {
            v68 = v62->domain;
            spath = (int)co->domain;
            if ( v68 )
            {
              if ( spath )
              {
                spath = curl_strequal(v68, spath, value);
                if ( spath )
                {
                  spath = (int)co;
                  LOBYTE(spath) = co->tailmatch;
                  v69 = v62->tailmatch == (unsigned __int8)spath;
                  goto LABEL_251;
                }
              }
              goto LABEL_247;
            }
            v69 = spath == 0;
LABEL_251:
            if ( v69 )
            {
LABEL_252:
              spath = (int)v62->spath;
              v70 = co->spath;
              if ( !spath || v70 && (spath = curl_strequal(spath, v70, co)) != 0 )
              {
                spath = (int)co;
                LOBYTE(spath) = co->spath == 0;
                if ( (v62->spath == 0) == (_BYTE)spath )
                {
                  replace_olda = co->livecookie;
                  if ( replace_olda )
                  {
                    spath = (int)co;
                    vlenc = v62;
                    fieldsd = co;
                  }
                  else
                  {
                    if ( v62->livecookie )
                      goto LABEL_241;
                    spath = (int)co;
                    vlenc = v62;
                    replace_olda = 1;
                    fieldsd = co;
                  }
                  goto LABEL_224;
                }
              }
            }
            else
            {
LABEL_247:
              if ( replace_olda )
                goto LABEL_252;
            }
            replace_olda = 0;
          }
        }
LABEL_224:
        sepd = v62;
        v62 = v62->next;
        continue;
      }
    }
    value = (char *)ptr;
LABEL_12:
    ++value;
  }
  freecookie(co);
  if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
  {
    v77 = (Curl_easy *)vlen;
    v15 = "oversized cookie dropped, name/val %zu + %zu bytes";
    v75 = (Curl_easy *)fieldsa;
LABEL_42:
    Curl_infof(data, v15, v75, v77);
  }
  return 0;
}
