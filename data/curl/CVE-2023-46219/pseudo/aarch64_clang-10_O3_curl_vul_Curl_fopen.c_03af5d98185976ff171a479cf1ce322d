CURLcode __fastcall Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  __mode_t st_mode; // w22
  CURLcode v9; // w0
  CURLcode v10; // w23
  char *v11; // x20
  FILE *v12; // x0
  const char *v14; // x0
  int v15; // w0
  int v16; // w23
  FILE *v17; // x0
  struct stat v18; // [xsp+0h] [xbp-110h] BYREF
  struct stat buf; // [xsp+80h] [xbp-90h] BYREF
  unsigned __int8 randsuffix[9]; // [xsp+104h] [xbp-Ch] BYREF

  *tempname = 0LL;
  if ( stat_0(filename, &buf) != -1 )
  {
    st_mode = buf.st_mode;
    if ( (buf.st_mode & 0xF000) == 0x8000 )
    {
      v9 = (unsigned int)Curl_rand_hex(data, randsuffix, 9LL);
      if ( v9 )
      {
        v10 = v9;
        v11 = 0LL;
LABEL_9:
        Curl_cfree(v11);
        v11 = 0LL;
LABEL_10:
        *tempname = v11;
        return v10;
      }
      v14 = (const char *)curl_maprintf("%s.%s.tmp", filename, (const char *)randsuffix);
      v11 = (char *)v14;
      if ( !v14 )
      {
        v10 = CURLE_OUT_OF_MEMORY;
        goto LABEL_9;
      }
      v15 = open(v14, 193, 384LL);
      if ( v15 != -1 )
      {
        v16 = v15;
        if ( fstat(v15, &v18) == -1
          || v18.st_uid != buf.st_uid
          || v18.st_gid != buf.st_gid
          || fchmod(v16, st_mode) != -1 )
        {
          v17 = fdopen(v16, "w");
          *fh = v17;
          if ( v17 )
          {
            v10 = CURLE_OK;
            goto LABEL_10;
          }
        }
        close(v16);
        unlink(v11);
      }
LABEL_8:
      v10 = CURLE_WRITE_ERROR;
      goto LABEL_9;
    }
  }
  v12 = fopen(filename, "w");
  *fh = v12;
  if ( !v12 )
  {
    v11 = 0LL;
    goto LABEL_8;
  }
  return 0;
}
