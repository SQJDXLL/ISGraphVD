CURLcode __fastcall Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  char *v8; // x19
  FILE *v9; // x0
  int v10; // w0
  __mode_t st_mode; // w25
  CURLcode v12; // w0
  CURLcode v13; // w24
  char *v14; // x20
  int v15; // w23
  const char *v17; // x0
  FILE *v18; // x0
  struct stat v19; // [xsp+0h] [xbp-130h] BYREF
  struct stat buf; // [xsp+80h] [xbp-B0h] BYREF
  unsigned __int8 randbuf[41]; // [xsp+104h] [xbp-2Ch] BYREF

  *tempname = 0LL;
  v8 = dirslash(filename);
  if ( !v8 || (v9 = fopen(filename, "w"), (*fh = v9) == 0LL) )
  {
    v14 = 0LL;
    v15 = -1;
    goto LABEL_8;
  }
  v10 = fileno(v9);
  if ( fstat(v10, &buf) == -1 || (st_mode = buf.st_mode, (buf.st_mode & 0xF000) != 0x8000) )
  {
    Curl_cfree(v8);
    return 0;
  }
  fclose(*fh);
  *fh = 0LL;
  v12 = (unsigned int)Curl_rand_alnum(data, randbuf, 41LL);
  if ( v12 == CURLE_OK )
  {
    v17 = (const char *)curl_maprintf("%s%s.tmp", v8, (const char *)randbuf);
    v14 = (char *)v17;
    if ( !v17 )
    {
      v13 = CURLE_OUT_OF_MEMORY;
      goto LABEL_10;
    }
    v15 = open(v17, 193, 384LL);
    if ( v15 != -1
      && (fstat(v15, &v19) == -1 || v19.st_uid != buf.st_uid || v19.st_gid != buf.st_gid || fchmod(v15, st_mode) != -1) )
    {
      v18 = fdopen(v15, "w");
      *fh = v18;
      if ( v18 )
      {
        Curl_cfree(v8);
        v13 = CURLE_OK;
        *tempname = v14;
        return v13;
      }
    }
LABEL_8:
    v13 = CURLE_WRITE_ERROR;
    if ( v15 != -1 )
    {
      close(v15);
      unlink(v14);
    }
    goto LABEL_10;
  }
  v13 = v12;
  v14 = 0LL;
LABEL_10:
  Curl_cfree(v14);
  Curl_cfree(v8);
  return v13;
}
