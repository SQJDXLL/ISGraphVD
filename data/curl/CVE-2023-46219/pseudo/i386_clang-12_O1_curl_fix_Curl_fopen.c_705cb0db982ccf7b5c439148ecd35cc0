CURLcode __cdecl Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  int v4; // edi
  const char *v5; // esi
  FILE *v6; // eax
  int v7; // eax
  int v8; // eax
  CURLcode v9; // ebp
  int v10; // eax
  char *v11; // ebp
  int v12; // eax
  int v13; // esi
  FILE *v14; // eax
  FILE *stream; // [esp+0h] [ebp-11Ch]
  char *v17; // [esp+14h] [ebp-108h]
  int mode; // [esp+18h] [ebp-104h]
  char v19[16]; // [esp+20h] [ebp-FCh] BYREF
  int v20; // [esp+30h] [ebp-ECh]
  int v21; // [esp+38h] [ebp-E4h]
  int v22; // [esp+3Ch] [ebp-E0h]
  char v23[24]; // [esp+80h] [ebp-9Ch] BYREF
  int v24; // [esp+98h] [ebp-84h]
  int v25; // [esp+9Ch] [ebp-80h]
  char v26[57]; // [esp+E3h] [ebp-39h] BYREF

  *tempname = 0;
  v4 = -1;
  v5 = 0;
  v17 = dirslash((const char *)stream);
  if ( !v17 )
    goto LABEL_19;
  v6 = (FILE *)fopen64(filename, "w");
  *fh = v6;
  if ( !v6 )
    goto LABEL_19;
  v7 = fileno(v6);
  if ( fstat64(v7, v19) == -1 || (v20 & 0xF000) != 0x8000 )
  {
    Curl_cfree(v17);
    return 0;
  }
  mode = v20;
  fclose(*fh);
  *fh = 0;
  v8 = Curl_rand_alnum(data, v26, 41);
  if ( !v8 )
  {
    v10 = curl_maprintf("%s%s.tmp", v17, v26);
    if ( !v10 )
    {
      v9 = CURLE_OUT_OF_MEMORY;
      goto fail;
    }
    v11 = (char *)v10;
    v12 = open64(v10, 193, 384);
    if ( v12 != -1 )
    {
      v13 = v12;
      if ( fstat64(v12, v23) == -1 || v24 != v21 || v25 != v22 || fchmod(v13, mode) != -1 )
      {
        v14 = fdopen(v13, "w");
        *fh = v14;
        if ( v14 )
        {
          Curl_cfree(v17);
          *tempname = v11;
          return 0;
        }
      }
      v4 = v13;
    }
    v5 = v11;
LABEL_19:
    v9 = CURLE_WRITE_ERROR;
    goto fail;
  }
  v9 = v8;
fail:
  if ( v4 != -1 )
  {
    close(v4);
    unlink(v5);
  }
  Curl_cfree(v5);
  Curl_cfree(v17);
  return v9;
}
