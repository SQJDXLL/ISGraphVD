CURLcode __fastcall Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  __mode_t st_mode; // w24
  CURLcode v9; // w0
  CURLcode v10; // w23
  char *v11; // x20
  FILE *v12; // x0
  int v13; // w22
  const char *v15; // x0
  FILE *v16; // x0
  struct stat v17; // [xsp+0h] [xbp-110h] BYREF
  struct stat buf; // [xsp+80h] [xbp-90h] BYREF
  char v19[12]; // [xsp+104h] [xbp-Ch] BYREF

  *tempname = 0LL;
  if ( stat_0(filename, &buf) != -1 )
  {
    st_mode = buf.st_mode;
    if ( (buf.st_mode & 0xF000) == 0x8000 )
    {
      v9 = (unsigned int)Curl_rand_hex(data, v19, 9LL);
      if ( v9 )
      {
        v10 = v9;
        v11 = 0LL;
LABEL_10:
        Curl_cfree(v11);
        v11 = 0LL;
LABEL_11:
        *tempname = v11;
        return v10;
      }
      v15 = (const char *)curl_maprintf("%s.%s.tmp", filename, v19);
      v11 = (char *)v15;
      if ( !v15 )
      {
        v10 = CURLE_OUT_OF_MEMORY;
        goto LABEL_10;
      }
      v13 = open(v15, 193, 384LL);
      if ( v13 != -1
        && (fstat(v13, &v17) == -1 || v17.st_uid != buf.st_uid || v17.st_gid != buf.st_gid || fchmod(v13, st_mode) != -1) )
      {
        v16 = fdopen(v13, "w");
        *fh = v16;
        if ( v16 )
        {
          v10 = CURLE_OK;
          goto LABEL_11;
        }
      }
LABEL_8:
      v10 = CURLE_WRITE_ERROR;
      if ( v13 != -1 )
      {
        close(v13);
        unlink(v11);
      }
      goto LABEL_10;
    }
  }
  v12 = fopen(filename, "w");
  *fh = v12;
  if ( !v12 )
  {
    v11 = 0LL;
    v13 = -1;
    goto LABEL_8;
  }
  return 0;
}
