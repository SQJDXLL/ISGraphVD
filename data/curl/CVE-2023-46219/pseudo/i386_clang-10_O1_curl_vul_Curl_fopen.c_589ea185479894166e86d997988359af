CURLcode __cdecl Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, const char **tempname)
{
  int v4; // eax
  int v5; // ebp
  const char *v6; // esi
  CURLcode v7; // edi
  FILE *v8; // ecx
  CURLcode result; // eax
  int v10; // eax
  int v11; // eax
  FILE *v12; // ecx
  int mode; // [esp+8h] [ebp-E4h]
  char v14[9]; // [esp+Fh] [ebp-DDh] BYREF
  char v15[16]; // [esp+18h] [ebp-D4h] BYREF
  int v16; // [esp+28h] [ebp-C4h]
  int v17; // [esp+30h] [ebp-BCh]
  int v18; // [esp+34h] [ebp-B8h]
  char v19[24]; // [esp+78h] [ebp-74h] BYREF
  int v20; // [esp+90h] [ebp-5Ch]
  int v21; // [esp+94h] [ebp-58h]

  *tempname = 0;
  if ( stat64(filename, v15) == -1 || (v16 & 0xF000) != 0x8000 )
  {
    v8 = (FILE *)fopen64(filename, "w");
    *fh = v8;
    result = CURLE_OK;
    if ( v8 )
      return result;
    v5 = -1;
    v7 = CURLE_WRITE_ERROR;
    v6 = 0;
  }
  else
  {
    mode = v16;
    v4 = Curl_rand_hex(data, v14, 9);
    v5 = -1;
    v6 = 0;
    if ( v4 )
    {
      v7 = v4;
    }
    else
    {
      v10 = curl_maprintf("%s.%s.tmp", filename, v14);
      if ( v10 )
      {
        v6 = (const char *)v10;
        v11 = open64(v10, 193, 384);
        v7 = CURLE_WRITE_ERROR;
        if ( v11 != -1 )
        {
          v5 = v11;
          if ( fstat64(v11, v19) == -1 || v20 != v17 || v21 != v18 || fchmod(v5, mode) != -1 )
          {
            v12 = fdopen(v5, "w");
            *fh = v12;
            result = CURLE_OK;
            if ( v12 )
              goto LABEL_20;
          }
          goto fail;
        }
      }
      else
      {
        v7 = CURLE_OUT_OF_MEMORY;
        v6 = 0;
      }
      v5 = -1;
    }
  }
fail:
  if ( v5 != -1 )
  {
    close(v5);
    unlink(v6);
  }
  Curl_cfree(v6);
  v6 = 0;
  result = v7;
LABEL_20:
  *tempname = v6;
  return result;
}
