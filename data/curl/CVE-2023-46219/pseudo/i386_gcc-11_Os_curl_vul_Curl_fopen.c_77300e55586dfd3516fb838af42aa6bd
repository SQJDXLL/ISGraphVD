// bad sp value at call has been detected, the output may be wrong!
CURLcode __cdecl Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  int v4; // eax
  CURLcode v5; // edi
  const char *v6; // esi
  int v7; // eax
  int v8; // ecx
  __uid_t st_uid; // eax
  int v10; // edx
  FILE *v11; // eax
  int v13; // [esp-8h] [ebp-100h]
  int v14; // [esp-4h] [ebp-FCh]
  int v15; // [esp+0h] [ebp-F8h]
  _DWORD *v16; // [esp+4h] [ebp-F4h]
  const char **v17; // [esp+8h] [ebp-F0h]
  int fd; // [esp+Ch] [ebp-ECh]
  int fda; // [esp+Ch] [ebp-ECh]
  stat sb; // [esp+10h] [ebp-E8h] BYREF
  stat nsb; // [esp+70h] [ebp-88h] BYREF
  unsigned __int8 randsuffix[9]; // [esp+D3h] [ebp-25h] BYREF
  unsigned int v23; // [esp+DCh] [ebp-1Ch]
  __uid_t v24; // [esp+E4h] [ebp-14h]
  __uid_t v25; // [esp+E8h] [ebp-10h]

  v23 = __readgsdword(0x14u);
  *tempname = 0;
  v4 = ((int (__stdcall *)(const char *, stat *, int, int, int, FILE **, char **, const char *))stat64)(
         filename,
         &sb,
         v13,
         v14,
         v15,
         fh,
         tempname,
         filename)
     + 1;
  if ( v4 )
  {
    v4 = sb.st_mode & 0xF000;
    if ( v4 == 0x8000 )
    {
      v6 = 0;
      v5 = Curl_rand_hex(data, randsuffix, 9, 0x8000);
      if ( v5 == CURLE_OK )
      {
        v7 = curl_maprintf("%s.%s.tmp", fd, randsuffix, 0);
        v6 = (const char *)v7;
        if ( v7 )
        {
          fda = open64(v7, 193, 384, v7);
          if ( fda != -1 )
          {
            st_uid = fstat64(fda, &nsb, v8, v8) + 1;
            if ( !st_uid
              || (st_uid = sb.st_uid, nsb.st_uid != sb.st_uid)
              || (st_uid = sb.st_gid, nsb.st_gid != sb.st_gid)
              || (v25 = v10, v24 = v10, (st_uid = fchmod(fda, sb.st_mode) + 1) != 0) )
            {
              v25 = st_uid;
              v24 = st_uid;
              v11 = fdopen(fda, "w");
              *v16 = v11;
              if ( v11 )
              {
                *v17 = v6;
                return v5;
              }
            }
            close(fda);
            unlink(v6);
          }
LABEL_16:
          v5 = CURLE_WRITE_ERROR;
          goto LABEL_17;
        }
        v5 = CURLE_OUT_OF_MEMORY;
      }
LABEL_17:
      Curl_cfree(v6);
      *v17 = 0;
      return v5;
    }
  }
  v5 = CURLE_OK;
  v6 = (const char *)fopen64(fd, "w", v4, v4);
  *v16 = v6;
  if ( !v6 )
    goto LABEL_16;
  return v5;
}
