CURLcode __cdecl Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  int v4; // eax
  FILE *v5; // rax
  stat nsb; // [rsp+8h] [rbp-198h] BYREF
  char *dir; // [rsp+98h] [rbp-108h]
  int fd; // [rsp+A4h] [rbp-FCh]
  stat sb; // [rsp+A8h] [rbp-F8h] BYREF
  char *tempstore; // [rsp+138h] [rbp-68h]
  unsigned __int8 randbuf[41]; // [rsp+140h] [rbp-60h] BYREF
  CURLcode result; // [rsp+174h] [rbp-2Ch]
  char **tempnamea; // [rsp+178h] [rbp-28h]
  FILE **fha; // [rsp+180h] [rbp-20h]
  const char *filenamea; // [rsp+188h] [rbp-18h]
  Curl_easy *dataa; // [rsp+190h] [rbp-10h]

  dataa = data;
  filenamea = filename;
  fha = fh;
  tempnamea = tempname;
  result = CURLE_WRITE_ERROR;
  tempstore = 0LL;
  fd = -1;
  *tempname = 0LL;
  dir = dirslash(filenamea);
  if ( dir )
  {
    *fha = fopen(filenamea, "w");
    if ( *fha )
    {
      v4 = fileno(*fha);
      if ( fstat(v4, &sb) == -1 || (sb.st_mode & 0xF000) != 0x8000 )
      {
        Curl_cfree(dir);
        return 0;
      }
      fclose(*fha);
      *fha = 0LL;
      result = (unsigned int)Curl_rand_alnum(dataa, randbuf, 41LL);
      if ( result == CURLE_OK )
      {
        tempstore = (char *)curl_maprintf("%s%s.tmp", dir, (const char *)randbuf);
        if ( tempstore )
        {
          result = CURLE_WRITE_ERROR;
          fd = open(tempstore, 193, 384LL);
          if ( fd != -1
            && (fstat(fd, &nsb) == -1
             || nsb.st_uid != sb.st_uid
             || nsb.st_gid != sb.st_gid
             || fchmod(fd, sb.st_mode) != -1) )
          {
            v5 = fdopen(fd, "w");
            *fha = v5;
            if ( *fha )
            {
              Curl_cfree(dir);
              *tempnamea = tempstore;
              return 0;
            }
          }
        }
        else
        {
          result = CURLE_OUT_OF_MEMORY;
        }
      }
    }
  }
  if ( fd != -1 )
  {
    close(fd);
    unlink(tempstore);
  }
  Curl_cfree(tempstore);
  Curl_cfree(dir);
  return result;
}
