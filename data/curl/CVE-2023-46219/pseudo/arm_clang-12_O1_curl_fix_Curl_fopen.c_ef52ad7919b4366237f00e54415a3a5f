CURLcode __fastcall Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  const char *v8; // r6
  char *v9; // r4
  int v10; // r5
  CURLcode v11; // r8
  FILE *v12; // r0
  int v13; // r0
  __mode_t v14; // r7
  int v15; // r0
  void (__fastcall **v16)(char *); // r5
  int v18; // r0
  char *v19; // r10
  int v20; // r0
  int v21; // r6
  FILE *v22; // r0
  char v23[24]; // [sp+8h] [bp-120h] BYREF
  int v24; // [sp+20h] [bp-108h]
  int v25; // [sp+24h] [bp-104h]
  char v26[16]; // [sp+70h] [bp-B8h] BYREF
  __mode_t v27; // [sp+80h] [bp-A8h]
  int v28; // [sp+88h] [bp-A0h]
  int v29; // [sp+8Ch] [bp-9Ch]
  char v30[77]; // [sp+DBh] [bp-4Dh] BYREF

  v8 = 0;
  *tempname = 0;
  v9 = dirslash(filename);
  v10 = -1;
  v11 = CURLE_WRITE_ERROR;
  if ( !v9 )
    goto fail;
  v12 = (FILE *)fopen64(filename, "w");
  *fh = v12;
  if ( !v12 )
    goto fail;
  v13 = fileno(v12);
  if ( fstat64(v13, v26) == -1 || (v14 = v27, (v27 & 0xF000) != 0x8000) )
  {
    ((void (__fastcall *)(char *))*Curl_cfree)(v9);
    return 0;
  }
  fclose(*fh);
  v8 = 0;
  *fh = 0;
  v15 = Curl_rand_alnum(data, v30, 41);
  if ( !v15 )
  {
    v18 = curl_maprintf("%s%s.tmp", v9, v30);
    if ( !v18 )
    {
      v11 = CURLE_OUT_OF_MEMORY;
      goto fail;
    }
    v19 = (char *)v18;
    v20 = open64(v18, 193, 384);
    if ( v20 != -1 )
    {
      v21 = v20;
      if ( fstat64(v20, v23) == -1 || v24 != v28 || v25 != v29 || fchmod(v21, v14) != -1 )
      {
        v22 = fdopen(v21, "w");
        *fh = v22;
        if ( v22 )
        {
          ((void (__fastcall *)(char *))*Curl_cfree)(v9);
          *tempname = v19;
          return 0;
        }
      }
      v10 = v21;
    }
    v8 = v19;
    goto fail;
  }
  v11 = v15;
fail:
  if ( v10 != -1 )
  {
    close(v10);
    unlink(v8);
  }
  v16 = (void (__fastcall **)(char *))Curl_cfree;
  ((void (__fastcall *)(const char *))*Curl_cfree)(v8);
  (*v16)(v9);
  return v11;
}
