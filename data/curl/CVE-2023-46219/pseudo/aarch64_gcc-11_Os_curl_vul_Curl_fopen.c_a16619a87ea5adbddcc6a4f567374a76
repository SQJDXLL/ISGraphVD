CURLcode __fastcall Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  FILE *v8; // x0
  char *v9; // x19
  CURLcode v10; // w20
  const char *v11; // x0
  int v12; // w0
  int v13; // w21
  FILE *v14; // x0
  stat sb; // [xsp+48h] [xbp+48h] BYREF
  stat nsb; // [xsp+C8h] [xbp+C8h] BYREF
  unsigned __int8 randsuffix[9]; // [xsp+148h] [xbp+148h] BYREF

  *tempname = 0LL;
  if ( stat_0(filename, &sb) != -1 && (sb.st_mode & 0xF000) == 0x8000 )
  {
    v10 = (unsigned int)Curl_rand_hex(data, randsuffix, 9LL);
    if ( v10 )
    {
      v9 = 0LL;
      goto LABEL_15;
    }
    v11 = (const char *)curl_maprintf("%s.%s.tmp", filename, (const char *)randsuffix);
    v9 = (char *)v11;
    if ( !v11 )
    {
      v10 = CURLE_OUT_OF_MEMORY;
      goto LABEL_15;
    }
    v12 = open(v11, 193, 384LL);
    v13 = v12;
    if ( v12 == -1 )
    {
LABEL_4:
      v10 = CURLE_WRITE_ERROR;
LABEL_15:
      Curl_cfree(v9);
      *tempname = 0LL;
      return v10;
    }
    if ( fstat(v12, &nsb) != -1 && *(_QWORD *)&nsb.st_uid == *(_QWORD *)&sb.st_uid && fchmod(v13, sb.st_mode) == -1
      || (v14 = fdopen(v13, "w"), (*fh = v14) == 0LL) )
    {
      close(v13);
      unlink(v9);
      goto LABEL_4;
    }
    *tempname = v9;
  }
  else
  {
    v8 = fopen(filename, "w");
    *fh = v8;
    v9 = (char *)v8;
    v10 = CURLE_OK;
    if ( !v8 )
      goto LABEL_4;
  }
  return v10;
}
