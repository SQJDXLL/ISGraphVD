CURLcode __fastcall Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  char *v6; // r13
  int v7; // ebp
  FILE *v8; // rax
  int v9; // eax
  __mode_t st_mode; // r14d
  CURLcode v11; // eax
  char *v12; // r14
  CURLcode v13; // ebx
  const char *v15; // rax
  int v16; // eax
  int v17; // ebx
  FILE *v18; // rax
  __mode_t mode; // [rsp+Ch] [rbp-18Ch]
  char v20[56]; // [rsp+10h] [rbp-188h] BYREF
  struct stat buf; // [rsp+48h] [rbp-150h] BYREF
  struct stat v22; // [rsp+D8h] [rbp-C0h] BYREF

  *tempname = 0LL;
  v6 = dirslash(filename);
  v7 = -1;
  if ( !v6 || (v8 = fopen(filename, "w"), (*fh = v8) == 0LL) )
  {
    v12 = 0LL;
    goto LABEL_8;
  }
  v9 = fileno(v8);
  if ( fstat(v9, &buf) == -1 || (st_mode = buf.st_mode, (buf.st_mode & 0xF000) != 0x8000) )
  {
    Curl_cfree(v6);
    return 0;
  }
  fclose(*fh);
  *fh = 0LL;
  v11 = (unsigned int)Curl_rand_alnum(data, v20, 41LL);
  if ( v11 == CURLE_OK )
  {
    mode = st_mode;
    v15 = (const char *)curl_maprintf("%s%s.tmp", v6, v20);
    if ( !v15 )
    {
      v13 = CURLE_OUT_OF_MEMORY;
      v12 = 0LL;
      goto LABEL_10;
    }
    v12 = (char *)v15;
    v16 = open(v15, 193, 384LL);
    if ( v16 != -1 )
    {
      v17 = v16;
      if ( fstat(v16, &v22) == -1 || v22.st_uid != buf.st_uid || v22.st_gid != buf.st_gid || fchmod(v17, mode) != -1 )
      {
        v18 = fdopen(v17, "w");
        *fh = v18;
        if ( v18 )
        {
          Curl_cfree(v6);
          *tempname = v12;
          return 0;
        }
      }
      v7 = v17;
    }
LABEL_8:
    v13 = CURLE_WRITE_ERROR;
    if ( v7 != -1 )
    {
      close(v7);
      unlink(v12);
    }
    goto LABEL_10;
  }
  v12 = 0LL;
  v13 = v11;
LABEL_10:
  Curl_cfree(v12);
  Curl_cfree(v6);
  return v13;
}
