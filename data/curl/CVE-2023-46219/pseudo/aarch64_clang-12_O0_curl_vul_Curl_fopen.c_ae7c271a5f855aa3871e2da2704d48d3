// local variable allocation has failed, the output may be wrong!
CURLcode __cdecl Curl_fopen(Curl_easy *data, const char *filename, FILE **fh, char **tempname)
{
  FILE *v4; // x0
  FILE *v5; // x0
  struct stat v7; // [xsp+8h] [xbp-148h] BYREF
  int fd; // [xsp+8Ch] [xbp-C4h]
  struct stat buf; // [xsp+90h] [xbp-C0h] BYREF
  char *v10; // [xsp+110h] [xbp-40h]
  char v11[9]; // [xsp+11Bh] [xbp-35h] BYREF
  int v12; // [xsp+124h] [xbp-2Ch]
  char **v13; // [xsp+128h] [xbp-28h]
  char *tempstore; // [xsp+130h] [xbp-20h]
  __int128 v15; // [xsp+138h] [xbp-18h] OVERLAPPED
  char **tempnamea; // [xsp+148h] [xbp-8h]

  *((_QWORD *)&v15 + 1) = data;
  *(_QWORD *)&v15 = filename;
  tempstore = (char *)fh;
  v13 = tempname;
  v12 = 23;
  v10 = 0LL;
  fd = -1;
  *tempname = 0LL;
  if ( stat_0((const char *)v15, &buf) != -0x1 && (buf.st_mode & 0xF000) == 0x8000 )
  {
    v12 = Curl_rand_hex(*((_QWORD *)&v15 + 1), v11, 9LL);
    if ( !v12 )
    {
      v10 = (char *)curl_maprintf("%s.%s.tmp", (const char *)v15, v11);
      if ( v10 )
      {
        v12 = 23;
        fd = open(v10, 193, 384LL);
        if ( fd != -0x1
          && (fstat(fd, &v7) == -0x1
           || v7.st_uid != buf.st_uid
           || v7.st_gid != buf.st_gid
           || fchmod(fd, buf.st_mode) != -0x1) )
        {
          v5 = fdopen(fd, "w");
          *(_QWORD *)tempstore = v5;
          if ( *(_QWORD *)tempstore )
          {
            *v13 = v10;
            HIDWORD(tempnamea) = 0;
            return HIDWORD(tempnamea);
          }
        }
      }
      else
      {
        v12 = 27;
      }
    }
  }
  else
  {
    v4 = fopen((const char *)v15, "w");
    *(_QWORD *)tempstore = v4;
    if ( *(_QWORD *)tempstore )
    {
      HIDWORD(tempnamea) = 0;
      return HIDWORD(tempnamea);
    }
  }
  if ( fd != -0x1 )
  {
    close(fd);
    unlink(v10);
  }
  Curl_cfree(v10);
  *v13 = 0LL;
  HIDWORD(tempnamea) = v12;
  return HIDWORD(tempnamea);
}
