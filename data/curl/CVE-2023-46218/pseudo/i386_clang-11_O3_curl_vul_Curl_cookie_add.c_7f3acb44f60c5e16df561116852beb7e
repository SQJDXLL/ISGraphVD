Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        char *path,
        bool secure)
{
  time_t v8; // eax
  Cookie *v9; // ebp
  int v10; // edi
  int v11; // eax
  int v12; // ebp
  const char *v13; // ecx
  const char *v14; // ebp
  char *i; // esi
  size_t v16; // eax
  unsigned int v17; // edi
  char v18; // dl
  size_t v19; // eax
  size_t v20; // ecx
  const char *v21; // edx
  const char *v22; // ebp
  char v23; // cl
  unsigned int v24; // edx
  unsigned int v25; // ebp
  size_t v26; // ecx
  int v27; // eax
  unsigned int v28; // edi
  int v29; // eax
  const char *v30; // eax
  char *v31; // edi
  size_t v32; // eax
  size_t v33; // esi
  int v34; // eax
  int v35; // eax
  const char *v36; // esi
  const char *v37; // edi
  size_t v38; // eax
  char v39; // al
  int v40; // eax
  size_t v41; // ebp
  int v42; // eax
  int v43; // edi
  unsigned int v44; // esi
  int v45; // eax
  const char *v46; // edi
  _BYTE *v47; // eax
  const char *v48; // esi
  size_t v49; // eax
  char v50; // cl
  int v51; // eax
  _DWORD *v52; // esi
  const char *v53; // eax
  int v54; // eax
  const char *v55; // eax
  char is_ipnum; // al
  size_t v57; // eax
  const char *v58; // ecx
  size_t v59; // esi
  int v60; // eax
  int v61; // eax
  size_t v62; // ebp
  int v63; // eax
  char v64; // cl
  int v65; // edi
  unsigned int v66; // eax
  unsigned int v67; // ecx
  const char *v68; // eax
  char *v69; // esi
  char *v70; // eax
  char *v71; // eax
  char *v72; // eax
  const char *v73; // edi
  int v74; // edx
  int v75; // ecx
  int v76; // eax
  int v77; // eax
  int v78; // ebp
  int v79; // eax
  const char *v80; // eax
  char *v81; // esi
  char *v82; // edi
  size_t v83; // eax
  size_t v84; // ebp
  int v85; // ecx
  int v86; // eax
  int v87; // eax
  int v88; // eax
  int v89; // eax
  int v90; // ebp
  int v91; // eax
  int v92; // ecx
  CookieInfo *v93; // eax
  int v94; // eax
  char *v95; // eax
  int v96; // eax
  char v97; // al
  int v98; // eax
  char v99; // cl
  char *v100; // eax
  char *v101; // eax
  int v102; // edi
  void *v103; // eax
  size_t v104; // edi
  const char *v105; // eax
  char *v106; // esi
  char *v107; // edi
  size_t v108; // eax
  size_t v109; // ebp
  int v110; // eax
  char v111; // cl
  bool running; // al
  int v113; // eax
  unsigned int next_expiration; // eax
  unsigned int next_expiration_high; // ecx
  Cookie *next; // eax
  int v117; // ebp
  Cookie *v118; // esi
  char *v119; // eax
  int v120; // ecx
  const char *spath; // edi
  char *v122; // eax
  size_t v123; // eax
  char *v124; // eax
  int v125; // ecx
  bool v126; // zf
  int v127; // eax
  char *v128; // eax
  char *v129; // ecx
  int v130; // eax
  __int64 v131; // xmm0_8
  CookieInfo *v133; // edi
  char v134; // al
  int v135; // eax
  CookieInfo *v136; // edi
  Cookie *v137; // esi
  Cookie *v138; // ebp
  curl_off_t v139; // rax
  int expires_high; // ecx
  Cookie **p_next; // eax
  const char *v142; // ecx
  Cookie **v143; // eax
  curl_off_t v144; // rax
  int v145; // ecx
  _DWORD *v146; // edi
  time_t *timer; // [esp+0h] [ebp-ECh]
  char *reject; // [esp+4h] [ebp-E8h]
  size_t n; // [esp+8h] [ebp-E4h]
  char v150; // [esp+2Ch] [ebp-C0h]
  const char *v151; // [esp+2Ch] [ebp-C0h]
  int v152; // [esp+2Ch] [ebp-C0h]
  int v153; // [esp+2Ch] [ebp-C0h]
  Cookie *v154; // [esp+2Ch] [ebp-C0h]
  char v155; // [esp+2Ch] [ebp-C0h]
  int v156; // [esp+30h] [ebp-BCh]
  const char *s; // [esp+34h] [ebp-B8h]
  const char *sa; // [esp+34h] [ebp-B8h]
  char sb; // [esp+34h] [ebp-B8h]
  void *sc; // [esp+34h] [ebp-B8h]
  Cookie *sd; // [esp+34h] [ebp-B8h]
  size_t v162; // [esp+38h] [ebp-B4h]
  size_t v163; // [esp+38h] [ebp-B4h]
  size_t v164; // [esp+38h] [ebp-B4h]
  size_t v165; // [esp+38h] [ebp-B4h]
  Cookie **v166; // [esp+38h] [ebp-B4h]
  size_t v167; // [esp+3Ch] [ebp-B0h]
  size_t v168; // [esp+3Ch] [ebp-B0h]
  char v169; // [esp+3Ch] [ebp-B0h]
  int v170; // [esp+3Ch] [ebp-B0h]
  size_t v171; // [esp+3Ch] [ebp-B0h]
  char v172; // [esp+40h] [ebp-ACh]
  int v173; // [esp+40h] [ebp-ACh]
  const char *v175; // [esp+44h] [ebp-A8h]
  _DWORD *v176; // [esp+48h] [ebp-A4h]
  int v177; // [esp+4Ch] [ebp-A0h]
  __int64 v178; // [esp+50h] [ebp-9Ch]
  int v179; // [esp+58h] [ebp-94h]
  char *dest[36]; // [esp+5Ch] [ebp-90h] BYREF

  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return v9;
  v10 = v8;
  v11 = Curl_ccalloc(1, 44);
  if ( !v11 )
    return 0;
  v12 = v11;
  v156 = v11;
  if ( !httpheader )
  {
    dest[0] = 0;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      *(_BYTE *)(v12 + 35) = 1;
      v68 = lineptr + 10;
      if ( lineptr[10] == 35 )
        goto LABEL_152;
    }
    else
    {
      v68 = lineptr;
      if ( *lineptr == 35 )
        goto LABEL_152;
    }
    v69 = (char *)v68;
    v70 = strchr(v68, 13);
    if ( v70 )
      *v70 = 0;
    v71 = strchr(v69, 10);
    if ( v71 )
      *v71 = 0;
    v72 = strtok_r(v69, "\t", dest);
    if ( !v72 )
      goto LABEL_329;
    v73 = v72;
    v74 = 0;
    v75 = 0;
    v170 = v12 + 24;
    while ( 1 )
    {
      v152 = v75;
      switch ( v74 )
      {
        case 0:
          if ( *v73 == 46 )
            ++v73;
          v76 = Curl_cstrdup(v73);
          *(_DWORD *)(v12 + 20) = v76;
          v126 = v76 == 0;
          v77 = (unsigned __int8)v152;
          if ( v126 )
            v77 = 1;
          v78 = 0;
          v152 = v77;
          goto LABEL_217;
        case 1:
          *(_BYTE *)(v12 + 32) = curl_strequal(v73, "TRUE") != 0;
          v78 = 1;
          goto LABEL_217;
        case 2:
          if ( !strcmp("TRUE", v73) || !strcmp("FALSE", v73) )
          {
            v90 = Curl_cstrdup("/");
            *(_DWORD *)(v156 + 12) = v90;
            v91 = Curl_cstrdup("/");
            v92 = (unsigned __int8)v152;
            if ( !v91 )
              v92 = 1;
            v126 = v90 == 0;
            v12 = v156;
            if ( v126 )
              v92 = 1;
            v152 = v92;
            *(_DWORD *)(v156 + 16) = v91;
            goto LABEL_196;
          }
          v79 = Curl_cstrdup(v73);
          *(_DWORD *)(v12 + 12) = v79;
          if ( !v79 )
          {
            v152 = 1;
            goto LABEL_216;
          }
          v80 = (const char *)Curl_cstrdup(v79);
          v81 = 0;
          if ( v80 )
          {
            v82 = (char *)v80;
            v83 = strlen(v80);
            v84 = v83;
            if ( *v82 == 34 )
            {
              memmove(v82, v82 + 1, v83);
              --v84;
            }
            if ( v84 )
            {
              if ( v82[v84 - 1] == 34 )
                v82[--v84] = 0;
              if ( *v82 != 47 )
              {
LABEL_211:
                Curl_cfree(v82);
                v94 = Curl_memdup("/", 2);
                v12 = v156;
                LOBYTE(v85) = v152;
                if ( v94 )
                {
                  *(_BYTE *)(v94 + 1) = 0;
                  v81 = (char *)v94;
                }
                goto LABEL_213;
              }
              if ( v84 )
              {
                LOBYTE(v85) = v152;
                if ( v82[v84 - 1] == 47 )
                  v82[v84 - 1] = 0;
                v12 = v156;
                v81 = v82;
                goto LABEL_213;
              }
            }
            else if ( *v82 != 47 )
            {
              goto LABEL_211;
            }
            v12 = v156;
            LOBYTE(v85) = v152;
            v81 = v82;
          }
          else
          {
            LOBYTE(v85) = v152;
          }
LABEL_213:
          v85 = (unsigned __int8)v85;
          *(_DWORD *)(v12 + 16) = v81;
          if ( !v81 )
            v85 = 1;
          v152 = v85;
LABEL_216:
          v78 = 2;
LABEL_217:
          v95 = strtok_r(0, "\t", dest);
          v75 = v152;
          v74 = v78 + 1;
          v12 = v156;
          if ( !v95 || (v73 = v95, (v152 & 1) != 0) )
          {
            if ( v74 == 6 )
            {
              v96 = Curl_cstrdup(&L_str_22);
              *(_DWORD *)(v156 + 8) = v96;
              LOBYTE(v75) = 1;
              if ( v96 )
                LOBYTE(v75) = v152;
              v74 = (v96 == 0) ^ 7;
            }
            if ( (v75 & 1) == 0 && v74 == 7 )
            {
              v97 = *(_BYTE *)(v156 + 40);
              if ( (v97 & 1) == 0 )
                goto LABEL_270;
              goto LABEL_226;
            }
LABEL_329:
            Curl_cfree(*(_DWORD *)(v12 + 20));
            Curl_cfree(*(_DWORD *)(v12 + 12));
            Curl_cfree(*(_DWORD *)(v12 + 16));
            Curl_cfree(*(_DWORD *)(v12 + 4));
            Curl_cfree(*(_DWORD *)(v12 + 8));
            Curl_cfree(v12);
            return 0;
          }
          break;
        case 3:
LABEL_196:
          *(_BYTE *)(v12 + 33) = 0;
          if ( !curl_strequal(v73, "TRUE") )
            goto LABEL_200;
          if ( secure || (v93 = c, c->running) )
          {
            *(_BYTE *)(v12 + 33) = 1;
LABEL_200:
            v78 = 3;
          }
          else
          {
            LOBYTE(v93) = 1;
            v78 = 3;
            v152 = (int)v93;
          }
          goto LABEL_217;
        case 4:
          v126 = curlx_strtoofft(v73, 0, 10, v170) == 0;
          v78 = 4;
          v86 = (unsigned __int8)v152;
          if ( !v126 )
            v86 = 1;
          v152 = v86;
          goto LABEL_217;
        case 5:
          v87 = Curl_cstrdup(v73);
          *(_DWORD *)(v12 + 4) = v87;
          if ( v87 )
          {
            if ( curl_strnequal("__Secure-", v87, 9) )
            {
              *(_BYTE *)(v12 + 40) |= 1u;
              v78 = 5;
            }
            else
            {
              if ( curl_strnequal("__Host-", *(_DWORD *)(v12 + 4), 7) )
                *(_BYTE *)(v12 + 40) |= 2u;
              v78 = 5;
            }
          }
          else
          {
            v78 = 5;
            v152 = 1;
          }
          goto LABEL_217;
        case 6:
          v88 = Curl_cstrdup(v73);
          *(_DWORD *)(v12 + 8) = v88;
          v126 = v88 == 0;
          v78 = 6;
          v89 = (unsigned __int8)v152;
          if ( v126 )
            v89 = 1;
          v152 = v89;
          goto LABEL_217;
        default:
          v78 = v74;
          goto LABEL_217;
      }
    }
  }
  if ( strlen(lineptr) > 0x1388 )
  {
LABEL_152:
    Curl_cfree(v12);
    return 0;
  }
  v172 = 0;
  v179 = v10;
  v176 = (_DWORD *)(v12 + 24);
  v177 = v10 >> 31;
  HIDWORD(v178) = 0x7FFFFFFF - (v10 >> 31);
  LODWORD(v178) = ~v10;
  v13 = lineptr;
  do
  {
    v14 = v13 + 1;
    for ( i = (char *)v13; *i == 32 || *i == 9; ++i )
      ++v14;
    v150 = *i;
    v16 = strcspn(i, ";\t\r\n=");
    if ( !v16 )
    {
      v13 = i;
      goto LABEL_71;
    }
    v13 = &i[v16];
    v17 = v16;
    while ( 1 )
    {
      v18 = i[v17 - 1];
      if ( v18 != 32 && v18 != 9 )
        break;
      if ( !--v17 )
      {
        v17 = 0;
        if ( *v13 != 61 )
          goto LABEL_28;
        goto LABEL_16;
      }
    }
    if ( *v13 != 61 )
    {
LABEL_28:
      v12 = v156;
      v24 = 0;
      v169 = 0;
      sa = 0;
      goto LABEL_33;
    }
LABEL_16:
    v167 = v16;
    s = &i[v16 + 1];
    v19 = strcspn(s, ";\r\n");
    v20 = v19 + v167;
    v168 = v19 + v167;
    if ( v19 )
    {
      v21 = s;
      v22 = &v14[v20];
      while ( 1 )
      {
        v23 = *(v22 - 1);
        if ( v23 != 32 && v23 != 9 )
          break;
        --v19;
        --v22;
        if ( !v19 )
          goto LABEL_30;
      }
      while ( *v21 == 32 || *v21 == 9 )
      {
        ++v21;
        if ( !--v19 )
        {
          v19 = 0;
          v21 = v22;
          break;
        }
      }
    }
    else
    {
      v21 = s;
LABEL_30:
      v19 = 0;
    }
    v25 = v19;
    sa = v21;
    if ( memchr(v21, 9, v19) )
    {
      Curl_cfree(*(_DWORD *)(v156 + 20));
      Curl_cfree(*(_DWORD *)(v156 + 12));
      Curl_cfree(*(_DWORD *)(v156 + 16));
      Curl_cfree(*(_DWORD *)(v156 + 4));
      Curl_cfree(*(_DWORD *)(v156 + 8));
      Curl_cfree(v156);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
        Curl_infof(data, "cookie contains TAB, dropping", n);
      return v9;
    }
    v26 = v168;
    v169 = 1;
    v24 = v25;
    v12 = v156;
    v13 = &i[v26 + 1];
LABEL_33:
    if ( v17 > 0xFFE || v24 > 0xFFE || v24 + v17 >= 0x1001 )
    {
      Curl_cfree(*(_DWORD *)(v12 + 20));
      Curl_cfree(*(_DWORD *)(v12 + 12));
      Curl_cfree(*(_DWORD *)(v12 + 16));
      Curl_cfree(*(_DWORD *)(v12 + 4));
      Curl_cfree(*(_DWORD *)(v12 + 8));
      Curl_cfree(v12);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v17);
      return v9;
    }
    v126 = v150 == 95;
    v151 = v13;
    if ( v126 && v17 >= 7 && i[1] == 95 )
    {
      v162 = v24;
      if ( curl_strnequal("__Secure-", i, 9) )
      {
        *(_BYTE *)(v12 + 40) |= 1u;
        v13 = v151;
        v24 = v162;
      }
      else
      {
        v27 = curl_strnequal("__Host-", i, 7);
        v13 = v151;
        v24 = v162;
        if ( v27 )
          *(_BYTE *)(v12 + 40) |= 2u;
      }
    }
    if ( !*(_DWORD *)(v12 + 4) )
    {
      if ( !v169 )
        goto LABEL_329;
      v163 = v24;
      Curl_cfree(0);
      v34 = Curl_memdup(i, v17 + 1);
      *(_DWORD *)(v12 + 4) = v34;
      if ( v34 )
        *(_BYTE *)(v34 + v17) = 0;
      v12 = v156;
      Curl_cfree(*(_DWORD *)(v156 + 8));
      v35 = Curl_memdup(sa, v163 + 1);
      *(_DWORD *)(v156 + 8) = v35;
      if ( v35 )
        *(_BYTE *)(v35 + v163) = 0;
      v36 = *(const char **)(v156 + 4);
      if ( !v36 )
        goto LABEL_329;
      v37 = *(const char **)(v156 + 8);
      if ( !v37 )
        goto LABEL_329;
      if ( v37[strcspn(v37, invalid_octets_badoctets)]
        || (v38 = strcspn(v36, invalid_octets_badoctets), v13 = v151, v36[v38]) )
      {
        v12 = v156;
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "invalid octets in name/value, cookie dropped", n);
        goto LABEL_329;
      }
      goto LABEL_71;
    }
    if ( !v24 )
    {
      if ( v17 == 8 )
      {
        v51 = curl_strnequal("httponly", i, 8);
        v24 = 0;
        if ( v51 )
        {
          *(_BYTE *)(v156 + 35) = 1;
          v13 = v151;
          goto LABEL_71;
        }
      }
      else if ( v17 == 6 )
      {
        v40 = curl_strnequal("secure", i, 6);
        v24 = 0;
        v12 = v156;
        if ( v40 )
        {
          if ( !secure && c->running )
            goto LABEL_329;
          v13 = v151;
          *(_BYTE *)(v156 + 33) = 1;
          goto LABEL_71;
        }
      }
      v13 = v151;
      if ( !v169 )
        goto LABEL_71;
    }
    if ( v17 == 7 )
    {
      v41 = v24;
      v42 = curl_strnequal("version", i, 7);
      v43 = v179;
      if ( v42 )
      {
        v13 = v151;
        goto LABEL_71;
      }
      if ( curl_strnequal("max-age", i, 7) )
      {
        v52 = v176;
        v53 = sa + 1;
        if ( *sa != 34 )
          v53 = sa;
        v54 = curlx_strtoofft(v53, 0, 10, v176);
        if ( !v54 )
        {
          v66 = *v176;
          v67 = v176[1];
          if ( *(_QWORD *)v176 )
          {
            if ( v178 >= __SPAIR64__(v67, v66) )
            {
              *(_QWORD *)v176 = __PAIR64__(v177, v43) + __PAIR64__(v67, v66);
              v13 = v151;
            }
            else
            {
              v13 = v151;
              *v176 = -1;
              v176[1] = 0x7FFFFFFF;
            }
            goto LABEL_71;
          }
LABEL_141:
          v52[1] = 0;
          *v52 = 1;
          v13 = v151;
          goto LABEL_71;
        }
        if ( v54 == 2 )
          goto LABEL_141;
        v13 = v151;
        if ( v54 == 1 )
        {
          *v176 = -1;
          v176[1] = 0x7FFFFFFF;
        }
      }
      else if ( curl_strnequal("expires", i, 7) )
      {
        v52 = v176;
        v13 = v151;
        if ( v41 > 0x7F || *(_QWORD *)v176 )
          goto LABEL_71;
        memcpy(dest, sa, v41);
        *((_BYTE *)dest + v41) = 0;
        v61 = Curl_getdate_capped(dest);
        *(_QWORD *)v176 = v61;
        if ( !v61 )
          goto LABEL_141;
        v13 = v151;
        if ( v61 < 0 )
        {
          v176[1] = 0;
          *v176 = 0;
        }
      }
      else
      {
        v13 = v151;
      }
      goto LABEL_71;
    }
    if ( v17 == 6 )
    {
      reject = i;
      v44 = v24;
      v45 = curl_strnequal("domain", reject, 6);
      if ( !v44 )
      {
        v13 = v151;
        goto LABEL_71;
      }
      if ( !v45 )
      {
        v13 = v151;
        goto LABEL_71;
      }
      v46 = sa + 1;
      if ( *sa != 46 )
        v46 = sa;
      v164 = v44 - (*sa == 46);
      if ( v164 == 9 && curl_strnequal(v46, "localhost", 9)
        || (v47 = memchr(v46, 46, v164)) != 0 && (unsigned int)(&v46[v164] - v47) > 1 )
      {
        v48 = domain;
        v55 = domain;
        if ( !domain )
          v55 = v46;
        is_ipnum = Curl_host_is_ipnum(v55);
        v12 = v156;
        v50 = is_ipnum;
        if ( !domain )
        {
          v48 = 0;
          goto LABEL_130;
        }
        if ( is_ipnum )
          goto LABEL_92;
      }
      else
      {
        v48 = ":";
        v12 = v156;
        if ( (unsigned __int8)Curl_host_is_ipnum(":") )
        {
LABEL_92:
          if ( strncmp(v46, v48, v164) )
            goto LABEL_146;
          v49 = strlen(v48);
          v50 = 1;
          if ( v164 != v49 )
            goto LABEL_146;
          goto LABEL_130;
        }
      }
      v57 = strlen(v48);
      v58 = v48;
      v59 = v57;
      if ( v57 < v164 )
      {
        v48 = v58;
LABEL_146:
        domain = v48;
        v172 = 1;
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "skipped cookie with bad tailmatch domain: %s", v46);
        v13 = v151;
        goto LABEL_71;
      }
      v175 = v58;
      v62 = (size_t)&v58[v57 - v164];
      if ( !curl_strnequal(v46, v62, v164) )
      {
        v48 = v175;
        goto LABEL_146;
      }
      if ( v59 == v164 )
      {
        v12 = v156;
        v48 = v175;
        v50 = 0;
      }
      else
      {
        v48 = v175;
        if ( *(_BYTE *)(v62 - 1) != 46 )
          goto LABEL_146;
        v12 = v156;
        v50 = 0;
      }
LABEL_130:
      sb = v50;
      domain = v48;
      Curl_cfree(*(_DWORD *)(v12 + 20));
      v63 = Curl_memdup(v46, v164 + 1);
      *(_DWORD *)(v12 + 20) = v63;
      if ( !v63 )
        goto LABEL_329;
      *(_BYTE *)(v63 + v164) = 0;
      v64 = v172;
      v65 = *(_DWORD *)(v12 + 20);
      if ( !v65 )
        v64 = 1;
      if ( (v65 == 0) | (unsigned __int8)sb )
      {
        v172 = v64;
        v13 = v151;
        if ( !v65 )
          break;
      }
      else
      {
        v13 = v151;
        *(_BYTE *)(v12 + 32) = 1;
      }
      goto LABEL_71;
    }
    if ( v17 != 4 )
      goto LABEL_71;
    v28 = v24;
    if ( !curl_strnequal("path", i, 4) )
    {
      v13 = v151;
      goto LABEL_71;
    }
    v12 = v156;
    Curl_cfree(*(_DWORD *)(v156 + 12));
    v29 = Curl_memdup(sa, v28 + 1);
    *(_DWORD *)(v156 + 12) = v29;
    if ( !v29 )
      goto LABEL_329;
    *(_BYTE *)(v29 + v28) = 0;
    if ( !*(_DWORD *)(v156 + 12) )
      goto LABEL_329;
    ((void (__thiscall *)(unsigned int, _DWORD))Curl_cfree)(v28, *(_DWORD *)(v156 + 16));
    v30 = (const char *)Curl_cstrdup(*(_DWORD *)(v156 + 12));
    if ( !v30 )
      goto LABEL_259;
    v31 = (char *)v30;
    v32 = strlen(v30);
    v33 = v32;
    if ( *v31 == 34 )
    {
      memmove(v31, v31 + 1, v32);
      --v33;
    }
    v13 = v151;
    if ( v33 )
    {
      if ( v31[v33 - 1] == 34 )
        v31[--v33] = 0;
      if ( *v31 == 47 )
      {
        if ( v33 )
        {
          if ( v31[v33 - 1] == 47 )
            v31[v33 - 1] = 0;
          *(_DWORD *)(v156 + 16) = v31;
        }
        else
        {
          *(_DWORD *)(v156 + 16) = v31;
        }
        goto LABEL_71;
      }
    }
    else if ( *v31 == 47 )
    {
      *(_DWORD *)(v156 + 16) = v31;
      goto LABEL_71;
    }
    Curl_cfree(v31);
    v60 = Curl_memdup("/", 2);
    if ( !v60 )
    {
LABEL_259:
      v12 = v156;
      *(_DWORD *)(v156 + 16) = 0;
      goto LABEL_329;
    }
    v13 = v151;
    *(_BYTE *)(v60 + 1) = 0;
    *(_DWORD *)(v156 + 16) = v60;
    do
    {
      do
LABEL_71:
        v39 = *v13++;
      while ( v39 == 32 );
    }
    while ( v39 == 9 );
  }
  while ( v39 == 59 );
  if ( (v172 & 1) != 0 )
  {
    v12 = v156;
  }
  else
  {
    v12 = v156;
    if ( domain && !*(_DWORD *)(v156 + 20) )
    {
      v98 = Curl_cstrdup(domain);
      v99 = 1;
      *(_DWORD *)(v156 + 20) = v98;
      if ( v98 )
        v99 = v172;
      v172 = v99;
    }
  }
  if ( (v172 & 1) != 0 || !path || *(_DWORD *)(v12 + 12) )
    goto LABEL_267;
  v100 = strchr(path, 63);
  v101 = v100 ? (char *)Curl_memrchr(path, 47, v100 - path) : strrchr(path, 47);
  if ( !v101 )
    goto LABEL_267;
  v102 = v101 - path;
  v103 = (void *)Curl_cmalloc(v101 - path + 2);
  *(_DWORD *)(v12 + 12) = v103;
  if ( !v103 )
    goto LABEL_329;
  v104 = v102 + 1;
  memcpy(v103, path, v104);
  *(_BYTE *)(*(_DWORD *)(v12 + 12) + v104) = 0;
  v105 = (const char *)Curl_cstrdup(*(_DWORD *)(v12 + 12));
  v106 = 0;
  if ( !v105 )
    goto LABEL_264;
  v107 = (char *)v105;
  v108 = strlen(v105);
  v109 = v108;
  if ( *v107 == 34 )
  {
    memmove(v107, v107 + 1, v108);
    --v109;
  }
  if ( !v109 )
  {
    if ( *v107 == 47 )
      goto LABEL_261;
    goto LABEL_262;
  }
  if ( v107[v109 - 1] == 34 )
    v107[--v109] = 0;
  if ( *v107 != 47 )
  {
LABEL_262:
    Curl_cfree(v107);
    v110 = Curl_memdup("/", 2);
    v12 = v156;
    if ( v110 )
    {
      v106 = (char *)v110;
      *(_BYTE *)(v110 + 1) = 0;
    }
    goto LABEL_264;
  }
  if ( v109 && v107[v109 - 1] == 47 )
    v107[v109 - 1] = 0;
LABEL_261:
  v12 = v156;
  v106 = v107;
LABEL_264:
  v111 = 1;
  *(_DWORD *)(v12 + 16) = v106;
  if ( v106 )
    v111 = v172;
  v172 = v111;
LABEL_267:
  v12 = v156;
  if ( (v172 & 1) != 0 || !*(_DWORD *)(v156 + 4) )
    goto LABEL_329;
  ++data->req.setcookies;
  v97 = *(_BYTE *)(v156 + 40);
  if ( (v97 & 1) != 0 )
  {
LABEL_226:
    if ( !*(_BYTE *)(v12 + 33) )
      goto LABEL_329;
  }
LABEL_270:
  if ( (v97 & 2) != 0
    && (!*(_BYTE *)(v12 + 33)
     || !*(_DWORD *)(v12 + 12)
     || strcmp(*(const char **)(v12 + 12), "/")
     || *(_BYTE *)(v12 + 32)) )
  {
    goto LABEL_329;
  }
  running = c->running;
  if ( !running && c->newsession && !*(_QWORD *)(v12 + 24) )
    goto LABEL_329;
  *(_BYTE *)(v12 + 34) = running;
  v113 = c->lastct + 1;
  c->lastct = v113;
  *(_DWORD *)(v12 + 36) = v113;
  if ( !noexpire )
  {
    sc = (void *)time(0);
    next_expiration = c->next_expiration;
    next_expiration_high = HIDWORD(c->next_expiration);
    if ( (int)sc >= __SPAIR64__(next_expiration_high, next_expiration)
      || !(~next_expiration | next_expiration_high ^ 0x7FFFFFFF) )
    {
      c->next_expiration = 0x7FFFFFFFFFFFFFFFLL;
      v135 = 0;
      do
      {
        v136 = c;
        v173 = v135;
        v137 = c->cookies[v135];
        if ( v137 )
        {
          v154 = 0;
          v166 = &c->cookies[v135];
          do
          {
            while ( 1 )
            {
              v138 = v137;
              v137 = v137->next;
              LODWORD(v139) = v138->expires;
              expires_high = HIDWORD(v138->expires);
              if ( !v138->expires )
                break;
              HIDWORD(v139) = HIDWORD(v138->expires);
              if ( v139 >= (int)sc )
                break;
              p_next = &v154->next;
              if ( !v154 )
                p_next = v166;
              *p_next = v137;
              --v136->numcookies;
              Curl_cfree(v138->domain);
              Curl_cfree(v138->path);
              Curl_cfree(v138->spath);
              Curl_cfree(v138->name);
              Curl_cfree(v138->value);
              Curl_cfree(v138);
              v136 = c;
              if ( !v137 )
                goto LABEL_334;
            }
            if ( expires_high | (unsigned int)v139 )
            {
              HIDWORD(v139) = HIDWORD(v138->expires);
              if ( v139 < v136->next_expiration )
              {
                LODWORD(v136->next_expiration) = v139;
                HIDWORD(v136->next_expiration) = expires_high;
              }
            }
            v154 = v138;
          }
          while ( v137 );
        }
LABEL_334:
        v135 = v173 + 1;
      }
      while ( v173 != 62 );
    }
  }
  v9 = (Cookie *)v156;
  v171 = cookiehash(*(const char *const *)(v156 + 20));
  next = c->cookies[v171];
  if ( !next )
  {
    v133 = c;
    v118 = 0;
    v134 = 0;
    goto LABEL_349;
  }
  v117 = 0;
  sd = 0;
  v153 = 0;
  while ( 2 )
  {
    v118 = next;
    if ( curl_strequal(next->name, *(_DWORD *)(v156 + 4)) )
    {
      v119 = v118->domain;
      v120 = *(_DWORD *)(v156 + 20);
      if ( v119 )
      {
        if ( v120 && curl_strequal(v119, *(_DWORD *)(v156 + 20)) )
        {
LABEL_284:
          spath = v118->spath;
          if ( spath && *(_DWORD *)(v156 + 16) && v118->secure && !*(_BYTE *)(v156 + 33) && !secure )
          {
            v165 = *(_DWORD *)(v156 + 16);
            v122 = strchr(spath + 1, 47);
            v123 = v122 ? v122 - spath : strlen(spath);
            if ( curl_strnequal(spath, v165, v123) )
            {
              v146 = (_DWORD *)v156;
              if ( data && (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
                Curl_infof(
                  data,
                  "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                  *(_DWORD *)(v156 + 4));
              goto LABEL_362;
            }
          }
        }
      }
      else if ( !v120 )
      {
        goto LABEL_284;
      }
    }
    if ( !v117 )
    {
      v117 = 0;
      if ( curl_strequal(v118->name, *(_DWORD *)(v156 + 4)) )
      {
        v124 = v118->domain;
        v125 = *(_DWORD *)(v156 + 20);
        if ( !v124 )
        {
          v126 = v125 == 0;
          goto LABEL_298;
        }
        if ( v125 && curl_strequal(v124, *(_DWORD *)(v156 + 20)) )
        {
          v126 = v118->tailmatch == *(_BYTE *)(v156 + 32);
LABEL_298:
          v127 = (unsigned __int8)v153;
          if ( v126 )
            v127 = 1;
        }
        else
        {
          v127 = v153;
        }
        v153 = v127;
        if ( (v127 & 1) != 0 )
        {
          v128 = v118->spath;
          v117 = 0;
          v129 = 0;
          if ( v128 )
          {
            if ( !*(_DWORD *)(v156 + 16) )
            {
              v129 = v118->spath;
              goto LABEL_306;
            }
            if ( curl_strequal(v128, *(_DWORD *)(v156 + 16)) )
            {
              v129 = v118->spath;
              goto LABEL_306;
            }
            v117 = 0;
            v153 = 0;
          }
          else
          {
LABEL_306:
            v130 = (unsigned __int8)v153;
            if ( (v129 != 0) == (*(_DWORD *)(v156 + 16) == 0) )
              v130 = 0;
            v153 = v130;
            if ( (v130 & 1) != 0 )
            {
              if ( *(_BYTE *)(v156 + 34) )
              {
                sd = v118;
                v117 = v156;
              }
              else
              {
                v117 = v156;
                sd = v118;
                if ( v118->livecookie )
                {
                  v146 = (_DWORD *)v156;
LABEL_362:
                  Curl_cfree(v146[5]);
                  Curl_cfree(v146[3]);
                  Curl_cfree(v146[4]);
                  Curl_cfree(v146[1]);
                  Curl_cfree(v146[2]);
                  Curl_cfree(v146);
                  return 0;
                }
              }
            }
          }
        }
      }
    }
    next = v118->next;
    if ( v118->next )
      continue;
    break;
  }
  if ( v117 )
  {
    *(_DWORD *)v117 = sd->next;
    *(_DWORD *)(v117 + 36) = sd->creationtime;
    Curl_cfree(sd->name);
    Curl_cfree(sd->value);
    Curl_cfree(sd->domain);
    Curl_cfree(sd->path);
    Curl_cfree(sd->spath);
    *(_DWORD *)&sd->prefix = *(_DWORD *)(v117 + 40);
    *(_QWORD *)&sd->tailmatch = *(_QWORD *)(v117 + 32);
    sd->expires = *(_QWORD *)(v117 + 24);
    *(_QWORD *)&sd->spath = *(_QWORD *)(v117 + 16);
    v131 = *(_QWORD *)v117;
    *(_QWORD *)&sd->value = *(_QWORD *)(v117 + 8);
    *(_QWORD *)&sd->next = v131;
    timer = (time_t *)v117;
    v9 = sd;
    Curl_cfree(timer);
  }
  else
  {
    v9 = (Cookie *)v156;
  }
  v133 = c;
  v134 = v153;
LABEL_349:
  if ( data )
  {
    if ( v133->running )
    {
      v155 = v134;
      if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
      {
        v142 = "Replaced";
        if ( (v134 & 1) == 0 )
          v142 = "Added";
        v133 = c;
        Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v142);
        v134 = v155;
      }
    }
  }
  if ( (v134 & 1) == 0 )
  {
    v143 = &v133->cookies[v171];
    if ( v118 )
      v143 = &v118->next;
    *v143 = v9;
    ++v133->numcookies;
  }
  LODWORD(v144) = v9->expires;
  v145 = HIDWORD(v9->expires);
  if ( v9->expires )
  {
    HIDWORD(v144) = HIDWORD(v9->expires);
    if ( v144 < v133->next_expiration )
    {
      LODWORD(v133->next_expiration) = v144;
      HIDWORD(v133->next_expiration) = v145;
    }
  }
  return v9;
}
