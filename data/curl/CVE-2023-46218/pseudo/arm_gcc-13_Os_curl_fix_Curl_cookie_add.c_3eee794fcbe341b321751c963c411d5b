Cookie *__fastcall Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  char *v8; // r6
  char *v11; // r0
  unsigned int v12; // r3
  int v13; // r4
  int v14; // r3
  bool v15; // zf
  size_t v16; // r0
  int v17; // r7
  size_t v18; // r8
  int v19; // r3
  bool v20; // zf
  size_t v21; // r0
  const char *v22; // r3
  size_t v23; // r5
  int v24; // r2
  bool v25; // zf
  const char *v26; // r7
  int v27; // r2
  int v28; // t1
  bool v29; // zf
  bool v30; // cc
  _BOOL4 v31; // r3
  char v32; // r2
  const char *v33; // r5
  int v34; // r6
  char *v35; // r2
  int v36; // r3
  int v37; // t1
  bool v38; // zf
  int v39; // r0
  __int64 v40; // r2
  char *v41; // r0
  int v42; // r0
  bool v43; // zf
  _BYTE *v44; // r0
  const char *v45; // r0
  int is_ipnum; // r0
  int v47; // r8
  bool v48; // zf
  void *v49; // r0
  int v50; // r0
  _BOOL4 v51; // r3
  _BOOL4 v52; // r3
  char *v53; // r0
  char *v54; // r0
  char *v55; // r0
  size_t v56; // r5
  void *v57; // r0
  char *v58; // r0
  const char *v59; // r0
  int v60; // r3
  size_t v61; // r0
  int v62; // r7
  Cookie *v63; // r6
  Cookie **v64; // r8
  _DWORD *p_next; // r10
  Cookie *v66; // r5
  char *name; // r0
  char *v68; // r1
  char *v69; // r2
  char *v70; // r3
  char *v71; // r1
  Cookie *v72; // r2
  Cookie *v73; // r3
  int v74; // r1
  Cookie *v75; // r2
  Cookie *v76; // r3
  const char *running; // r3
  const char *v78; // r2
  curl_off_t v79; // r2
  int v80; // r0
  char *v81; // r0
  unsigned __int8 v82; // r8
  char *v83; // r0
  char *v84; // r0
  int v85; // r6
  char *v86; // r5
  _BOOL4 v87; // r10
  int v88; // r0
  char *v89; // r0
  int v90; // r0
  int (__fastcall *v91)(const char *); // r8
  const char *v92; // r0
  unsigned int v93; // r6
  int v94; // r0
  int (__fastcall *v95)(const char *); // r1
  unsigned int v96; // r8
  int v97; // r0
  unsigned int v98; // r6
  const char *v99; // r1
  int v100; // r1
  char v101; // r3
  char *v102; // r0
  int v103; // r1
  const char *spath; // r10
  char *v105; // r0
  int v106; // r1
  char *v107; // r0
  size_t v108; // r2
  bool v109; // zf
  char *v110; // r0
  int v111; // r1
  int v113; // [sp+0h] [bp-F8h] BYREF
  const char *valuep; // [sp+18h] [bp-E0h]
  time_t now; // [sp+1Ch] [bp-DCh]
  const char *httpheadera; // [sp+20h] [bp-D8h]
  char *s1; // [sp+24h] [bp-D4h]
  const char *badcookie; // [sp+28h] [bp-D0h]
  int v119; // [sp+2Ch] [bp-CCh]
  int v120; // [sp+30h] [bp-C8h]
  const char *noexpirea; // [sp+34h] [bp-C4h]
  _BOOL4 v122; // [sp+38h] [bp-C0h]
  _BOOL4 v123; // [sp+3Ch] [bp-BCh]
  char *reject; // [sp+40h] [bp-B8h]
  const char *v125; // [sp+44h] [bp-B4h]
  char *tok_buf; // [sp+48h] [bp-B0h] BYREF
  char date[128]; // [sp+4Ch] [bp-ACh] BYREF

  v123 = noexpire;
  badcookie = (const char *)httpheader;
  now = (time_t)path;
  v122 = secure;
  valuep = (const char *)data;
  v8 = (char *)lineptr;
  v11 = (char *)time(0u);
  v12 = *((unsigned __int8 *)valuep + 270);
  s1 = v11;
  if ( v12 > 0x31 )
    return 0;
  v13 = Curl_ccalloc(1, 48);
  if ( !v13 )
    return 0;
  if ( !badcookie )
  {
    tok_buf = 0;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v8 = (char *)(lineptr + 0xA);
      *(_BYTE *)(v13 + 35) = 1;
    }
    if ( *v8 == 35 )
      goto LABEL_5;
    v81 = strchr(v8, 13);
    v82 = 0;
    if ( v81 )
      *v81 = 0;
    v83 = strchr(v8, 10);
    if ( v83 )
      *v83 = 0;
    v84 = strtok_r(v8, "\t", &tok_buf);
    v85 = 0;
    httpheadera = "TRUE";
    s1 = "TRUE";
    badcookie = "TRUE";
    v86 = v84;
    while ( 1 )
    {
      v87 = v86 && (v82 ^ 1) & 1;
      if ( !v87 )
        break;
      switch ( v85 )
      {
        case 0:
          if ( *v86 == 46 )
            ++v86;
          v89 = (char *)Curl_cstrdup(v86);
          *(_DWORD *)(v13 + 20) = v89;
          goto LABEL_215;
        case 1:
          *(_BYTE *)(v13 + 32) = curl_strequal(v86, badcookie) != 0;
          goto LABEL_218;
        case 2:
          v90 = strcmp(s1, v86);
          v91 = (int (__fastcall *)(const char *))Curl_cstrdup;
          now = (time_t)&Curl_cstrdup;
          if ( !v90 || !strcmp("FALSE", v86) )
          {
            v93 = (unsigned int)"/";
            v94 = v91("/");
            v95 = *(int (__fastcall **)(const char *))now;
            v96 = v94;
            *(_DWORD *)(v13 + 12) = v94;
            v97 = v95("/");
            if ( v97 )
              v93 = __clz(v96);
            *(_DWORD *)(v13 + 16) = v97;
            if ( v97 )
              v98 = v93 >> 5;
            else
              LOBYTE(v98) = v87;
LABEL_229:
            v99 = httpheadera;
            *(_BYTE *)(v13 + 33) = 0;
            if ( curl_strequal(v86, v99) )
            {
              if ( v122 || c->running )
              {
                *(_BYTE *)(v13 + 33) = 1;
                goto LABEL_230;
              }
            }
            else
            {
LABEL_230:
              LOBYTE(v87) = v98;
            }
            v85 = 3;
            goto LABEL_216;
          }
          v92 = (const char *)v91(v86);
          *(_DWORD *)(v13 + 12) = v92;
          if ( v92 )
          {
            v89 = sanitize_cookie_path(v92);
            *(_DWORD *)(v13 + 16) = v89;
LABEL_215:
            LOBYTE(v87) = v89 == 0;
          }
LABEL_216:
          ++v85;
          v82 = v87;
          v86 = strtok_r(0u, "\t", &tok_buf);
          break;
        case 3:
          LOBYTE(v98) = 0;
          goto LABEL_229;
        case 4:
          LOBYTE(v87) = curlx_strtoofft(v86, 0, 10, v13 + 0x18) != 0;
          goto LABEL_216;
        case 5:
          v100 = Curl_cstrdup(v86);
          *(_DWORD *)(v13 + 4) = v100;
          if ( !v100 )
            goto LABEL_216;
          if ( curl_strnequal("__Secure-", v100, 9) )
          {
            v101 = *(_BYTE *)(v13 + 40) | 1;
LABEL_239:
            *(_BYTE *)(v13 + 40) = v101;
            goto LABEL_218;
          }
          if ( curl_strnequal("__Host-", *(_DWORD *)(v13 + 4), 7) )
          {
            v101 = *(_BYTE *)(v13 + 40) | 2;
            goto LABEL_239;
          }
LABEL_218:
          LOBYTE(v87) = 0;
          goto LABEL_216;
        case 6:
          v89 = (char *)Curl_cstrdup(v86);
          *(_DWORD *)(v13 + 8) = v89;
          goto LABEL_215;
        default:
          goto LABEL_218;
      }
    }
    if ( v85 == 6 )
    {
      v88 = Curl_cstrdup(&LC2);
      if ( v88 )
        v85 = 7;
      *(_DWORD *)(v13 + 8) = v88;
      if ( !v88 )
        goto LABEL_62;
    }
    if ( v85 != 7 )
      v82 |= 1u;
    if ( v82 )
      goto LABEL_62;
LABEL_156:
    if ( (*(_BYTE *)(v13 + 40) & 1) != 0 && !*(_BYTE *)(v13 + 33) )
      goto LABEL_62;
    if ( (*(_BYTE *)(v13 + 40) & 2) != 0 )
    {
      if ( !*(_BYTE *)(v13 + 33) )
        goto LABEL_62;
      v59 = *(const char **)(v13 + 12);
      if ( !v59 || strcmp(v59, "/") || *(_BYTE *)(v13 + 32) )
        goto LABEL_62;
    }
    if ( !c->running && c->newsession && !*(_QWORD *)(v13 + 24) )
      goto LABEL_62;
    *(_BYTE *)(v13 + 34) = c->running;
    v60 = c->lastct + 1;
    c->lastct = v60;
    *(_DWORD *)(v13 + 36) = v60;
    if ( !v123 )
      remove_expired(c);
    v61 = cookiehash(*(const char *const *)(v13 + 20));
    v62 = 0;
    v63 = 0;
    v64 = 0;
    p_next = 0;
    v66 = c->cookies[v61];
    httpheadera = (const char *)v61;
    while ( 1 )
    {
      if ( !v66 )
      {
        if ( v64 )
        {
          name = v63->name;
          *v64 = v63->next;
          v64[9] = (Cookie *)v63->creationtime;
          Curl_cfree(name);
          Curl_cfree(v63->value);
          Curl_cfree(v63->domain);
          Curl_cfree(v63->path);
          Curl_cfree(v63->spath);
          v68 = (char *)v64[1];
          v69 = (char *)v64[2];
          v70 = (char *)v64[3];
          v63->next = *v64;
          v63->name = v68;
          v63->value = v69;
          v63->path = v70;
          v71 = (char *)v64[5];
          v72 = v64[6];
          v73 = v64[7];
          v63->spath = (char *)v64[4];
          v63->domain = v71;
          LODWORD(v63->expires) = v72;
          HIDWORD(v63->expires) = v73;
          v74 = (int)v64[9];
          v75 = v64[10];
          v76 = v64[11];
          *(_DWORD *)&v63->tailmatch = v64[8];
          v63->creationtime = v74;
          *(_DWORD *)&v63->prefix = v75;
          *((_DWORD *)&v63->prefix + 1) = v76;
          Curl_cfree(v64);
          v13 = (int)v63;
        }
        running = (const char *)c->running;
        if ( c->running )
        {
          running = (const char *)*((unsigned __int8 *)valuep + 1617);
          if ( ((unsigned __int8)running & 0x20) != 0 )
          {
            if ( v62 )
              v78 = "Replaced";
            else
              v78 = "Added";
            Curl_infof(
              valuep,
              "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld",
              v78,
              *(const char **)(v13 + 4),
              *(const char **)(v13 + 8),
              *(const char **)(v13 + 20),
              *(const char **)(v13 + 12),
              *(_QWORD *)(v13 + 0x18));
          }
        }
        if ( !v62 )
        {
          if ( p_next )
            *p_next = v13;
          else
            running = httpheadera;
          if ( !p_next )
            c->cookies[(_DWORD)running] = (Cookie *)v13;
          ++c->numcookies;
        }
        v79 = *(_QWORD *)(v13 + 0x18);
        if ( v79 && v79 < c->next_expiration )
          c->next_expiration = v79;
        return (Cookie *)v13;
      }
      if ( curl_strequal(v66->name, *(_DWORD *)(v13 + 4)) )
      {
        v102 = v66->domain;
        v103 = *(_DWORD *)(v13 + 20);
        if ( v102 )
        {
          if ( !v103 || !curl_strequal(v102, v103) )
            goto LABEL_249;
        }
        else if ( v103 )
        {
          goto LABEL_249;
        }
        spath = v66->spath;
        if ( spath )
        {
          now = *(_DWORD *)(v13 + 16);
          if ( now )
          {
            if ( v66->secure && !(v122 | *(unsigned __int8 *)(v13 + 33)) )
            {
              v107 = strchr(spath + 1, 47);
              v108 = v107 ? v107 - spath : strlen(spath);
              if ( curl_strnequal(spath, now, v108) )
              {
                if ( (valuep[1617] & 0x20) != 0 )
                  Curl_infof(
                    valuep,
                    "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                    *(const char **)(v13 + 4),
                    *(const char **)(v13 + 20));
                goto LABEL_62;
              }
            }
          }
        }
      }
LABEL_249:
      if ( v64 || !curl_strequal(v66->name, *(_DWORD *)(v13 + 4)) )
        goto LABEL_255;
      v105 = v66->domain;
      v106 = *(_DWORD *)(v13 + 20);
      if ( v105 )
      {
        if ( !v106 || !curl_strequal(v105, v106) )
        {
LABEL_253:
          if ( !v62 )
            goto LABEL_254;
          goto LABEL_271;
        }
        v109 = v66->tailmatch == *(unsigned __int8 *)(v13 + 32);
      }
      else
      {
        v109 = v106 == 0;
      }
      if ( !v109 )
        goto LABEL_253;
LABEL_271:
      v110 = v66->spath;
      v111 = *(_DWORD *)(v13 + 16);
      if ( v110 && (!v111 || !curl_strequal(v110, v111)) || (v66->spath == 0) != (*(_DWORD *)(v13 + 16) == 0) )
      {
LABEL_254:
        v62 = 0;
        goto LABEL_255;
      }
      v62 = *(unsigned __int8 *)(v13 + 34);
      if ( *(_BYTE *)(v13 + 34) )
      {
        v63 = v66;
        v64 = (Cookie **)v13;
      }
      else
      {
        if ( v66->livecookie )
          goto LABEL_62;
        v63 = v66;
        v64 = (Cookie **)v13;
        v62 = 1;
      }
LABEL_255:
      p_next = &v66->next;
      v66 = v66->next;
    }
  }
  if ( strlen(lineptr) > (unsigned int)&loc_1388 )
  {
LABEL_5:
    Curl_cfree(v13);
    return 0;
  }
  v120 = 0;
  reject = ";\t\r\n=";
  v125 = "domain";
  while ( 1 )
  {
    while ( 1 )
    {
      v14 = (unsigned __int8)*v8;
      v119 = v14;
      if ( !v14 )
        break;
      v15 = v14 == 9;
      if ( v14 != 9 )
        v15 = v14 == 32;
      if ( !v15 )
        break;
      ++v8;
    }
    v16 = strcspn(v8, reject);
    if ( !v16 )
    {
      noexpirea = v8;
      goto LABEL_69;
    }
    v17 = (int)&v8[v16];
    while ( 1 )
    {
      v18 = v16--;
      v19 = (unsigned __int8)v8[v16];
      v20 = v19 == 9;
      if ( v19 != 9 )
        v20 = v19 == 32;
      if ( !v20 )
        break;
      if ( !v16 )
      {
        v18 = 0;
        break;
      }
    }
    if ( *(_BYTE *)v17 == 61 )
    {
      httpheadera = (const char *)(v17 + 1);
      v21 = strcspn((const char *)(v17 + 1), ";\r\n");
      v22 = httpheadera;
      v23 = v21;
      noexpirea = &httpheadera[v21];
      while ( v23 )
      {
        v24 = *(unsigned __int8 *)(v17 + v23);
        v25 = v24 == 9;
        if ( v24 != 9 )
          v25 = v24 == 32;
        if ( !v25 )
          break;
        --v23;
      }
      while ( 1 )
      {
        v26 = v22;
        if ( !v23 )
          goto LABEL_44;
        v28 = *(unsigned __int8 *)v22++;
        v27 = v28;
        v29 = v28 == 9;
        if ( v28 != 9 )
          v29 = v27 == 32;
        if ( !v29 )
          break;
        --v23;
      }
      if ( memchr(v26, 9, v23) )
      {
        freecookie((Cookie *)v13);
        if ( (valuep[1617] & 0x20) != 0 )
          Curl_infof(valuep, "cookie contains TAB, dropping");
        return 0;
      }
LABEL_44:
      httpheadera = badcookie;
    }
    else
    {
      noexpirea = (const char *)v17;
      v26 = 0;
      v23 = 0;
      httpheadera = 0;
    }
    v30 = v23 > 0xFFE;
    if ( v23 <= 0xFFE )
      v30 = v18 > 0xFFE;
    if ( v30 || v23 + v18 > 0x1000 )
    {
      freecookie((Cookie *)v13);
      if ( (valuep[1617] & 0x20) != 0 )
        Curl_infof(valuep, "oversized cookie dropped, name/val %zu + %zu bytes", v18, v23);
      return 0;
    }
    v31 = v119 == 0x5F;
    if ( v18 <= 6 )
      v31 = 0;
    if ( v31 && v8[1] == 95 )
    {
      if ( curl_strnequal("__Secure-", v8, 9) )
      {
        v32 = *(_BYTE *)(v13 + 40) | 1;
      }
      else
      {
        if ( !curl_strnequal("__Host-", v8, 7) )
          goto LABEL_54;
        v32 = *(_BYTE *)(v13 + 40) | 2;
      }
      *(_BYTE *)(v13 + 40) = v32;
    }
LABEL_54:
    if ( !*(_DWORD *)(v13 + 4) )
    {
      if ( !httpheadera )
        goto LABEL_62;
      strstore((char **)(v13 + 4), v8, v18);
      strstore((char **)(v13 + 8), v26, v23);
      v33 = *(const char **)(v13 + 4);
      if ( !v33 )
        goto LABEL_62;
      v34 = *(_DWORD *)(v13 + 8);
      if ( !v34 )
        goto LABEL_62;
      if ( *(_BYTE *)(v34 + strcspn(*(const char **)(v13 + 8), badoctets_0)) || v33[strcspn(v33, badoctets_0)] )
      {
        if ( (valuep[1617] & 0x20) != 0 )
          Curl_infof(valuep, "invalid octets in name/value, cookie dropped");
        goto LABEL_62;
      }
      goto LABEL_69;
    }
    if ( v23 )
    {
      if ( v18 == 4 )
      {
LABEL_94:
        if ( curl_strnequal("path", v8, 4) )
        {
          strstore((char **)(v13 + 0xC), v26, v23);
          if ( !*(_DWORD *)(v13 + 12) )
            goto LABEL_62;
          Curl_cfree(*(_DWORD *)(v13 + 16));
          v41 = sanitize_cookie_path(*(const char **)(v13 + 12));
          *(_DWORD *)(v13 + 16) = v41;
          if ( !v41 )
            goto LABEL_62;
        }
        goto LABEL_69;
      }
      if ( v18 == 6 )
        goto LABEL_99;
      goto LABEL_82;
    }
    if ( v18 == 6 )
    {
      if ( curl_strnequal("secure", v8, 6) )
      {
        if ( !v122 && c->running )
          goto LABEL_62;
        *(_BYTE *)(v13 + 33) = 1;
        goto LABEL_69;
      }
      if ( !httpheadera )
        goto LABEL_69;
LABEL_99:
      v42 = curl_strnequal(v125, v8, 6);
      v43 = v42 == 0;
      if ( v42 )
        v43 = v23 == 0;
      if ( v43 )
        goto LABEL_69;
      if ( *v26 == 46 )
      {
        --v23;
        ++v26;
      }
      if ( v23 == 9 && curl_strnequal(v26, "localhost", 9) )
        goto LABEL_111;
      v44 = memchr(v26, 46, v23);
      if ( v44 )
      {
        if ( v23 - (v44 - v26) > 1 )
        {
LABEL_111:
          if ( domain )
            v45 = domain;
          else
            v45 = v26;
          goto LABEL_114;
        }
        domain = ":";
      }
      else
      {
        domain = ":";
      }
      v45 = ":";
LABEL_114:
      is_ipnum = Curl_host_is_ipnum(v45);
      v47 = is_ipnum;
      if ( !domain )
        goto LABEL_115;
      if ( is_ipnum )
      {
        if ( !strncmp(v26, domain, v23) && strlen(domain) == v23 )
        {
LABEL_115:
          strstore((char **)(v13 + 0x14), v26, v23);
          if ( !*(_DWORD *)(v13 + 20) )
            goto LABEL_62;
          if ( !v47 )
            *(_BYTE *)(v13 + 32) = 1;
          goto LABEL_69;
        }
      }
      else if ( cookie_tailmatch(v26, v23, domain) )
      {
        goto LABEL_115;
      }
      if ( (valuep[1617] & 0x20) != 0 )
        Curl_infof(valuep, "skipped cookie with bad tailmatch domain: %s", v26);
      v120 = 1;
      goto LABEL_69;
    }
    if ( v18 == 8 )
    {
      if ( curl_strnequal("httponly", v8, 8) )
        *(_BYTE *)(v13 + 35) = 1;
      goto LABEL_69;
    }
    if ( httpheadera )
    {
      if ( v18 == 4 )
        goto LABEL_94;
LABEL_82:
      if ( v18 != 7 || curl_strnequal("version", v8, 7) )
        goto LABEL_69;
      httpheadera = (const char *)curl_strnequal("max-age", v8, 7);
      if ( !httpheadera )
      {
        if ( !curl_strnequal("expires", v8, 7) )
          goto LABEL_69;
        v48 = v23 == 127;
        if ( v23 <= 0x7F )
          v48 = *(_QWORD *)(v13 + 0x18) == 0LL;
        if ( !v48 )
          goto LABEL_69;
        v49 = memcpy(date, v26, v23);
        *((_BYTE *)&v113 + v23 + 0x4C) = (_BYTE)httpheadera;
        v50 = Curl_getdate_capped(v49);
        if ( v50 )
        {
          if ( v50 >> 31 != -1 )
          {
            *(_QWORD *)(v13 + 24) = v50;
            goto LABEL_69;
          }
          LODWORD(v40) = 0;
        }
        else
        {
LABEL_91:
          LODWORD(v40) = 1;
        }
        HIDWORD(v40) = 0;
LABEL_132:
        *(_QWORD *)(v13 + 0x18) = v40;
        goto LABEL_69;
      }
      if ( *v26 == 34 )
        ++v26;
      v39 = curlx_strtoofft(v26, 0, 10, v13 + 0x18);
      switch ( v39 )
      {
        case 1:
          goto LABEL_131;
        case 2:
          goto LABEL_91;
        case 0:
          if ( !*(_QWORD *)(v13 + 24) )
            goto LABEL_91;
          if ( __SPAIR64__(0x7FFFFFFF - ((int)s1 >> 0x1F), ~(unsigned int)s1) < *(_QWORD *)(v13 + 24) )
          {
LABEL_131:
            v40 = 0x7FFFFFFFFFFFFFFFLL;
            goto LABEL_132;
          }
          *(_QWORD *)(v13 + 24) += (int)s1;
          break;
      }
    }
LABEL_69:
    v35 = (char *)noexpirea;
    do
    {
      v37 = (unsigned __int8)*v35++;
      v36 = v37;
      if ( !v37 )
        goto LABEL_142;
      v38 = v36 == 9;
      if ( v36 != 9 )
        v38 = v36 == 32;
    }
    while ( v38 );
    if ( v36 != 59 )
      break;
    v8 = v35;
  }
LABEL_142:
  if ( !v120 )
  {
    v51 = *(_DWORD *)(v13 + 20) == 0;
    if ( !domain )
      v51 = 0;
    if ( !v51 || (v80 = Curl_cstrdup(domain), (*(_DWORD *)(v13 + 20) = v80) != 0) )
    {
      v52 = *(_DWORD *)(v13 + 12) == 0;
      if ( !now )
        v52 = 0;
      if ( !v52 )
        goto LABEL_286;
      v53 = strchr((const char *)now, 63);
      v54 = v53 ? (char *)Curl_memrchr(now, 47, &v53[-now]) : strrchr((const char *)now, 47);
      if ( !v54 )
        goto LABEL_286;
      v55 = &v54[-now];
      v56 = (size_t)(v55 + 1);
      v57 = (void *)Curl_cmalloc(v55 + 2);
      *(_DWORD *)(v13 + 12) = v57;
      if ( v57 )
      {
        memcpy(v57, (const void *)now, v56);
        *(_BYTE *)(*(_DWORD *)(v13 + 12) + v56) = 0;
        v58 = sanitize_cookie_path(*(const char **)(v13 + 12));
        *(_DWORD *)(v13 + 16) = v58;
        if ( v58 )
        {
LABEL_286:
          if ( *(_DWORD *)(v13 + 4) )
          {
            ++valuep[270];
            goto LABEL_156;
          }
        }
      }
    }
  }
LABEL_62:
  freecookie((Cookie *)v13);
  return 0;
}
