Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  const char *i; // esi
  Cookie *v9; // ebp
  size_t v10; // edi
  size_t v11; // eax
  char v12; // dl
  size_t v13; // edx
  const char *v14; // eax
  bool v15; // si
  _BYTE *v16; // eax
  char is_ipnum; // al
  const char *name; // esi
  const char *value; // edi
  char v20; // al
  const char *v21; // ebp
  char *v22; // eax
  int v23; // eax
  __int64 expires; // rax
  curl_off_t v25; // rax
  const char *v26; // ebp
  char v27; // al
  int v28; // eax
  char *v29; // eax
  char *v30; // eax
  int v31; // esi
  size_t v32; // edi
  char *v33; // eax
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  char *v37; // esi
  int v38; // edi
  int v39; // eax
  const char *v40; // eax
  char *v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  char v45; // bp
  Cookie *v46; // esi
  char *v47; // eax
  char *spath; // ecx
  char *v49; // eax
  size_t v50; // eax
  char *v51; // eax
  char *v52; // eax
  Cookie *v53; // edi
  unsigned int v54; // ebx
  unsigned int expires_high; // ecx
  char v57; // si
  int v58; // eax
  unsigned __int8 prefix; // al
  const char *v60; // eax
  bool running; // al
  unsigned int v62; // ecx
  char *vlen; // [esp+10h] [ebp-ECh]
  size_t vlena; // [esp+10h] [ebp-ECh]
  __int64 vlenb; // [esp+10h] [ebp-ECh]
  bool vlenc; // [esp+10h] [ebp-ECh]
  char vlend; // [esp+10h] [ebp-ECh]
  int vlenf; // [esp+10h] [ebp-ECh]
  size_t vlene; // [esp+10h] [ebp-ECh]
  const char *ptr; // [esp+1Ch] [ebp-E0h]
  char *ptra; // [esp+1Ch] [ebp-E0h]
  const char *ptrb; // [esp+1Ch] [ebp-E0h]
  char replace_clist; // [esp+20h] [ebp-DCh]
  Cookie *replace_clista; // [esp+20h] [ebp-DCh]
  Cookie *co; // [esp+24h] [ebp-D8h]
  const char *maxage; // [esp+28h] [ebp-D4h]
  const char *maxagea; // [esp+28h] [ebp-D4h]
  size_t maxageb; // [esp+28h] [ebp-D4h]
  char *reject; // [esp+2Ch] [ebp-D0h]
  int now; // [esp+48h] [ebp-B4h]
  bool v82; // [esp+4Ch] [ebp-B0h]
  bool badcookie; // [esp+4Fh] [ebp-ADh]
  char *tok_buf; // [esp+58h] [ebp-A4h] BYREF
  char date[128]; // [esp+5Ch] [ebp-A0h] BYREF
  unsigned int v86; // [esp+DCh] [ebp-20h]

  vlen = (char *)lineptr;
  v86 = __readgsdword(0x14u);
  now = time(0);
  if ( data->req.setcookies > 0x31u )
    return 0;
  co = (Cookie *)Curl_ccalloc(1, 44);
  if ( !co )
    return 0;
  if ( httpheader )
  {
    badcookie = 0;
    if ( strlen(lineptr) > 0x1388 )
    {
      Curl_cfree(co);
      return 0;
    }
    for ( i = lineptr; ; i = v26 + 1 )
    {
      while ( 2 )
      {
        v27 = *i;
        replace_clist = *i;
        if ( *i )
        {
          if ( v27 == 32 || v27 == 9 )
          {
            ++i;
            continue;
          }
          v10 = strcspn(i, ";\t\r\n=");
          if ( !v10 )
          {
            v20 = *i;
            v26 = i;
            goto LABEL_108;
          }
        }
        else
        {
          v10 = strcspn(i, ";\t\r\n=");
          if ( !v10 )
          {
            v21 = path;
            goto LABEL_118;
          }
        }
        break;
      }
      ptrb = &i[v10];
      do
      {
        v62 = v10--;
        if ( i[v10] != 9 && i[v10] != 32 )
        {
          v82 = 0;
          if ( *ptrb == 61 )
          {
            v10 = v62;
            goto LABEL_281;
          }
          if ( v62 <= 0xFFE )
          {
            v10 = v62;
            v26 = ptrb;
            maxage = 0;
            vlena = 0;
            goto LABEL_22;
          }
          goto LABEL_47;
        }
      }
      while ( v10 );
      if ( *ptrb != 61 )
      {
        vlena = 0;
        v26 = ptrb;
        maxage = 0;
        v82 = 0;
        goto LABEL_22;
      }
LABEL_281:
      maxage = ptrb + 1;
      vlene = strcspn(ptrb + 1, ";\r\n");
      v26 = &ptrb[vlene + 1];
      if ( !vlene )
      {
LABEL_273:
        if ( v10 <= 0xFFE )
        {
          v82 = httpheader;
          vlena = 0;
          goto LABEL_22;
        }
LABEL_47:
        freecookie(co);
        v9 = 0;
        if ( (data->set.gap52B[3] & 0x10) != 0 )
          Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes");
        return v9;
      }
      v11 = vlene;
      while ( 1 )
      {
        v12 = ptrb[v11];
        if ( v12 != 32 && v12 != 9 )
          break;
        if ( !--v11 )
          goto LABEL_273;
      }
      v13 = v11;
      v14 = ptrb + 1;
      while ( *v14 == 32 || *v14 == 9 )
      {
        ++v14;
        if ( !--v13 )
        {
          vlena = 0;
          maxage = v14;
          goto LABEL_18;
        }
      }
      vlena = v13;
      maxage = v14;
      if ( memchr(v14, 9, v13) )
      {
        freecookie(co);
        v9 = 0;
        if ( (data->set.gap52B[3] & 0x10) != 0 )
          Curl_infof(data, "cookie contains TAB, dropping");
        return v9;
      }
LABEL_18:
      if ( v10 > 0xFFE || vlena > 0xFFE || v10 + vlena > 0x1000 )
        goto LABEL_47;
      v82 = httpheader;
LABEL_22:
      if ( v10 > 6 && replace_clist == 95 && i[1] == 95 )
      {
        if ( curl_strnequal("__Secure-", i, 9) )
        {
          co->prefix |= 1u;
        }
        else if ( curl_strnequal("__Host-", i, 7) )
        {
          co->prefix |= 2u;
        }
      }
      if ( !co->name )
      {
        if ( !v82 )
          goto LABEL_201;
        strstore(&co->name, i, v10);
        strstore(&co->value, maxage, vlena);
        name = co->name;
        if ( !name )
          goto LABEL_201;
        value = co->value;
        if ( !value )
          goto LABEL_201;
        if ( value[strcspn(value, badoctets_0)] || name[strcspn(name, badoctets_0)] )
        {
          if ( (data->set.gap52B[3] & 0x10) != 0 )
            Curl_infof(data, "invalid octets in name/value, cookie dropped");
          goto LABEL_201;
        }
        goto LABEL_70;
      }
      if ( vlena )
        goto LABEL_29;
      if ( v10 == 6 )
      {
        if ( curl_strnequal("secure", i, 6) )
        {
          if ( !secure && c->running )
            goto LABEL_201;
          co->secure = 1;
          goto LABEL_70;
        }
        if ( !v82 )
          goto LABEL_70;
LABEL_30:
        if ( v10 == 6 )
        {
          v15 = (vlena != 0) & (curl_strnequal("domain", i, 6) != 0);
          if ( !v15 )
            goto LABEL_70;
          if ( *maxage == 46 )
          {
            ++maxage;
            --vlena;
          }
          if ( vlena == 9 && curl_strnequal(maxage, "localhost", 9)
            || (v16 = memchr(maxage, 46, vlena)) != 0 && vlena - (v16 - maxage) > 1 )
          {
            if ( domain )
            {
              is_ipnum = Curl_host_is_ipnum(domain);
              goto LABEL_39;
            }
            v57 = Curl_host_is_ipnum(maxage);
            strstore(&co->domain, maxage, vlena);
            if ( !co->domain )
              goto LABEL_201;
            if ( v57 )
              goto LABEL_70;
LABEL_81:
            co->tailmatch = 1;
            goto LABEL_70;
          }
          domain = ":";
          is_ipnum = Curl_host_is_ipnum(":");
LABEL_39:
          if ( is_ipnum )
          {
            if ( !strncmp(maxage, domain, vlena) && strlen(domain) == vlena )
            {
              strstore(&co->domain, maxage, vlena);
              if ( !co->domain )
                goto LABEL_201;
              goto LABEL_70;
            }
          }
          else if ( cookie_tailmatch(maxage, vlena, domain) )
          {
            strstore(&co->domain, maxage, vlena);
            if ( !co->domain )
              goto LABEL_201;
            goto LABEL_81;
          }
          badcookie = v15;
          if ( (data->set.gap52B[3] & 0x10) != 0 )
          {
            Curl_infof(data, "skipped cookie with bad tailmatch domain: %s");
            badcookie = v15;
          }
          goto LABEL_70;
        }
LABEL_69:
        if ( v10 == 7 && !curl_strnequal("version", i, 7) )
        {
          if ( curl_strnequal("max-age", i, 7) )
          {
            v23 = curlx_strtoofft(&maxage[*maxage == 34], 0, 10, &co->expires);
            switch ( v23 )
            {
              case 1:
                LODWORD(co->expires) = -1;
                HIDWORD(co->expires) = 0x7FFFFFFF;
                break;
              case 2:
                LODWORD(co->expires) = 1;
                HIDWORD(co->expires) = 0;
                break;
              case 0:
                expires = co->expires;
                if ( expires )
                {
                  LODWORD(vlenb) = now;
                  if ( 0x7FFFFFFFFFFFFFFFLL - now >= expires )
                  {
                    HIDWORD(vlenb) = now >> 31;
                    co->expires = vlenb + expires;
                  }
                  else
                  {
                    LODWORD(co->expires) = -1;
                    HIDWORD(co->expires) = 0x7FFFFFFF;
                  }
                }
                else
                {
                  LODWORD(co->expires) = 1;
                  HIDWORD(co->expires) = 0;
                }
                break;
            }
          }
          else if ( curl_strnequal("expires", i, 7) && !co->expires && vlena <= 0x7F )
          {
            if ( vlena >= 4 )
            {
              *(_DWORD *)&date[vlena - 4] = *(_DWORD *)&maxage[vlena - 4];
              qmemcpy(date, maxage, 4 * ((vlena - 1) >> 2));
            }
            else if ( vlena )
            {
              date[0] = *maxage;
              if ( (vlena & 2) != 0 )
                *(_WORD *)&date[vlena - 2] = *(_WORD *)&maxage[vlena - 2];
            }
            date[vlena] = 0;
            v25 = Curl_getdate_capped(date);
            if ( (_DWORD)v25 )
            {
              if ( (int)v25 >> 31 < 0 )
              {
                LODWORD(co->expires) = 0;
                HIDWORD(co->expires) = 0;
              }
              else
              {
                co->expires = v25;
              }
            }
            else
            {
              LODWORD(co->expires) = 1;
              HIDWORD(co->expires) = 0;
            }
          }
        }
        goto LABEL_70;
      }
      if ( v10 == 8 )
      {
        if ( curl_strnequal("httponly", i, 8) )
        {
          co->httponly = 1;
          goto LABEL_70;
        }
        if ( !v82 )
          goto LABEL_70;
        goto LABEL_69;
      }
      if ( v82 )
      {
LABEL_29:
        if ( v10 != 4 )
          goto LABEL_30;
        if ( curl_strnequal("path", i, 4) )
        {
          strstore(&co->path, maxage, vlena);
          if ( !co->path || (Curl_cfree(co->spath), v22 = sanitize_cookie_path(co->path), (co->spath = v22) == 0) )
          {
LABEL_201:
            freecookie(co);
            return 0;
          }
        }
      }
LABEL_70:
      v20 = *v26;
      if ( !*v26 )
      {
        v21 = path;
LABEL_118:
        if ( badcookie )
          goto LABEL_201;
        if ( !co->domain )
        {
          if ( domain )
          {
            v28 = Curl_cstrdup(domain);
            co->domain = (char *)v28;
            if ( !v28 )
              goto LABEL_201;
          }
        }
        if ( !co->path && v21 )
        {
          v29 = strchr(v21, 63);
          v30 = v29 ? (char *)Curl_memrchr(v21, 47, v29 - v21) : strrchr(v21, 47);
          if ( v30 )
          {
            v31 = v30 - v21;
            v32 = v30 - v21 + 1;
            v33 = (char *)Curl_cmalloc(v30 - v21 + 2);
            co->path = v33;
            if ( !v33 )
              goto LABEL_201;
            memcpy(v33, v21, v32);
            co->path[v31 + 1] = 0;
            v34 = sanitize_cookie_path(co->path);
            co->spath = v34;
            if ( !v34 )
              goto LABEL_201;
          }
        }
        if ( !co->name )
          goto LABEL_201;
        ++data->req.setcookies;
LABEL_255:
        prefix = co->prefix;
        if ( (prefix & 1) != 0 )
        {
          if ( !co->secure )
            goto LABEL_201;
          if ( (prefix & 2) != 0 )
          {
LABEL_258:
            v60 = co->path;
            if ( !v60 || strcmp(v60, "/") || co->tailmatch )
              goto LABEL_201;
          }
        }
        else if ( (prefix & 2) != 0 )
        {
          if ( !co->secure )
            goto LABEL_201;
          goto LABEL_258;
        }
        running = c->running;
        if ( !running && c->newsession && !co->expires )
          goto LABEL_201;
        co->livecookie = running;
        vlenf = c->lastct;
        c->lastct = vlenf + 1;
        co->creationtime = vlenf + 1;
        if ( !noexpire )
          remove_expired(c);
        maxageb = cookiehash(co->domain);
        v46 = c->cookies[maxageb];
        ptra = (char *)v46;
        if ( v46 )
        {
          vlend = 0;
          v53 = 0;
          replace_clista = 0;
          while ( 1 )
          {
            if ( !curl_strequal(v46->name, co->name) )
              goto LABEL_184;
            v47 = v46->domain;
            if ( v47 )
            {
              if ( !co->domain || !curl_strequal(v47, co->domain) )
                goto LABEL_184;
            }
            else if ( co->domain )
            {
              goto LABEL_184;
            }
            spath = v46->spath;
            if ( spath )
            {
              ptr = co->spath;
              if ( ptr )
              {
                if ( v46->secure && !co->secure && !secure )
                {
                  reject = v46->spath;
                  v49 = strchr(spath + 1, 47);
                  v50 = v49 ? v49 - reject : strlen(reject);
                  if ( curl_strnequal(reject, ptr, v50) )
                  {
                    if ( (data->set.gap52B[3] & 0x10) != 0 )
                      Curl_infof(data, "cookie '%s' for domain '%s' dropped, would overlay an existing cookie");
                    goto LABEL_201;
                  }
                }
              }
            }
LABEL_184:
            if ( v53 || !curl_strequal(v46->name, co->name) )
              goto LABEL_185;
            v51 = v46->domain;
            if ( v51 )
            {
              if ( !co->domain || !curl_strequal(v51, co->domain) || v46->tailmatch != co->tailmatch )
              {
LABEL_210:
                if ( !vlend )
                  goto LABEL_185;
              }
            }
            else if ( co->domain )
            {
              goto LABEL_210;
            }
            v52 = v46->spath;
            if ( !v52 )
              goto LABEL_214;
            if ( !co->spath )
            {
              v53 = 0;
              vlend = 0;
              goto LABEL_185;
            }
            if ( !curl_strequal(v52, co->spath) )
            {
              vlend = 0;
            }
            else
            {
LABEL_214:
              if ( (v46->spath == 0) == (co->spath == 0) )
              {
                vlend = co->livecookie;
                if ( vlend )
                {
                  replace_clista = v46;
                  v53 = co;
                }
                else
                {
                  if ( v46->livecookie )
                    goto LABEL_201;
                  replace_clista = v46;
                  v53 = co;
                  vlend = 1;
                }
              }
              else
              {
                vlend = 0;
              }
            }
LABEL_185:
            if ( !v46->next )
            {
              ptra = (char *)v46;
              v9 = replace_clista;
              if ( v53 )
              {
                v53->next = replace_clista->next;
                v53->creationtime = replace_clista->creationtime;
                Curl_cfree(replace_clista->name);
                Curl_cfree(replace_clista->value);
                Curl_cfree(replace_clista->domain);
                Curl_cfree(replace_clista->path);
                Curl_cfree(replace_clista->spath);
                replace_clista->next = v53->next;
                replace_clista->name = v53->name;
                replace_clista->value = v53->value;
                replace_clista->path = v53->path;
                replace_clista->spath = v53->spath;
                replace_clista->domain = v53->domain;
                LODWORD(replace_clista->expires) = v53->expires;
                HIDWORD(replace_clista->expires) = HIDWORD(v53->expires);
                *(_DWORD *)&replace_clista->tailmatch = *(_DWORD *)&v53->tailmatch;
                replace_clista->creationtime = v53->creationtime;
                *(_DWORD *)&replace_clista->prefix = *(_DWORD *)&v53->prefix;
                Curl_cfree(v53);
              }
              else
              {
                v9 = co;
              }
              if ( !c->running )
                goto LABEL_226;
              goto LABEL_232;
            }
            v46 = v46->next;
          }
        }
        if ( !c->running )
        {
          v9 = co;
LABEL_270:
          c->cookies[maxageb] = v9;
          goto LABEL_236;
        }
        v9 = co;
        vlend = 0;
LABEL_232:
        if ( (data->set.gap52B[3] & 0x10) != 0 )
          Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld");
LABEL_226:
        if ( !vlend )
        {
          if ( !ptra )
            goto LABEL_270;
          *(_DWORD *)ptra = v9;
LABEL_236:
          ++c->numcookies;
        }
        v54 = v9->expires;
        expires_high = HIDWORD(v9->expires);
        if ( v9->expires && __SPAIR64__(expires_high, v54) < c->next_expiration )
        {
          LODWORD(c->next_expiration) = v54;
          HIDWORD(c->next_expiration) = expires_high;
        }
        return v9;
      }
LABEL_108:
      while ( v20 == 32 || v20 == 9 )
      {
        v20 = *++v26;
        if ( !*v26 )
        {
          v21 = path;
          goto LABEL_118;
        }
      }
      if ( v20 != 59 )
      {
        v21 = path;
        goto LABEL_118;
      }
    }
  }
  tok_buf = 0;
  if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
  {
    vlen = (char *)(lineptr + 10);
    co->httponly = 1;
  }
  if ( *vlen == 35 )
  {
    Curl_cfree(co);
    return 0;
  }
  v35 = strchr(vlen, 13);
  if ( v35 )
    *v35 = 0;
  v36 = strchr(vlen, 10);
  if ( v36 )
    *v36 = 0;
  v37 = strtok_r(vlen, "\t", &tok_buf);
  if ( !v37 )
    goto LABEL_176;
  v38 = 0;
  while ( 2 )
  {
    switch ( v38 )
    {
      case 0:
        v39 = Curl_cstrdup(&v37[*v37 == 46]);
        co->domain = (char *)v39;
        if ( !v39 )
          goto LABEL_250;
        vlenc = httpheader;
        goto LABEL_148;
      case 1:
        co->tailmatch = curl_strequal(v37, "TRUE") != 0;
        vlenc = httpheader;
        goto LABEL_148;
      case 2:
        if ( strcmp("TRUE", v37) && strcmp("FALSE", v37) )
        {
          v40 = (const char *)Curl_cstrdup(v37);
          co->path = (char *)v40;
          if ( !v40 )
            goto LABEL_250;
          v41 = sanitize_cookie_path(v40);
          co->spath = v41;
          if ( !v41 )
            goto LABEL_250;
          vlenc = httpheader;
          goto LABEL_148;
        }
        maxagea = (const char *)Curl_cstrdup("/");
        co->path = (char *)maxagea;
        v42 = Curl_cstrdup("/");
        co->spath = (char *)v42;
        vlenc = 1;
        if ( v42 )
          vlenc = maxagea == 0;
LABEL_159:
        co->secure = 0;
        if ( !curl_strequal(v37, "TRUE") )
        {
          v38 = 3;
LABEL_148:
          v37 = strtok_r(0, "\t", &tok_buf);
          ++v38;
          if ( !v37 || vlenc )
          {
            v45 = vlenc;
            if ( v38 == 6 )
              goto LABEL_251;
LABEL_253:
            if ( v38 == 7 && !v45 )
              goto LABEL_255;
            goto LABEL_176;
          }
          continue;
        }
        if ( secure || c->running )
        {
          co->secure = 1;
          v38 = 3;
          goto LABEL_148;
        }
        v38 = 3;
LABEL_250:
        strtok_r(0, "\t", &tok_buf);
        v45 = 1;
        if ( v38 == 5 )
        {
LABEL_251:
          v58 = Curl_cstrdup(&LC1);
          co->value = (char *)v58;
          if ( v58 )
          {
            v38 = 7;
            goto LABEL_253;
          }
        }
LABEL_176:
        freecookie(co);
        return 0;
      case 3:
        vlenc = httpheader;
        goto LABEL_159;
      case 4:
        if ( curlx_strtoofft(v37, 0, 10, &co->expires) )
          goto LABEL_250;
        vlenc = httpheader;
        goto LABEL_148;
      case 5:
        v43 = Curl_cstrdup(v37);
        co->name = (char *)v43;
        if ( !v43 )
          goto LABEL_250;
        if ( curl_strnequal("__Secure-", v43, 9) )
        {
          co->prefix |= 1u;
          vlenc = httpheader;
        }
        else
        {
          vlenc = httpheader;
          if ( curl_strnequal("__Host-", co->name, 7) )
            co->prefix |= 2u;
        }
        goto LABEL_148;
      case 6:
        v44 = Curl_cstrdup(v37);
        co->value = (char *)v44;
        if ( !v44 )
          goto LABEL_250;
        vlenc = httpheader;
        goto LABEL_148;
      default:
        vlenc = httpheader;
        goto LABEL_148;
    }
  }
}
