Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  char *v8; // edi
  char v9; // dl
  __int64 expires; // rax
  unsigned int v11; // esi
  char *v12; // ebp
  char *v13; // eax
  int v14; // ecx
  char v15; // bl
  bool v16; // cl
  bool v17; // al
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  int v21; // esi
  char *v22; // eax
  char *v23; // eax
  char *v24; // esi
  int v25; // eax
  int (__cdecl *v26)(void *); // edi
  const char *v27; // eax
  char *v28; // eax
  char *v29; // edi
  int v30; // edi
  int v31; // eax
  bool v32; // si
  char *v33; // eax
  int v34; // esi
  char *v35; // eax
  int v36; // eax
  char *v37; // eax
  int v38; // esi
  Cookie *v39; // ebp
  size_t v41; // ecx
  unsigned __int8 prefix; // al
  char *v43; // eax
  bool running; // al
  Cookie *v45; // esi
  Cookie *v46; // edi
  Cookie *next; // eax
  char *v48; // eax
  char *v49; // edx
  char *spath; // edx
  char *v51; // eax
  char *v52; // edx
  unsigned int expires_high; // eax
  unsigned int v54; // ecx
  _BYTE *v55; // eax
  int v56; // eax
  char *v57; // edx
  const char *v58; // eax
  const char *name; // edi
  int v60; // eax
  char *v61; // eax
  int v62; // eax
  size_t v63; // esi
  int v64; // eax
  int v65; // eax
  char *v66; // eax
  char is_ipnum; // si
  int v68; // eax
  int v69; // eax
  int v70; // eax
  char *v71; // eax
  const char *v72; // edx
  char *v73; // ecx
  size_t v74; // eax
  int v75; // ecx
  int v76; // eax
  int v77; // eax
  char *v78; // eax
  char *v79; // eax
  int v80; // esi
  size_t v81; // ebx
  char *v82; // eax
  char *v83; // eax
  char vlen; // [esp+14h] [ebp-E8h]
  char vlene; // [esp+14h] [ebp-E8h]
  size_t vlena; // [esp+14h] [ebp-E8h]
  size_t vlenb; // [esp+14h] [ebp-E8h]
  int vlenf; // [esp+14h] [ebp-E8h]
  char vlenc; // [esp+14h] [ebp-E8h]
  bool vlend; // [esp+14h] [ebp-E8h]
  Cookie *co; // [esp+18h] [ebp-E4h]
  const char *maxage; // [esp+1Ch] [ebp-E0h]
  bool maxagea; // [esp+1Ch] [ebp-E0h]
  char *maxageb; // [esp+1Ch] [ebp-E0h]
  char *reject; // [esp+20h] [ebp-DCh]
  char *rejecta; // [esp+20h] [ebp-DCh]
  bool myhash; // [esp+24h] [ebp-D8h]
  size_t myhasha; // [esp+24h] [ebp-D8h]
  char sd; // [esp+28h] [ebp-D4h]
  char *s; // [esp+28h] [ebp-D4h]
  char sa; // [esp+28h] [ebp-D4h]
  bool sb; // [esp+28h] [ebp-D4h]
  char *sc; // [esp+28h] [ebp-D4h]
  char *se; // [esp+28h] [ebp-D4h]
  time_t now; // [esp+44h] [ebp-B8h]
  bool badcookie; // [esp+4Fh] [ebp-ADh]
  char *tok_buf; // [esp+58h] [ebp-A4h] BYREF
  char date[128]; // [esp+5Ch] [ebp-A0h] BYREF
  unsigned int v110; // [esp+DCh] [ebp-20h]

  v8 = (char *)lineptr;
  v110 = __readgsdword(0x14u);
  now = time(0);
  if ( data->req.setcookies > 0x31u )
    return 0;
  co = (Cookie *)Curl_ccalloc(1, 44);
  if ( !co )
    return 0;
  if ( httpheader )
  {
    badcookie = 0;
    if ( strlen(lineptr) <= 0x1388 )
    {
      while ( 1 )
      {
        v9 = *v8;
        if ( !*v8 )
          goto LABEL_15;
        while ( v9 != 32 )
        {
          vlen = v9;
          if ( v9 == 9 )
            break;
          LODWORD(expires) = strcspn(v8, ";\t\r\n=");
          BYTE4(expires) = vlen;
          v11 = expires;
          if ( !(_DWORD)expires )
          {
            v12 = v8;
            goto LABEL_11;
          }
          while ( 2 )
          {
            vlena = (size_t)&v8[v11];
            while ( 1 )
            {
              if ( !v11 )
              {
                v13 = (char *)vlena;
                if ( *(_BYTE *)vlena == 61 )
                  goto LABEL_21;
                vlenb = 0;
                v12 = v13;
                v16 = 0;
                maxage = 0;
LABEL_129:
                if ( !co->name )
                {
LABEL_154:
                  if ( v16 )
                  {
                    Curl_cfree(0);
                    co->name = (char *)Curl_strndup(v8, v11);
                    Curl_cfree(co->value);
                    v58 = (const char *)Curl_strndup(maxage, vlenb);
                    co->value = (char *)v58;
                    name = co->name;
                    if ( name )
                    {
                      if ( v58 )
                      {
                        if ( !v58[strcspn(v58, badoctets_0)] && !name[strcspn(name, badoctets_0)] )
                          goto LABEL_75;
                        if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                          Curl_infof(data, "invalid octets in name/value, cookie dropped");
                      }
                    }
                  }
                  goto LABEL_55;
                }
                if ( !vlenb )
                {
                  if ( v11 == 6 )
                  {
                    vlend = v16;
                    if ( !curl_strnequal("secure", v8, 6) )
                    {
                      if ( vlend )
                        curl_strnequal("domain", v8, 6);
                      goto LABEL_75;
                    }
                    if ( secure || !c->running )
                    {
                      co->secure = 1;
                      BYTE4(expires) = *v12;
                      goto LABEL_76;
                    }
                    goto LABEL_55;
                  }
                  if ( !v16 || v11 != 4 )
                    goto LABEL_75;
LABEL_163:
                  if ( !curl_strnequal("path", v8, 4) )
                    goto LABEL_75;
                  Curl_cfree(co->path);
                  v60 = Curl_strndup(maxage, vlenb);
                  co->path = (char *)v60;
                  if ( v60 )
                  {
                    Curl_cfree(co->spath);
                    v61 = sanitize_cookie_path(co->path);
                    co->spath = v61;
                    if ( v61 )
                      goto LABEL_75;
                  }
                  goto LABEL_55;
                }
                if ( v11 == 4 )
                  goto LABEL_163;
                if ( v11 != 6 || !curl_strnequal("domain", v8, 6) )
                  goto LABEL_75;
                if ( *maxage == 46 )
                {
                  ++maxage;
                  --vlenb;
                }
                if ( vlenb == 9 && curl_strnequal(maxage, "localhost", 9)
                  || (v55 = memchr(maxage, 46, vlenb)) != 0 && vlenb - (v55 - maxage) > 1 )
                {
                  if ( !domain )
                  {
                    is_ipnum = Curl_host_is_ipnum(maxage);
                    Curl_cfree(co->domain);
                    v68 = Curl_strndup(maxage, vlenb);
                    co->domain = (char *)v68;
                    if ( !v68 )
                      goto LABEL_55;
                    if ( is_ipnum )
                      goto LABEL_75;
                    goto LABEL_215;
                  }
                  if ( !(unsigned __int8)Curl_host_is_ipnum(domain) )
                    goto LABEL_181;
LABEL_146:
                  if ( !strncmp(maxage, domain, vlenb) && strlen(domain) == vlenb )
                  {
                    Curl_cfree(co->domain);
                    v70 = Curl_strndup(maxage, vlenb);
                    co->domain = (char *)v70;
                    if ( v70 )
                      goto LABEL_75;
                    goto LABEL_55;
                  }
                }
                else
                {
                  domain = (const char *)&LC1;
                  if ( (unsigned __int8)Curl_host_is_ipnum(&LC1) )
                    goto LABEL_146;
LABEL_181:
                  v63 = strlen(domain);
                  if ( v63 >= vlenb
                    && curl_strnequal(maxage, &domain[v63 - vlenb], vlenb)
                    && (vlenb == v63 || domain[v63 - vlenb - 1] == 46) )
                  {
                    Curl_cfree(co->domain);
                    v64 = Curl_strndup(maxage, vlenb);
                    co->domain = (char *)v64;
                    if ( !v64 )
                      goto LABEL_55;
LABEL_215:
                    co->tailmatch = 1;
                    goto LABEL_75;
                  }
                }
                if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                  Curl_infof(data, "skipped cookie with bad tailmatch domain: %s");
                BYTE4(expires) = *v12;
                badcookie = httpheader;
                goto LABEL_76;
              }
              if ( v8[v11 - 1] != 9 && v8[v11 - 1] != 32 )
                break;
              --v11;
            }
            v16 = 0;
            if ( *(_BYTE *)vlena != 61 )
            {
              v12 = (char *)vlena;
              maxage = 0;
              v17 = 0;
              vlenb = 0;
              goto LABEL_65;
            }
LABEL_21:
            sd = BYTE4(expires);
            maxage = (const char *)(vlena + 1);
            LODWORD(expires) = strcspn((const char *)(vlena + 1), ";\r\n");
            BYTE4(expires) = sd;
            s = (char *)(vlena + 1 + expires);
            if ( !(_DWORD)expires )
            {
LABEL_25:
              v12 = s;
              v16 = httpheader;
              vlenb = expires;
              v17 = 0;
              goto LABEL_65;
            }
            while ( 1 )
            {
              v14 = expires - 1;
              v15 = *(_BYTE *)(vlena + expires);
              if ( v15 != 32 && v15 != 9 )
                break;
              LODWORD(expires) = expires - 1;
              if ( !v14 )
                goto LABEL_25;
            }
            v41 = expires;
            v12 = s;
            LODWORD(expires) = vlena + 1;
            do
            {
              if ( *(_BYTE *)expires != 32 && *(_BYTE *)expires != 9 )
              {
                sa = BYTE4(expires);
                vlenb = v41;
                maxage = (const char *)expires;
                if ( !memchr((const void *)expires, 9, v41) )
                {
                  BYTE4(expires) = sa;
                  goto LABEL_64;
                }
                freecookie(co);
                if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                  Curl_infof(data, "cookie contains TAB, dropping");
                return 0;
              }
              LODWORD(expires) = expires + 1;
              --v41;
            }
            while ( v41 );
            vlenb = 0;
            maxage = (const char *)expires;
LABEL_64:
            v16 = httpheader;
            v17 = vlenb > 0xFFE;
LABEL_65:
            if ( v11 > 0xFFE || v17 || v11 + vlenb > 0x1000 )
            {
              freecookie(co);
              if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes");
              return 0;
            }
            if ( v11 <= 6 )
              goto LABEL_129;
            if ( BYTE4(expires) != 95 || v8[1] != 95 )
            {
              if ( co->name )
                goto LABEL_71;
              goto LABEL_154;
            }
            sb = v16;
            v56 = curl_strnequal("__Secure-", v8, 9);
            v16 = sb;
            if ( v56 )
            {
              v57 = co->name;
              co->prefix |= 1u;
              if ( !v57 )
                goto LABEL_154;
            }
            else
            {
              v77 = curl_strnequal("__Host-", v8, 7);
              v16 = sb;
              if ( v77 )
              {
                co->prefix |= 2u;
                if ( !co->name )
                  goto LABEL_154;
              }
              else if ( !co->name )
              {
                goto LABEL_154;
              }
            }
LABEL_71:
            if ( vlenb )
            {
LABEL_74:
              if ( v11 != 7 || curl_strnequal("version", v8, 7) )
                goto LABEL_75;
              if ( !curl_strnequal("max-age", v8, 7) )
              {
                if ( curl_strnequal("expires", v8, 7) && !co->expires && vlenb <= 0x7F )
                {
                  if ( vlenb >= 4 )
                  {
                    *(_DWORD *)&date[vlenb - 4] = *(_DWORD *)&maxage[vlenb - 4];
                    qmemcpy(date, maxage, 4 * ((vlenb - 1) >> 2));
                  }
                  else if ( vlenb )
                  {
                    date[0] = *maxage;
                    if ( (vlenb & 2) != 0 )
                      *(_WORD *)&date[vlenb - 2] = *(_WORD *)&maxage[vlenb - 2];
                  }
                  date[vlenb] = 0;
                  v75 = Curl_getdate_capped(date);
                  if ( v75 )
                  {
                    if ( v75 >> 31 == -1 )
                    {
                      LODWORD(co->expires) = 0;
                      HIDWORD(co->expires) = 0;
                    }
                    else
                    {
                      co->expires = v75;
                    }
                  }
                  else
                  {
                    LODWORD(co->expires) = 1;
                    HIDWORD(co->expires) = 0;
                  }
                }
                goto LABEL_75;
              }
              v62 = curlx_strtoofft(&maxage[*maxage == 34], 0, 10);
              if ( v62 == 1 )
                goto LABEL_234;
              if ( v62 == 2 )
              {
                LODWORD(co->expires) = 1;
                HIDWORD(co->expires) = 0;
                BYTE4(expires) = *v12;
                goto LABEL_76;
              }
              if ( v62 )
                goto LABEL_75;
              expires = co->expires;
              if ( !expires )
              {
                LODWORD(co->expires) = 1;
                HIDWORD(co->expires) = 0;
                HIDWORD(expires) = (unsigned __int8)*v12;
                goto LABEL_76;
              }
              if ( 0x7FFFFFFFFFFFFFFFLL - now < expires )
              {
LABEL_234:
                LODWORD(co->expires) = -1;
                HIDWORD(co->expires) = 0x7FFFFFFF;
                BYTE4(expires) = *v12;
              }
              else
              {
                co->expires = now + expires;
                BYTE4(expires) = *v12;
              }
            }
            else if ( v11 == 8 )
            {
              if ( !curl_strnequal("httponly", v8, 8) )
                goto LABEL_75;
              co->httponly = 1;
              BYTE4(expires) = *v12;
            }
            else
            {
              if ( v16 )
                goto LABEL_74;
LABEL_75:
              BYTE4(expires) = *v12;
            }
LABEL_76:
            if ( !BYTE4(expires) )
            {
LABEL_77:
              if ( !badcookie )
              {
                if ( co->domain || !domain || (v76 = Curl_cstrdup(domain), (co->domain = (char *)v76) != 0) )
                {
                  if ( co->path || !path )
                    goto LABEL_283;
                  v78 = strchr(path, 63);
                  v79 = v78 ? (char *)Curl_memrchr(path, 47, v78 - path) : strrchr(path, 47);
                  if ( !v79 )
                    goto LABEL_283;
                  v80 = v79 - path;
                  v81 = v79 - path + 1;
                  v82 = (char *)Curl_cmalloc(v79 - path + 2);
                  co->path = v82;
                  if ( v82 )
                  {
                    memcpy(v82, path, v81);
                    co->path[v80 + 1] = 0;
                    v83 = sanitize_cookie_path(co->path);
                    co->spath = v83;
                    if ( v83 )
                    {
LABEL_283:
                      if ( co->name )
                      {
                        ++data->req.setcookies;
                        goto LABEL_84;
                      }
                    }
                  }
                }
              }
LABEL_55:
              freecookie(co);
              return 0;
            }
LABEL_11:
            while ( BYTE4(expires) == 32 || BYTE4(expires) == 9 )
            {
              BYTE4(expires) = *++v12;
              if ( !BYTE4(expires) )
                goto LABEL_77;
            }
            if ( BYTE4(expires) != 59 )
              goto LABEL_77;
            v9 = v12[1];
            v8 = v12 + 1;
            if ( !v9 )
            {
LABEL_15:
              vlene = v9;
              LODWORD(expires) = strcspn(v8, ";\t\r\n=");
              BYTE4(expires) = vlene;
              v11 = expires;
              if ( !(_DWORD)expires )
                goto LABEL_77;
              continue;
            }
            break;
          }
        }
        ++v8;
      }
    }
LABEL_212:
    Curl_cfree(co);
    return 0;
  }
  tok_buf = 0;
  if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
  {
    v8 = (char *)(lineptr + 10);
    co->httponly = 1;
  }
  if ( *v8 == 35 )
    goto LABEL_212;
  v18 = strchr(v8, 13);
  if ( v18 )
    *v18 = 0;
  v19 = strchr(v8, 10);
  if ( v19 )
    *v19 = 0;
  v20 = strtok_r(v8, "\t", &tok_buf);
  if ( !v20 )
    goto LABEL_55;
  v21 = Curl_cstrdup(&v20[*v20 == 46]);
  co->domain = (char *)v21;
  v22 = strtok_r(0, "\t", &tok_buf);
  maxagea = v22 != 0 && v21 != 0;
  if ( !maxagea )
  {
    maxagea = v21 != 0;
    v65 = 1;
    myhash = v21 == 0;
    goto LABEL_269;
  }
  co->tailmatch = curl_strequal(v22, "TRUE") != 0;
  v23 = strtok_r(0, "\t", &tok_buf);
  v24 = v23;
  if ( !v23 )
  {
    myhash = httpheader;
    v65 = 2;
    goto LABEL_269;
  }
  v25 = strcmp("TRUE", v23);
  v26 = (int (__cdecl *)(void *))Curl_cstrdup;
  if ( !v25 || !strcmp("FALSE", v24) )
  {
    v30 = v26(&LC0);
    co->path = (char *)v30;
    v31 = Curl_cstrdup(&LC0);
    co->spath = (char *)v31;
    if ( !v31 )
    {
      co->secure = 0;
      if ( !curl_strequal(v24, "TRUE") )
        goto LABEL_192;
      goto LABEL_188;
    }
    maxagea = v30 == 0;
  }
  else
  {
    v27 = (const char *)v26(v24);
    co->path = (char *)v27;
    if ( !v27 )
      goto LABEL_192;
    v28 = sanitize_cookie_path(v27);
    co->spath = v28;
    v29 = v28;
    maxagea = v28 != 0;
    v24 = strtok_r(0, "\t", &tok_buf);
    if ( !v24 || !maxagea )
    {
      v65 = 3;
      myhash = v29 == 0;
      goto LABEL_269;
    }
    maxagea = httpheader;
  }
  co->secure = 0;
  if ( curl_strequal(v24, "TRUE") )
  {
LABEL_188:
    if ( secure || c->running )
    {
      co->secure = 1;
      v32 = !maxagea;
      v33 = strtok_r(0, "\t", &tok_buf);
      if ( !v33 )
        goto LABEL_191;
      goto LABEL_46;
    }
LABEL_192:
    strtok_r(0, "\t", &tok_buf);
    freecookie(co);
    return 0;
  }
  v32 = !maxagea;
  v33 = strtok_r(0, "\t", &tok_buf);
  if ( !v33 )
  {
LABEL_191:
    myhash = maxagea;
    maxagea = v32;
    v65 = 4;
    goto LABEL_269;
  }
LABEL_46:
  if ( !v32 )
    goto LABEL_191;
  v34 = curlx_strtoofft(v33, 0, 10);
  maxagea = v34 == 0;
  v35 = strtok_r(0, "\t", &tok_buf);
  myhash = v34 == 0 && v35 != 0;
  if ( !myhash )
  {
    v65 = 5;
    myhash = v34 != 0;
    goto LABEL_269;
  }
  v36 = Curl_cstrdup(v35);
  co->name = (char *)v36;
  if ( !v36 )
  {
    strtok_r(0, "\t", &tok_buf);
    goto LABEL_217;
  }
  if ( curl_strnequal("__Secure-", v36, 9) )
  {
    co->prefix |= 1u;
  }
  else if ( curl_strnequal("__Host-", co->name, 7) )
  {
    co->prefix |= 2u;
  }
  v37 = strtok_r(0, "\t", &tok_buf);
  if ( !v37 )
  {
    myhash = httpheader;
LABEL_217:
    v69 = Curl_cstrdup(&LC24);
    co->value = (char *)v69;
    if ( !v69 )
      goto LABEL_55;
    goto LABEL_218;
  }
  v38 = Curl_cstrdup(v37);
  maxagea = v38 != 0;
  co->value = (char *)v38;
  if ( strtok_r(0, "\t", &tok_buf) && v38 )
  {
    while ( strtok_r(0, "\t", &tok_buf) )
      ;
    goto LABEL_55;
  }
  v65 = 7;
  myhash = v38 == 0;
LABEL_269:
  if ( v65 != 7 && maxagea )
    goto LABEL_55;
LABEL_218:
  if ( myhash )
    goto LABEL_55;
LABEL_84:
  prefix = co->prefix;
  if ( (prefix & 1) != 0 )
  {
    if ( !co->secure )
      goto LABEL_55;
    if ( (prefix & 2) != 0 )
    {
LABEL_87:
      v43 = co->path;
      if ( !v43 || *v43 != 47 || v43[1] || co->tailmatch )
        goto LABEL_55;
    }
  }
  else if ( (prefix & 2) != 0 )
  {
    if ( !co->secure )
      goto LABEL_55;
    goto LABEL_87;
  }
  running = c->running;
  if ( !running && c->newsession && !co->expires )
    goto LABEL_55;
  co->livecookie = running;
  vlenf = c->lastct;
  c->lastct = vlenf + 1;
  co->creationtime = vlenf + 1;
  if ( !noexpire )
    remove_expired(c);
  myhasha = cookiehash(co->domain);
  v45 = c->cookies[myhasha];
  if ( !v45 )
  {
    if ( c->running && (*(&data->set.connect_only + 4) & 0x20) != 0 )
    {
      v39 = co;
      vlenc = 0;
LABEL_121:
      Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld");
      if ( vlenc )
        goto LABEL_122;
      if ( v45 )
        goto LABEL_205;
    }
    else
    {
      v39 = co;
    }
    c->cookies[myhasha] = v39;
    goto LABEL_206;
  }
  vlenc = 0;
  v46 = 0;
  maxageb = 0;
  while ( 1 )
  {
    if ( !curl_strequal(v45->name, co->name) )
      goto LABEL_109;
    v48 = v45->domain;
    v49 = co->domain;
    if ( v48 )
    {
      if ( !v49 || !curl_strequal(v48, co->domain) )
        goto LABEL_109;
    }
    else if ( v49 )
    {
      goto LABEL_109;
    }
    spath = v45->spath;
    if ( spath )
    {
      reject = co->spath;
      if ( reject )
      {
        if ( v45->secure && !co->secure && !secure )
        {
          sc = v45->spath;
          v71 = strchr(spath + 1, 47);
          v72 = sc;
          v73 = reject;
          if ( v71 )
          {
            v74 = v71 - sc;
          }
          else
          {
            se = reject;
            rejecta = (char *)v72;
            v74 = strlen(v72);
            v73 = se;
            v72 = rejecta;
          }
          if ( curl_strnequal(v72, v73, v74) )
          {
            if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
              Curl_infof(data, "cookie '%s' for domain '%s' dropped, would overlay an existing cookie");
            goto LABEL_55;
          }
        }
      }
    }
LABEL_109:
    if ( v46 || !curl_strequal(v45->name, co->name) )
      goto LABEL_98;
    v51 = v45->domain;
    v52 = co->domain;
    if ( v51 )
    {
      if ( v52 && curl_strequal(v51, co->domain) && v45->tailmatch == co->tailmatch )
        goto LABEL_196;
    }
    else if ( !v52 )
    {
      goto LABEL_196;
    }
    if ( !vlenc )
      goto LABEL_116;
LABEL_196:
    v66 = v45->spath;
    if ( v66 )
      break;
LABEL_200:
    if ( (v66 == 0) != (co->spath == 0) )
      goto LABEL_116;
    vlenc = co->livecookie;
    if ( vlenc )
    {
      maxageb = (char *)v45;
      v46 = co;
    }
    else
    {
      if ( v45->livecookie )
        goto LABEL_55;
      maxageb = (char *)v45;
      v46 = co;
      vlenc = 1;
    }
LABEL_98:
    next = v45->next;
    if ( !v45->next )
      goto LABEL_117;
LABEL_99:
    v45 = next;
  }
  if ( co->spath && curl_strequal(v66, co->spath) )
  {
    v66 = v45->spath;
    goto LABEL_200;
  }
LABEL_116:
  next = v45->next;
  vlenc = 0;
  if ( v45->next )
    goto LABEL_99;
LABEL_117:
  v39 = (Cookie *)maxageb;
  if ( v46 )
  {
    v46->next = *(Cookie **)maxageb;
    v46->creationtime = *((_DWORD *)maxageb + 9);
    Curl_cfree(*((_DWORD *)maxageb + 1));
    Curl_cfree(*((_DWORD *)maxageb + 2));
    Curl_cfree(*((_DWORD *)maxageb + 5));
    Curl_cfree(*((_DWORD *)maxageb + 3));
    Curl_cfree(*((_DWORD *)maxageb + 4));
    *(_DWORD *)maxageb = v46->next;
    *((_DWORD *)maxageb + 1) = v46->name;
    *((_DWORD *)maxageb + 2) = v46->value;
    *((_DWORD *)maxageb + 3) = v46->path;
    *((_DWORD *)maxageb + 4) = v46->spath;
    *((_DWORD *)maxageb + 5) = v46->domain;
    *((_DWORD *)maxageb + 6) = v46->expires;
    *((_DWORD *)maxageb + 7) = HIDWORD(v46->expires);
    *((_DWORD *)maxageb + 8) = *(_DWORD *)&v46->tailmatch;
    *((_DWORD *)maxageb + 9) = v46->creationtime;
    *((_DWORD *)maxageb + 10) = *(_DWORD *)&v46->prefix;
    Curl_cfree(v46);
  }
  else
  {
    v39 = co;
  }
  if ( c->running && (*(&data->set.connect_only + 4) & 0x20) != 0 )
    goto LABEL_121;
  if ( vlenc )
    goto LABEL_122;
LABEL_205:
  v45->next = v39;
LABEL_206:
  ++c->numcookies;
LABEL_122:
  expires_high = HIDWORD(v39->expires);
  v54 = v39->expires;
  if ( v39->expires && __SPAIR64__(expires_high, v54) < c->next_expiration )
  {
    LODWORD(c->next_expiration) = v54;
    HIDWORD(c->next_expiration) = expires_high;
  }
  return v39;
}
