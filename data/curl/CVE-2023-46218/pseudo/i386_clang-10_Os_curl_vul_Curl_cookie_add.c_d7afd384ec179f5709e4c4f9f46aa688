Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  time_t v8; // eax
  Cookie *v9; // esi
  int v10; // ebp
  int v11; // eax
  int v12; // edi
  const char *v13; // ecx
  const char *v14; // ebp
  const char *i; // esi
  size_t v16; // eax
  unsigned int v17; // edi
  char v18; // dl
  size_t v19; // eax
  size_t v20; // ecx
  const char *v21; // edx
  const char *v22; // ebp
  char v23; // cl
  size_t v24; // ebp
  const char *v25; // edx
  const char *v26; // ebp
  int v27; // eax
  int v28; // eax
  char *v29; // eax
  int v30; // eax
  int v31; // eax
  const char *v32; // esi
  const char *v33; // edi
  size_t v34; // eax
  const char *v35; // ebp
  int v36; // eax
  const char *v37; // edi
  const char *v38; // eax
  int v39; // eax
  const char *v40; // edi
  int v41; // eax
  const char *v42; // ecx
  size_t v43; // ebp
  const char *v44; // edi
  _BYTE *v45; // eax
  const char *v46; // ebp
  Curl_easy *v47; // esi
  const char *v48; // ebp
  int v49; // eax
  const char *v50; // eax
  char is_ipnum; // al
  char v52; // cl
  int v53; // eax
  size_t v54; // eax
  int v55; // eax
  char v56; // cl
  int v57; // ebp
  unsigned int v58; // eax
  unsigned int v59; // ecx
  char v60; // al
  char *v61; // ebp
  char *v62; // eax
  char *v63; // eax
  char *v64; // eax
  const char *v65; // edi
  int v66; // edx
  int v67; // eax
  unsigned __int8 v68; // bp
  int v69; // ebp
  const char *v70; // eax
  char *v71; // eax
  int v72; // ecx
  bool v73; // zf
  unsigned __int8 v74; // di
  int v75; // eax
  int v76; // ebp
  int v77; // eax
  char v78; // di
  int v79; // eax
  int v80; // ebp
  int v81; // eax
  int v82; // ebp
  int v83; // eax
  int v84; // eax
  char *v85; // eax
  int v86; // ebp
  int v87; // eax
  _BOOL4 v88; // eax
  Curl_easy *v89; // edi
  char v90; // al
  int v91; // esi
  int v92; // eax
  char v93; // bp
  char *v94; // eax
  char *v95; // eax
  int v96; // edi
  void *v97; // eax
  size_t v98; // edi
  char *v99; // eax
  char v100; // al
  bool running; // al
  int v102; // eax
  Cookie *v103; // esi
  Cookie *next; // eax
  Cookie **v105; // edi
  Cookie *v106; // ebp
  char *v107; // eax
  int v108; // ecx
  const char *spath; // esi
  char *v110; // eax
  size_t v111; // eax
  char *v112; // eax
  int v113; // ecx
  bool v114; // zf
  int v115; // eax
  char *v116; // eax
  char *v117; // ecx
  int v118; // eax
  const char *v119; // eax
  char v121; // al
  char v122; // si
  const char *v123; // ecx
  Cookie **p_next; // eax
  curl_off_t v125; // rax
  int expires_high; // ecx
  const char *v127; // [esp-10h] [ebp-DCh]
  const char *v128; // [esp-10h] [ebp-DCh]
  size_t v129; // [esp-Ch] [ebp-D8h]
  const char *v130; // [esp-8h] [ebp-D4h]
  int v131; // [esp-4h] [ebp-D0h]
  Cookie *v132; // [esp+0h] [ebp-CCh]
  char v133; // [esp+Ch] [ebp-C0h]
  const char *v134; // [esp+Ch] [ebp-C0h]
  int v135; // [esp+Ch] [ebp-C0h]
  unsigned __int8 v136; // [esp+Ch] [ebp-C0h]
  int v137; // [esp+Ch] [ebp-C0h]
  int v138; // [esp+10h] [ebp-BCh]
  const char *s; // [esp+14h] [ebp-B8h]
  const char *sa; // [esp+14h] [ebp-B8h]
  const char *sb; // [esp+14h] [ebp-B8h]
  const char *sc; // [esp+14h] [ebp-B8h]
  char sd; // [esp+14h] [ebp-B8h]
  Cookie *se; // [esp+14h] [ebp-B8h]
  size_t n; // [esp+18h] [ebp-B4h]
  size_t na; // [esp+18h] [ebp-B4h]
  size_t nb; // [esp+18h] [ebp-B4h]
  size_t v148; // [esp+1Ch] [ebp-B0h]
  size_t v149; // [esp+1Ch] [ebp-B0h]
  char v150; // [esp+1Ch] [ebp-B0h]
  int v151; // [esp+1Ch] [ebp-B0h]
  char v152; // [esp+20h] [ebp-ACh]
  unsigned int *v154; // [esp+28h] [ebp-A4h]
  int v155; // [esp+2Ch] [ebp-A0h]
  __int64 v156; // [esp+34h] [ebp-98h]
  char *dest[36]; // [esp+3Ch] [ebp-90h] BYREF

  v131 = 134218452;
  v8 = time(0);
  v9 = 0;
  if ( data->req.setcookies > 0x31u )
    return v9;
  v10 = v8;
  v11 = Curl_ccalloc(1, 44);
  if ( !v11 )
    return v9;
  v12 = v11;
  v155 = v10;
  v138 = v11;
  if ( !httpheader )
  {
    dest[0] = 0;
    v61 = lineptr;
    if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
    {
      v61 = lineptr + 10;
      *(_BYTE *)(v12 + 35) = 1;
    }
    if ( *v61 == 35 )
      goto LABEL_129;
    v62 = strchr(v61, 13);
    if ( v62 )
      *v62 = 0;
    v63 = strchr(v61, 10);
    if ( v63 )
      *v63 = 0;
    v64 = strtok_r(v61, "\t", dest);
    if ( !v64 )
      goto LABEL_274;
    v65 = v64;
    v66 = 0;
    v67 = 0;
    while ( 1 )
    {
      switch ( v67 )
      {
        case 0:
          v68 = v66;
          if ( *v65 == 46 )
            ++v65;
          v84 = Curl_cstrdup(v65);
          *(_DWORD *)(v138 + 20) = v84;
          v72 = v68;
          if ( !v84 )
            v72 = 1;
          v69 = 0;
          goto LABEL_169;
        case 1:
          v135 = v66;
          *(_BYTE *)(v138 + 32) = curl_strequal(v65, "TRUE") != 0;
          v69 = 1;
          goto LABEL_177;
        case 2:
          v136 = v66;
          if ( !strcmp("TRUE", v65) || !strcmp("FALSE", v65) )
          {
            v80 = Curl_cstrdup("/");
            *(_DWORD *)(v138 + 12) = v80;
            v81 = Curl_cstrdup("/");
            v9 = 0;
            v66 = v136;
            if ( !v81 )
              v66 = 1;
            if ( !v80 )
              v66 = 1;
            *(_DWORD *)(v138 + 16) = v81;
LABEL_160:
            v82 = v66;
            *(_BYTE *)(v138 + 33) = 0;
            if ( !curl_strequal(v65, "TRUE") )
              goto LABEL_164;
            if ( secure || (v83 = (int)c, c->running) )
            {
              *(_BYTE *)(v138 + 33) = 1;
LABEL_164:
              v135 = v82;
              v69 = 3;
              goto LABEL_177;
            }
            LOBYTE(v83) = 1;
            v69 = 3;
          }
          else
          {
            v70 = (const char *)Curl_cstrdup(v65);
            *(_DWORD *)(v138 + 12) = v70;
            if ( v70 )
            {
              v71 = sanitize_cookie_path(v70);
              LOBYTE(v72) = v136;
              *(_DWORD *)(v138 + 16) = v71;
              v73 = v71 == 0;
              v69 = 2;
LABEL_152:
              v72 = (unsigned __int8)v72;
              if ( v73 )
                v72 = 1;
LABEL_169:
              v135 = v72;
              goto LABEL_177;
            }
            v83 = 1;
            v69 = 2;
          }
          v135 = v83;
LABEL_177:
          v85 = strtok_r(0, "\t", dest);
          v66 = v135;
          v86 = v69 + 1;
          v65 = v85;
          v67 = v86;
          if ( (v135 & 1) != 0 || !v65 )
          {
            if ( v86 == 6 )
            {
              v87 = Curl_cstrdup(&L_str_22);
              LOBYTE(v66) = v135;
              *(_DWORD *)(v138 + 8) = v87;
              v73 = v87 == 0;
              v88 = v87 == 0;
              if ( v73 )
                LOBYTE(v66) = 1;
              v67 = v88 ^ 7;
            }
            if ( (v66 & 1) == 0 && v67 == 7 )
            {
              v89 = data;
              goto LABEL_214;
            }
LABEL_274:
            freecookie(v132);
            return v9;
          }
          break;
        case 3:
          goto LABEL_160;
        case 4:
          v127 = v65;
          v74 = v66;
          v75 = curlx_strtoofft(v127, 0, 10, v138 + 24);
          v69 = 4;
          v72 = v74;
          if ( v75 )
            v72 = 1;
          goto LABEL_169;
        case 5:
          v76 = v66;
          v77 = Curl_cstrdup(v65);
          *(_DWORD *)(v138 + 4) = v77;
          if ( v77 )
          {
            v135 = v76;
            if ( curl_strnequal("__Secure-", v77, 9) )
            {
              *(_BYTE *)(v138 + 40) |= 1u;
            }
            else if ( curl_strnequal("__Host-", *(_DWORD *)(v138 + 4), 7) )
            {
              *(_BYTE *)(v138 + 40) |= 2u;
            }
          }
          else
          {
            v135 = 1;
          }
          v69 = 5;
          goto LABEL_177;
        case 6:
          v128 = v65;
          v78 = v66;
          v79 = Curl_cstrdup(v128);
          v73 = v79 == 0;
          v69 = 6;
          *(_DWORD *)(v138 + 8) = v79;
          LOBYTE(v72) = v78;
          goto LABEL_152;
        default:
          v135 = v66;
          v69 = v67;
          goto LABEL_177;
      }
    }
  }
  if ( strlen(lineptr) > 0x1388 )
  {
LABEL_129:
    Curl_cfree(v12);
    return v9;
  }
  v152 = 0;
  v154 = (unsigned int *)(v12 + 24);
  LODWORD(v156) = ~v10;
  v13 = lineptr;
  HIDWORD(v156) = 0x7FFFFFFF - (v10 >> 31);
  do
  {
    v14 = v13 + 1;
    for ( i = v13; *i == 32 || *i == 9; ++i )
      ++v14;
    v133 = *i;
    v16 = strcspn(i, ";\t\r\n=");
    if ( !v16 )
    {
      v13 = i;
      goto LABEL_120;
    }
    v13 = &i[v16];
    v17 = v16;
    while ( 1 )
    {
      v18 = i[v17 - 1];
      if ( v18 != 32 && v18 != 9 )
        break;
      if ( !--v17 )
      {
        v17 = 0;
        break;
      }
    }
    if ( *v13 == 61 )
    {
      s = &i[v16 + 1];
      v148 = v16;
      v19 = strcspn(s, ";\r\n");
      v20 = v19 + v148;
      v149 = v19 + v148;
      if ( v19 )
      {
        v21 = s;
        v22 = &v14[v20];
        while ( 1 )
        {
          v23 = *(v22 - 1);
          if ( v23 != 32 && v23 != 9 )
            break;
          --v19;
          --v22;
          if ( !v19 )
            goto LABEL_30;
        }
        while ( *v21 == 32 || *v21 == 9 )
        {
          ++v21;
          if ( !--v19 )
          {
            v21 = v22;
            goto LABEL_30;
          }
        }
      }
      else
      {
        v21 = s;
LABEL_30:
        v19 = 0;
      }
      n = v19;
      v26 = v21;
      if ( memchr(v21, 9, v19) )
      {
        freecookie(v132);
        v9 = 0;
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "cookie contains TAB, dropping", v130, v131);
        return v9;
      }
      v25 = v26;
      v24 = n;
      v13 = &i[v149 + 1];
      v150 = 1;
    }
    else
    {
      v24 = 0;
      v25 = 0;
      v150 = 0;
    }
    if ( v17 > 0xFFE || v24 > 0xFFE || v24 + v17 >= 0x1001 )
    {
      freecookie(v132);
      v9 = 0;
      if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
        Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes", v17, v24);
      return v9;
    }
    v73 = v133 == 95;
    v134 = v13;
    if ( v73 && v17 >= 7 && i[1] == 95 )
    {
      sa = v25;
      if ( curl_strnequal("__Secure-", i, 9) )
      {
        *(_BYTE *)(v138 + 40) |= 1u;
        v13 = v134;
        v25 = sa;
      }
      else
      {
        v27 = curl_strnequal("__Host-", i, 7);
        v13 = v134;
        v25 = sa;
        if ( v27 )
          *(_BYTE *)(v138 + 40) |= 2u;
      }
    }
    if ( !*(_DWORD *)(v138 + 4) )
    {
      if ( !v150 )
        goto LABEL_264;
      sc = v25;
      Curl_cfree(0);
      v30 = Curl_memdup(i, v17 + 1);
      *(_DWORD *)(v138 + 4) = v30;
      if ( v30 )
        *(_BYTE *)(v30 + v17) = 0;
      Curl_cfree(*(_DWORD *)(v138 + 8));
      v31 = Curl_memdup(sc, v24 + 1);
      *(_DWORD *)(v138 + 8) = v31;
      if ( v31 )
        *(_BYTE *)(v31 + v24) = 0;
      v32 = *(const char **)(v138 + 4);
      if ( !v32 )
        goto LABEL_264;
      v33 = *(const char **)(v138 + 8);
      if ( !v33 )
        goto LABEL_264;
      if ( v33[strcspn(v33, invalid_octets_badoctets)]
        || (v34 = strcspn(v32, invalid_octets_badoctets), v13 = v134, v32[v34]) )
      {
        if ( (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
          Curl_infof(data, "invalid octets in name/value, cookie dropped", v130, v131);
        goto LABEL_264;
      }
      goto LABEL_120;
    }
    if ( !v24 )
    {
      if ( v17 == 8 )
      {
        v48 = v25;
        v49 = curl_strnequal("httponly", i, 8);
        v25 = v48;
        v24 = 0;
        v13 = v134;
        if ( v49 )
        {
          *(_BYTE *)(v138 + 35) = 1;
          goto LABEL_120;
        }
      }
      else if ( v17 == 6 )
      {
        v35 = v25;
        v36 = curl_strnequal("secure", i, 6);
        v25 = v35;
        v24 = 0;
        v13 = v134;
        if ( v36 )
        {
          if ( !secure && c->running )
            goto LABEL_264;
          *(_BYTE *)(v138 + 33) = 1;
          goto LABEL_120;
        }
      }
      if ( !v150 )
        goto LABEL_120;
    }
    if ( v17 != 7 )
    {
      if ( v17 != 6 )
      {
        if ( v17 != 4 )
          goto LABEL_120;
        sb = v25;
        if ( !curl_strnequal("path", i, 4) )
          goto LABEL_119;
        Curl_cfree(*(_DWORD *)(v138 + 12));
        v28 = Curl_memdup(sb, v24 + 1);
        *(_DWORD *)(v138 + 12) = v28;
        if ( !v28 )
          goto LABEL_264;
        *(_BYTE *)(v28 + v24) = 0;
        if ( !*(_DWORD *)(v138 + 12) )
          goto LABEL_264;
        Curl_cfree(*(_DWORD *)(v138 + 16));
        v29 = sanitize_cookie_path(*(const char **)(v138 + 12));
        v13 = v134;
        *(_DWORD *)(v138 + 16) = v29;
        if ( !v29 )
          goto LABEL_264;
        goto LABEL_120;
      }
      v40 = v25;
      v41 = curl_strnequal("domain", i, 6);
      if ( !v24 || !v41 )
        goto LABEL_119;
      v42 = v40 + 1;
      if ( *v40 != 46 )
        v42 = v40;
      v43 = v24 - (*v40 == 46);
      v44 = v42;
      na = v43;
      if ( v43 == 9 && curl_strnequal(v42, "localhost", 9)
        || (v45 = memchr(v44, 46, v43)) != 0 && (unsigned int)(&v44[v43] - v45) > 1 )
      {
        v46 = domain;
        v50 = v44;
        if ( domain )
          v50 = domain;
        is_ipnum = Curl_host_is_ipnum(v50);
        v47 = data;
        v52 = is_ipnum;
        if ( !domain )
        {
          v46 = 0;
LABEL_106:
          sd = v52;
          domain = v46;
          Curl_cfree(*(_DWORD *)(v138 + 20));
          v55 = Curl_memdup(v44, na + 1);
          *(_DWORD *)(v138 + 20) = v55;
          if ( !v55 )
            goto LABEL_264;
          *(_BYTE *)(v55 + na) = 0;
          v56 = v152;
          v57 = *(_DWORD *)(v138 + 20);
          if ( !v57 )
            v56 = 1;
          if ( !((v57 == 0) | (unsigned __int8)sd) )
          {
            *(_BYTE *)(v138 + 32) = 1;
            goto LABEL_119;
          }
          v152 = v56;
          v13 = v134;
          if ( !v57 )
            break;
          goto LABEL_120;
        }
        if ( is_ipnum )
          goto LABEL_86;
      }
      else
      {
        v46 = ":";
        v47 = data;
        if ( (unsigned __int8)Curl_host_is_ipnum(":") )
        {
LABEL_86:
          if ( strncmp(v44, v46, na) || (v54 = strlen(v46), v52 = 1, na != v54) )
          {
LABEL_112:
            domain = v46;
            v152 = 1;
            if ( (*((_BYTE *)&v47->set + 1326) & 0x10) != 0 )
              Curl_infof(v47, "skipped cookie with bad tailmatch domain: %s", v44, v131);
            goto LABEL_119;
          }
          goto LABEL_106;
        }
      }
      if ( !cookie_tailmatch(v46, v129, v130) )
        goto LABEL_112;
      v52 = 0;
      goto LABEL_106;
    }
    v37 = v25;
    if ( curl_strnequal("version", i, 7) )
      goto LABEL_119;
    if ( curl_strnequal("max-age", i, 7) )
    {
      v38 = v37 + 1;
      if ( *v37 != 34 )
        v38 = v37;
      v39 = curlx_strtoofft(v38, 0, 10, v154);
      if ( !v39 )
      {
        v58 = *v154;
        v59 = v154[1];
        if ( *(_QWORD *)v154 )
        {
          if ( v156 >= __SPAIR64__(v59, v58) )
          {
            *(_QWORD *)v154 = v155 + __PAIR64__(v59, v58);
          }
          else
          {
            v154[1] = 0x7FFFFFFF;
            *v154 = -1;
          }
        }
        else
        {
LABEL_118:
          v154[1] = 0;
          *v154 = 1;
        }
LABEL_119:
        v13 = v134;
        goto LABEL_120;
      }
      if ( v39 == 2 )
        goto LABEL_118;
      v13 = v134;
      if ( v39 == 1 )
      {
        v154[1] = 0x7FFFFFFF;
        *v154 = -1;
      }
    }
    else
    {
      if ( !curl_strnequal("expires", i, 7) )
        goto LABEL_119;
      v13 = v134;
      if ( v24 > 0x7F || *(_QWORD *)v154 )
        goto LABEL_120;
      memcpy(dest, v37, v24);
      *((_BYTE *)dest + v24) = 0;
      v53 = Curl_getdate_capped(dest);
      *(_QWORD *)v154 = v53;
      if ( !v53 )
      {
        v154[1] = 0;
        *v154 = 1;
        goto LABEL_119;
      }
      v13 = v134;
      if ( v53 < 0 )
      {
        v154[1] = 0;
        *v154 = 0;
      }
    }
    do
    {
      do
LABEL_120:
        v60 = *v13++;
      while ( v60 == 32 );
    }
    while ( v60 == 9 );
  }
  while ( v60 == 59 );
  v90 = v152;
  if ( (v152 & 1) != 0 )
  {
    v91 = v138;
  }
  else
  {
    v91 = v138;
    if ( domain )
    {
      if ( !*(_DWORD *)(v138 + 20) )
      {
        v92 = Curl_cstrdup(domain);
        *(_DWORD *)(v138 + 20) = v92;
        v73 = v92 == 0;
        v90 = v152;
        if ( v73 )
          v90 = 1;
      }
    }
  }
  if ( (v90 & 1) == 0 && path && !*(_DWORD *)(v91 + 12) )
  {
    v93 = v90;
    v94 = strchr(path, 63);
    if ( v94 )
      v95 = (char *)Curl_memrchr(path, 47, v94 - path);
    else
      v95 = strrchr(path, 47);
    if ( v95 )
    {
      v96 = v95 - path;
      v97 = (void *)Curl_cmalloc(v95 - path + 2);
      *(_DWORD *)(v138 + 12) = v97;
      if ( !v97 )
        goto LABEL_264;
      v98 = v96 + 1;
      memcpy(v97, path, v98);
      *(_BYTE *)(*(_DWORD *)(v138 + 12) + v98) = 0;
      v99 = sanitize_cookie_path(*(const char **)(v138 + 12));
      *(_DWORD *)(v138 + 16) = v99;
      v73 = v99 == 0;
      v90 = v93;
      if ( v73 )
        v90 = 1;
    }
    else
    {
      v90 = v93;
    }
  }
  if ( (v90 & 1) != 0 || !*(_DWORD *)(v138 + 4) )
  {
LABEL_264:
    freecookie(v132);
    return 0;
  }
  v89 = data;
  v9 = 0;
  ++data->req.setcookies;
LABEL_214:
  v100 = *(_BYTE *)(v138 + 40);
  if ( (v100 & 1) != 0 && !*(_BYTE *)(v138 + 33) )
    goto LABEL_274;
  if ( (v100 & 2) != 0 )
  {
    if ( !*(_BYTE *)(v138 + 33) )
      goto LABEL_274;
    v119 = *(const char **)(v138 + 12);
    if ( !v119 || strcmp(v119, "/") || *(_BYTE *)(v138 + 32) )
      goto LABEL_274;
  }
  running = c->running;
  if ( !running && c->newsession && !*(_QWORD *)(v138 + 24) )
    goto LABEL_274;
  *(_BYTE *)(v138 + 34) = running;
  v102 = c->lastct + 1;
  c->lastct = v102;
  *(_DWORD *)(v138 + 36) = v102;
  if ( !noexpire )
    remove_expired((CookieInfo *)v132);
  v103 = (Cookie *)v138;
  nb = cookiehash(*(const char *const *)(v138 + 20));
  next = c->cookies[nb];
  if ( next )
  {
    v105 = 0;
    se = 0;
    v137 = 0;
    while ( 1 )
    {
      v106 = next;
      if ( !curl_strequal(next->name, v103->name) )
        goto LABEL_237;
      v107 = v106->domain;
      v108 = *(_DWORD *)(v138 + 20);
      if ( v107 )
      {
        if ( !v108 || !curl_strequal(v107, *(_DWORD *)(v138 + 20)) )
          goto LABEL_237;
      }
      else if ( v108 )
      {
        goto LABEL_237;
      }
      spath = v106->spath;
      if ( spath && *(_DWORD *)(v138 + 16) && v106->secure && !*(_BYTE *)(v138 + 33) && !secure )
      {
        v151 = *(_DWORD *)(v138 + 16);
        v110 = strchr(spath + 1, 47);
        v111 = v110 ? v110 - spath : strlen(spath);
        if ( curl_strnequal(spath, v151, v111) )
        {
          if ( data && (*((_BYTE *)&data->set + 1326) & 0x10) != 0 )
            Curl_infof(
              data,
              "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
              *(_DWORD *)(v138 + 4),
              *(_DWORD *)(v138 + 20));
          goto LABEL_264;
        }
      }
LABEL_237:
      if ( v105 )
      {
        v103 = (Cookie *)v138;
        goto LABEL_239;
      }
      v103 = (Cookie *)v138;
      v105 = 0;
      if ( !curl_strequal(v106->name, *(_DWORD *)(v138 + 4)) )
        goto LABEL_239;
      v112 = v106->domain;
      v113 = *(_DWORD *)(v138 + 20);
      if ( v112 )
      {
        if ( !v113 || !curl_strequal(v112, *(_DWORD *)(v138 + 20)) )
        {
          v115 = v137;
          goto LABEL_250;
        }
        v114 = v106->tailmatch == *(_BYTE *)(v138 + 32);
      }
      else
      {
        v114 = v113 == 0;
      }
      v115 = (unsigned __int8)v137;
      if ( v114 )
        v115 = 1;
LABEL_250:
      v137 = v115;
      if ( (v115 & 1) != 0 )
      {
        v116 = v106->spath;
        v105 = 0;
        v117 = 0;
        if ( !v116 )
          goto LABEL_256;
        if ( !*(_DWORD *)(v138 + 16) )
        {
          v117 = v106->spath;
LABEL_256:
          v118 = (unsigned __int8)v137;
          if ( (v117 == 0) != (*(_DWORD *)(v138 + 16) == 0) )
            v118 = 0;
          v137 = v118;
          if ( (v118 & 1) != 0 )
          {
            if ( *(_BYTE *)(v138 + 34) )
            {
              se = v106;
              v105 = (Cookie **)v138;
            }
            else
            {
              v105 = (Cookie **)v138;
              se = v106;
              if ( v106->livecookie )
                goto LABEL_264;
            }
          }
          goto LABEL_239;
        }
        if ( curl_strequal(v116, *(_DWORD *)(v138 + 16)) )
        {
          v117 = v106->spath;
          goto LABEL_256;
        }
        v137 = 0;
        v105 = 0;
      }
LABEL_239:
      next = v106->next;
      if ( !v106->next )
      {
        if ( v105 )
        {
          *v105 = se->next;
          v105[9] = (Cookie *)se->creationtime;
          Curl_cfree(se->name);
          Curl_cfree(se->value);
          Curl_cfree(se->domain);
          Curl_cfree(se->path);
          Curl_cfree(se->spath);
          qmemcpy(se, v105, sizeof(Cookie));
          Curl_cfree(v105);
        }
        else
        {
          se = v103;
        }
        v89 = data;
        v121 = v137;
        goto LABEL_279;
      }
    }
  }
  v106 = 0;
  v121 = 0;
  se = (Cookie *)v138;
LABEL_279:
  if ( v89 )
  {
    v122 = v121;
    if ( c->running && (*((_BYTE *)&v89->set + 1326) & 0x10) != 0 )
    {
      v123 = "Replaced";
      if ( (v121 & 1) == 0 )
        v123 = "Added";
      Curl_infof(v89, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld", v123, se->name);
      v121 = v122;
    }
  }
  if ( (v121 & 1) == 0 )
  {
    p_next = &c->cookies[nb];
    if ( v106 )
      p_next = &v106->next;
    *p_next = se;
    ++c->numcookies;
  }
  v9 = se;
  LODWORD(v125) = se->expires;
  expires_high = HIDWORD(se->expires);
  if ( se->expires )
  {
    HIDWORD(v125) = HIDWORD(se->expires);
    if ( v125 < c->next_expiration )
    {
      LODWORD(c->next_expiration) = v125;
      HIDWORD(c->next_expiration) = expires_high;
    }
  }
  return v9;
}
