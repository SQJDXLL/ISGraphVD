Cookie *__cdecl Curl_cookie_add(
        Curl_easy *data,
        CookieInfo *c,
        bool httpheader,
        bool noexpire,
        const char *lineptr,
        const char *domain,
        const char *path,
        bool secure)
{
  char *v8; // edi
  char v9; // dl
  __int64 expires; // rax
  unsigned int v11; // esi
  char *v12; // ebp
  char *v13; // eax
  int v14; // ecx
  char v15; // bl
  bool v16; // cl
  bool v17; // al
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  int v21; // esi
  char *v22; // eax
  char *v23; // eax
  char *v24; // esi
  int v25; // eax
  int (__cdecl *v26)(const char *); // edi
  const char *v27; // eax
  char *v28; // eax
  char *v29; // edi
  int v30; // edi
  int v31; // eax
  bool v32; // si
  char *v33; // eax
  int v34; // esi
  char *v35; // eax
  int v36; // eax
  char *v37; // eax
  int v38; // esi
  Cookie *v39; // ebp
  size_t v41; // ecx
  unsigned __int8 prefix; // al
  char *v43; // eax
  bool running; // al
  Cookie *v45; // esi
  Cookie *v46; // edi
  Cookie *next; // eax
  char *v48; // eax
  char *v49; // edx
  char *spath; // edx
  char *v51; // eax
  char *v52; // edx
  unsigned int expires_high; // eax
  unsigned int v54; // ecx
  _BYTE *v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  char *v59; // edx
  const char *v60; // eax
  const char *name; // edi
  int v62; // eax
  char *v63; // eax
  int v64; // eax
  int v65; // eax
  char is_ipnum; // si
  int v67; // eax
  char *v68; // eax
  int v69; // eax
  char *v70; // eax
  const char *v71; // edx
  void *v72; // ecx
  size_t v73; // eax
  int v74; // ecx
  int v75; // eax
  char *v76; // eax
  char *v77; // eax
  int v78; // esi
  size_t v79; // ebx
  char *v80; // eax
  char *v81; // eax
  int v82; // eax
  char vlen; // [esp+14h] [ebp-E8h]
  char vlene; // [esp+14h] [ebp-E8h]
  size_t vlena; // [esp+14h] [ebp-E8h]
  size_t vlenb; // [esp+14h] [ebp-E8h]
  int vlenf; // [esp+14h] [ebp-E8h]
  char vlenc; // [esp+14h] [ebp-E8h]
  bool vlend; // [esp+14h] [ebp-E8h]
  Cookie *co; // [esp+18h] [ebp-E4h]
  const char *maxage; // [esp+1Ch] [ebp-E0h]
  bool maxagea; // [esp+1Ch] [ebp-E0h]
  const char *maxageb; // [esp+1Ch] [ebp-E0h]
  const char *maxagec; // [esp+1Ch] [ebp-E0h]
  Cookie *replace_clist; // [esp+20h] [ebp-DCh]
  bool myhash; // [esp+24h] [ebp-D8h]
  size_t myhasha; // [esp+24h] [ebp-D8h]
  char sd; // [esp+28h] [ebp-D4h]
  char *s; // [esp+28h] [ebp-D4h]
  char sa; // [esp+28h] [ebp-D4h]
  bool sb; // [esp+28h] [ebp-D4h]
  char *sc; // [esp+28h] [ebp-D4h]
  char *se; // [esp+28h] [ebp-D4h]
  time_t now; // [esp+44h] [ebp-B8h]
  bool badcookie; // [esp+4Fh] [ebp-ADh]
  char *tok_buf; // [esp+58h] [ebp-A4h] BYREF
  char date[128]; // [esp+5Ch] [ebp-A0h] BYREF
  unsigned int v109; // [esp+DCh] [ebp-20h]

  v8 = (char *)lineptr;
  v109 = __readgsdword(0x14u);
  now = time(0);
  if ( data->req.setcookies > 0x31u )
    return 0;
  co = (Cookie *)Curl_ccalloc(1, 44);
  if ( !co )
    return 0;
  if ( httpheader )
  {
    badcookie = 0;
    if ( strlen(lineptr) <= 0x1388 )
    {
      while ( 1 )
      {
        v9 = *v8;
        if ( !*v8 )
          goto LABEL_15;
        while ( v9 != 32 )
        {
          vlen = v9;
          if ( v9 == 9 )
            break;
          LODWORD(expires) = strcspn(v8, ";\t\r\n=");
          BYTE4(expires) = vlen;
          v11 = expires;
          if ( !(_DWORD)expires )
          {
            v12 = v8;
            goto LABEL_11;
          }
          while ( 2 )
          {
            vlena = (size_t)&v8[v11];
            while ( 1 )
            {
              if ( !v11 )
              {
                v13 = (char *)vlena;
                if ( *(_BYTE *)vlena == 61 )
                  goto LABEL_21;
                vlenb = 0;
                v12 = v13;
                v16 = 0;
                maxage = 0;
LABEL_129:
                if ( !co->name )
                {
LABEL_162:
                  if ( v16 )
                  {
                    Curl_cfree(0);
                    co->name = (char *)Curl_strndup(v8, v11);
                    Curl_cfree(co->value);
                    v60 = (const char *)Curl_strndup(maxage, vlenb);
                    co->value = (char *)v60;
                    name = co->name;
                    if ( name )
                    {
                      if ( v60 )
                      {
                        if ( !v60[strcspn(v60, badoctets_0)] && !name[strcspn(name, badoctets_0)] )
                          goto LABEL_75;
                        if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                          Curl_infof(data, "invalid octets in name/value, cookie dropped");
                      }
                    }
                  }
                  goto LABEL_55;
                }
                if ( !vlenb )
                {
                  if ( v11 == 6 )
                  {
                    vlend = v16;
                    if ( !curl_strnequal("secure", v8, 6) )
                    {
                      if ( vlend )
                        curl_strnequal("domain", v8, 6);
                      goto LABEL_75;
                    }
                    if ( secure || !c->running )
                    {
                      co->secure = 1;
                      BYTE4(expires) = *v12;
                      goto LABEL_76;
                    }
                    goto LABEL_55;
                  }
                  if ( !v16 || v11 != 4 )
                    goto LABEL_75;
LABEL_171:
                  if ( !curl_strnequal("path", v8, 4) )
                    goto LABEL_75;
                  Curl_cfree(co->path);
                  v62 = Curl_strndup(maxage, vlenb);
                  co->path = (char *)v62;
                  if ( v62 )
                  {
                    Curl_cfree(co->spath);
                    v63 = sanitize_cookie_path(co->path);
                    co->spath = v63;
                    if ( v63 )
                      goto LABEL_75;
                  }
                  goto LABEL_55;
                }
                if ( v11 == 4 )
                  goto LABEL_171;
                if ( v11 != 6 || !curl_strnequal("domain", v8, 6) )
                  goto LABEL_75;
                if ( *maxage == 46 )
                {
                  ++maxage;
                  --vlenb;
                }
                if ( vlenb == 9 && curl_strnequal(maxage, "localhost", 9)
                  || (v55 = memchr(maxage, 46, vlenb)) != 0 && vlenb - (v55 - maxage) > 1 )
                {
                  if ( !domain )
                  {
                    is_ipnum = Curl_host_is_ipnum(maxage);
                    Curl_cfree(co->domain);
                    v67 = Curl_strndup(maxage, vlenb);
                    co->domain = (char *)v67;
                    if ( !v67 )
                      goto LABEL_55;
                    if ( is_ipnum )
                      goto LABEL_75;
LABEL_155:
                    co->tailmatch = 1;
                    goto LABEL_75;
                  }
                  if ( !(unsigned __int8)Curl_host_is_ipnum(domain) )
                    goto LABEL_153;
LABEL_146:
                  if ( !strncmp(maxage, domain, vlenb) && strlen(domain) == vlenb )
                  {
                    Curl_cfree(co->domain);
                    v56 = Curl_strndup(maxage, vlenb);
                    co->domain = (char *)v56;
                    if ( v56 )
                      goto LABEL_75;
                    goto LABEL_55;
                  }
                }
                else
                {
                  domain = ":";
                  if ( (unsigned __int8)Curl_host_is_ipnum(":") )
                    goto LABEL_146;
LABEL_153:
                  if ( cookie_tailmatch(maxage, vlenb, domain) )
                  {
                    Curl_cfree(co->domain);
                    v57 = Curl_strndup(maxage, vlenb);
                    co->domain = (char *)v57;
                    if ( !v57 )
                      goto LABEL_55;
                    goto LABEL_155;
                  }
                }
                if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                  Curl_infof(data, "skipped cookie with bad tailmatch domain: %s");
                BYTE4(expires) = *v12;
                badcookie = httpheader;
                goto LABEL_76;
              }
              if ( v8[v11 - 1] != 9 && v8[v11 - 1] != 32 )
                break;
              --v11;
            }
            v16 = 0;
            if ( *(_BYTE *)vlena != 61 )
            {
              v12 = (char *)vlena;
              maxage = 0;
              v17 = 0;
              vlenb = 0;
              goto LABEL_65;
            }
LABEL_21:
            sd = BYTE4(expires);
            maxage = (const char *)(vlena + 1);
            LODWORD(expires) = strcspn((const char *)(vlena + 1), ";\r\n");
            BYTE4(expires) = sd;
            s = (char *)(vlena + 1 + expires);
            if ( !(_DWORD)expires )
            {
LABEL_25:
              v12 = s;
              v16 = httpheader;
              vlenb = expires;
              v17 = 0;
              goto LABEL_65;
            }
            while ( 1 )
            {
              v14 = expires - 1;
              v15 = *(_BYTE *)(vlena + expires);
              if ( v15 != 32 && v15 != 9 )
                break;
              LODWORD(expires) = expires - 1;
              if ( !v14 )
                goto LABEL_25;
            }
            v41 = expires;
            v12 = s;
            LODWORD(expires) = vlena + 1;
            do
            {
              if ( *(_BYTE *)expires != 32 && *(_BYTE *)expires != 9 )
              {
                sa = BYTE4(expires);
                vlenb = v41;
                maxage = (const char *)expires;
                if ( !memchr((const void *)expires, 9, v41) )
                {
                  BYTE4(expires) = sa;
                  goto LABEL_64;
                }
                freecookie(co);
                if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                  Curl_infof(data, "cookie contains TAB, dropping");
                return 0;
              }
              LODWORD(expires) = expires + 1;
              --v41;
            }
            while ( v41 );
            vlenb = 0;
            maxage = (const char *)expires;
LABEL_64:
            v16 = httpheader;
            v17 = vlenb > 0xFFE;
LABEL_65:
            if ( v11 > 0xFFE || v17 || v11 + vlenb > 0x1000 )
            {
              freecookie(co);
              if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
                Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes");
              return 0;
            }
            if ( v11 <= 6 )
              goto LABEL_129;
            if ( BYTE4(expires) != 95 || v8[1] != 95 )
            {
              if ( co->name )
                goto LABEL_71;
              goto LABEL_162;
            }
            sb = v16;
            v58 = curl_strnequal("__Secure-", v8, 9);
            v16 = sb;
            if ( v58 )
            {
              v59 = co->name;
              co->prefix |= 1u;
              if ( !v59 )
                goto LABEL_162;
            }
            else
            {
              v75 = curl_strnequal("__Host-", v8, 7);
              v16 = sb;
              if ( v75 )
              {
                co->prefix |= 2u;
                if ( !co->name )
                  goto LABEL_162;
              }
              else if ( !co->name )
              {
                goto LABEL_162;
              }
            }
LABEL_71:
            if ( vlenb )
            {
LABEL_74:
              if ( v11 != 7 || curl_strnequal("version", v8, 7) )
                goto LABEL_75;
              if ( !curl_strnequal("max-age", v8, 7) )
              {
                if ( curl_strnequal("expires", v8, 7) && !co->expires && vlenb <= 0x7F )
                {
                  if ( vlenb >= 4 )
                  {
                    *(_DWORD *)&date[vlenb - 4] = *(_DWORD *)&maxage[vlenb - 4];
                    qmemcpy(date, maxage, 4 * ((vlenb - 1) >> 2));
                  }
                  else if ( vlenb )
                  {
                    date[0] = *maxage;
                    if ( (vlenb & 2) != 0 )
                      *(_WORD *)&date[vlenb - 2] = *(_WORD *)&maxage[vlenb - 2];
                  }
                  date[vlenb] = 0;
                  v74 = Curl_getdate_capped(date);
                  if ( v74 )
                  {
                    if ( v74 >> 31 == -1 )
                    {
                      LODWORD(co->expires) = 0;
                      HIDWORD(co->expires) = 0;
                    }
                    else
                    {
                      co->expires = v74;
                    }
                  }
                  else
                  {
                    LODWORD(co->expires) = 1;
                    HIDWORD(co->expires) = 0;
                  }
                }
                goto LABEL_75;
              }
              v64 = curlx_strtoofft(&maxage[*maxage == 34], 0, 10);
              if ( v64 == 1 )
                goto LABEL_231;
              if ( v64 == 2 )
              {
                LODWORD(co->expires) = 1;
                HIDWORD(co->expires) = 0;
                BYTE4(expires) = *v12;
                goto LABEL_76;
              }
              if ( v64 )
                goto LABEL_75;
              expires = co->expires;
              if ( !expires )
              {
                LODWORD(co->expires) = 1;
                HIDWORD(co->expires) = 0;
                HIDWORD(expires) = (unsigned __int8)*v12;
                goto LABEL_76;
              }
              if ( 0x7FFFFFFFFFFFFFFFLL - now < expires )
              {
LABEL_231:
                LODWORD(co->expires) = -1;
                HIDWORD(co->expires) = 0x7FFFFFFF;
                BYTE4(expires) = *v12;
              }
              else
              {
                co->expires = now + expires;
                BYTE4(expires) = *v12;
              }
            }
            else if ( v11 == 8 )
            {
              if ( !curl_strnequal("httponly", v8, 8) )
                goto LABEL_75;
              co->httponly = 1;
              BYTE4(expires) = *v12;
            }
            else
            {
              if ( v16 )
                goto LABEL_74;
LABEL_75:
              BYTE4(expires) = *v12;
            }
LABEL_76:
            if ( !BYTE4(expires) )
            {
LABEL_77:
              if ( !badcookie )
              {
                if ( co->domain || !domain || (v82 = Curl_cstrdup(domain), (co->domain = (char *)v82) != 0) )
                {
                  if ( co->path || !path )
                    goto LABEL_280;
                  v76 = strchr(path, 63);
                  v77 = v76 ? (char *)Curl_memrchr(path, 47, v76 - path) : strrchr(path, 47);
                  if ( !v77 )
                    goto LABEL_280;
                  v78 = v77 - path;
                  v79 = v77 - path + 1;
                  v80 = (char *)Curl_cmalloc(v77 - path + 2);
                  co->path = v80;
                  if ( v80 )
                  {
                    memcpy(v80, path, v79);
                    co->path[v78 + 1] = 0;
                    v81 = sanitize_cookie_path(co->path);
                    co->spath = v81;
                    if ( v81 )
                    {
LABEL_280:
                      if ( co->name )
                      {
                        ++data->req.setcookies;
                        goto LABEL_84;
                      }
                    }
                  }
                }
              }
LABEL_55:
              freecookie(co);
              return 0;
            }
LABEL_11:
            while ( BYTE4(expires) == 32 || BYTE4(expires) == 9 )
            {
              BYTE4(expires) = *++v12;
              if ( !BYTE4(expires) )
                goto LABEL_77;
            }
            if ( BYTE4(expires) != 59 )
              goto LABEL_77;
            v9 = v12[1];
            v8 = v12 + 1;
            if ( !v9 )
            {
LABEL_15:
              vlene = v9;
              LODWORD(expires) = strcspn(v8, ";\t\r\n=");
              BYTE4(expires) = vlene;
              v11 = expires;
              if ( !(_DWORD)expires )
                goto LABEL_77;
              continue;
            }
            break;
          }
        }
        ++v8;
      }
    }
LABEL_214:
    Curl_cfree(co);
    return 0;
  }
  tok_buf = 0;
  if ( !strncmp(lineptr, "#HttpOnly_", 0xAu) )
  {
    v8 = (char *)(lineptr + 10);
    co->httponly = 1;
  }
  if ( *v8 == 35 )
    goto LABEL_214;
  v18 = strchr(v8, 13);
  if ( v18 )
    *v18 = 0;
  v19 = strchr(v8, 10);
  if ( v19 )
    *v19 = 0;
  v20 = strtok_r(v8, "\t", &tok_buf);
  if ( !v20 )
    goto LABEL_55;
  v21 = Curl_cstrdup(&v20[*v20 == 46]);
  co->domain = (char *)v21;
  v22 = strtok_r(0, "\t", &tok_buf);
  maxagea = v22 != 0 && v21 != 0;
  if ( !maxagea )
  {
    maxagea = v21 != 0;
    v65 = 1;
    myhash = v21 == 0;
    goto LABEL_268;
  }
  co->tailmatch = curl_strequal(v22, "TRUE") != 0;
  v23 = strtok_r(0, "\t", &tok_buf);
  v24 = v23;
  if ( !v23 )
  {
    myhash = httpheader;
    v65 = 2;
    goto LABEL_268;
  }
  v25 = strcmp("TRUE", v23);
  v26 = (int (__cdecl *)(const char *))Curl_cstrdup;
  if ( !v25 || !strcmp("FALSE", v24) )
  {
    v30 = v26("/");
    co->path = (char *)v30;
    v31 = Curl_cstrdup("/");
    co->spath = (char *)v31;
    if ( !v31 )
    {
      co->secure = 0;
      if ( !curl_strequal(v24, "TRUE") )
        goto LABEL_194;
      goto LABEL_187;
    }
    maxagea = v30 == 0;
  }
  else
  {
    v27 = (const char *)v26(v24);
    co->path = (char *)v27;
    if ( !v27 )
      goto LABEL_194;
    v28 = sanitize_cookie_path(v27);
    co->spath = v28;
    v29 = v28;
    maxagea = v28 != 0;
    v24 = strtok_r(0, "\t", &tok_buf);
    if ( !v24 || !maxagea )
    {
      v65 = 3;
      myhash = v29 == 0;
      goto LABEL_268;
    }
    maxagea = httpheader;
  }
  co->secure = 0;
  if ( curl_strequal(v24, "TRUE") )
  {
LABEL_187:
    if ( secure || c->running )
    {
      co->secure = 1;
      v32 = !maxagea;
      v33 = strtok_r(0, "\t", &tok_buf);
      if ( !v33 )
        goto LABEL_190;
      goto LABEL_46;
    }
LABEL_194:
    strtok_r(0, "\t", &tok_buf);
    freecookie(co);
    return 0;
  }
  v32 = !maxagea;
  v33 = strtok_r(0, "\t", &tok_buf);
  if ( !v33 )
  {
LABEL_190:
    myhash = maxagea;
    maxagea = v32;
    v65 = 4;
    goto LABEL_268;
  }
LABEL_46:
  if ( !v32 )
    goto LABEL_190;
  v34 = curlx_strtoofft(v33, 0, 10);
  maxagea = v34 == 0;
  v35 = strtok_r(0, "\t", &tok_buf);
  myhash = v34 == 0 && v35 != 0;
  if ( !myhash )
  {
    v65 = 5;
    myhash = v34 != 0;
    goto LABEL_268;
  }
  v36 = Curl_cstrdup(v35);
  co->name = (char *)v36;
  if ( !v36 )
  {
    strtok_r(0, "\t", &tok_buf);
    goto LABEL_216;
  }
  if ( curl_strnequal("__Secure-", v36, 9) )
  {
    co->prefix |= 1u;
  }
  else if ( curl_strnequal("__Host-", co->name, 7) )
  {
    co->prefix |= 2u;
  }
  v37 = strtok_r(0, "\t", &tok_buf);
  if ( !v37 )
  {
    myhash = httpheader;
LABEL_216:
    v69 = Curl_cstrdup(&LC0);
    co->value = (char *)v69;
    if ( !v69 )
      goto LABEL_55;
    goto LABEL_217;
  }
  v38 = Curl_cstrdup(v37);
  maxagea = v38 != 0;
  co->value = (char *)v38;
  if ( strtok_r(0, "\t", &tok_buf) && v38 )
  {
    while ( strtok_r(0, "\t", &tok_buf) )
      ;
    goto LABEL_55;
  }
  v65 = 7;
  myhash = v38 == 0;
LABEL_268:
  if ( v65 != 7 && maxagea )
    goto LABEL_55;
LABEL_217:
  if ( myhash )
    goto LABEL_55;
LABEL_84:
  prefix = co->prefix;
  if ( (prefix & 1) != 0 )
  {
    if ( !co->secure )
      goto LABEL_55;
    if ( (prefix & 2) != 0 )
    {
LABEL_87:
      v43 = co->path;
      if ( !v43 || *v43 != 47 || v43[1] || co->tailmatch )
        goto LABEL_55;
    }
  }
  else if ( (prefix & 2) != 0 )
  {
    if ( !co->secure )
      goto LABEL_55;
    goto LABEL_87;
  }
  running = c->running;
  if ( !running && c->newsession && !co->expires )
    goto LABEL_55;
  co->livecookie = running;
  vlenf = c->lastct;
  c->lastct = vlenf + 1;
  co->creationtime = vlenf + 1;
  if ( !noexpire )
    remove_expired(c);
  myhasha = cookiehash(co->domain);
  v45 = c->cookies[myhasha];
  if ( !v45 )
  {
    if ( c->running && (*(&data->set.connect_only + 4) & 0x20) != 0 )
    {
      v39 = co;
      vlenc = 0;
LABEL_121:
      Curl_infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, expire %lld");
      if ( vlenc )
        goto LABEL_122;
      if ( v45 )
        goto LABEL_207;
    }
    else
    {
      v39 = co;
    }
    c->cookies[myhasha] = v39;
    goto LABEL_208;
  }
  vlenc = 0;
  v46 = 0;
  replace_clist = 0;
  while ( 1 )
  {
    if ( !curl_strequal(v45->name, co->name) )
      goto LABEL_109;
    v48 = v45->domain;
    v49 = co->domain;
    if ( v48 )
    {
      if ( !v49 || !curl_strequal(v48, co->domain) )
        goto LABEL_109;
    }
    else if ( v49 )
    {
      goto LABEL_109;
    }
    spath = v45->spath;
    if ( spath )
    {
      maxageb = co->spath;
      if ( maxageb )
      {
        if ( v45->secure && !co->secure && !secure )
        {
          sc = v45->spath;
          v70 = strchr(spath + 1, 47);
          v71 = sc;
          v72 = (void *)maxageb;
          if ( v70 )
          {
            v73 = v70 - sc;
          }
          else
          {
            se = (char *)maxageb;
            maxagec = v71;
            v73 = strlen(v71);
            v72 = se;
            v71 = maxagec;
          }
          if ( curl_strnequal(v71, v72, v73) )
          {
            if ( (*(&data->set.connect_only + 4) & 0x20) != 0 )
              Curl_infof(data, "cookie '%s' for domain '%s' dropped, would overlay an existing cookie");
            goto LABEL_55;
          }
        }
      }
    }
LABEL_109:
    if ( v46 || !curl_strequal(v45->name, co->name) )
      goto LABEL_98;
    v51 = v45->domain;
    v52 = co->domain;
    if ( v51 )
    {
      if ( v52 && curl_strequal(v51, co->domain) && v45->tailmatch == co->tailmatch )
        goto LABEL_198;
    }
    else if ( !v52 )
    {
      goto LABEL_198;
    }
    if ( !vlenc )
      goto LABEL_116;
LABEL_198:
    v68 = v45->spath;
    if ( v68 )
      break;
LABEL_202:
    if ( (v68 == 0) != (co->spath == 0) )
      goto LABEL_116;
    vlenc = co->livecookie;
    if ( vlenc )
    {
      replace_clist = v45;
      v46 = co;
    }
    else
    {
      if ( v45->livecookie )
        goto LABEL_55;
      replace_clist = v45;
      v46 = co;
      vlenc = 1;
    }
LABEL_98:
    next = v45->next;
    if ( !v45->next )
      goto LABEL_117;
LABEL_99:
    v45 = next;
  }
  if ( co->spath && curl_strequal(v68, co->spath) )
  {
    v68 = v45->spath;
    goto LABEL_202;
  }
LABEL_116:
  next = v45->next;
  vlenc = 0;
  if ( v45->next )
    goto LABEL_99;
LABEL_117:
  v39 = replace_clist;
  if ( v46 )
  {
    v46->next = replace_clist->next;
    v46->creationtime = replace_clist->creationtime;
    Curl_cfree(replace_clist->name);
    Curl_cfree(replace_clist->value);
    Curl_cfree(replace_clist->domain);
    Curl_cfree(replace_clist->path);
    Curl_cfree(replace_clist->spath);
    replace_clist->next = v46->next;
    replace_clist->name = v46->name;
    replace_clist->value = v46->value;
    replace_clist->path = v46->path;
    replace_clist->spath = v46->spath;
    replace_clist->domain = v46->domain;
    LODWORD(replace_clist->expires) = v46->expires;
    HIDWORD(replace_clist->expires) = HIDWORD(v46->expires);
    *(_DWORD *)&replace_clist->tailmatch = *(_DWORD *)&v46->tailmatch;
    replace_clist->creationtime = v46->creationtime;
    *(_DWORD *)&replace_clist->prefix = *(_DWORD *)&v46->prefix;
    Curl_cfree(v46);
  }
  else
  {
    v39 = co;
  }
  if ( c->running && (*(&data->set.connect_only + 4) & 0x20) != 0 )
    goto LABEL_121;
  if ( vlenc )
    goto LABEL_122;
LABEL_207:
  v45->next = v39;
LABEL_208:
  ++c->numcookies;
LABEL_122:
  expires_high = HIDWORD(v39->expires);
  v54 = v39->expires;
  if ( v39->expires && __SPAIR64__(expires_high, v54) < c->next_expiration )
  {
    LODWORD(c->next_expiration) = v54;
    HIDWORD(c->next_expiration) = expires_high;
  }
  return v39;
}
