int __fastcall receive_query(int *a1, int a2)
{
  int *v2; // $v1
  int v3; // $s4
  int v4; // $s7
  _DWORD *v6; // $a1
  int v7; // $a0
  int v8; // $s5
  int v9; // $a0
  int v10; // $a1
  int v11; // $v1
  ssize_t v12; // $s1
  int result; // $v0
  int v14; // $v1
  int v15; // $v0
  _DWORD *v16; // $s0
  int j; // $v0
  struct cmsghdr *v18; // $v1
  size_t v19; // $s7
  int v20; // $a0
  size_t v21; // $fp
  int v22; // $v0
  int v23; // $v1
  int v24; // $a2
  char *v25; // $a0
  int v26; // $a3
  unsigned __int8 *v27; // $v0
  int v28; // $a0
  int v29; // $a2
  unsigned int v30; // $a3
  unsigned int v31; // $a1
  unsigned int v32; // $a0
  int v33; // $s6
  int v34; // $a1
  int v35; // $v1
  int v36; // $s0
  int v37; // $a3
  int v38; // $a1
  int v39; // $a0
  int i; // $v1
  unsigned __int16 v41; // [sp+30h] [-90h] BYREF
  unsigned __int8 *v42; // [sp+34h] [-8Ch] BYREF
  int v43; // [sp+38h] [-88h] BYREF
  int v44[2]; // [sp+3Ch] [-84h] BYREF
  int v45[2]; // [sp+44h] [-7Ch] BYREF
  __int16 v46; // [sp+4Ch] [-74h] BYREF
  unsigned __int16 v47; // [sp+4Eh] [-72h]
  int v48[3]; // [sp+50h] [-70h] BYREF
  char v49; // [sp+5Ch] [-64h] BYREF
  struct msghdr v50; // [sp+74h] [-4Ch] BYREF
  char v51[32]; // [sp+90h] [-30h] BYREF
  int v52; // [sp+B0h] [-10h]
  __int16 *v53; // [sp+B4h] [-Ch]
  int *v54; // [sp+B8h] [-8h]

  v43 = 0;
  v2 = (int *)dnsmasq_daemon;
  *(_DWORD *)(dnsmasq_daemon + 520) = 0;
  v3 = v2[117];
  v4 = *v2;
  v44[0] = 0;
  if ( (*v2 & 0x2000) != 0 && (v6 = (_DWORD *)a1[4]) != 0 && (v7 = a1[3], v43 = v6[11], v7 == 2) )
  {
    v8 = v6[1];
    v44[0] = v8;
    v52 = v6[4];
  }
  else
  {
    v52 = 0;
    v8 = 0;
  }
  v9 = *a1;
  v10 = *(unsigned __int16 *)(dnsmasq_daemon + 424);
  v11 = *(_DWORD *)(dnsmasq_daemon + 468);
  v53 = &v46;
  v45[1] = v10;
  v45[0] = v11;
  v50.msg_control = &v49;
  v50.msg_controllen = 24;
  v50.msg_namelen = 16;
  v50.msg_name = &v46;
  v50.msg_iov = (struct iovec *)v45;
  v50.msg_iovlen = 1;
  v50.msg_flags = 0;
  v12 = recvmsg(v9, &v50, 0);
  result = -1;
  if ( v12 == -1 )
    return result;
  result = v50.msg_flags;
  if ( v12 < 12 )
    return result;
  result = v50.msg_flags & 0x20;
  if ( (v50.msg_flags & 0x20) != 0 )
    return result;
  result = (int)&dnsmasq_daemon;
  if ( *(char *)(v3 + 2) < 0 )
    return result;
  memset((void *)(*(_DWORD *)(dnsmasq_daemon + 468) + v12), 0, *(unsigned __int16 *)(dnsmasq_daemon + 424) - v12);
  v14 = a1[3];
  v46 = v14;
  if ( v14 == 2 )
  {
    result = v47;
    if ( !v47 )
      return result;
  }
  v15 = v4 & 0x2000;
  if ( ((*(_DWORD *)(dnsmasq_daemon + 4) >> 17) & 1) == 0 )
  {
LABEL_18:
    if ( v15 )
    {
      v21 = 0;
      v54 = v44;
    }
    else
    {
      result = 2;
      if ( v50.msg_controllen < 0xC )
        return result;
      v18 = (struct cmsghdr *)v50.msg_control;
      if ( a1[3] == 2 && (v19 = 0, v50.msg_control) )
      {
        do
        {
          if ( !v18->cmsg_level && v18->cmsg_type == 8 )
          {
            v8 = v18[1].cmsg_level;
            v44[0] = v8;
            v19 = v18[1].cmsg_len;
          }
          v18 = _cmsg_nxthdr(&v50, v18);
        }
        while ( v18 );
      }
      else
      {
        v19 = 0;
      }
      result = indextoname(*a1, v19, v51);
      if ( !result )
        return result;
      v20 = a1[3];
      v54 = v44;
      if ( !iface_check(v20, v44, v51, &v43) )
      {
        if ( (*(_DWORD *)(dnsmasq_daemon + 4) & 0x80) == 0 )
          enumerate_interfaces(0);
        if ( !loopback_exception(*a1, a1[3], v54, v51) )
        {
          result = label_exception(v19, a1[3], v54);
          if ( !result )
            return result;
        }
      }
      v21 = v19;
      if ( a1[3] == 2 && ((*(_DWORD *)dnsmasq_daemon >> 18) & 1) != 0 )
      {
        v39 = *(_DWORD *)(dnsmasq_daemon + 500);
        for ( i = v39; i; i = *(_DWORD *)(i + 68) )
        {
          if ( *(_WORD *)i == 2 && *(_DWORD *)(i + 4) == v8 )
            goto LABEL_71;
        }
        if ( (*(_DWORD *)(dnsmasq_daemon + 4) & 0x80) == 0 )
          enumerate_interfaces(0);
        v39 = *(_DWORD *)(dnsmasq_daemon + 500);
        if ( v39 )
        {
LABEL_71:
          while ( 1 )
          {
            if ( *(_WORD *)v39 == 2 )
            {
              v21 = v19;
              if ( *(_DWORD *)(v39 + 4) == v8 )
                break;
            }
            v39 = *(_DWORD *)(v39 + 68);
            v21 = v19;
            if ( !v39 )
              goto LABEL_80;
          }
          v52 = *(_DWORD *)(v39 + 16);
        }
        else
        {
          v21 = v19;
LABEL_80:
          v8 = 0;
        }
      }
    }
    v22 = dnsmasq_daemon;
    v23 = *(_DWORD *)(dnsmasq_daemon + 1132);
    v24 = *(_DWORD *)(dnsmasq_daemon + 476);
    *(_DWORD *)(dnsmasq_daemon + 1140) = v53;
    *(_DWORD *)(v22 + 1136) = ++v23;
    *(_DWORD *)(v22 + 1132) = v23;
    if ( extract_request(v3, v12, v24, &v41) )
    {
      v25 = v43 ? "auth" : "query";
      v26 = querystr(v25, v41);
      if ( a1[3] == 2 )
        log_query(524424, *(_DWORD *)(dnsmasq_daemon + 476), v48, v26);
    }
    if ( find_pseudoheader(v3, v12, 0, &v42, 0, 0) )
    {
      v27 = v42;
      v28 = *v42;
      v29 = v42[1];
      v42 += 4;
      v30 = *(unsigned __int16 *)(dnsmasq_daemon + 424);
      v31 = *v42;
      v32 = (v28 << 8) | v29;
      v42 = v27 + 6;
      v33 = v31 >> 7;
      if ( v30 >= v32 )
      {
        v34 = 512;
        if ( v32 >= 0x200 )
          v34 = v32;
        v35 = 1;
      }
      else
      {
        v34 = v30;
        v35 = 1;
      }
    }
    else
    {
      v33 = 0;
      v35 = 0;
      v34 = 512;
    }
    v36 = 1;
    if ( (*(_BYTE *)(v3 + 3) & 0x20) == 0 )
      v36 = v33;
    v37 = answer_request(v3, v3 + v34, v12, v8, v52, a2, v36, v33, v35);
    if ( v37 )
    {
      v38 = 1;
      if ( (*(_DWORD *)dnsmasq_daemon & 0x2000) == 0 )
        v38 = (*(_DWORD *)(dnsmasq_daemon + 4) >> 7) & 1;
      send_from(*a1, v38, v3, v37, v53, v54, v21);
      result = *(_DWORD *)(dnsmasq_daemon + 480) + 1;
      *(_DWORD *)(dnsmasq_daemon + 480) = result;
    }
    else if ( forward_query(*a1, v53, v54, v21, v3, v12, a2, 0, v36, v33) )
    {
      result = *(_DWORD *)(dnsmasq_daemon + 484) + 1;
      *(_DWORD *)(dnsmasq_daemon + 484) = result;
    }
    else
    {
      result = *(_DWORD *)(dnsmasq_daemon + 480) + 1;
      *(_DWORD *)(dnsmasq_daemon + 480) = result;
    }
    return result;
  }
  v16 = *(_DWORD **)(dnsmasq_daemon + 1128);
  if ( v16 )
  {
    for ( j = v16[2]; (j & 2) != 0 || !is_same_net(*v16, v48[0], -1 << (32 - v16[3])); j = v16[2] )
    {
      v16 = (_DWORD *)v16[4];
      if ( !v16 )
        goto LABEL_50;
    }
    v15 = v4 & 0x2000;
    goto LABEL_18;
  }
LABEL_50:
  result = warned_6652;
  if ( !warned_6652 )
  {
    my_syslog(4, "Ignoring query from non-local network");
    result = 1;
    warned_6652 = 1;
  }
  return result;
}
