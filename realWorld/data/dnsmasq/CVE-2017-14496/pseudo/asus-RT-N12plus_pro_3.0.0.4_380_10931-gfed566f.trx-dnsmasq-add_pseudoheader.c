unsigned __int8 *__fastcall add_pseudoheader(unsigned __int8 *a1, unsigned int a2, unsigned int a3, unsigned __int16 a4, int a5, void *src, signed int n, int a8, int a9)
{
  unsigned int v9; // $s7
  int v10; // $v1
  unsigned __int16 v11; // $fp
  unsigned __int8 *v12; // $a1
  _BYTE *v13; // $s2
  __int16 v14; // $s6
  int v15; // $s1
  const void *v16; // $s3
  _BYTE *v17; // $s5
  unsigned __int8 *v18; // $s0
  int v19; // $s4
  int v20; // $a1
  int v21; // $v0
  unsigned __int8 *v22; // $a1
  int v23; // $a0
  __int16 v24; // $s6
  void *v25; // $s4
  void *v26; // $v0
  __int16 v27; // $s1
  int v28; // $t0
  _BYTE *v29; // $v0
  char *v30; // $s2
  unsigned int v31; // $v1
  _BYTE *v32; // $s3
  char *v33; // $a2
  unsigned __int8 *v34; // $a0
  unsigned __int8 *result; // $v0
  unsigned __int8 *v36; // [sp+20h] [-20h] BYREF
  int v37; // [sp+24h] [-1Ch] BYREF
  int v38; // [sp+28h] [-18h] BYREF
  int v39; // [sp+30h] [-10h]
  int v40; // [sp+34h] [-Ch]
  int v41; // [sp+38h] [-8h]
  unsigned int v42; // [sp+3Ch] [-4h]

  v42 = a4;
  v9 = a2;
  v10 = find_pseudoheader(a1, a2, 0, &v36, &v37, &v38);
  v11 = 0x8000;
  if ( !a8 )
    v11 = 0;
  if ( v37 )
    return (unsigned __int8 *)v9;
  v12 = v36;
  if ( v10 )
  {
    v11 = _byteswap_ushort(*((_WORD *)v36 + 2));
    v13 = v36 + 6;
    v41 = *v36;
    v40 = v36[1];
    v14 = v36[2];
    v39 = v36[3];
    if ( a8 )
    {
      v11 |= 0x8000u;
      v36[4] = HIBYTE(v11);
      v12[5] = v11;
    }
    v15 = v12[7] | (v12[6] << 8);
    v16 = v12 + 8;
    if ( v9 < v12 + 8 - a1 + v15 )
      return (unsigned __int8 *)v9;
    v17 = v12 + 6;
    if ( !a5 )
      return (unsigned __int8 *)v9;
    v18 = v12 + 8;
    v19 = 0;
    while ( 1 )
    {
      v23 = v19 + 4;
      if ( v19 + 4 >= v15 )
        break;
      v20 = (v18[2] << 8) | v18[3];
      v21 = (*v18 << 8) | v18[1];
      v18 += 4;
      if ( v15 < v20 + v23 )
      {
        v15 = 0;
        v38 = 0;
        break;
      }
      if ( v21 == a5 )
      {
        v15 = v15 - 4 - v20;
        v18 -= 4;
        v22 = &v18[v20 + 4];
        if ( !a9 )
          return (unsigned __int8 *)v9;
        memmove(v18, v22, v15 - v19);
        *v13 = BYTE1(v15);
        v13[1] = v15;
      }
      else
      {
        v18 += v20;
        v19 = v20 + v23;
      }
    }
    v42 = (v41 << 8) | v40;
    v24 = (v14 << 8) | v39;
    if ( v38 )
    {
      v25 = 0;
      if ( v18 )
      {
        v27 = (__int16)v16;
        goto LABEL_35;
      }
    }
    else
    {
      v25 = 0;
      if ( v15 )
      {
        v26 = (void *)whine_malloc(v15);
        v25 = v26;
        if ( v26 )
          memcpy(v26, v16, v15);
      }
      v9 = rrfilter(a1, v9, 0);
    }
  }
  else
  {
    v25 = 0;
    v15 = 0;
    v24 = 0;
  }
  v28 = skip_questions(a1, v9);
  if ( !v28 )
    goto LABEL_30;
  v29 = (_BYTE *)skip_section(
                   v28,
                   (((unsigned __int8)*((_WORD *)a1 + 4) << 8) | HIBYTE(*((unsigned __int16 *)a1 + 4)))
                 + (((unsigned __int8)*((_WORD *)a1 + 3) << 8) | HIBYTE(*((unsigned __int16 *)a1 + 3)))
                 + (((unsigned __int8)*((_WORD *)a1 + 5) << 8) | HIBYTE(*((unsigned __int16 *)a1 + 5))),
                   a1,
                   v9);
  if ( !v29 )
    goto LABEL_30;
  v30 = v29 + 11;
  if ( a3 < (unsigned int)(v29 + 11) )
    goto LABEL_30;
  v31 = v42 >> 8;
  v29[9] = BYTE1(v15);
  v29[2] = 41;
  v29[3] = v31;
  v32 = v29 + 9;
  v29[4] = v42;
  v29[5] = HIBYTE(v24);
  v29[6] = v24;
  v29[7] = HIBYTE(v11);
  v29[8] = v11;
  *v29 = 0;
  v29[1] = 0;
  v29[10] = v15;
  if ( v25 )
  {
    v18 = (unsigned __int8 *)&v30[v15];
    if ( a3 >= (unsigned int)&v30[v15] )
    {
      memcpy(v30, v25, v15);
      free(v25);
      goto LABEL_32;
    }
LABEL_30:
    free(v25);
    return (unsigned __int8 *)v9;
  }
  v18 = v29 + 11;
LABEL_32:
  v17 = v32;
  if ( (int)(a3 - (_DWORD)(v18 + 4)) >= n )
    *((_WORD *)a1 + 5) = ((unsigned __int8)(HIBYTE(*((_WORD *)a1 + 5)) + 1) << 8) | ((unsigned __int16)((((unsigned __int8)*((_WORD *)a1 + 5) << 8) | HIBYTE(*((_WORD *)a1 + 5))) + 1) >> 8);
  v27 = (__int16)v30;
LABEL_35:
  v33 = (char *)(v18 + 4);
  if ( (int)(a3 - (_DWORD)(v18 + 4)) >= n )
  {
    v34 = a1;
    if ( !a5 )
      return (unsigned __int8 *)(v18 - v34);
    if ( a9 == 2 )
    {
LABEL_41:
      v34 = a1;
      return (unsigned __int8 *)(v18 - v34);
    }
    if ( a3 >= (unsigned int)v33 )
    {
      v18[3] = n;
      *v18 = BYTE1(a5);
      v18[1] = a5;
      v18[2] = BYTE1(n);
      v18 = (unsigned __int8 *)&v33[n];
      result = (unsigned __int8 *)v9;
      if ( a3 < (unsigned int)&v33[n] )
        return result;
      memcpy(v33, src, n);
      v17[1] = (_BYTE)v18 - v27;
      *v17 = (unsigned __int16)((_WORD)v18 - v27) >> 8;
      goto LABEL_41;
    }
  }
  return (unsigned __int8 *)v9;
}
